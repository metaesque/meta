#!/usr/bin/python
import os
import re
import sys

# The legal flags for the compiler are defined in metameta2.py, which is
# guaranted to exist in PYTHONPATH independent of which version of the
# compiler is being used.
import metameta2  # bootstraps meta source detection.

metameta2.AutoCompile()


def Main():
  flags, args = metameta2.ParseFlags()
  if not flags.metalang:
    print 'Error: Must specify a value for --metalang or set META_METALANG'
    sys.exit(1)
    
  #if not flags.baselang:
  #  print 'Error: Must specify a value for --baselang or set META_BASELANG'
  #  sys.exit(1)

  if flags.metadir == '.meta':
    flags.metadir = '.meta2'

  # We establish which version of the meta library to use based on flags, and
  # adjust sys.path before we load the meta code itself.
  metameta2.Metastrap(version=flags.version)

  # Now load up the meta library code.
  import metax.c

  # Initialize the compiler class
  #  - create singleton Filesystem instance
  #  - store the singleton flags
  metax.c.Compiler.Initialize(flags)

  if args and args[0] == 'config':
    # User wants to know a config variable, so we do not need a
    # Compiler instance.
    configpath = os.path.join(os.getenv('HOME'), '.config', 'meta')
    config = metax.c.Compiler.CONFIG
    for var in args[1:]:
      print '%s = %s' % (var, config.get(var, '<INVALID>'))
      
  else:
    # Create a Compiler instance.
    metac = metax.c.Compiler(metal=flags.metalang, basel=flags.baselang)

    # Ensure that the repository directory exists.
    if not metac.verifyDirectory():
      sys.exit(1)

    # Process the commandline.
    metac.interact(args)


if __name__ == '__main__':
  Main()
