#!/usr/bin/python
import copy
import cStringIO
import importlib
import os
import re
import shutil
import subprocess
import sys
import traceback

import metastrap
# metastrap.AutoCompile()

def Main():
  compiler_class, command, cli = metastrap.ImportMeta()
  if not cli:
    print 'ERROR: Exiting due to errors.'
    sys.exit(1)

  cli = command.instantiate(sys.argv).asValues()

  # Although we don't need metax.c within this script (we already
  # have compiler_class from above), other modules will be
  # importing metax.c (and various other metax.* modules), so we
  # perform one last sanity check to ensure that a new import of
  # metax.c yields the same module as compiler_class is in.
  import metax.c
  assert metax.c is sys.modules[compiler_class.__module__]

  # Initialize the compiler class.
  compiler_class.Initialize()

  # Invoke the compiler
  try:
    # CODETANGLE(meta2_entry_main): First arg must be 'main'
    argv = ['main'] + cli.args
    compiler_class.Entry(argv, parent=command)
  except Exception as e:
    # Perform base-to-meta line remapping on the exception string.
    print '****** EXCEPTION: %s' % type(e)
    err = traceback.format_exc()
    metac = compiler_class.Current()
    if metac is None:
      # TODO(wmh): This means the attempt to instantiate the specified
      # version of the compiler failed.  We attempt to instantiate an
      # older version instead.
      print 'NOTE: metac is None'
      version = metastrap.Version
      new_version = None
      if version == 'beta':
        new_version = 'current'
      elif version == 'current':
        new_version = 'stable'
      if new_version:
        # TODO(wmh): We have identified a new version of metax.c.  The question is,
        # how do we load this new version into python, given that metax.c already
        # exists?
        #  - reload(metax.c) just reloads the source already identified for metax.c
        #    without checking sys.path to see if a new path is available.
        #  - deleting metax.c from sys.path and doing an 'import metax.c' does not
        #    work (it finds the old version, so python's cache of already-loaded
        #    modules is someplace other than sys.modules).
        #  - modifying metax.c.__file__ and/or metax.c.__path__ does not appear to
        #    work either.
        #  - we make a symlink from new_path to new_path + '_' + new_version,
        #    and import that module instead (after modifying sys.path to ensure
        #    that new_path appears first in path).
        new_path = metastrap.VersionPath(new_version)
        print 'In meta2 with version %s path %s' % (new_version, new_path)

        # Adjust sys.path so that the new path appears first in the list.
        sys.path.insert(0, new_path)

        if False:
          # The 'reload' method just looks at the pre-existing source files
          # associated with metax.c when we instead want python to re-examine
          # sys.path.
          print 'SRC BEFORE: %s' % metax.c.__file__          
          reload(metax.c)
          print 'SRC AFTER: %s' % metax.c.__file__          

        elif False:
          # Modifying metax.c.__file__ first does not work
          print 'SRC BEFORE: %s' % metax.c.__file__
          metax.c.__file__ = new_path + '/__init__.pyc'          
          reload(metax.c)
          print 'SRC AFTER: %s' % metax.c.__file__          

        elif False:
          # Modifying metax.c.__path__ first does not work
          print 'SRC BEFORE: %s' % metax.c.__file__
          metax.c.__path__ = [new_path]
          reload(metax.c)
          print 'SRC AFTER: %s' % metax.c.__file__          

        elif False:
          # Deleting all symbols associated with metax.c first does not work.
          print 'Before fix, found %d symbols in sys.modules' % len(sys.modules)
          for nfqn in sorted(sys.modules):
            if nfqn == 'metax.c' or nfqn.startswith('metax.c.'):
              del sys.modules[nfqn]
          print 'After  fix, Found %d symbols in sys.modules' % len(sys.modules)
          # TODO(wmh): Try reload!
          import metax.c

        elif True:
          new_metaxname = 'metax_' + new_version
          metax_src = os.path.join(new_path, 'metax')
          metax_dst = os.path.join(new_path, new_metaxname)
          if not os.path.lexists(metax_dst):
            print '  symlinked %s to %s' % (metax_src, metax_dst)
            os.symlink(metax_src, metax_dst)
          metax_c = importlib.import_module(new_metaxname + '.c')
          metax_cli = importlib.import_module(new_metaxname + '.cli')
          print metax_c.Compiler
          print metax_cli.Command

        # Create the new instance of Compiler with appropriate flags.
        print 'Here'
        print err
    if metac:
      ifp = cStringIO.StringIO(err)
      print metac.filterMetaOutput(ifp=ifp, debug=False)


if __name__ == '__main__':
  Main()
