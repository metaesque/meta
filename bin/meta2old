#!/usr/bin/python
import os
import re
import sys

# We set all the old META* env vars here in case they are used by the
# old version of meta2 (many of them aren't used, but this provides
# some assurances that the old version will work as we get the new
# version working with env.vars).
env = os.environ
env['METAPATH'] = '/Users/wmh/src/meta/src/kernel:/Users/wmh/src/meta/src/kernel/ex:.'
env['METAREP'] = '/Users/wmh/src/wmh/lib/meta'
env['METAREPATH'] = '/Users/wmh/src/wmh/lib/meta'
env['METAROOT2'] = '/Users/wmh/src/meta2'
env['METAROOT'] = '/Users/wmh/src/meta'
env['META_BASELANG'] = 'python'
env['META_METALANG'] = 'oopl'
env['META_VERSION'] = 'beta'

# The legal flags for the compiler are defined in metameta2.py, which is
# guaranted to exist in PYTHONPATH independent of which version of the
# compiler is being used.
import metameta2  # bootstraps meta source detection.

metameta2.AutoCompile()

def Main():
  flags, args = metameta2.ParseFlags()
  if not flags.metalang:
    print 'Error: Must specify a value for --metalang or set META_METALANG'
    sys.exit(1)
    
  #if not flags.baselang:
  #  print 'Error: Must specify a value for --baselang or set META_BASELANG'
  #  sys.exit(1)

  if flags.metadir == '.meta':
    flags.metadir = '.meta2'

  # We establish which version of the meta library to use based on flags, and
  # adjust sys.path before we load the meta code itself.
  metameta2.Metastrap(version=flags.version)

  # Now load up the meta library code.
  import metax.c

  # Initialize the compiler class
  #  - create singleton Filesystem instance
  #  - store the singleton flags
  metax.c.Compiler.Initialize(flags)

  if args and args[0] == 'config':
    # User wants to know a config variable, so we do not need a
    # Compiler instance.
    config = metax.c.Compiler.CONFIG
    vars = args[1:] or sorted(config)
    if len(vars) == 1:
      print config.get(vars[0], '<INVALID>')
    else:
      for var in vars:
        print '%s = %s' % (var, config.get(var, '<INVALID>'))
      
  else:
    # Create a Compiler instance.
    metac = metax.c.Compiler(metal=flags.metalang, basel=flags.baselang)

    # Ensure that the repository directory exists.
    if not metac.verifyDirectory():
      sys.exit(1)

    # Process the commandline.
    metac.interact(args)


if __name__ == '__main__':
  Main()
