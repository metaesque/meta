namespace metax.cli #:
  Classes related to flags and other command-line artifacts.

  Motiviation:
   - A program often has need for user-provided customizations, often
     in the form of command-line flags
   - A program often has multiple behaviors it can exhibit, which can be thought
     of as a collection of 'commands'. For example, think of how 'git or 'svn'
     works ... an executable with flags and a variety of subcommands like
     'git init', 'git push', 'git add', etc., each exibiting differing behavior.
   - Parsing and accessing the underlying data represented by command line
     arguments should be automated by the language.

  Notes:
   - A given program has a top-level Command instance that contains
      - all of the Flag instances that can appear
      - all of the Command instances that are legal at this level
      - any positional args that are legal (if any subcommands exist,
        positional args are not legal).
   - Each Command has a recusively defined collection of Flag, Command and arg
     instances.

  Command: A command, associated flags, and optional args.
  Flag: A single customizable (usually optional) typed name/value pair.
  Arg: A single customizable (usually required) typed positional argument.

  Examples:

  - The command line
      % metac -L oopl -b py canonical --expand flags.metac metax.cli
    is represented by:
     - A Command instance whose name is 'metac', with flags -L and -b.
     - A Command instance whose name is 'canonical', with flag --expand
       and positional args 'flags.metac' and 'metax.cli'
        - this command is a 'child' of the 'metac' command.
     - A meta program that was invoked via a Meta-generated Entry() method
       will have the (instantiated) command-line information available in
       Meta().CLI(),
        - is an instance of metax.cli.Values
        - common idiom:
            CLI = Meta().CLI()
        - The Command instance identified by the command-line args is available
          CLI._command_().
        - All flags and args are available by name, alias and index within
          CLI.
        - Flag and arg values can be modified dynamically at run-time, can
          be reset to their values at start of program or to their defaults.
scope:

  class Error < metax.root.Error;

  nometanotest
  class NameConflict < Error #:
    An attempt to define a command/flag/arg whose name or aliases conflict with
    pre-existing symbol.
    TODO(wmh): Need to establish a formal set of exception classes in Meta.
    They should inherit from baselang equivalents where possible so that
    exceptions raised by Meta classes can be properly caught in baselang
    code that uses the Meta-generated code without having to use the
    Meta-generated exception classes.

  pre
  native PrePart scope<cc>:
    // Forward declare the Command class.
    // TODO(wmh): Support for this should be made available via assocs!
    class Command;
  end;

  abstract
  class Part #:
    Abstract superclass of Command, Flag and Arg.
  assocs<py>:
    usertest std assoc datetime;
    std assoc logging;
    std assoc os;
    std assoc re;
  assocs<cc>:
    std assoc iostream;
  scope:

    field parent : Command #:
      The parent Command instance to which this part belongs.

    field name : @str #:
      The name of the part.  For Command instances, the name of the
      top-level instance is the executable used to invoke the program.

    field aliases : @vec<@str> #:
      The aliases by which the flag or arg can be identified.

    field summary : str #:
      A one line summary of the flag or arg.

    field desc : str #:
      A multi-line description of the flag or arg.

    lifecycle params:
      var name -> name;
      var parent -> parent = null;
      var aliases : str = null #:
        A comma-separated list of aliases.
      var summary -> summary = null;
      var desc -> desc = null;
    scope<py>:
      if aliases:
        assert isinstance(aliases, str)
        alist = re.split(r'\s*,\s*', aliases)
        self.aliasesIs(alist)
    scope<cc>:
    clinit<py>:
      cls.RegexpClass = re.compile('.').__class__
      cls.InvalidValue = object()
    end lifecycle;

    method typecheck : any #:
      Convert a string value into some python object as dictated by mytype.

      Returns:
        A python object dictated by vtype. If the typecheck fails, returns
        Part.InvalidValue.
    params:
      var value : str #:
        The type to convert.
      var mytype : str = null #:
        The type to use to typecheck. Normally null, in which case self.mytype()
        is used.
    scope<py>:
      result = Part.InvalidValue
      if mytype is None:
        mytype = self.mytype()

      if mytype == 'str':
        /# Any value is legal.
        if isinstance(value, str):
          result = value
        else:
          /# Instead of converting to string, we could report an error for
          /# this situation.
          result = str(value)

      elif mytype == 'bool':
        if isinstance(value, bool):
          result = value
        elif value == 'true':
          result = True
        elif value == 'false':
          result = False

      elif mytype == 'trilean':
        if isinstance(value, bool):
          result = value
        elif value == 'true':
          result = True
        elif value == 'false':
          result = False
        elif value == 'null':
          result = None
        else:
          raise Error('Invalid trilean "%s"' % value)

      elif mytype == 'int':
        if isinstance(value, int):
          result = value
        elif re.match(r'^[+-]?\d+$', value):
          result = int(value)

      elif mytype in ('real', 'float', 'double'):
        if isinstance(value, (int, float)):
          result = float(value)
        elif re.match(r'^-?\d*\.\d+$', value):
          result = float(value)
        elif re.match(r'^-?\d+$', value):
          result = float(value)

      elif mytype == 'date':
        m = re.match(
          '^(?:to)?(?P<kind>minute|hour|day|week|month|year)'
          '(?:(?P<sign>[-+])(?P<adj>\d+))?', value)
        if m:
          now = datetime.datetime.now()
          onesec = datetime.timedelta(seconds=1)
          kind = m.group('kind')
          sign = m.group('sign') or ''
          adj = int(m.group('adj') or 0)
          if sign == '-':
            adj = -adj
          if kind == 'sec':
            result = now.replace(microsecond=0)
            result += onesec * adj
          elif kind == 'min':
            result = now.replace(second=0, microsecond=0)
            result += onesec * adj * 60
          elif kind == 'hour':
            result = now.replace(minute=0, second=0, microsecond=0)
            result += onesec * adj * 60 * 60
          elif kind == 'day':
            result = now.replace(hour=0, minute=0, second=0, microsecond=0)
            result += onesec * adj * 60 * 60 * 24
          elif kind == 'month':
            result = now.replace(
              day=1, hour=0, minute=0, second=0, microsecond=0)
            oneday = datetime.timedelta(days=1)
            if sign == '-': oneday = oneday * -1
            /# TODO(wmh): Fix me!
            result += onesec * adj * 60 * 60 * 24 * 30
          elif kind == 'year':
            result = now.replace(
              month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
            /# TODO(wmh): Fix this ... this does not properly return the
            /# first of a year!
            result += onesec * adj * 60 * 60 * 24 * 365
          else:
            raise Error('Invalid kind "%s"' % kind)
        else:
          val = re.sub(r'[-/@:T ]', '', value)
          n = len(val)
          if n == 0:
            result = None
          elif n == 8:
            result = datetime.datetime.strptime(val, '%Y%m%d')
          elif n == 10:
            result = datetime.datetime.strptime(val, '%Y%m%d%H')
          elif n == 12:
            result = datetime.datetime.strptime(val, '%Y%m%d%H%M')
          elif n == 14:
            result = datetime.datetime.strptime(val, '%Y%m%d%H%M%S')
          elif val == 'now':
            result = datetime.datetime.now()

      elif mytype == 're':
        if value == '':
          /# Fix this hackery. How to specify a default value?
          result = None
        else:
          try:
            result = re.compile(value)
          except re.error:
            raise Error('Invalid regexp "%s"' % value)

      elif mytype.startswith('enum'):
        enumtype = self.enumtype()
        if enumtype:
          /# We support two different value modes for enums.
          /#  - if the enum specifies an integer for the enum value specified,
          /#    we return the integer.
          /#  - if the enum does NOT specify an integer, we return the value
          /#    string.
          /# Examples:
          /#  - mytype 'enum<red,green,blue>' will return
          /#    'red' for 'red', 'green' for 'green' and 'blue' for 'blue'.
          /#  - mytype 'enum<red=1,green=2,blue=3>' will return
          /#    1 for 'red', 2 for 'green' and 3 for 'blue'.
          if value in enumtype:
            result = enumtype[value]
            if result == -1:
              result = value

      elif mytype.startswith('list<'):

        m = re.match('^list<(.*)>', mytype)
        if m:
          subtype = m.group(1)
          if not isinstance(value, list):
            /# TODO(wmh): Do we want to support splitting on chars other than
            /# comma?
            value = re.split('\s*,\s*', value)
          /# Now typecheck each element.
          result = []
          error = False
          for subval in value:
            realval = self.typecheck(subval, mytype=subtype)
            if realval is Part.InvalidValue:
              /# How to report this?
              error = True
            result.append(realval)
          if error:
            result = Part.InvalidValue
        else:
          raise Error('Unknown type "%s"' % mytype)
      else:
        raise Error('Unknown type "%s"' % mytype)

      return result
    test<py>:
      invalid = metax.cli.Part.InvalidValue
      test.iseq(87, test.arg1.typecheck('87'))
      test.iseq(-1, test.arg1.typecheck('-1'))
      test.iseq(12, test.arg1.typecheck('+12'))
      test.iseq(invalid, test.arg1.typecheck('a'))
      test.iseq('oopl', test.metalang.typecheck('oopl'))
      test.iseq(True, test.expand.typecheck('true'))
      test.iseq(False, test.expand.typecheck('false'))
      test.iseq(invalid, test.expand.typecheck('blah'))
      test.iseq('red', test.arg3.typecheck('red'))
      test.iseq(invalid, test.arg3.typecheck('purple'))
      test.iseq('female', test.enumflag.typecheck('female'))
      test.iseq(True, test.trilflag.typecheck('true'))
      test.iseq(False, test.trilflag.typecheck('false'))
      test.iseq(None, test.trilflag.typecheck('null'))
      test.iseq(
        datetime.datetime(2018, 12, 11, 6, 37, 11),
        test.dateflag.typecheck('2018-12-11@06:37:11'))
      test.reflag.typecheck('$v\d+$')
    end method typecheck;

    method names : vec<str> #:
      Obtain the names of my ancestors (and myself).
    scope<py>:
      names = []
      obj = self
      while obj is not None:
        names.append(obj.name())
        obj = obj.parent()
      return list(reversed(names))
    test<py>:
      test.iseqvec(['faux', 'image'], test.fauximg.names())
    end method names;

    method fqn : str #:
      The fully qualified name of this command.
    params:
      var delim : str = '_' #:
        What to separate command names with.
    scope<py>:
      return delim.join(self.names())
    test<py>:
      test.iseq('metac', test.command.fqn())
      test.iseq('metac_canonical', test.subcommand.fqn())
      test.iseq('deps', test.intflag.fqn())
      test.iseq('length', test.arg2.fqn())
    end method fqn;

    method isCommand : bool scope<py>:
      return False
    test<py>:
      test.isfalse(test.arg4.isCommand())
      test.isfalse(test.strflag.isCommand())
      test.istrue(test.subcommand.isCommand())
    end method isCommand;

    method isFlag : bool scope<py>:
      return False
    test<py>:
      test.isfalse(test.arg4.isFlag())
      test.istrue(test.strflag.isFlag())
    end method isFlag;

    method isArg : bool scope<py>:
      return False
    test<py>:
      test.istrue(test.arg4.isArg())
      test.isfalse(test.strflag.isArg())
    end method isArg;

    method terminalSize : int #:
      Establish size of current terminal
    scope:
      /# https://stackoverflow.com/questions/566746/how-to-get-linux-console-window-width-in-python
      rows, columns = os.popen('stty size', 'r').read().split()
      return int(columns)
    test:
      pass
    end method terminalSize;

  end class Part;

  post nmsp
  native PostPart scope<cc>:
    // Now include the Command
    // TODO(wmh): Support for this should be made available via assocs!
    #include "Command.h"
  end;

  class Command < Part #:
    Represents a command, associated flags, and optional args.
  assocs<py>:
    std assoc sys #:
      TODO(wmh): Meta should automatically include implicit dependencies
      due to use of native types. For example, if a method uses:
         var fp : ostream = out
      in Python this gets mapped to
         fp = sys.stdout
      and Meta should add an implicit reliance on module 'sys'.
  scope:

    field order : @vec<Command> #:
      The sub-commands of this command in the order they were registered.
      In addition to ordering, this provides a unique set of subcommands,
      unlike 'commands', which has entries for every alias as well.

    field commands : @map<str,Command> #:
      Maps command names anad aliases to Command instances.

    field parts : @map<str,Part> #:
      Maps flag names and aliases to Flag instances, and arg names, aliases
      and index to Arg instances.

    field args : @vec<Arg> #:
      A list of non-flag positional arguments.

    ro
    field id : str #:
      The name as set when created.  The name can be changed via instantiate(),
      but the id should be constant.

    lifecycle params:
      var name : str #:
        The name of the command.
      var parent : Command = null #:
        The parent of this command.
      var aliases : str = null #:
        Aliases by which this command is recognized.
      var flags : vec<Flag> = null #:
        If present, flags to be registered.
      var args : vec<Arg> = null #:
        If present, args to be registered.
      var summary : str = null #:
        A one-line summary of the flag.
      var desc : str = null #:
        A multi-line description of the flag.
    super (name, parent=parent, aliases=aliases, summary=summary, desc=desc)
    scope<py>:
      self.idIs(name)
      if flags:
        for flag in flags:
          self.registerPart(flag)
      if args:
        for arg in args:
          self.registerArg(arg)
    scope<cc>:
    end;

    method isCommand : bool scope<py>:
      return True
    test<py>:
      test.isfalse(test.arg4.isCommand())
      test.isfalse(test.strflag.isCommand())
      test.istrue(test.subcommand.isCommand())
    end method isCommand;

    method root : Command #:
      The top-level command above this one.
    scope<py>:
      result = self
      cmd = self.parent()
      while cmd is not None:
        result = cmd
        cmd = cmd.parent()
      return result
    test<py>:
      test.issame(test.command, test.subcommand.root())
    end method root;

    method help #:
      Print out help for this command.
    params:
      var fp : ostream = out #:
        Where to write output.
      var indent : str = '' #:
        Indentation before each line.
      var mode : str = 'summary' #:
        How much detail to print out. Legal values are:
          summary: provide a one-line summary
          help: provide help for the part
          helpfull: provide detailed help for the part.
      var commands : vec<str> = null #:
        The subcommand(s) for which help is desired. If null or empty,
        top-level help is produced.
    scope<py>:

      /# Print flags inherited from parent commands.
      subindent = indent + '  '
      full = 'ful' in mode
      ancestors = []
      parent = self.parent()
      while parent:
        ancestors.append(parent)
        parent = parent.parent()
      for parent in reversed(ancestors):
        fp.write('%s%s\n' % (indent, parent.name()))
        parts = parent.allParts() if full else parent.parts()
        count = 0
        for flagname in sorted(parts):
          part = parts[flagname]
          if part.name() != flagname: continue   # skip aliases
          if part.isFlag():
            part.show(fp=fp, indent=subindent, mode=mode)
            count += 1
        if not count:
          fp.write('%sno flags\n' % subindent)

      /# Print specified child commands
      command = self
      if commands:
        for nora in commands:
          subcmd = command.findCommand(nora)
          if subcmd:
            /# Valid subcommand.
            fp.write('%s%s:\n' % (indent, command.name()))
            indent += '  '
            command = subcmd
          else:
            /# Invalid subcommand ... print out from this level
            print(u'WARNING: Unknown command "%s"' % nora)
            break

      /# Print self
      command.show(fp=fp, indent=indent, mode=mode)

    test<py>:
      fp = test.fp()
      test.command.help(fp=fp)
      test.command.help(fp=fp, mode='helpful')
      test.iseqtext("""\
        >|metac          : None
        >|metac:
        >|  --baselang|b : str = "<special>"
        >|    The baselang to compile into.
        >|    If this is <special>, a metalang-specific default is used
        >|  --metadir : str = ".metac"
        >|    The subdir to write code to.
        >|    A value of .metac is treated specially, being symlinked to repo
        >|  --metalang|L : str = "oopl"
        >|    The metalang the code is defined in.
        >|
        >|  canonical:
        >|    Canonicalize the specified meta files and report diffs.
        >|    --baselang|b : str = "<special>"
        >|      The baselang to compile into.
        >|      If this is <special>, a metalang-specific default is used
        >|    --expand|e : bool = False
        >|      If true, invoke expandMeta() before canonicalizing
        >|      By default, expandMeta() invokes parseMeta() but not expandMeta().
        >|    --metadir : str = ".metac"
        >|      The subdir to write code to.
        >|      A value of .metac is treated specially, being symlinked to repo
        >|    --metalang|L : str = "oopl"
        >|      The metalang the code is defined in.
        >|""",
        test.out())
    end method help;

    method findCommand : Command #:
      Find a command by name or alias within myself.
    params:
      var nora : str #:
        The name or alias of the command desired.
    scope<py>:
      return self.commands().get(nora, None)
    test<py>:
      test.issame(test.subcommand, test.command.findCommand('canonical'))
      test.issame(test.subcommand, test.command.findCommand('can'))
      test.isnull(test.command.findCommand('not-a-command'))
    end method findCommand;

    method registerCommand #:
      Register this command.
    params:
      var command : Command #:
        docstr
    scope<py>:
      commands = self.commands()
      order = self.order()

      if command in order:
        raise Error('Attempt to re-register command %s' % command.fqn())
      order.append(command)

      noras = [command.name()] + (command.aliases() or [])
      for nora in noras:
        existing = self.findCommand(nora)
        if existing:
          kind = 'name' if nora == command.name() else 'alias'
          raise NameConflict(
            '%s "%s" of command %s conflicts with pre-existing command "%s"' %
            (kind, nora, command.name(), existing.name()))
        commands[nora] = command
    test<py>:
      command = test.command
      newcom = metax.cli.Command('subcom', aliases='can')
      test.raises(
        metax.cli.NameConflict, command.registerCommand, newcom)
    end method registerCommand;

    method newCommand : Command #:
      Create a new subcommand.
    params:
      var name : str #:
        The name of the command.
      var aliases : str = null #:
        Aliases by which this command is recognized.
      var flags : vec<Flag> = null #:
        If present, flags to be registered.
      var args : vec<Arg> = null #:
        If present, args to be registered.
      var summary : str = null #:
        A one-line summary of the flag.
      var desc : str = null #:
        A multi-line description of the flag.
    scope<py>:
      if self.args():
        /# Cannot add a subcommand to a command that has args.
        raise Error(
          "Command '%s' has args (%s) and thus cannot accept subcommand '%s'" %
          (self.name(), ','.join([arg.name() for arg in self.args()]), name))
      command = Command(
        name, parent=self, aliases=aliases, flags=flags, args=args,
        summary=summary, desc=desc)
      self.registerCommand(command)
      return command
    test<py>:
      test.iseq([], sorted(test.subcommand.commands()))
      command = test.subcommand.newCommand('subcan')
      test.iseq(['subcan'], sorted(test.subcommand.commands()))
    end method newCommand;

    method findPart : Part #:
      Obtain a flag or arg by name or alias or index.

      This method looks up the inheritance chain if not found locally.

      Returns:
        null if no such flag/arg is found.
    params:
      var nora : str #:
        Name or alias (or string-valued index) of flag/arg desired.
    scope<py>:
      obj = self
      while obj is not None:
        result = obj.parts().get(nora, None)
        if result: break
        obj = obj.parent()
      return result
    test<py>:
      command = test.subcommand
      test.iseq('metalang', command.findPart('metalang').name())
      test.iseq('metalang', command.findPart('L').name())
      test.isnull(command.findPart('not-a-flag'))
    end method findPart;

    method registerPart #:
      Register a Flag or Arg with this Command.
    params:
      var part : Part #:
        The flag or arg to register.
    scope<py>:
      parts = self.parts()
      noras = [part.name()] + (part.aliases() or [])
      for nora in noras:
        /# existing = self.findPart(nora)
        existing = self.parts().get(nora, None)
        if existing:
          partkind = self.__class__.__name__
          norakind = 'name' if nora == part.name() else 'alias'
          if False:
            /# Temporary hack while we migrate to metacnew
            print (
              'WARNING: %s "%s" of %s %s conflicts with pre-existing %s "%s"' %
              (norakind, nora, partkind, part.name(),
               existing.__class__.__name__, existing.name()))
          else:
            raise NameConflict(
              '%s "%s" of %s %s conflicts with pre-existing %s "%s"' %
              (norakind, nora, partkind, part.name(),
               existing.__class__.__name__, existing.name()))
        else:
          parts[nora] = part

      if part.isArg():
        /# In addition to being discoverable by name and aliases, args are
        /# discoverable by their index, and an ordered list of args is
        /# maintained.
        arg = part
        args = self.args()
        lastarg = args[-1] if args else None
        if lastarg:
          if lastarg.default() is not None:
            /# A previous arg has a default value, which means it is not legal
            /# for the new arg to NOT have a default value.
            if arg.default() is None:
              raise Error(
                'Cannot have required Arg %s after optional Arg %s' %
                (arg.name(), lastarg.name()))
            /# A previous arg has a default value, which means it is not legal
            /# to specify a multi-valued arg.
            if arg.ismulti():
              raise Error(
                'Cannot have multi-valued Arg %s after optional Arg %s' %
                (arg.name(), lastarg.name()))

        /# Add the arg to the positional list.
        arg_index = len(args)
        args.append(arg)
        assert args[arg_index] is arg

        /# Add string-valued keys to parts() based on arg position
        /#  - we add the string value of the index itself (e.g. '0' or '1', etc.)
        /#  - we also add 'arg0' or 'arg1', etc. This is because one cannot
        /#    use 'cli.0' but one can use 'cli.arg0'.
        for argkey in (str(arg_index), 'arg%d' % arg_index):
          /# existing = self.findPart(argkey)
          existing = self.parts().get(argkey, None)
          if existing:
            raise NameConflict('Arg %s (%s) has conflict' % (argkey, arg.name()))
          parts[argkey] = arg
    test<py>:
      cmd = metax.cli.Command(
        'cmd', aliases='cc', summary='Some command.')
      test.iseq([], sorted(cmd.parts()))
      test.iseq([], sorted(cmd.allParts()))

      /# Create and register a Flag
      flag = metax.cli.Flag(
        'flaga', default='', aliases='a', summary='some flag')
      cmd.registerPart(flag)
      test.iseqvec(['a', 'flaga'], sorted(cmd.parts()))

      /# Create and register an Arg
      arg = metax.cli.Arg(
        'somearg', aliases='sa', summary='some arg')
      cmd.registerPart(arg)
      test.iseq(1, len(cmd.args()))
      test.issame(arg, cmd.args()[-1])
      test.iseqvec(
        ['0', 'a', 'arg0', 'flaga', 'sa', 'somearg'], sorted(cmd.parts()))
      test.iseqvec(['flaga', 'somearg'], sorted(cmd.allParts()))
      test.iseqvec(
        ['0', 'a', 'arg0', 'flaga', 'sa', 'somearg'],
        sorted(cmd.allParts(aliases=True)))

      /# Ensure that a flag that has a name conflict raises an exception
      flag2 = metax.cli.Flag(
        'flagb', default='', aliases='a,b', summary='some other flag')
      /# TODO(wmh): Reinstate this when moved to metacnew!
      /# print('reinstate test for Command.registerPart')
      test.raises(metax.cli.NameConflict, cmd.registerPart, flag2)
    end method registerPart;

    method allParts : map<str,Part> #:
      Compute the set of all flags that are available in this command.
    params:
      var aliases : bool = false #:
        If true, include aliases (which means there will be multiple keys with
        the same Flag instance). By default, returns name to flag, wherein
        there is one key per Flag.
    scope<py>:
      result = {}
      command = self
      while command is not None:
        for nora, part in command.parts().items():
          if not aliases and nora != part.name(): continue
          if nora not in result:
            result[nora] = part
        command = command.parent()
      return result
    test<py>:
      test.iseqvec(
        ['baselang', 'metadir', 'metalang'],
        sorted(test.command.allParts()))
      test.iseqvec(
        ['L', 'b', 'baselang', 'metadir', 'metalang'],
        sorted(test.command.allParts(aliases=True)))

      test.iseqvec(
        ['baselang', 'expand', 'metadir', 'metalang'],
        sorted(test.subcommand.allParts()))
      test.iseqvec(
        ['L', 'b', 'baselang', 'e', 'expand', 'metadir', 'metalang'],
        sorted(test.subcommand.allParts(aliases=True)))
    end method allParts;

    method newFlag : Flag #:
      Create a Flag instance and register it with myself.
    params:
      var name : str #:
        The name of the flag.
      var mytype : str = 'str' #:
        The type of the flag.
      var default : str = null #:
        The string representation of the default value of the flag.
      var aliases : str = null #:
        Aliases for the flag.
      var summary : str = null #:
        A one-line summary of the flag.
      var desc : str = null #:
        A multi-line description of the flag.
    scope<py>:
      /#if default is None:
      /#  raise Error('Flag --%s : %s needs a default value' % (name, mytype))
      result = Flag(
        name, mytype=mytype, default=default, aliases=aliases,
        summary=summary, desc=desc)
      self.registerPart(result)
      return result
    test<py>:
      command = self.subcommand
      test.iseq(['e', 'expand'], sorted(command.parts()))

      flag = command.newFlag(
        'test', 'bool', False, aliases='T,tst', summary='testing',
        desc='more testing')
      test.iseq(['T', 'e', 'expand', 'test', 'tst'], sorted(command.parts()))
      test.issame(flag, command.findPart('test'))
      test.issame(flag, command.findPart('T'))
      test.issame(flag, command.findPart('tst'))
    end method newFlag;

    method findFlag : Flag #:
      Obtain a flag by name or alias.

      This method looks up the inheritance chain if not found locally.

      Returns:
        null if no such flag is found.
    params:
      var nora : str #:
        Name or alias of flag desired.
    scope<py>:
      result = self.findPart(nora)
      if result and not result.isFlag():
        result = None
      return result
    test<py>:
      cmd1 = test.subcommand

      test.iseq('metalang', cmd1.findFlag('metalang').name())
      test.iseq('metalang', cmd1.findFlag('L').name())
      test.isnull(cmd1.findFlag('not-a-flag'))

      cmd2 = test.fauximg2
      test.iseq('files', cmd2.findPart('files').name())
      test.isnull(cmd2.findFlag('files'))
    end method findFlag;

    method newArg : Arg #:
      Create and register an Arg instance with this Command.
    params:
      var name : str #:
        The name of the arg.  Since args are positional, this does not have
        the same importance for Arg instances as for Flag instances, but is
        useful for reference purposes.
      var mytype : str = 'str' #:
        The type of the arg. Critically important when validating a value.
      var default : str = null #:
        The string representation of the default value of the flag. If null,
        the arg is required.
      var aliases : str = null #:
        Aliases for the arg. Rarely used for Arg instances, since even the
        name itself is only useful for reference purposes.
      var summary : str = null #:
        A one-line summary of the arg.
      var desc : str = null #:
        A multi-line description of the arg.
      var multi : bool = false #:
        If true, this Arg bundles all remaining command line args into a single
        list of strings.
    scope<py>:
      if multi:
        if not mytype.startswith('list<'):
          mytype = 'list<' + mytype + '>'
        default = []
      result = Arg(
        name, mytype=mytype, default=default, aliases=aliases,
        summary=summary, desc=desc)
      self.registerPart(result)
      return result
    test<py>:
      /# TestCase setup invoked newArg on test.faux
      command = self.fauximg
      test.iseq(3, len(command.args()))
    end method newArg;

    method findArg : Arg #:
      Obtain a arg by name or alias or (str-valued) index

      This method looks up the inheritance chain if not found locally.

      Returns:
        null if no such arg is found.
    params:
      var nora : str #:
        Name or alias or string-valued index of arg desired.
    scope<py>:
      result = self.findPart(str(nora))
      if result and not result.isArg():
        result = None
      return result
    test<py>:
      cmd1 = test.fauximg2
      test.iseq('files', cmd1.findArg('files').name())
      test.isnull(cmd1.findArg('not-a-arg'))

      cmd2 = test.subcommand
      test.iseq('metalang', cmd2.findPart('metalang').name())
      test.isnull(cmd2.findArg('metalang'))
    end method findArg;

    method instantiate : Command #:
      Parse a list of strings and identify a specific Command instance,
      with values assigned to each relevant Flag and Arg instance.

      IMPORTANT: The first element of argv passed into this method must be the
      name of this Command instance ... one must already know which Command
      instance represents the command and invoke it appropriately. In
      particular, this method does NOT determine, based on the first element of
      argv, which Command to instantiate at this level (it DOES use the second
      element of argv to decide which SubCommand to instantiate though).

      Returns:
        The Command instance identified by argv, or null if invalid args
        were found in argv (errors will be written to stderr if found).
    params:
      var argv : vec<str> #:
        The list of command line arguments to parse.  The first element
        in the list is a command, followed by flags, followed by either
        args or a subcommand. If a subcommand is found, this method is
        recursively invoked to identify the subcommand.
      var parent : Command = null #:
        The parent command, relevant when parsing a subcommand.  When
        passing command line arguments to this method, this is null.
        Be careful about passing in parent=null in other situations ... the
        name field is tromped if parent is null, which can be a subtle
        source of errors.
      var start : bool = false #:
        True if argv represents command line arguments.  If true, the
        'start' field of Flag and Arg instances are initialized during
        instantiation. If false, they are not initialized.
      var efp : ostream = err #:
        Where to write error output.
      var debug : bool = false #:
        If true, turn on debugging output. Useful in tracking down esoteric
        errors, which are easy to create if one is careless about passing
        in the wrong combination of argv and parent.
    scope<py>:
      result = self
      errors = []

      if debug:
        print(
          'DEBUG: Starting instantiate with names=%s argv=%s start=%s' %
          (self.names(), argv, start))
        self.show()

      if parent is None:
        /# For the top-level Command instance, we set the name to the
        /# executable.
        self.nameIs(argv[0])
        if debug:
          print('DEBUG: Setting name to %s' % self.name())
      else:
        /# For subcommands, the name of the command is fixed, and must match
        /# argv[0].
        if argv[0] != self.name() and argv[0] not in self.aliases():
          raise Error(
            "Invocation of command '%s' when seeing command '%s'" %
            (self.name(), argv[0]))

      fre = re.compile(r'^(-{1,2})([^= ]+)(?:=(.*))?')
      negnumre = re.compile('^-(?:\d*\.\d+|\d+(\.\d+)?)')

      /# Now parse flags/args/subcommands.
      index = 1
      argc = len(argv)
      nm1 = argc - 1
      current_arg_index = 0
      while index < argc:
        item = argv[index]
        nextitem = argv[index+1] if index < nm1 else None
        if debug:
          print('Working on index=%d item="%s" next="%s"' % (index, item, nextitem))
        if item[0] == '-' and not negnumre.match(item):
          /# We are parsing a flag.
          m = fre.match(item)
          flagmark = m.group(1)
          flagname = m.group(2)
          flagval = m.group(3)
          if flagmark == '-':
            /# Only single-letter flags can be specified with '-', and
            /# multiple can be merged together. Only the last one can have
            /# a value (all others must be of type bool
            if flagval is not None:
              errors.append('Cannot inline assign to short flags (%s)' % item)
              break
            shorts = list(flagname)
            sn = len(shorts)
            for si, short in enumerate(shorts):
              flag = result.findPart(short)
              if flag:
                flagtype = flag.mytype()
                if si < sn - 1:
                  /# There are other short flags after this one, so this flag
                  /# must be boolean.
                  if flagtype != 'bool':
                    errors.append(
                      'Using -%s in %s which must be boolean but --%s is %s' %
                      (short, item, flag.name(), flagtype))
                    break
                /# Set the value.
                res = flag.instantiate(short, None, nextitem)
                if res is None:
                  /# We failed to set the flag.
                  errors.append(
                    '%s cannot have value "%s"' %
                    (flag.title(), flagval or nextitem))
                else:
                  /# We successfully set the flag
                  if res is True:
                    /# We consumed nextitem
                    index += 1
                  if start:
                    flag.startIs(flag.value())
                  if debug:
                    print('DEBUG: item "%s" sets flag "--%s" to "%s"' % (
                      item, flag.name(), flag.value()))
              else:
                errors.append(
                  'Command %s does not recognize flag -%s' %
                  (result.name(), short))
            if errors:
              break
          else:
            /# We have a longform flag.
            flag = result.findPart(flagname)
            if not flag and flagname.startswith('no'):
              flag = result.findPart(flagname[2:])
            if flag:
              /# The flag is legal. Obtain the value and typecheck.
              flagtype = flag.mytype()
              res = flag.instantiate(flagname, flagval, nextitem)
              if res is None:
                /# We failed to set the flag.
                errors.append(
                  '%s cannot have value "%s"' % (flag.title(), flagval))
                break
              else:
                /# We succeeded in setting the flag.
                if res:
                  /# The next arg was consumed.
                  index += 1
                if start:
                  flag.startIs(flag.value())
                if debug:
                  print(
                    'DEBUG: item "%s" sets flag "--%s" to "%s"' %
                    (item, flagname, flag.value()))
            else:
              errors.append(
                'Command %s does not recognize flag --%s' %
                (result.name(), flagname))
              break
        else:
          /# This item is either a subcommand or a positional arg.
          command = result.findCommand(item)
          if command:
            /# We are parsing a subcommand.
            if debug:
              print('DEBUG: item "%s" is a subcommand' % item)
            result = command.instantiate(
              argv[index:], parent=self, start=start, efp=efp, debug=debug)
            /# The recursive call consumes all args, so we are done.
            index = argc
            break
          else:
            /# This must be an argument. We see if one is defined for arg
            /# index 'current_arg_index'.
            arg = result.findArg(current_arg_index)
            if arg:
              if debug:
                print('DEBUG: Identified arg %s at position %d' % (arg.name(), current_arg_index))

              next_index = arg.instantiate(argv, index)
              if next_index > -1:
                /# We have a valid arg.
                if debug:
                  if next_index > index + 1:
                    print(
                      'DEBUG: arg "%s" consumes items %s' %
                      (arg.name(), argv[index:next_index]))
                  else:
                    print('DEBUG: item "%s" is arg "%s"' % (item, arg.name()))
                if start:
                  arg.startIs(arg.value())

                /# Advance current_arg_index
                current_arg_index += 1

                /# How many values were consumed.
                diff = next_index - index
                assert diff > 0
                /# We increment index by 1 at the end of the loop, so we
                /# need to increment by diff-1 here.  Note that diff will
                /# normally be 1, in which case we don't adjust index at all.
                /# It will be >1 if arg is multi. Currently, it will consume
                /# all elements, but we may add support for some subset in
                /# the future, hence this somewhat hacky general solution.
                index += (diff - 1)
              else:
                /# We have an invalid arg.
                /#  - Arg.instantiate() will already have printed out an error.
                errors.append(
                  '%s cannot have value "%s"' % (arg.title(), item))
                break
            else:
              /# This item is not a subcommand or flag or arg ... unrecognized.
              result.show(mode='helpfull')
              errors.append(
                'Command %s has no args to represent "%s" (%d)' %
                (result.name(), item, current_arg_index))
              break
        index += 1

      /# After consuming all args in argv, we now verify that all required
      /# args and flags have values.
      if result and not errors:
        for arg in result.args():
          if arg.value() is None:
            /# A required arg without a value.
            errors.append(
              'Command %s has required %s that is missing a value' %
              (result.name(), arg.title()))
        allflags = result.allParts()
        for flagname in sorted(allflags):
          flag = allflags[flagname]
          if flag.isArg(): continue
          if flag.value() is None:
            /# A required flag without a value
            errors.append(
              'Command %s has required %s that is missing a value' %
              (result.name(), flag.title()))

      if errors:
        efp.write(
          "Found errors while instantiating command '%s' with args\n  %s\n" % (
            result.name(), ' '.join(
              ['"%s"' % arg if ' ' in arg else arg for arg in argv])))
        efp.write('Errors:\n')
        for error in errors:
          efp.write('  ' + error + '\n')
        result = None

      if debug:
        self.show()

      return result
    tests:
      testx t1 scope<py>:
        command = test.faux
        test.iseq('faux', command.fqn())
        command.show(fp=test.fp(), mode='help')
        before = test.out()

        res = command.instantiate(
          ['./person', '--name', 'Alice', '--gender=female', '--deps', '1',
           '-h', '1.63', 'image', '300'],
          start=True)
        res.show(fp=test.fp(), mode='help')
        after = test.out()
        test.iseqvec(['./person', 'image'], res.names())

        test.iseqtext("""\
          >|faux:
          >|  A command with a flag and arg of each type.
          >|  --deps : int = 0
          >|    Number of dependents.
          >|  --dob|d : date = 1980-05-17
          >|    Date of birth.
          >|  --gender : enum<undef|female|male|trans> = undef
          >|    Gender of person
          >|  --height|h : real = 1.87
          >|    Height in meters.
          >|  --name : str = "Bob"
          >|    The name of the person
          >|  --top : trilean = true
          >|    Misc. trilean flag
          >|  --version|r : re = |<
          >|    Version to use.
          >|  image:
          >|    Image processing.
          >|  list:
          >|    Image listing
          >|""",
          before)

        test.iseqtext("""\
          >|image:
          >|  Image processing.
          >|""",
          after)

        res = command.instantiate(['./person', 'list', 'a', 'b', 'c'], debug=False)
        res.show(fp=test.fp(), mode='helpful')

        test.iseqtext("""\
          >|list:
          >|  Image listing
          >|  --deps : int = 0
          >|    Number of dependents.
          >|  --dob|d : date = 1980-05-17
          >|    Date of birth.
          >|  --gender : enum<undef|female|male|trans> = undef
          >|    Gender of person
          >|  --height|h : real = 1.87
          >|    Height in meters.
          >|  --name : str = "Bob"
          >|    The name of the person
          >|  --top : trilean = true
          >|    Misc. trilean flag
          >|  --version|r : re = |<
          >|    Version to use.
          >|  files: The image files.
          >|""",
          test.out())

        /# Verify that command aliases work.
        res2 = command.instantiate(['./person', 'dir', 'a', 'b', 'c'], debug=False)
        test.iseq('list', res2.name())

        /# The following code sets of a similar situation to what is used in
        /# actual code between the 'metac' executable front-end and the
        /# metax.c.Compiler.MetaxEntry() entry point.
        /#  - we create a Command instance in 'metac' to parse some initial flags
        /#  - then we call metax.c.Compiler.MetaxEntry which creates another Command
        /#    instance (linked to the command created in 'metac' so its flags
        /#    can be seen) and various child Command instances.
        /#  - then we instantiate the top-level command created within
        /#    metax.c.Compiler.MetaxEntry WITHOUT passing 'parent' in (which means
        /#    the name field will be tromped, and was hiding an error in logic).
        top_command = metax.cli.Command('metac')
        command = metax.cli.Command(
          'main', parent=top_command,
          summary='The public interface to the Meta compiler.')
        hierarchy_command = command.newCommand(
          'hierarchy', aliases='hier', summary='Print hierarchy')
        hierarchy_command.newArg(
          'rest', multi=True, summary='Leftover args.')
        res = command.instantiate(
          ['dummy', 'hierarchy', 'a.b'], start=True, debug=False)
        test.iseq('hierarchy', res.name())
        test.iseq(['a.b'], res.findPart('rest').value())

      testx t2 scope<py>:
        command = metax.cli.Command('demo', parent=None, summary='', desc='')
        command.newFlag(
          'name', mytype='str', default='Bob', aliases='n',
          summary='The name of the person.')
        command.newArg('height', mytype='float', default=None)
        command.newArg('weight', mytype='float', default=None)
        command.newArg('rest', multi=True, summary='Leftover args.')

        res = command.instantiate(
          ['demo', '1.87', '190', 'extra', 'args'], start=True, debug=False)
        values = res.asValues()
        test.iseq('Bob', values.name)
        test.isapprox(1.87, values.height)
        test.isapprox(190, values.weight)
    end method instantiate;

    method findValue : any #:
      Obtain the value of a flag or arg defined within this command.

      Returns:
        The value if present, or null.
    params:
      var nora : str #:
        The name or alias desired.
    scope<py>:
      flags = self.allParts()
      part = flags.get(nora, None)
      if part:
        result = part.value()
      else:
        result = None
      return result
    test<py>:
      res = test.faux.instantiate(
        ['./person', '--name', 'Charles', 'list', 'a', 'b', 'c'])
      test.iseq('Charles', res.findValue('name'))
      test.iseq(0, res.findValue('deps'))
      test.iseq(['a', 'b', 'c'], res.findValue('files'))
    end method findValue;

    method asValues : Values #:
      Wrap myself in a Values instance
    scope<py>:
      return Values(self)
    test<py>:
      res = test.faux.instantiate(
        ['./person', '--name', 'Charles', 'list', 'a', 'b', 'c'])
      values = res.asValues()
      test.isinst(values, metax.cli.Values)
    end method asValues;

    method title : str #:
      A small snippet summarizing this flag.
    scope<py>:
      return 'Command %s' % self.name()
    test<py>:
      test.iseq('Command faux', test.faux.title())
    end method title;

  end class Command;

  abstract
  class SubPart < Part #:
    Abstract superclass of Flag and Arg.
  scope:

    field mytype : str #:
      The type of the part. Legal values are:
        str
        bool
        int
        real<n> or float or double
        enum<val1,val2,...>
        list<T> for T above.

    field enumtype : map #:
      If 'type' is 'enum<...>', this field contains a mapping from values
      to ordinals.  It is null if type isn't 'enum<...>'
    scope:
      accessor get lazy:
        ere = re.compile(r'^enum<(.*)>$')
        m = ere.match(self.mytype())
        if m:
          result = {}
          parts = re.split(r'\s*[,\|]\s*', m.group(1))
          vre = re.compile(r'^([^= ]+)(?:\s*=\s*(\d+))?$')
          for part in parts:
            vm = vre.match(part)
            if vm:
              result[vm.group(1)] = int(vm.group(2) or -1)
            else:
              print('ERROR: Invalid enum spec "%s" (ignored)' % part)
        else:
          result = None
        -> result
      test<py>:
        test.iseqmap(
          {'trans': -1, 'undef': -1, 'male': -1, 'female': -1},
          test.enumflag.enumtype())
        test.isnull(test.dateflag.enumtype())
      end accessor get;
    end field;

    field default : str #:
      The string representation of the default value of the part.

    field start : any #:
      The value of the flag/arg as specified by the command line.  This will
      be null if it was not explicitly specified on the command line.
    field value : any #:
      The current value of the flag/arg. This can be from the default, or from
      a value specified on the command line, or from a runtime modification.

    field error : str #:
      An error message initialized during instantiate().

    lifecycle params:
      var name : str;
      var mytype -> mytype = 'str';
      var default -> default = null;
      var aliases : str = null;
      var summary : str = null;
      var desc : str = null;
    super (name, aliases=aliases, summary=summary, desc=desc)
    scope<py>:
      default = self.default()
      if default is None:
        self.valueIs(None)
      else:
        value = self.typecheck(default)
        if value is Part.InvalidValue:
          raise Error(
            '%s cannot have default value "%s"' % (self.title(), default))
        self.valueIs(value)
    scope<cc>:
    end;

  end class SubPart;

  class Flag < SubPart #:
    A single customizable (usually optional) name/value pair accessible
    within a program by name or alias.
  scope:

    protected
    method instantiate : trilean #:
      Typecheck and conditionally assign a value to this flag.

      Returns:
        null if the value is invalid.
        true if the next arg was needed.
        false if the next arg was not needed.
    params:
      var nora : str #:
        The name or alias by which the flag was specified. For bool flags,
        this may include a 'no' prefix.
      var inval : str #:
        The value specified inline with the flag reference via '='. If null,
        it means there was no inline value given.
      var nextval : str #:
        The value of the arg after the flag. This may or may not be used,
        depending on nora and inline. A value of null means no value available.
    scope<py>:
      /# None means the value is invalid
      /# True means the value is valid and nextval was consumed
      /# False means the value is valid and nextval was not consumed
      result = None

      flagtype = self.mytype()
      if flagtype == 'bool':
        /# We do NOT currently support assigning a value to booleans from
        /# nextval ... only by using nora and inval.
        if inval:
          /# The only legal inval values are 'true' and 'false'
          realval = self.typecheck(inval)
        elif nora.startswith('no'):
          realval = False
        else:
          realval = True

        /# false means we did NOT use nextval.
        result = False

      else:
        /# Non-boolean flags can get their value from inval or nextval.
        if inval is None:
          result = True
          flagval = nextval
        else:
          result = False
          flagval = inval
        realval = self.typecheck(flagval)

      if realval is Part.InvalidValue:
        /# means the specified value is not legal for the flag, and returning
        /# None from this method indicates that.
        result = realval
        /# We mark the value of the flag is invalid.
        self.valueIs(realval)
      else:
        self.valueIs(realval)

      return result
    test<py>:
      def Chk(flag, flagname, inval, nextval, eres, evalue):
        res = flag.instantiate(flagname, inval, nextval)
        test.iseq(eres, res)
        test.iseq(evalue, flag.value())
      invalid = metax.cli.Part.InvalidValue

      /# str flags.
      Chk(test.metalang, 'metalang', 'oopl', 'blah', False, 'oopl')
      Chk(test.metalang, 'metalang', None, 'oopl', True, 'oopl')
      Chk(test.metalang, 'L', 'oopl', 'blah', False, 'oopl')
      Chk(test.metalang, 'L', None, 'oopl', True, 'oopl')
      Chk(test.metalang, 'metalang', 20, 'oopl', False, '20')

      /# bool flags.
      /#  - the nextval is currently never used, so res is always False or None,
      /#    never True.
      Chk(test.expand, 'expand', 'true', 'false', False, True)
      Chk(test.expand, 'expand', 'false', 'true', False, False)
      Chk(test.expand, 'e', 'true', 'false', False, True)
      Chk(test.expand, 'e', 'false', 'true', False, False)
      Chk(test.expand, 'expand', None, 'true', False, True)
      Chk(test.expand, 'noexpand', None, 'true', False, False)
      Chk(test.expand, 'expand', 'blah', 'true', invalid, invalid)
    end method instantiate;

    method isFlag : bool scope<py>:
      return True
    test<py>:
      test.isfalse(test.arg4.isFlag())
      test.istrue(test.strflag.isFlag())
    end method isFlag;

    method title : str #:
      A small snippet summarizing this flag.
    scope<py>:
      return 'Flag --%s : %s' % (self.name(), self.mytype())
    test<py>:
      test.iseq('Flag --name : str', test.strflag.title())
    end method title;

  end class Flag;

  class Arg < SubPart #:
    A positional argument.
  assocs:
    std assoc textwrap
  scope:

    method instantiate : int #:
      Instantiate this instance (set its value) if the given value matches
      the type of this arg.

      Returns:
        -1 if the arg failed to instantiate
        Otherwise returns the index within values one past those consumed
        by this arg.
    params:
      var values : vec<str> #:
        The values being processed.
      var index : int #:
        The index within values corresponding to this arg.
    scope<py>:
      error = None
      if self.ismulti():
        /# This is a multi-valued arg (i.e. type 'list<...>')
        value_list = values[index:]
        realval = self.typecheck(value_list)

        if realval is Part.InvalidValue:
          error = (
            "%s cannot have value '%s'" % (self.title(), str(value_list)))
          result = -1
          /# TODO(wmh): SHould we set value to Part.InvalidValue?
          self.valueIs(None)
        else:
          /# We've consumed all the values.
          result = len(values)
          self.valueIs(realval)
      else:
        /# This is a single-valued arg.
        value = values[index]
        realval = self.typecheck(value)
        if realval is Part.InvalidValue:
          error = (
            "%s cannot have value '%s'" % (self.title(), value))
          result = -1
          /# TODO(wmh): SHould we set value to Part.InvalidValue?
          self.valueIs(None)
        else:
          self.valueIs(realval)
          result = index + 1

      self.errorIs(error)
      return result
    test<py>:
      /# TODO(wmh): How to redirect the stream written to by logging.info()?
      /# Maybe https://stackoverflow.com/questions/22105465/how-can-i-temporarily-redirect-the-output-of-logging-in-python
      arg1 = test.arg1
      arg4 = test.arg4
      values = ['abc', '500', '200', '300']

      test.isnull(arg1.value())

      def Chk(arg, values, index, expected_index, expected_value):
        test.iseq(expected_index, arg.instantiate(values, index))
        test.iseq(expected_value, arg.value())

      Chk(arg1, values, 1, 2, 500)
      Chk(arg1, values, 2, 3, 200)
      Chk(arg1, values, 0, -1, None)

      Chk(arg4, values, 1, 4, ['500', '200', '300'])
      arg4.mytypeIs('list<int>')
      Chk(arg4, values, 1, 4, [500, 200, 300])
      Chk(arg4, values, 0, -1, None)
    end method instantiate;

    method ismulti : bool #:
      True if this is a multi-value arg.
    scope<py>:
      return self.mytype().startswith('list<')
    test<py>:
      test.isfalse(test.arg1.ismulti())
      test.istrue(test.arg4.ismulti())
    end method ismulti;

    method isArg : bool scope<py>:
      return True
    test<py>:
      test.istrue(test.arg4.isArg())
      test.isfalse(test.strflag.isArg())
    end method isArg;

    method title : str #:
      A small snippet summarizing this flag.
    scope<py>:
      return 'Arg %s : %s' % (self.name(), self.mytype())
    test<py>:
      test.iseq('Arg width : int', test.arg1.title())
    end method title;

  end class Arg;

  behavior show  #:
    Print out information about this part.
  params:
    var fp : ostream = out #:
      Where to write output.
    var indent : str = "" #:
      The indentation to insert before each line of output.
    var mode : str = 'help' #:
      How much details to show.  Possible values are:
        summary: provide a one-line summary
        help: provide help for the part
        helpfull: provide detailed help for the part.
  scope:
    receiver Command scope<py>:
      indent = u'' + indent
      subindent = indent + '  '
      full = 'ful' in mode

      if mode == 'summary':
        /# One line summary (no flags, no args, no long-winded description)
        /# CODETANGLE(help_width) in src/kernel/shell.meta (not
        /# lib/kernel/shell.meta)
        fp.write(u'%s%-15s: %s\n' % (indent, self.name(), self.summary()))

      else:
        /# Multi-line help
        fp.write(u'%s%s:\n' % (indent, self.name()))
        summary = self.summary()
        if summary:
          fp.write(u'%s  %s\n' % (indent, summary))
        if full:
          desc = self.desc()
          if desc:
            for line in desc.split('\n'):
              fp.write(u'%s  %s\n' % (indent, line))

        parts = self.allParts() if full else self.parts()

        for flagname in sorted(parts):
          part = parts[flagname]
          if part.name() != flagname: continue   # skip aliases
          /# flags and args are both recorded in parts, but we only want to
          /# show flags here.
          if part.isFlag():
            part.show(fp=fp, indent=subindent, mode=mode)

        /# Intentionally listing in order instead of alphabetically, in case
        /# the order is important (user can order them alphabetically if
        /# order isn't important).
        for command in self.order():
          if full:
            fp.write(u'\n')
          command.show(fp=fp, indent=subindent, mode=mode)

        for arg in self.args():
          if 'help' not in mode or not arg.ismulti or full:
            arg.show(fp=fp, indent=subindent, mode=mode)
    test<py>:
      fp = test.fp()
      test.command.show(fp=fp, mode='help')
      test.iseqtext("""\
        >|metac:
        >|  --baselang|b : str = "<special>"
        >|    The baselang to compile into.
        >|  --metadir : str = ".metac"
        >|    The subdir to write code to.
        >|  --metalang|L : str = "oopl"
        >|    The metalang the code is defined in.
        >|  canonical:
        >|    Canonicalize the specified meta files and report diffs.
        >|    --expand|e : bool = False
        >|      If true, invoke expandMeta() before canonicalizing
        >|""",
        test.out())
    end receiver Command;

    receiver Flag scope<py>:
      value = self.value()
      start = self.start()
      default = self.default()

      if isinstance(value, Part.RegexpClass):
        valstr = value.pattern
      else:
        valstr = str(value)

      def Trunc(val, width):
        w = len(val)
        return val if w < width else val[:width-1] + '$'

      if mode == 'summary':
        sval = (
          'none' if start is None
          else ('=' if str(start) == valstr else Trunc(str(start), 10)))
        dval = '=' if str(default) == valstr else Trunc(str(default), 10)

        fp.write(
          u'%s--%-20s %-30s %-10s %-10s\n' %
          (indent, self.name(), valstr, sval, dval))

      elif 'help' in mode:
        symbols = '|'.join([self.name()] + self.aliases())
        mytype = self.mytype()
        default = self.default()
        if mytype == 'str':
          default = '"%s"' % default
        fp.write(
          u'%s--%s : %s = %s\n' % (indent, symbols, mytype,default))
        summary = self.summary()
        if summary:
          fp.write(u'%s  %s\n' % (indent, summary))
        desc = self.desc()
        if desc and 'ful' in mode:
          for line in desc.split('\n'):
            fp.write(u'%s  %s\n' % (indent, line))

      else:
        fp.write(u'%sERROR: Unknown mode %s\n' % (indent, summary))
    test<py>:
      fp = test.fp()
      test.baselang.show(fp=fp, mode='summary')
      test.iseqtext(
        '--baselang             <special>                      none       '
        '=         \n',
        fp.getvalue())
    end receiver Flag;

    receiver Arg scope<py>:
      value = self.value()
      start = self.start()
      default = self.default()

      def Trunc(val, width):
        w = len(val)
        return val if w < width else val[:width-1] + '$'

      if mode == 'summary':
        sval = '=' if str(start) == str(value) else Trunc(str(start), 10)
        dval = '=' if str(default) == str(value) else Trunc(str(default), 10)

        fp.write(
          '%s%-22s %-30s %-10s %-10s\n' %
          (indent, self.name(), value, sval, dval))

      elif 'help' in mode:
        symbols = '|'.join([self.name()] + self.aliases())
        fp.write('%s%s: %s\n' % (indent, symbols, self.summary() or ''))
        desc = self.desc()
        if desc and 'ful' in mode:
          for line in desc.split('\n'):
            fp.write('%s  %s\n' % (indent, line))

      else:
        fp.write('%sERROR: Unknown mode %s\n' % (indent, summary))
    test<py>:
      fp = test.fp()
      test.baselang.show(fp=fp, mode='summary')
      test.iseq(
        '--baselang             <special>                      none       '
        '=         \n',
        fp.getvalue())
    end receiver Arg;

  end behavior show;

  class Values #:
    A wrapper around a Command instance providing accessing to flags and args.
  scope:

    field _command_ : Command #:
      TODO(wmh): Change this to metax__command and have the rule that
      programmers should never use 'metax__' or 'Metax__' as a prefix in any
      attribute value (maybe even enforce that rule).

    lifecycle params:
      var command -> _command_;
    scope<py>:
    scope<cc>:
    end;

    method __getattr__ : any #:
      Allow one to obtain the values of flags/args as properties on self.
    params:
      var nora : str #:
        The name or alias of the flag or arg desired.
    scope<py>:
      command = self._command_()
      result = command.findValue(nora)
      if result is None:
        raise AttributeError('Undefined flag --%s (or arg %s)' % (nora, nora))
      return result
    test<py>:
      command = test.faux.instantiate(
        ['./person', '--name', 'Charles', 'list', 'a', 'b', 'c'])
      values = metax.cli.Values(command)
      test.iseq('Charles', values.name)
      test.iseq(0, values.deps)
      test.iseq(['a', 'b', 'c'], values.files)

      try:
        value = values.blah
      except AttributeError:
        pass
      else:
        test.fail('Failed to raise AttributeError')
    end method __getattr__;

    method __setattr__ #:
      Assign a value to a flag.
    params:
      var nora : str #:
        The name or alias of the flag or arg to set.
      var value : any #:
        The value to assign.
    scope<py>:
      if nora == '_Values__command_':
        self.__dict__[nora] = value
      else:
        command = self._command_()
        flags = command.allParts()
        part = flags.get(nora, None)
        if part is None:
          raise AttributeError('Undefined flag --%s (or arg %s)' % (nora, nora))
        else:
          realval = part.typecheck(value)
          if realval is Part.InvalidValue:
            logging.error("%s cannot have value '%s'", self.title(), value)
          else:
            part.valueIs(value)
    test<py>:
      command = test.faux.instantiate(
        ['./person', '--name', 'Charles', 'list', 'a', 'b', 'c'])
      values = metax.cli.Values(command)
      values.name = 'Chuck'
    end method __setattr__;

  end class Values;

  test
  class TestCase < metax.test.TestCase scope:
    lifecycle setup:
      command = metax.cli.Command('metac')
      test.command = command
      test.baselang = command.newFlag(
        'baselang', 'str', '<special>', aliases='b',
        summary='The baselang to compile into.',
        desc='If this is <special>, a metalang-specific default is used')
      test.metalang = command.newFlag(
        'metalang', 'str', 'oopl', aliases='L',
        summary='The metalang the code is defined in.')
      test.metadir = command.newFlag(
        'metadir', 'str', '.metac',
        summary='The subdir to write code to.',
        desc="A value of .metac is treated specially, being symlinked to repo")

      test.subcommand = command.newCommand(
        'canonical', aliases='can',
        summary='Canonicalize the specified meta files and report diffs.')
      test.expand = test.subcommand.newFlag(
        'expand', 'bool', False, aliases='e',
        summary='If true, invoke expandMeta() before canonicalizing',
        desc='By default, expandMeta() invokes parseMeta() but not expandMeta().')

      test.faux = metax.cli.Command(
        'faux', summary='A command with a flag and arg of each type.')
      test.strflag = test.faux.newFlag(
        'name', default='Bob', summary='The name of the person')
      test.intflag = test.faux.newFlag(
        'deps', mytype='int', default='0', summary='Number of dependents.')
      test.realflag = test.faux.newFlag(
        'height', mytype='real', aliases='h', default='1.87',
        summary='Height in meters.')
      test.dateflag = test.faux.newFlag(
        'dob', mytype='date', aliases='d', default='1980-05-17',
        summary='Date of birth.')
      test.reflag = test.faux.newFlag(
        'version', mytype='re', aliases='r', default='',
        summary='Version to use.')
      test.enumflag = test.faux.newFlag(
        'gender', mytype='enum<undef|female|male|trans>', default='undef',
        summary='Gender of person')
      test.trilflag = test.faux.newFlag(
        'top', mytype='trilean', default='true',
        summary='Misc. trilean flag')

      test.fauximg = test.faux.newCommand(
        'image', summary='Image processing.')
      test.arg1 = test.fauximg.newArg(
        'width', mytype='int', summary='Image width')
      test.arg2 = test.fauximg.newArg(
        'length', mytype='int', default=600, summary='Image length')
      test.arg3 = test.fauximg.newArg(
        'color', mytype='enum<red,green,blue>', aliases='c', default='red',
        summary='Preferred primary color')

      test.fauximg2 = test.faux.newCommand(
        'list', aliases='dir', summary='Image listing')
      test.arg4 = test.fauximg2.newArg(
        'files', multi=True, summary='The image files.')
    end;
  end class TestCase;

end namespace metax.cli;
