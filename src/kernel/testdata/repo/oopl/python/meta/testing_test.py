# -*- coding: utf-8 -*-
"""Unit tests for meta.testing"""
import cStringIO
import os
import sys
import unittest

import fake_filesystem
import meta.testing
import mox


class TestCaseMetaClass(meta.root.ObjectMetaClass):
  """Meta class of meta.testing_test.TestCase."""

  def __init__(cls, meta__name, meta__bases, meta__dct):
    """Initializer.

    Args:
      meta__name: str
      meta__bases: list
      meta__dct: dict
    """
    super(TestCaseMetaClass, cls).__init__(meta__dct, meta__bases, meta__name)
    # User-provided code follows.


class TestCase(unittest.TestCase):
  """We are intentionally not subclassing from meta.testing.TestCase (the
  class we want to test) as the superclass of this test class (regardless
  of how meta that would be) because we can do a better job of verifying
  functionality if the machinery of unit testing isn't being mixed up with
  the unit tests themselves.

  Note that the carat (^) before unittest.TestCase above indicates that
  the parent is not a class generated by Meta. In particular, since
  parent classes are implicitly added as associations, the carat indicates
  that we should NOT add unittest as a dependency of testing_test.py.
  This works as long as we are subclassing from a class in a module from
  the default python library, but will fail if we need to inherit from
  an meta-external thirdparty class.

  Possible solutions:
    1) Do not implicitly add parents as associations.
        - this is such a convenience that I'd really prefer to keep it if possible
    2) If an explicit association for the parent class is specified, it
       is used instead of the implicit one.
        - This may be a bit messy to implement, but should fix the problems
          nicely (and remove the need to have the hacky '^' syntax in the
          first place).
  """
  __metaclass__ = TestCaseMetaClass

  def __init__(self, meta__name):
    """Initializer.

    Args:
      meta__name: str
    """
    super(TestCase, self).__init__(meta__name)
    # User-provided code follows.

# The singleton instance of the metaclass.
TestCaseClass = TestCase


class TestCaseTestMetaClass(TestCaseMetaClass):
  """Meta class of meta.testing_test.TestCaseTest."""

  def __init__(cls, meta__name, meta__bases, meta__dct):
    """Initializer.

    Args:
      meta__name: str
      meta__bases: list
      meta__dct: dict
    """
    super(TestCaseTestMetaClass, cls).__init__(
      meta__dct, meta__bases, meta__name)
    # User-provided code follows.


class TestCaseTest(TestCase):
  """Unit tests for class TestCase."""
  __metaclass__ = TestCaseTestMetaClass

  def __init__(self, meta__name):
    """Initializer.

    Args:
      meta__name: str
    """
    super(TestCaseTest, self).__init__(meta__name)
    self._tc = None
    # User-provided code follows.

  # field _tc : meta.testing.TestCase

  def tc(self):
    """Returns: meta.testing.TestCase"""
    return self._tc

  def tcIs(self, value):
    """Setter for field tc

    Args:
      value: meta.testing.TestCase

    Returns: meta.testing_test.TestCaseTest
    """
    self._tc = value
    return self

  def setUp(self):
    self._tc = meta.testing.TestCase('captureStdout')
    self._tc.setUp()

  def tearDown(self):
    self._tc.tearDown()

  def test_setenv(self):
    # TODO(wmh): Work on this.
    return

    home = os.getenv('HOME', None)
    self._tc.setenv('HOME', '/home/bob')
    self.assertEqual('/home/bob', os.getenv('HOME', None))
    self._tc.tearDown()
    self.assertEqual(home, os.getenv('HOME', None))

  def test_captureStdout(self):
    self.assertTrue(sys.stdout is meta.testing.TestCase.STDOUT)
    self._tc.captureStdout()
    self.assertTrue(isinstance(sys.stdout, meta.testing.cStringIOClass))
    print 'hello world'
    out = self._tc.getStdout()
    self.assertTrue(sys.stdout is meta.testing.TestCase.STDOUT)
    self.assertEqual('hello world\n', out)

  def test_getStdout(self):
    # noop, tested in test_captureStdout()
    pass

  def test_captureStderr(self):
    self.assertTrue(sys.stderr is meta.testing.TestCase.STDERR)
    self._tc.captureStderr()
    self.assertTrue(isinstance(sys.stderr, meta.testing.cStringIOClass))
    sys.stderr.write('hello world\n')
    err = self._tc.getStderr()
    self.assertTrue(sys.stderr is meta.testing.TestCase.STDERR)
    self.assertEqual('hello world\n', err)

  def test_getStderr(self):
    # noop, tested in test_captureStderr()
    pass

  def test_newMox(self):
    tc = self._tc
    self.assertEqual(0, len(tc._moxlist))

    # Basic mox
    m1 = tc.newMox()
    self.assertEqual(1, len(tc._moxlist))
    m1.UnsetStubs()

    # Another mox, this time with a stub.
    m2 = tc.newMox(tc.tmpFile)
    tc.tmpFile().AndReturn('blah')
    m2.ReplayAll()
    res = tc.tmpFile()
    self.assertEqual('blah', res)
    m2.VerifyAll()

    # TODO(wmh): Add additional code for verifying static and
    # class method stubs?

    # Important to clean up tc here!
    tc.tearDown()

  def test_fp(self):
    pass

  def test_tmpFile(self):
    self.assertEqual([], self._tc._tmpfiles)
    tmpfile = self._tc.tmpFile()
    self.assertEqual([tmpfile], self._tc._tmpfiles)
    self.assertTrue(os.path.exists(tmpfile))
    tmpfile2 = self._tc.tmpFile(create=False)
    self.assertEqual([tmpfile, tmpfile2], self._tc._tmpfiles)
    self.assertFalse(os.path.exists(tmpfile2))
    self._tc.tearDown()
    self.assertFalse(os.path.exists(tmpfile))
    self.assertFalse(os.path.exists(tmpfile2))

  def test_tmpDir(self):
    self.assertEqual([], self._tc._tmpdirs)
    tmpdir = self._tc.tmpDir()
    self.assertEqual([tmpdir], self._tc._tmpdirs)
    self.assertTrue(os.path.exists(tmpdir))
    tmpdir2 = self._tc.tmpDir(create=False)
    self.assertEqual([tmpdir, tmpdir2], self._tc._tmpdirs)
    self.assertFalse(os.path.exists(tmpdir2))
    self._tc.tearDown()
    self.assertFalse(os.path.exists(tmpdir))
    self.assertFalse(os.path.exists(tmpdir2))

  def test_fileContents(self):
    # path = os.path.join(
    #   os.path.dirname('/Users/wmh/src/meta/src/kernel/root.meta'), './testdata/testing/cipherfile')
    path = meta.root.Object.Resource(
      'cipherfile', fqn='meta.testing.TestCase')
    self.assertEqual('aes-128-cbc\ntesting\n', self._tc.fileContents(path))

  def test_isInteractive(self):
    pass

  def test_setupSharedFilesystem(self):
    tc = self._tc
    self.assertEqual(None, tc._fs)

    modules = [meta.testing, sys.modules[__name__]]
    tc.setupSharedFilesystem(
        modules, [('/a/b/c', {'contents': 'blah'})])

    fsinfo = tc._fsinfo
    self.assertEqual(
        ['__main__', 'meta.testing'],
        sorted(fsinfo.keys()))
    self.assertTrue(
      fsinfo['__main__']['objs'] is
      fsinfo['meta.testing']['objs'])
    self.assertNotEqual(None, tc._fs)

  def test_setupFilesystem(self):
    test = self
    # User-provided code follows.
    tc = self._tc
    self.assertEqual({}, tc._fsinfo)
    tc.setupFilesystem(
        meta.testing,
        path_specs=[
            '/home/bob/file1',
            ('/home/bob/file2',
             {'contents': 'hello world\n', 'perms': 0640}),
            ('/home/bob/dir1', 'dir'),
            ('/home/bob/dir2', {'type': 'dir', 'perms': 0755}),
            ('/home/bob/link1',
             {'type': 'link', 'srcpath': '/home/bob/file1'}),
        ])

    # Verify that tc._fsinfo has been augmented.
    self.assertEqual(
        ['meta.testing'],
        tc._fsinfo.keys())

    # Basic test (more thorough testing in testPopulateFilesystem()).
    self.assertEqual(
        True, meta.testing.os.path.exists('/home/bob/file1'))
    stat_info = meta.testing.os.stat('/home/bob/file1')

    self.assertEqual(0, stat_info.st_size)
    self.assertEqual('100666', '%o' % stat_info.st_mode)
    self.assertEqual(None, tc._fs)

  def test_populateFilesystem(self):
    test = self
    # User-provided code follows.
    tc = self._tc
    self.assertEqual({}, tc._fsinfo)

    if False:
      epath = os.path.join(
        os.path.dirname('/Users/wmh/src/meta/src/kernel/root.meta'),
        './testdata/regexp/entry.mre')
      with open(epath, 'r') as fp:
        contents = fp.read()
    else:
      epath = meta.root.Object.Resource(
        'entry_mre', fqn='meta.testing.TestCase')
      # print '**** HERE with epath=%s' % epath
      with open(epath, 'r') as fp:
        contents = fp.read()

    # We mock out the single call to meta.testing.TestCase._ReadFile() which
    # will be invoked for '/home/bob/file3'
    m = tc.newMox()
    m.StubOutWithMock(tc, '_readFile')
    tc._readFile(mox.IsA(str)).AndReturn(contents)
    m.ReplayAll()

    # Calling SetupFilesystem() will call PopulateFileSystem(), and it is
    # easier to test after fully initializing than to test in isolation.
    tc.setupFilesystem(
        meta.testing,
        path_specs=[
            '/home/bob/file1',
            ('/home/bob/file2',
             {'contents': 'hello world\n', 'perms': 0640}),
            ('/home/bob/dir1', 'dir'),
            ('/home/bob/dir2', {'type': 'dir', 'perms': 0755}),
            ('/home/bob/link1',
             {'type': 'link', 'srcpath': '/home/bob/file1'}),
            ('/home/bob/file3',
             {'contents_path': epath}),
        ])
    package = 'meta.testing'
    self.assertTrue(package in tc._fsinfo)
    self.assertTrue(meta.testing is tc._fsinfo[package]['module'])
    for k in ('fs', 'open', 'os', 'fcntl'):
      self.assertTrue(k in tc._fsinfo[package]['objs'])

    # file1 is a file with no content.
    self.assertEqual(
        True, meta.testing.os.path.exists('/home/bob/file1'))
    stat_info = meta.testing.os.stat('/home/bob/file1')
    self.assertEqual(0, stat_info.st_size)
    self.assertEqual('100666', '%o' % stat_info.st_mode)

    # file2 is a file with content.
    fp = meta.testing.open('/home/bob/file2', 'r')
    self.assertEqual('hello world\n', fp.read())
    fp.close()
    stat_info = meta.testing.os.stat('/home/bob/file2')
    self.assertEqual('100640', '%o' % stat_info.st_mode)

    # dir1 is a directory with default permissions.
    self.assertEqual(
        True, meta.testing.os.path.isdir('/home/bob/dir1'))
    stat_info = meta.testing.os.stat('/home/bob/dir1')
    self.assertEqual('40777', '%o' % stat_info.st_mode)

    # dir2 is a directory with specific permissions.
    self.assertEqual(
        True, meta.testing.os.path.isdir('/home/bob/dir2'))
    stat_info = meta.testing.os.stat('/home/bob/dir2')
    self.assertEqual('40755', '%o' % stat_info.st_mode)

    # link1 is a symlink to file1
    stat_info = meta.testing.os.stat('/home/bob/link1')
    self.assertEqual('100666', '%o' % stat_info.st_mode)

    # file3 has content initialized from a file.
    self.assertEqual(
        True, meta.testing.os.path.exists('/home/bob/file3'))
    stat_info = meta.testing.os.stat('/home/bob/file3')
    self.assertEqual(28, stat_info.st_size)
    self.assertEqual('100666', '%o' % stat_info.st_mode)

    m.VerifyAll()

  def test_fakeFile(self):
    tc = self._tc

    # If we don't first call SetupSharedFilesystem, FakeFile() is an error.
    self.assertRaises(meta.testing.Error, tc.fakeFile, '/any/path')

    fs = tc.setupSharedFilesystem(
        [meta.testing], [('/a/b/c', {'contents': 'blah'})])
    fake = tc.fakeFile('/a/b/c')
    self.assertTrue(isinstance(fake, fake_filesystem.FakeFile))
    self.assertEqual('blah', fake.contents)

  def test_fakeFileExists(self):
    pass

  def test_fakeContents(self):
    tc = self._tc

    # If we don't first call SetupSharedFilesystem, FakeContent() is an error.
    self.assertRaises(meta.testing.Error, tc.fakeContents, '/any/path')

    fs = tc.setupSharedFilesystem(
        [meta.testing], [('/a/b/c', {'contents': 'blah'})])
    self.assertEqual('blah', tc.fakeContents('/a/b/c'))

  def test__readFile(self):
    pass

  def test_revertFilesystem(self):
    tc = self._tc
    mname = meta.testing.__name__
    self.assertFalse(mname in tc._fsinfo)
    unused_fs = tc.setupFilesystem(meta.testing)
    self.assertTrue(mname in tc._fsinfo)
    tc.revertFilesystem(meta.testing)
    self.assertFalse(mname in tc._fsinfo)

  def test_startswith(self):
    pass


class FakeFcntlTestMetaClass(TestCaseMetaClass):
  """Meta class of meta.testing_test.FakeFcntlTest."""

  def __init__(cls, meta__name, meta__bases, meta__dct):
    """Initializer.

    Args:
      meta__name: str
      meta__bases: list
      meta__dct: dict
    """
    super(FakeFcntlTestMetaClass, cls).__init__(
      meta__dct, meta__bases, meta__name)
    # User-provided code follows.


class FakeFcntlTest(TestCase):
  """Unit tests for class FakeFcntl."""
  __metaclass__ = FakeFcntlTestMetaClass

  def __init__(self, meta__name):
    """Initializer.

    Args:
      meta__name: str
    """
    super(FakeFcntlTest, self).__init__(meta__name)
    # User-provided code follows.

  def test_FakeFcntl(self):
    pass

  def test_fcntl(self):
    # noop
    # TODO(wmh): Is there a way to verify this method does nothing?
    pass

  def test_ioctl(self):
    # noop
    # TODO(wmh): Is there a way to verify this method does nothing?
    pass

  def test_flock(self):
    # noop
    # TODO(wmh): Is there a way to verify this method does nothing?
    pass

  def test_lockf(self):
    # noop
    # TODO(wmh): Is there a way to verify this method does nothing?
    pass


class StubHolderTestMetaClass(TestCaseMetaClass):
  """Meta class of meta.testing_test.StubHolderTest."""

  def __init__(cls, meta__name, meta__bases, meta__dct):
    """Initializer.

    Args:
      meta__name: str
      meta__bases: list
      meta__dct: dict
    """
    super(StubHolderTestMetaClass, cls).__init__(
      meta__dct, meta__bases, meta__name)
    # User-provided code follows.


class StubHolderTest(TestCase):
  """Unit tests for class StubHolder."""
  __metaclass__ = StubHolderTestMetaClass

  def __init__(self, meta__name):
    """Initializer.

    Args:
      meta__name: str
    """
    super(StubHolderTest, self).__init__(meta__name)
    # User-provided code follows.

  def test_Meta__9_id(self):
    pass

  def test___del__(self):
    pass

  def test___enter__(self):
    pass

  def test___exit__(self):
    pass

  def test_CleanUp(self):
    pass

  def test_SmartSet(self):
    pass

  def test_SmartUnsetAll(self):
    pass

  def test_Set(self):
    pass

  def test_UnsetAll(self):
    pass


if __name__ == '__main__':
  meta.testing.main()
