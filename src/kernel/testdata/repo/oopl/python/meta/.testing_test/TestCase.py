# Imports for class TestCase
import sys                                # core 
# End imports for class TestCase


class TestCase(unittest.TestCase):
  """We are intentionally not subclassing from meta.testing.TestCase (the
  class we want to test) as the superclass of this test class (regardless
  of how meta that would be) because we can do a better job of verifying
  functionality if the machinery of unit testing isn't being mixed up with
  the unit tests themselves.

  Note that the carat (^) before unittest.TestCase above indicates that
  the parent is not a class generated by Meta. In particular, since
  parent classes are implicitly added as associations, the carat indicates
  that we should NOT add unittest as a dependency of testing_test.py.
  This works as long as we are subclassing from a class in a module from
  the default python library, but will fail if we need to inherit from
  an meta-external thirdparty class.

  Possible solutions:
    1) Do not implicitly add parents as associations.
        - this is such a convenience that I'd really prefer to keep it if possible
    2) If an explicit association for the parent class is specified, it
       is used instead of the implicit one.
        - This may be a bit messy to implement, but should fix the problems
          nicely (and remove the need to have the hacky '^' syntax in the
          first place).
  """
  __metaclass__ = TestCaseMetaClass

  def __init__(self, meta__name):
    """Initializer.

    Args:
      meta__name: str
    """
    super(TestCase, self).__init__(meta__name)
    # User-provided code follows.

# The singleton instance of the metaclass.
TestCaseClass = TestCase
