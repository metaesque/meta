namespace metax.c.shell #:
  An interactive shell for exploring Meta.
scope:

  class Shell < metax.lib.shell.Shell assocs:
    std assoc io;
    std assoc os;
  scope:

    field compiler : metax.c.Compiler #:
      The compiler instance invoking this shell.

    lifecycle params:
      var compiler -> compiler;
    scope:
      self.setvarCommand('prompt', 'meta> ')

      self.rcfileIs(
        os.path.join(os.getenv('HOME'), '.config', 'metaxy', 'metarc'))

      /# Register commands
      /#  - If the method associated with a command accepts arbitrary args,
      /#    a dispatcher keyword param is not needed. However, if the method
      /#    does not accept arbitrary args, one should provide dispatcher
      /#    keyword.
      self.defineCommand('context', self.showMetaContext)
      self.defineCommand('hier', self.showHierarchy)
      self.defineCommand('sym', self.showSymbols)

      /# Directory hierarchy:
      /#  /disk/<nmsp1>/<nmsp2>/.../<class>
      /#    provides access to information about already-compiled namespaces
      /#    and classes, aggregating information across all base langs.
      /#  /mem/<metafile>/<nmsp>/.../<class>/<method>
      /#    provides access to information about in-memory parsed .meta files
      /#    and the entire construct hierarchy within each metafile
      /#     - ability to print out the Context associated with arbitrary block
      root = self.filesystem()
      disk = root.add('dir', 'disk')

      /# Defining directory 'mem'
      mem = root.add(
        'dir', 'mem', childvar='metafile', freshold=1,
        /# Generating the children of 'mem', each of which is a metafile abbrev.
        generator=lambda mem: [
          /# Defining a directory representing a metafile
          mem.add(
            'dir', metafile.abbrev(), childvar='namespace', freshold=1,
            info={'construct': metafile.construct()},
            /# Generating the children of the metafile dir, each of which is
            /# a fully-qualified namespace.
            generator=lambda metafile_dir: [
              /# Defining a directory representing a namespace
              metafile_dir.add(
                'dir', namespace.id(), childvar='class', freshold=1,
                info={'construct': namespace},
                /# Generating the children of the namespace dir, each of which
                /# is a class id within the namespace.
                generator=lambda namespace_dir: [
                  /# Defining a directory representing a class
                  namespace_dir.add(
                    'dir', klass.id(), childvar='method', freshold=1,
                    info={'construct': klass},
                    /# Generating the children of the class dir, each of which
                    /# is a method id within the class.
                    generator=lambda klass_dir: [
                      /# Defining a directory representing a method.
                      klass_dir.add(
                        'dir', method.id(), childvar=None, freshold=1,
                        info={'construct': method},
                        /# Generating the children of the method dir
                        generator=lambda method_dir: [
                          /# TODO(wmh): What should we display here? Will
                          /# probably need to define it in a function, as this
                          /# lambda won't be expressive enough to generate
                          /# file contents, etc.
                          /#
                          /# Possibilities:
                          /#   meta --> file containing meta source code of method
                          /#   py   --> file containing python source code
                          /#   cc   --> file containing c++ source code
                          /#   ...
                        ]
                      )
                      for method in klass_dir.info('construct').attrval('scope:')
                      if method.kind() == 'method'
                    ],
                  )
                  for klass in namespace_dir.info('construct').attrval('scope:')
                  if klass.kind() == 'class'
                ],
              )
              for namespace in metafile_dir.info('construct').attrval('scope:')
              if namespace.kind() == 'namespace'
            ],
          )
          for metafile in self.compiler().metaorder()
        ]
      )
    end lifecycle;

    override
    method dispatch : bool #:
      Find and execute a command based on a command and args provided by user.

      Returns:
        true if command was found and invoked (regardless of success of
        command), false if command not legal.
    params:
      var command : str #:
        A word provided by the user representing a registered command to invoke.
      var args : vec<str> #:
        The args provided by the user after the command.
    scope:
      info = self._commands.get(command, None)
      if info:
        /# A recognized command ... let the parent implementation handle it.
        result = super(Shell, self).dispatch(command, args)
      else:
        /# There is a Compiler instance associated with this Shell. It should
        /# have a top-level 'metac' command defined on it, with numerous
        /# sub-commands within that top-level command. Those subcommands are
        /# legal commands here. Determining what to invoke is based on the
        /# following notes:
        /#  - all of the subcommands should have feature attribute 'kind'
        /#    value 'named', which means a '_<command>_command' method will
        /#    be defined to implement the code, so that method can be invoked.
        /#  - need to update the comamnd stored in the Object.CLI() ...
        /#    this code is fragile and esoteric (would be nice to cleanup).
        result = None

        /# Find the top-level (metac) compiler.
        compiler = self.compiler()
        cli = compiler.cli()
        cmd = cli._command_()
        root = cmd.root()
        assert root.id() == 'metac'

        /# Form a command line based on 'command' and 'args'. Use this
        /# command-line to instantiate the metac Command (which should return
        /# some sub-command within metac, properly initialized).
        allargs = [root.name(), command] + args
        cmd = root.instantiate(allargs, parent=None)

        if cmd is root:
          /# Failed to find a valid command.
          print('Unknown command "%s"' % command)
        elif cmd.id() != command:
          print('Matched %s not %s' % (cmd.id(), command))
        else:
          /# Command instantiation identified a command.

          /# We update the global metax.cli.Values() instance with a
          /# new Command. 
          compiler.updateCLI(cmd)

          /# Individual commands should set this. In fact, consider
          /# deleting this field.
          compiler.argmapIs(None)

          func_name = '_%s_command' % command
          method = getattr(compiler, func_name, None)
          if method:
            method()
          else:
            print('Unknown command "%s" (ignored)' % command)
      return result
    end method dispatch;

    override
    method helpCommand #:
      Provide summary of commands.

      This augments the parent implementation with the commands available
      via command 'main' in metax.c.Compiler.
    params:
      multi var args : vec;
    scope:
      super(Shell, self).helpCommand(*args)

      if False:
        command = self.compiler().cli()._command_()
        while command.parent():
          command = command.parent()
        command.help()
    test:
    end method helpCommand;

    method showMetaContext : any #:
      Print out the Context instance identified by directory or args.
    params:
      multi var args : vec;
    scope:
      dir = self.cwd()
      nmsp = self.getctx('namespace', default=None)
      if nmsp:
        /# If namespace is set, we know that cwd contains the construct,
        /# and we can obtain its context and print it.
        construct = dir.info('construct')
        if construct:
          context = construct.context()
          context.show()
    test:
    end method showMetaContext;

    method showHierarchy #:
      Print out the hierarchy in the current context.
       - if in a class directory, print out the inheritance hierarchy.
       - if in a method directory, print out the ancestor definitions.
    params:
      multi var args : vec;
    scope:
      below = False
      if args and args[0] in ('--below', '--b', '-b'):
        below = True

      nmsp = self.getctx('namespace', default=None)
      if nmsp:
        /# We know we are in a directory containing a 'construct'
        dir = self.cwd()
        construct = dir.info('construct')
        if construct:
          if construct.isClass():
            /# First, we print out the hierarchy above us.
            ancestors = construct.ancestors()
            indent = ''
            for ancestor in ancestors:
              print('%s%s' % (indent, ancestor.idfqn()))
              indent += '  '
            /# Now, if requested, we print out the hierarchy below us.
            if below:
              self._showHierarchy(construct, indent)
            else:
              print('%s%s' % (indent, construct.idfqn()))
          elif construct.isMethod():
            print('Have method!')
          else:
            print('Warning: no hierarchy action defined for %s' % dir.abspath())
    test:
    end method showHierarchy;

    method showSymbols #:
      Print out the symbol table in the current context.
       - if in a namespace directory, print out its symbol table
       - if in a class directory, print out its symbol table
       - if in a method directory, print out its symbol table
    params:
      multi var args : vec;
    scope:
      if args:
        print('Warning; args ignored')
      nmsp = self.getctx('namespace', default=None)
      if nmsp:
        /# We know we are in a directory containing a 'construct'
        dir = self.cwd()
        construct = dir.info('construct')
        if construct:
          construct.symbols().show()
    test:
    end method showSymbols;

    method _showHierarchy #:
      Print out this class and all subclasses indented to show hierarchy.
    params:
      var klass : ClassConstruct #:
        The klass to show the descendent hierarchy of.
      var indent : str #:
        The indent before this class.
    scope:
      fp = sys.stdout
      fp.write('%s%s\n' % (indent, klass.idfqn()))
      subindent = indent + '  '
      children = klass.childclasses()
      for name in sorted(children):
        child = children[name]
        self._showHierarchy(child, subindent)
    test:
    end method _showHierarchy;

    method generateMetafiles  #:
      Dynamically populate 'parent' with child directories, the names of which
      are the abbrevs of all currently parsed metafiles.  The content of
      each subdir is expected to be namespace names.
    params:
      var parent : Directory;
    scope:
      result = []
      for metafile in self.compiler().metaorder():
        dir = parent.add(
          'dir', metafile.abbrev(), context='namespace',
          generator=self.generateConstructs, freshold=1)
        dir.opaqueIs({'construct': metafile.construct()})
        result.append(dir)
      return result
    test:
    end method generateMetafiles;

    method generateConstructs #:
      Given a directory whose opaque() field has key 'construct' storing a
      Construct, generate a set of directories representing the children of that
      construct with a specific kind.  The kind is dictated by the kind of
      'construct'. For example, if the construct stored in opaque() is a
      namespace, only children with kind 'class' are shown. If the construct
      is a class, only children with kind 'method' are shown, etc.
    params:
      var parent : Directory;
      var kind : str #:
        Only children with the specified kind are considered.
    scope:
      return self._generateConsSym(parent, kind, symbols=False)
    test:
    end method generateConstructs;

    method generateSymbols #:
      Given a directory whose opaque() field has key 'construct' storing a
      Construct, generate a set of directories representing all symbols in
      the symboltable of the stored construct whose associated construct
      has kind 'kind'.
    params:
      var parent : Directory;
      var kind : str #:
        Only children with the specified kind are considered.
    scope:
      return self._generateConsSym(parent, kind, symbols=True)
    test:
    end method generateSymbols;

    method _generateConsSym #:
      Given a directory whose opaque() field has key 'construct' storing a
      Construct, generate a set of directories representing either:
        1. the children of that construct with kind 'child_kind'
        2. the symbols in the symboltable of that construct whose associated
           construct has kind 'child_kind'
    params:
      var parent : Directory;
      var child_kind : str;
      var symbols : bool = false #:
        If true, show symbols not constructs.
    scope:
      result = []
      construct = parent.opaque()['construct']
      kind = construct.kind()
      scope = construct.attrval('scope:', default=None) or []

      debug = True

      def GenerateChildren(scope, kind, subkind, output, generator=None):
        if generator is None:
          generator = self.generateConstructs
        for child in scope:
          if child.kind() != kind: continue
          dir = parent.add(
            'dir', child.id(), context=subkind,
            generator=generator, freshold=1)
          dir.opaqueIs({'construct': child})
          output.append(dir)

      def GenerateSymbols(construct, target_kind, cvar, output):
        generator = self.generateSymbols
        table = construct.symbols()
        symbols = table.allSymbols()
        for sym, info in symbols.iteritems():
          cons = info['construct']
          if cons.kind() == target_kind:
            dir = parent.add(
              'dir', sym, context=cvar, generator=generator, freshold=1)
            dir.opaqueIs({'construct': cons})
            if debug:
              print('  Setting %s = %s (%s -> %s)' % (sym, cons.kindfqn(), cvar, dir.familyPath()))
            output.append(dir)
          else:
            if debug:
              print('WARNING: Ignoring symbol %s (%s) within %s' % (
                sym, cons.kindfqn(), construct.kindfqn()))

      newform = True

      if kind == 'File':
        /# Create namespaces that generate classes.
        GenerateChildren(scope, 'namespace', 'class', result)

      elif kind == 'namespace':
        if newform:
          /# Show the symbol table of the namespace with classes being dirs.
          /# TODO(wmh): For symbols that are namespaces, make symlinks.
          GenerateSymbols(construct, 'class', 'class', result)
        else:
          /# Create classes that generate methods and fields
          GenerateChildren(scope, 'class', 'method', result)

      elif kind == 'class':
        if newform:
          /# Show the symbol table of the class, with methods being dirs.
          /# TODO(wmh): What other symbols appear within a class symbol table?
          GenerateSymbols(construct, 'method', 'method', result)
        else:
          /# Create methods that has special generator.
          GenerateChildren(
            scope, 'method', 'fixme', result, generator=self.generateMethodDir)

      elif kind == 'method':
        if newform:
          /# Show the symbol table of the method.
          /#  - methods without complex scope have a limited symbol table
          /#    (only parameters), whereas methods with complex-valued scopes
          /#    will have a full symbol table with all top-level local vars
          /#    also available in the symtable, and the possibility of showing
          /#    sub-blocks as subdirs, with their own symbol tables.
          GenerateSymbols(construct, 'var', 'var', result)
        else:
          pass

      return result
    test:
    end method _generateConsSym;

    method generateMethodDir #:
      Generate the content of a directory representing a method.
    params:
      var parent : Directory #:
        The method directory.
    scope:
      result = []
      method = parent.opaque()['construct']
      assert method.kind() == 'method', 'expecting method not %s' % method.kind()

      fp = io.StringIO()
      method.write(fp=fp)
      meta = parent.add('file', 'meta')
      meta.contentIs(fp.getvalue())
      result.append(meta)

      return result
    test:
    end method generateMethodDir;

  end class Shell;

end namespace metax.c.shell;