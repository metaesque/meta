namespace metax.fs #:
  When parsing Meta files, all interaction with file systems should occur
  through this namespace, and in particular metax.fs.Filesystem.
scope:

  class Error < metax.root.Error;

  pre native ##:
    TODO(wmh): Use metqx.c.REQUIRED
  defn<py>:
    /# Test 1
    REQUIRED = object()
  end;

  class GenericFile #:
    Abstract superclass of all kinds of files.

    TODO(wmh): The space/time tradeoff is especially problematic for these
    classes. It is easy for there to be millions of files in a filesystem, which
    argues for memory conservation. But that implies we do not store the
    absolute path of files and instead compute the path when needed (which is
    much less time efficient than storing it explicitly).

    The assumption here is that these classes will NOT be used to model an
    entire filesystem. Methods defined on Filesystem will allow direct access to
    the underlying filesystem, but other methods will allow one to interact with
    this more abstract hierarchy of classes as well. Especially useful for code
    that wants to provide both disk-based and in-memory implementations of
    files.

    TODO(wmh): Need to implement fake_filesystem in Meta, so that it is
    available in all baselangs. The goal is for any library function that calls
    into any I/O based method to execute our version of the method instead of
    the normal method. This is possible in dynamic languages where methods can
    be overwritten at runtime, but is probably not possible (or challenging) to
    do for static languages (but consider for example
    https://github.com/dyninst/dyninst for modifying C++).

    Such extremes may not be necessary if we design interfaces in ways that
    make it clear when on-disk vs in-memory files are desired. For example,
    Filesystem can operate in either mode, and can return File instances
    of appropriate classes to capture on-disk vs in-memory. Care would of
    course need to be taken in the in-memory implementation to never invoke
    any method that could possibly write to disk.
  scope:

    field name : str #:
      The leaf name of the file (not the absolute path)
    field parent : Directory #:
      The parent of this file.  Only null if name is '' (the root).
    field mode : int #:
      The permissions of this file.

    lifecycle params:
      var name -> name;
      var parent -> parent;
    scope:
      if parent:
        parent.register(self)
    end;

    method path : @str #:
      The absolute path of the file.
    scope:
      parts = []
      file = self
      while file:
        parts.append(file.name())
        file = file.parent()
      result = '/'.join(reversed(parts))
      if not result:
        result = '/'
      return result
    test:
      alice = test.hier()
      test.iseq('/home/alice', alice.path())
      home = alice.parent()
      test.iseq('/home', home.path())
      root = home.parent()
      test.iseq('/', root.path())
    end method path;

    method child : GenericFile #:
      Find a child by name.

      TODO(wmh): By having the arg be vararg, we add convenience at the expense
      of conflating the term 'child' with 'descendent' and potentially pose
      problems in baselangs that cannot handle varargs well. Do we want a safer
      interface?
    params:
      multi var subnames : vec<str> #:
        The subnames to obtain.
    scope:
      result = self
      for name in subnames:
        /# name represents a child of result, so result must be a directory
        if result.isdir():
          result = result.children().get(name, None)
          if not result:
            break
        else:
          /# This is an error in some sense, but we just return null.
          result = None
          break
      return result
    test:
      alice = test.hier()
      test.iseq('README', alice.child('README').name())
      test.isnull(alice.child('not-a-child'))
      home = alice.parent()
      test.iseq('README', home.child('bob', 'README').name())
    end method child;

    method isdir : bool #:
      True if this file is a directory.
    scope:
      return False
    test:
      alice = test.hier()
      test.istrue(alice.isdir())
      readme = alice.child('README')
      test.isfalse(readme.isdir())
    end method isdir;

    abstract
    method show #:
      Print out the hierarchy below this directory.
    params:
      var fp : ostream = out #:
        Where to write the output.
      var indent : str = '' #:
        How much to indent each line of output.
      var details : var = false #:
        If true, print out details.
    end method show;

  end;

  class Directory < GenericFile #:
    A file that can contain other files.
  assocs:
    std assoc collections;
  scope:

    field children : map<str,GenericFile> #:
      The child files this directory contains. Null until children added.
    scope:
      accessor get lazy:
        result = collections.OrderedDict()
        -> result
    end field children;

    method isdir : bool #:
      True if this file is a directory.
    scope:
      return True
    test:
      alice = test.hier()
      test.istrue(alice.isdir())
    end method isdir;

    method register params:
      var child : GenericFile;
    scope:
      children = self.children()
      if child in children:
        raise Error(
          'Attempt to re-register %s within %s' % (child.name(), self.path()))
      children[child.name()] = child
    test:
      /# register() is invoked in GenericFile initializer if parent is non-null.
      alice = test.hier()
      test.notnull(alice.parent())
    end method register;

    method show #:
      Print out the hierarchy below this directory.
    params:
      var fp : ostream = out #:
        Where to write the output.
      var indent : str = '' #:
        How much to indent each line of output.
      var details : var = false #:
        If true, print out children.
    scope:
      subindent = indent + '  '
      fp.write(u'%s%s/\n' % (indent, self.name()))
      if details:
        for child in self.children().values():
          child.show(fp=fp, indent=subindent, details=details)
    test:
      alice = test.hier()
      fp = test.fp()
      alice.show(fp=fp)
      home = alice.parent()
      root = home.parent()
      home.show(fp=fp, details=False)
      home.show(fp=fp, details=True)
      root.show(fp=fp, details=True)
      test.iseqtext(
        >|"""alice/
        >|home/
        >|home/
        >|  bob/
        >|    README
        >|  alice/
        >|    README -> /home/bob/README
        >|/
        >|  home/
        >|    bob/
        >|      README
        >|    alice/
        >|      README -> /home/bob/README
        >|""",
        fp.getvalue())
    end method show;

  end class Directory;

  class File < GenericFile #:
    A normal file (not symlink, not block, etc.)
  scope:

    method show #:
      Print out this file
    params:
      var fp : ostream = out #:
        Where to write the output.
      var indent : str = '' #:
        How much to indent each line of output.
      var details : var = false #:
        If true, print out details.
    scope:
      isexec = False  # TODO(wmh): Fix this.
      fp.write(u'%s%s%s\n' % (indent, self.name(), '*' if isexec else ''))
    test:
      alice = test.hier()
      readme = alice.parent().child('bob', 'README')
      fp = test.fp()
      readme.show(fp=fp)
      test.iseq('README\n', fp.getvalue())
    end method show;

  end class File;

  class Symlink < GenericFile #:
    A link to another file.
  scope:

    field src : GenericFile #:
      The file this symlink links to.

    lifecycle params:
      var parent : str;
      var name : str;
      var src : GenericFile;
    super (parent, name)
    scope:
      self.srcIs(src)
    end;

    method show #:
      Print out the hierarchy below this directory.
    params:
      var fp : ostream = out #:
        Where to write the output.
      var indent : str = '' #:
        How much to indent each line of output.
      var details : var = false #:
        If true, print out details.
    scope:
      if details:
        fp.write(u'%s%s -> %s\n' % (indent, self.name(), self.src().path()))
      else:
        fp.write(u'%s%s@\n' % (indent, self.name()))
    test:
      alice = test.hier()
      readme = alice.child('README')
      fp = test.fp()
      readme.show(fp=fp)
      test.iseq('README@\n', fp.getvalue())
      fp = test.fp()
      readme.show(fp=fp, details=True)
      test.iseq('README -> /home/bob/README\n', fp.getvalue())
    end method show;

  end class Symlink;

  class Filesystem #:
    Provides functions for interacting with a file system.

    IMPORTANT: All I/O related functionality within the Meta parser/compiler
    MUST use the methods defined on Filesystem, rather than using any
    baselang-specific functionality directly (e.g. os, open, etc.). Having
    all I/O functionality defined by Filesystem provides two huge benefits:

    1. we will be able to provide a Meta(Oopl)* implementation of Meta much
       easier by abstracting out baselang-specific I/O functionality now.

    2. allows us to provide a memory-only implementation of the parsing/
       compilation process, for use in GAE, etc.

    assocs:
      TODO(wmh): Get this working! Do not include fake_filesystem until
      bazel can handle it ... want to ensure that parser.meta is fully
      bazelified at all times.
      lib assoc fake_filesystem;
  assocs:
    std assoc glob;
    std assoc io;
    std usertest assoc os;
    std assoc re;
    std usertest assoc shutil;
    std assoc tempfile;
    std usertest assoc time;

    test resource testdata path "./testdata/fs";
  scope:

    field kind : str #:
      Identifies the kind of filesystem.  Values are:
        disk:
          use the underlying disk filesystem
        memory:
          do not write files to disk, but don't mock out I/O methods. TODO(wmh):
          Change this to 'readonly' ... it relies on a read-only disk filesystem
          to acquire data, but all methods that modify the filesystem are
          rewritten to have an effect on in-memory representations rather than
          the disk. Subsequent reads of modified data should see the new data,
          not the disk data. Decide whether we need two flavors of readonly
          filesystems, one that simply raises errors when write-based
          functionality is invoked, and the other that emulates such
          functionality.
        emulate:
          do not write files to disk, and emulate all I/O methods so that
          code that uses os, open, glob, etc. writes to memory versions instead.
          TODO(wmh): Is this needed, or can we remove support for this?

    field modules : vec<module> #:
      The modules to replace filesystem-related methods within.

    field origs : map #:
      Maps conceptual module names to module instances.

    field filemap : @map<str,BaseFile> #:
      Maps subpaths (relative to metaRepository) to BaseFile instances.

    field metadir : str #:
      When metac is invoked to compile .meta files into baselang files,
      the baselang code is written into $CWD/$metadir/$metalang/$baselang/...
      where $metadir is usually '.meta', a symlink to $METAREP. The --metadir
      flag qllows us to change that.

    field rootdir : str #:
      Relative paths are relative to ${rootdir}/.meta
      TODO(wmh): Consider renaming this to 'cwd'.

    field disk_filesystem : map #:
      None if we are using a memory filesystem, a map otherwise.
      Keys are file paths, values are bool True.

    field fake_filesystem : fake_filesystem.FakeFilesystem #:
      If we are using an in-memory filesystem via fakefilesystem.

    lifecycle params:
      var kind -> kind = 'disk';
      var metadir -> metadir = '.meta';
      var rootdir : str = null;
    scope:
      if rootdir is None:
        rootdir = self.cwd()
      self.rootdirIs(rootdir)

      /# In case we want to emulate IO, we remember the real I/O modules.
      self.modulesIs([sys.modules[__name__]])
      origs = {
        'os': os,
        'open': open,
        'glob': glob,
        'shutil': shutil,
        'tempfile': tempfile,
      }
      self.origsIs(origs)

      if kind == 'emulate':
        self.emulateIO()
    clinit:
      cls.Root = Directory('', None)
    end lifecycle;

    method subpath : BaseFile #:
      Obtain the file with a given subpath. May return null.
    params:
      var subpath : str #:
        The subpath to query for.
    scope:
      return self.filemap().get(subpath, None)
    test:
      fs = test.diskfs
      metafile = test.metafile()
      /# TODO(wmh): This test is creating actual files within ${METAREPO},
      /# which it really shouldn't do.
      basefile = metax.fs.BaseFile('test/sub/b.meta', '', metafile=metafile)
      fs.addFile(basefile)
      basefile2 = fs.subpath('test/sub/b.meta')
      test.issame(basefile2, basefile)
    end method subpath;

    method environ : map #:
      Obtain the map of all environment variable/value pairs.
    scope:
      return os.environ
    test:
      res = test.diskfs.environ()
      test.contains('HOME', res)
    end method environ;

    method getenv : str #:
      Obtain an environment variable by name.
    params:
      var name : str #:
        The environment variable name.
      var default : any = REQUIRED #:
        If REQUIRED, raise error.
    scope:
      result = os.getenv(name, default)
      if result is REQUIRED:
        raise Error('Failed to find envar %s' % name)
      return result
    test:
      test.iseq('/bin/bash', test.diskfs.getenv('SHELL'))
    end method getenv;

    method setenv : any #:
      Set an environment variable.
    params:
      var name : str #:
        The environment variable name.
      var value : str #:
        The value to set.
    scope:
      os.environ[name] = value
    test:
      test.diskfs.setenv('BLAH', '1')
      test.iseq('1', test.diskfs.getenv('BLAH'))
    end method setenv;

    method unsetenv : any #:
      Unset an environment variable.
    params:
      var name : str #:
        The environment variable name.
    scope:
      if name in os.environ:
        del os.environ[name]
    test:
      test.diskfs.setenv('BLAH', '1')
      test.diskfs.unsetenv('BLAH')
      test.isnull(test.diskfs.getenv('BLAH', default=None))
    end method unsetenv;

    method join : str #:
      Join a collection of path parts.
    params:
      multi var parts : vec;
    scope:
      return os.path.join(*parts)
    test:
      test.iseq('/a/b/c', test.diskfs.join('/a', 'b', 'c'))
    end method join;

    method split : tuple<str,str> #:
      Split a file into dirname and basename+suffix
    params:
      var path : str;
    scope:
      return os.path.split(path)
    test:
      test.iseq(('/a/b', 'c'), test.diskfs.split('/a/b/c'))
    end method split;

    method splitext : tuple<str,str> #:
      Split a file into basepath and suffix
    params:
      var path : str;
    scope:
      return os.path.splitext(path)
    test:
      test.iseq(('/a/b/c', '.py'), test.diskfs.splitext('/a/b/c.py'))
    end method splitext;

    method splitall : tuple<str,str,str> #:
      Split a file into dirname, basename, and suffix
    params:
      var path : str;
    scope:
      dirname, basesuff = os.path.split(path)
      basename, suffix = os.path.splitext(basesuff)
      return (dirname, basename, suffix)
    test:
      test.iseq(
        ('/some/dir', 'base', '.suff'),
        test.diskfs.splitall('/some/dir/base.suff'))
    end method splitall;

    method expandvars : str #:
      Expand env.vars. in a string.
    params:
      var value : str #:
        The value to expand vars within.
    scope:
      return os.path.expandvars(value)
    test:
      res = test.diskfs.expandvars('${HOME}/.config/${USER}')
    end method expandvars;

    method touch #:
      Modify timestamp of file to current time. Creates file if it doesn't
      exist.
    params:
      var path : str #:
        Path to file to create.
      var atime : float = null #:
        If provided, atime is set to this value
      var mtime : float = null #:
        If provied, mtime is set to this value
    scope:
      /# https://stackoverflow.com/questions/1158076/implement-touch-using-python
      with open(path, 'a') as fp:
        os.utime(path, (atime or time.time(), mtime or time.time()))
    test:
      tm = os.path.getmtime(test.filepath)
      time.sleep(0.0001)
      test.diskfs.touch(test.filepath)
      tm2 = os.path.getmtime(test.filepath)
      test.isgt(tm2 - tm, 0.0001)
    end method touch;

    method emulateIO #:
      Make this instance use memory instead of disk.
    params:
      var pathmap : map = null #:
        Maps path strings to path content.  If content is None, it is a request
        to obtain the contents from disk (using the key as the ile path). This
        requires read-only access to the underlying filesystem, but after this
        method returns no such access is available until undoMemory() is
        invoked.
      var gae : bool = false #:
        If True, we are running on Google App Engine, and certain methods
        need to be disabled.
    scope:
      /# GAE does not support os.umask()
      def umask(val):
        return val
      if gae:
        os.umask = umask

      filesystem = fake_filesystem.FakeFilesystem()
      self._fake_filesystem = filesystem

      /# Define the required fake filesystem.  We do this before we rebind the
      /# modules so that we still have access to the real filesystem to get
      /# data to populate our fake filesystem.
      for path, contents in pathmap.iteritems():
        if contents is None:
          with open(path, 'r') as fp:
            contents = fp.read()
        self.addFakeFile(path, contents=contents)
        logging.info('Populated %d bytes into %s', len(contents), path)

      /# Now rebind the various modules/functions making up the IO interface
      /# to their fake variants.
      faux_os = fake_filesystem.FakeOsModule(filesystem)
      /# TODO(wmh): Add support for the following if unittests require it.
      /# Hopefully, one can parse the meta file using the real filesystem,
      /# then switch to a faux filesystem for file generation, which may allow
      /# us to avoid this hackery.
      if False:
        env = os.environ
        faux_os.getenv = lambda var: env.get(var, None)
        faux_os.makedirs(faux_os.getenv('METAROOT'), 0o755)

      faux_open = fake_filesystem.FakeFileOpen(filesystem)
      faux_glob = fake_filesystem_glob.FakeGlobModule(filesystem)
      faux_shutil = fake_filesystem_shutil.FakeShutilModule(filesystem)
      if not gae:
        /# GAE uses a replacement tempfile module
        /#   google-cloud-sdk/platform/google_appengine/google/appengine/dist/tempfile.py
        /# that does not implement _RandomNameSequence, which is assumed to
        /# exist in pyfakefs version 3.2
        faux_tempfile = fake_tempfile.FakeTempfileModule(filesystem)

      for module in self.MODULES_TO_REPLACE_FILESYSTEM_IN:
        logging.info('REPLACING file modules in %s', module)
        module.os = faux_os
        module.open = faux_open
        module.glob = faux_glob
        module.shutil = faux_shutil
        if not gae:
          module.tempfile = faux_tempfile

      /# print('***** HERE in emulateIO with %s' % faux_os.getenv('METAROOT'))
    test:
      /# TODO(wmh): Are we supporting this?  The readonly implementtiaon of
      /# the filesystem will need something like this, although only half-way.
      pass
    end method emulateIO;

    method undoMemory #:
      Reinstate module remaps.
    scope:
      raise Error('Unused method?')
      origs = self.origs()
      for module in self.modules():
        print('FIXME: %s' % module)
        /# for key in orgs:
        /#   setattr(module, key, origs[key])
    test:
      /# test.rofs.undoMemory()
      pass
    end method undoMemory;

    method addFile : vec<str> #:
      Add a file to the filesystem.

      TODO(wmh): Decide how to rename this or addFauxFile so as not to be
      so similar to one another.

      Returns:
        null if not in disk mode.
        otherwise first element is always path of basefile. If basefile has
        mapfile, second element is path of mapfile.
    params:
      var basefile : meta.c.BaseFile;
    scope:
      result = None
      filemap = self.filemap()
      filemap[basefile.subpath()] = basefile
      mapfile = basefile.mapfile()
      if False:
        /# TODO(wmh): We should record the mapfiles, but filemap requires
        /# BaseFile instances currently. Do we generalize?
        if mapfile:
          filemap[mapfile.path()] = mapfile
      if self.kind() == 'disk':
        /# Serialize this file to disk immediately.

        /# Write the basefile to disk
        /#  - obtain the on-disk path
        /#  - create the directory of the file if it does not exist.
        /#  - write the file
        fullpath, mroot = self.basefilePath(basefile)
        dirpath = self.dirname(fullpath)
        if not self.exists(dirpath):
          print('NOTE: Creating %s' % dirpath)
          self.makedirs(dirpath, mode=0o755)
        link = basefile.link()
        if link:
          linkpath, _ = self.basefilePath(link)
          self.symlink(linkpath, fullpath)
        else:
          contents = basefile.contents()
          with self.open(fullpath, 'w') as fp:
            try:
              fp.write(contents)
            except UnicodeEncodeError as e:
              /# print('metax.fs.Filesystem.addFile: %s' % e)
              fp.write(contents.encode('utf8', 'replace'))
          /# TODO(wmh): Should mode be disabled if link is provided in BaseFile(), since we
          /# are ignoring it here?
          self.chmod(fullpath, basefile.mode())
        result = [fullpath]

        /# Write the mapfile associated with the file to disk if it exists.
        mappath = None
        if mapfile:
          mappath = self.realpath(self.join(mroot, mapfile.path()))
          mapdir = self.dirname(mappath)
          realdirpath = self.realpath(dirpath)
          if mapdir != realdirpath:
            raise Error('ERROR: %s not in same dir as %s' % (mappath, fullpath))
          with self.open(mappath, 'w') as fp:
            mapfile.serialize(fp)
          result.append(mappath)
      return result
    test:
      test.rofs.addFile(test.basefile)
    end method addFile;

    method basefilePath : tuple<str,str> #:
      Obtain the on-disk location of a BaseFile instance.

      Returns:
       0. The basefile path
       1. The root dir
    params:
      var basefile : meta.c.BaseFile;
    scope:
      /# TODO(wmh): This method is performing bad logic.
      /#  - if ${rootdir}/.meta exists, we obtain the real path to which it
      /#    symlinks.
      /#  - otherwise we IGNORE ${rootdir} and use the repository path stored
      /#    in the compiler!
      /#
      /# This means this Filesystem class only works as intended when rootdir is
      /# set to a directory containing .meta files that also contains a
      /# symlinked .meta file pointing to the repository.
      /#
      /# TODO(wmh): Consider renaming the current 'rootdir' to 'localdir' or
      /# 'cwd'. Then define 'rootdir' (or 'realrootdir' if we don't rename
      /# existing 'rotodir') as a field that can be initialized upon creation,
      /# with its default value being
      /# basefile.metafile().compiler().repositoryPath(). Then we can continue
      /# to use the current logic but also support file systems that do not
      /# conform to the rigid usecase of the meta code hierarchy.

      /# Obtain the absolute real path of the file on disk.
      metadir = self.metadir()
      mroot = self.join(self.rootdir(), metadir)
      if self.exists(mroot):
        /# TODO(wmh): Need to use self.flags.metadir
        fullpath = self.realpath(self.join(mroot, basefile.subpath()))
        /# print('metadir=%s mroot=%s subpath=%s fullpath=%s' % (metadir, mroot, basefile.subpath(), fullpath))
      else:
        /# TODO(wmh): Clean up this logic. Rather than using
        /#   basefile.metafile().compiler().repositoryPath()
        /# we should be using self.realrootdir(), which can be initialized based
        /# on a provided metafile.compiler().repositoryPath().
        metafile = basefile.metafile()
        metac = metafile.compiler()
        mroot_orig = mroot
        mroot = metac.repositoryPath()
        /# print('WARNING: %s does not exist, so using %s' % (mroot_orig, mroot))
        fullpath = self.join(mroot, basefile.subpath())
      return fullpath, mroot
    test:
      metafile = test.metafile()
      basefile = metax.fs.BaseFile('some/path/a.meta', '', metafile=metafile)
      fullpath, mroot = test.diskfs.basefilePath(basefile)
      relpath = fullpath.replace(mroot, '')
      test.iseq('/some/path/a.meta', relpath)
    end method basefilePath;

    method subfilePath : tuple<str,str> #:
      Obtain the on-disk location of a subdir (relative to baselang specific
      dest dir).

      Returns:
       0. The full path
       1. The root dir
    params:
      var subpath : str;
    scope:
      /# Obtain the absolute real path of the file on disk.
      metadir = self.metadir()
      mroot = self.join(self.rootdir(), metadir)
      if False:
        /# It would be nice to verify this in production, but we need a way
        /# of disabling it in unittests where the filesystem is altered.
        if not self.exists(mroot):
          raise Error('Failed to find "%s"' % mroot)
      /# TODO(wmh): Need to use self.flags.metadir
      fullpath = self.realpath(self.join(mroot, subpath))
      /# print('metadir=%s mroot=%s subpath=%s fullpath=%s' % (metadir, mroot, basefile.subpath(), fullpath))
      return fullpath, mroot
    test:
      test.iseq(
        ('/foo/.meta/b/file.txt', '/foo/.meta'),
        test.diskfs.subfilePath('b/file.txt'))
    end method subfilePath;

    method open #:
      Open a filehandle.
    params:
      var path : str;
      var mode : str = 'r';
    scope:
      kind = self.kind()
      if kind == 'memory':
        if 'r' in mode:
          with open(path, mode) as tfp:
            contents = tfp.read()
          result = io.BytesIO(contents)
        else:
          result = StrStream(self, path)
      else:
        result = open(path, mode)
      return result
    test:
      ifp = test.diskfs.open(test.filepath, 'r')
      contents = ifp.read()
      ifp.close()
      test.contains('This file should stay unchanged', contents)

      ofp = test.diskfs.open(test.filepath, 'w')
      ofp.write('This is a test')
      ofp.close()
      ifp = test.diskfs.open(test.filepath, 'r')
      contents = ifp.read()
      ifp.close()
      test.iseq('This is a test', contents)

      ifp = test.rofs.open(test.filepath, 'r')
      contents = ifp.read()
      ifp.close()
      test.iseq('This is a test', contents)

      test.iseq(0, len(test.rofs.filemap().keys()))
      with test.rofs.open(test.filepath, 'w') as ofp:
        ofp.write('Different content, should not affect actual disk\n')
      test.iseq(1, len(test.rofs.filemap().keys()))
      ifp = test.rofs.open(test.filepath, 'r')
      contents = ifp.read()
      ifp.close()
      test.iseq('This is a test', contents)
    end method open;

    method close #:
      Close a filehandle opened with reader() or writer().
    params:
      var fp : file #:
        The filehandle to close.
      var log : bool = false #:
        If True, log the closing of the path.
    scope:
      /# We either have a writable filesystem or are using a fake filesystem.
      /# (close normally)
      fp.close()

      kind = self.kind()
      if kind == 'emulate':
        /# FakeFileWrapper.close() in fake_filesystem is not fully implemented,
        /# in that it does not properly set fp.closed to True.  There is no
        /# 'closed' defined on FakeFileWrapper, but __getattr__ delegates to
        /# fp._io, which is a cStringIO.StringIO, which does have 'closed'.
        /# But fp._io.close() is never called as part of FakeFileWrapper.close().
        /# The code for close() should be something like:
        /#   def close(self):
        /#     """File close."""
        /#     if self._update:
        /#       self._file_object.SetContents(self._io.getvalue())
        /#     self._filesystem.CloseOpenFile(self)
        /#     self._io.close()  # <---- new code
        /#     if self._delete_on_close:
        /#       self._filesystem.RemoveObject(self.name)
        if not fp._io.closed:
          fp._io.close()
    test:
      fp = test.diskfs.open(test.filepath, 'r')
      test.diskfs.close(fp)
    end method close;

    method read : str #:
      Read a file and return contents
    params:
      var path : str;
    scope:
      with self.open(path, 'r') as fp:
        result = fp.read()
      return result
    test:
      contents = test.diskfs.read(test.filepath)
      test.contains('This file should stay unchanged', contents)
    end method read;

    method exists : bool #:
      Determine if path exists.

      If using a memory filesystem, we check both it and disk.
    params:
      var path : str #:
        The path to check for existence.
    scope:
      kind = self.kind()
      if kind == 'memory':
        /# We need to make a distinction between "readonly" (which has
        /# read-access to the file system) and "no filesystem at all". For now,
        /# 'memory' really means 'readonly'
        result = os.path.exists(path)
      else:
        result = os.path.exists(path)
      return result
    test:
      test.istrue(test.diskfs.exists(test.filepath))
      test.isfalse(test.diskfs.exists(test.filepath + '.missing'))
    end method exists;

    method lexists : bool #:
      Determine if symlink exists.

      If using a memory filesystem, we check both it and disk.
    params:
      var path : str #:
        The path to check for existence.
    scope:
      kind = self.kind()
      if kind == 'memory':
        raise Error('lexists not implemented')
      else:
        result = os.path.lexists(path)
      return result
    test:
      test.istrue(test.diskfs.lexists(test.linkpath))
      test.istrue(test.diskfs.lexists(test.filepath))
      test.isfalse(test.diskfs.lexists(test.linkpath + '.missing'))
    end method lexists;

    method chmod #:
      Change the mode of the file.
    params:
      var path : str #:
        The path to check for existence.
      var mode : int #:
        The mode (e.g. 0o640, 0o755, etc.)
    scope:
      kind = self.kind()
      if kind == 'memory':
        raise Error('lexists not implemented')
      else:
        os.chmod(path, mode)
    test:
      filepath = test.filepath
      test.iseq('100644', '%o' % os.stat(filepath).st_mode)
      test.diskfs.chmod(filepath, 0o755)
      test.iseq('100755', '%o' % os.stat(filepath).st_mode)
      /# cleanup
      os.unlink(filepath)
    end method chmod;

    method basename : str #:
      The basename of a path
    params:
      var path : str;
    scope:
      kind = self.kind()
      if kind == 'memory':
        return os.path.basename(path)
        /# raise Error('basename not implemented')
      else:
        return os.path.basename(path)
    test:
      test.iseq('c.py', test.diskfs.basename('/a/b/c.py'))
    end method basename;

    method dirname : str #:
      The dirname of a path
    params:
      var path : str;
    scope:
      kind = self.kind()
      if kind == 'memory':
        return os.path.dirname(path)
        /# raise Error('dirname not implemented')
      else:
        return os.path.dirname(path)
    test:
      test.iseq('/a/b', test.diskfs.dirname('/a/b/c.py'))
    end method dirname;

    method abspath : str #:
      The abspath of a path
    params:
      var path : str;
    scope:
      kind = self.kind()
      if kind == 'memory':
        return os.path.abspath(path)
        /# raise Error('abspath not implemented')
      else:
        return os.path.abspath(path)
    test:
      test.endswith('/a/b/c', test.diskfs.abspath('a/b/c'))
    end method abspath;

    method normpath : str #:
      The normpath of a path
    params:
      var path : str;
    scope:
      kind = self.kind()
      if kind == 'memory':
        return os.path.normpath(path)
        /# raise Error('normpath not implemented')
      else:
        return os.path.normpath(path)
    test:
      test.iseq('/a/c', test.diskfs.normpath('/a/./b/../c'))
    end method normpath;

    method relpath : str #:
      The relpath of a path
    params:
      var path : str;
      var src : str = null;
    scope:
      return os.path.relpath(path, src) if src else os.path.relpath(path)
    test:
      test.iseq('c', test.diskfs.relpath('/a/b/c', '/a/b'))
      test.iseq('b/c', test.diskfs.relpath('/a/b/c', '/a'))
    end method relpath;

    method realpath : str #:
      The real path of a path (e.g. remove all symlinks)
    params:
      var path : str;
    scope:
      return os.path.realpath(path)
    test:
      test.iseq('/a/b/c', test.diskfs.realpath('/a/b/c'))
    end method realpath;

    method copyfile #:
      Copy a src path to a dest path.
    params:
      var src : str #:
        The source path.
      var dest : str #:
        The destination path.
    scope:
      shutil.copyfile(src, dest)
    test:
      filepath = test.filepath
      filepath2 = filepath + '2'
      test.istrue(os.path.exists(filepath))
      test.isfalse(os.path.exists(filepath2))
      test.diskfs.copyfile(filepath, filepath2)
      test.istrue(os.path.exists(filepath))
      test.istrue(os.path.exists(filepath2))
      /# cleanup
      os.unlink(filepath2)
    end method copyfile;

    method copytree #:
      Copy a src dirt to a dest dir.
    params:
      var src : str #:
        The source path.
      var dest : str #:
        The destination path.
      var symlinks : bool = false #:
        If true, keep symlinks as symlinks.  By default, they are converted
        into real files during the copy.
    scope:
      shutil.copytree(src, dest, symlinks=symlinks)
    test:
      dirpath = test.dirpath
      dirpath2 = dirpath + '2'
      test.istrue(os.path.exists(dirpath))
      test.isfalse(os.path.exists(dirpath2))
      test.diskfs.copytree(dirpath, dirpath2)
      test.istrue(os.path.exists(dirpath))
      test.istrue(os.path.exists(dirpath2))
      /# cleanup
      shutil.rmtree(dirpath2)
    end method copytree;

    method cwd : str #:
      The current working directory
    scope:
      return os.getcwd()
    test:
      test.iseq(os.getcwd(), test.diskfs.cwd())
    end method cwd;

    method mkdir #:
      Create a directory
    params:
      var thedir : str;
      var mode : int = 493;
    scope:
      /# print('MKDIR: %s' % thedir)
      kind = self.kind()
      if kind == 'memory':
        raise Error('mkdir not implemented')
      else:
        os.mkdir(thedir, mode)
    test:
      dirpath = test.dirpath
      subdir = dirpath + '/subdir'
      test.isfalse(os.path.exists(subdir))
      test.diskfs.mkdir(subdir)
      test.istrue(os.path.exists(subdir))
      /# cleanup
      os.rmdir(subdir)
    end method mkdir;

    method makedirs #:
      Create a directory, including missing parents.
    params:
      var thedir : str;
      var mode : int = 493;
    scope:
      kind = self.kind()
      if kind == 'memory':
        /# TODO(wmh): Do we need to create an instance of some directory class
        /# here, or is this a no-op?
        pass
      else:
        os.makedirs(thedir, mode)
    test:
      dirpath = test.dirpath
      subdir = dirpath + '/subdir'
      subsubdir = subdir + '/subsub'
      test.isfalse(os.path.exists(subdir))
      test.isfalse(os.path.exists(subsubdir))
      test.diskfs.makedirs(subsubdir)
      test.istrue(os.path.exists(subsubdir))
      /# cleanup
      os.rmdir(subsubdir)
      os.rmdir(subdir)
    end method makedirs;

    method unlink : bool #:
      Remove the specified file.
    params:
      var path : str;
    scope:
      kind = self.kind()
      if kind == 'memory':
        raise Error('unlink not implemented')
      else:
        return os.unlink(path)
    test:
      test.istrue(os.path.exists(test.filepath))
      test.diskfs.unlink(test.filepath)
      test.isfalse(os.path.exists(test.filepath))
    end method unlink;

    method symlink #:
      Create a symlink from a real file to a link file
    params:
      var realpath : str;
      var linkpath : str;
    scope:
      kind = self.kind()
      if kind == 'memory':
        raise Error('unlink not implemented')
      else:
        if os.path.exists(linkpath):
          os.unlink(linkpath)
        os.symlink(realpath, linkpath)
    test:
      linkpath = test.linkpath + '2'
      test.isfalse(os.path.exists(linkpath))
      test.diskfs.symlink(test.filepath, linkpath)
      test.istrue(os.path.exists(linkpath))
      /# cleanup
      os.unlink(linkpath)
    end method symlink;

    method isdir : bool #:
      Determine if a path is a symlink
    params:
      var path : str;
    scope:
      kind = self.kind()
      if kind == 'memory':
        raise Error('isdir not implemented')
      else:
        return os.path.isdir(path)
    test:
      test.isfalse(test.diskfs.isdir(test.linkpath))
      test.isfalse(test.diskfs.isdir(test.filepath))
      test.istrue(test.diskfs.isdir(test.dirpath))
    end method isdir;

    method isfile : bool #:
      Determine if a path is a symlink
    params:
      var path : str;
    scope:
      kind = self.kind()
      if kind == 'memory':
        raise Error('isfile not implemented')
      else:
        return os.path.isfile(path)
    test:
      test.istrue(test.diskfs.isfile(test.linkpath))
      test.istrue(test.diskfs.isfile(test.filepath))
      test.isfalse(test.diskfs.isfile(test.dirpath))
    end method isfile;

    method islink : bool #:
      Determine if a path is a symlink
    params:
      var path : str;
    scope:
      kind = self.kind()
      if kind == 'memory':
        raise Error('islink not implemented')
      else:
        return os.path.islink(path)
    test:
      test.istrue(test.diskfs.islink(test.linkpath))
      test.isfalse(test.diskfs.islink(test.filepath))
      test.isfalse(test.diskfs.islink(test.dirpath))
    end method islink;

    method is_r : bool #:
      Is readable.
    params:
      var path : str;
    scope:
      return os.access(path, os.R_OK)
    test:
      test.istrue(test.diskfs.is_r(test.linkpath))
      test.istrue(test.diskfs.is_r(test.filepath))
      test.istrue(test.diskfs.is_r(test.dirpath))
    end method is_r;

    method is_w : bool #:
      Is writeable.
    params:
      var path : str;
    scope:
      return os.access(path, os.W_OK)
    test:
      test.istrue(test.diskfs.is_w(test.linkpath))
      test.istrue(test.diskfs.is_w(test.filepath))
      test.istrue(test.diskfs.is_w(test.dirpath))
    end method is_w;

    method is_x : bool #:
      Is readable.
    params:
      var path : str;
    scope:
      return os.access(path, os.X_OK)
    test:
      test.isfalse(test.diskfs.is_x(test.linkpath))
      test.isfalse(test.diskfs.is_x(test.filepath))
      test.istrue(test.diskfs.is_x(test.dirpath))
    end method is_x;

    method mtime : float #:
      Obtain the last modified time of a file, in seconds since unix epoch.
    params:
      var path : str;
    scope:
      return os.path.getmtime(path)
    test:
      mtime = test.diskfs.mtime(test.filepath)
      test.islt(1558236982, mtime)
      test.islt(mtime, time.time())

      mtime = test.rofs.mtime(test.filepath)
      test.islt(1558236982, mtime)
      test.islt(mtime, time.time())
    end method mtime;

    method readlink : str #:
      Obtain the file that a symlink is linked to
    params:
      var path : str;
    scope:
      return os.readlink(path)
    test:
      test.iseq(test.frozenpath, test.diskfs.readlink(test.linkpath))
    end method readlink;

    method rename #:
      Rename a file to a new file.
    params:
      var oldpath : str;
      var newpath : str;
    scope:
      kind = self.kind()
      if kind == 'memory':
        raise Error('rename not implemented')
      else:
        print('RENAME: %s %s' % (oldpath, newpath))
        os.rename(oldpath, newpath)
    test:
      test.captureStdout()
      filepath = test.filepath
      newpath = filepath + '.new'
      test.istrue(os.path.exists(filepath))
      test.isfalse(os.path.exists(newpath))
      test.diskfs.rename(filepath, newpath)
      try:
        test.isfalse(os.path.exists(filepath))
        test.istrue(os.path.exists(newpath))
        out = test.getStdout()
        test.contains('RENAME: ', out)
      finally:
        /# cleanup
        os.unlink(newpath)
    end method rename;

    method listdir #:
      Obtain the immediate child files/dirs within thedir.

      Supports in-memory filesystems.
    params:
      var thedir : str #:
        The directory to query.
    scope:
      kind = self.kind()
      if kind == 'memory':
        raise Error('listdir not implemented')
      else:
        return os.listdir(thedir)
    test:
      expected = [
        '.gitignore',
        'frozen.txt',
        'link.txt',
        'scratch.txt',
      ]
      test.iseqvec(expected, test.diskfs.listdir(test.dirpath))
    end method listdir;

    method filesWithinMatching : vec<str> #:
      Obtain all files within the specified dir matching given pattern.

      Returns:
        The paths (including 'thedir' if basename is False) of matching files.
    params:
      var thedir : str #:
        The directory to search within (we only return files immediately within
        the dir).
      var pattern : any #:
        The regexp to apply to each base file. Can be a str or regexp obj.
      var basename : bool = false #:
        If True, do NOT add 'thedir' to each result.
    scope:
      result = []
      if isinstance(pattern, basestring):
        pattern = re.compile(pattern)
      for base in sorted(self.listdir(thedir)):
        if pattern.search(base):
          if basename:
            result.append(base)
          else:
            result.append(os.path.join(thedir, base))
      return result
    test:
      test.iseq(
        ['frozen.txt'],
        test.diskfs.filesWithinMatching(test.dirpath, r'frozen', basename=True))
    end method filesWithinMatching;

    method summarize #:
      Print information about the filesystem
    params:
      var fp : ostream = out #:
        Where to write output.
      var verbose : bool = false #:
        If true, show contents of files.
    scope:
      kind = self.kind()
      fp.write(u'\n')
      if verbose:
        fp.write(u'#' * 80 + '\n')
      fp.write(u'Filesystem:\n')
      filemap = self.filemap()
      for i, subpath in enumerate(sorted(filemap), start=1):
        basefile = filemap[subpath]
        contents = basefile.contents()
        mapfile = basefile.mapfile()
        if verbose:
          fp.write(u'  ' + '=' * 80 + '\n')
        subpathstr = subpath if len(subpath) < 60 else subpath[:59] + '$'
        fp.write(
          u'  %2d %8d %-60s%s\n' %
          (i, len(contents), subpathstr, ' map' if mapfile else ''))
        if verbose:
          fill = '   |'
          assert contents[-1] == '\n'
          fp.write(fill + contents[:-1].replace('\n', '\n' + fill) + '\n')
          if mapfile:
            fp.write(u'  ' + '-' * 80 + '\n')
            mapfile.serialize(fp=fp, indent='  ')

      if kind == 'disk':
        fs = self._disk_filesystem
        if fs:
          fp.write(u'On-disk filesystem\n')
          for path in sorted(fs):
            st = os.stat(path)
            fp.write(u'  %6d bytes: %s\n' % (st.st_size, path))
      else:
        if kind == 'emulate':
          diskfs = self._disk_filesystem
          fakefs = self._fake_filesystem
          if diskfs and fakefs:
            fp.write(u'On fake_filesystem\n')
            for path in sorted(diskfs):
              fakefile = self.getFakeFile(path)
              size = len(fakefile.contents)
              fp.write(u'  %6d bytes: %s\n' % (size, path))
    test:
      fs = test.diskfs
      metafile = test.metafile()
      /# TODO(wmh): This test is creating actual files within ${METAREPO},
      /# which it really shouldn't do.
      fs.addFile(metax.fs.BaseFile('test/a.meta', '', metafile=metafile))
      fs.addFile(metax.fs.BaseFile('test/sub/b.meta', '', metafile=metafile))
      fs.addFile(metax.fs.BaseFile('test/other/c.meta', '', metafile=metafile))
      fs.summarize(fp=test.fp())
      out = test.out()
      test.iseqtext("""
        >|Filesystem:
        >|   1        0 test/a.meta                                                 |<
        >|   2        0 test/other/c.meta                                           |<
        >|   3        0 test/sub/b.meta                                             |<
        >|""",
        out)
    end method summarize;

    method addFauxFile #:
      Add a new file to our fake filesystem.

      This method is only valid if we are using in-memory with fake filesystem.
    params:
      var path : str;
      var contents : str = '';
      var perms : int = 420;
      var inode : int = null;
    scope:
      if self.kind() != 'emulate':
        raise meta.errors.Error('addFakeFile() only valid when kind=emulate')
      kwds = {}
      kwds['st_mode'] = stat.S_IFREG | perms
      kwds['contents'] = contents
      if inode is not None:
        kwds['inode'] = inode
      kwds['create_missing_dirs'] = True
      self._fake_filesystem.CreateFile(path, **kwds)
    test:
      /# Are we supporting this?
      pass
    end method addFauxFile;

    method addFakeDir #:
      Add a new directory to our fake filesystem
    params:
      var path : str;
      var perms : int = 493;
      var inode : int = null;
    scope:
      if self.kind() != 'emulate':
        raise meta.errors.Error('addFakeDir() only valid when kind=emulate')
      kwds = {}
      kwds['perm_bits'] = stat.S_IFREG | perms
      if inode is not None:
        kwds['inode'] = inode
      /#kwds['create_missing_dirs'] = True
      self._fake_filesystem.CreateDirectory(path, **kwds)
    test:
      /# Are we supporting this?
      pass
    end method addFakeDir;

    method getFakeFile #:
      Obtain a fake file
    params:
      var path : str;
    scope:
      if self.kind() != 'emulate':
        raise meta.errors.Error('getFakeFile() only valid when kind=emulate')
      return self._fake_filesystem.GetObject(path)
    test:
      /# TODO(wmh): Are we supporting emulate?
      pass
    end method getFakeFile;

    test
    lifecycle setup:
      rootdir = metax.root.Object.Resource('testdata')
      /#test.fs = metax.fs.Filesystem(rootdir=rootdir)
    end;

  end class Filesystem;

  class BaseFile #:
    An output file generated when compiling Meta source into a base language.

    Provides an abstraction layer between on-disk vs in-memory files. Also
    provides a mechanism for maintaining a mapping between line numbers in
    Meta source code and associated lines in the baselang code (for BaseFile
    instances that represent baselang source files)
  scope:

    field subpath : str #:
      The on-disk path of the file relative to Compiler.repositoryPath().

    field contents : str #:
      The contents of the file.
    scope:
      accessor get lazy:
        link = self.link()
        if link:
          /# TODO(wmh): Is this the right way to handle symlinks when inmemory?
          contents = link.contents()
        else:
          bytes = self.bytes()
          contents = bytes.getvalue() if bytes else None
        /# print('NOTE: Acquired %d bytes from implicit bytes for %s' % (
        /#   len(contents), self.subpath()))
        -> contents
      end;
    end field contents;

    field bytes : io.BytesIO #:
      Normally null. Used when Filesystem kind is 'memory'.
      TODO(wmh): We could avoid having this if we used some wrapper on
      top of io.BytesIO in metax.fs.Filesystem.open() that properly defined
      __exit__ to create a BaseFile instance for us.

    field metafile : MetaFile #:
      The meta file that generated this BaseFile.

    field mapfile : MapFile #:
      The mapfile associated with this BaseFile. Not all BaseFile instance
      have mapfiles (e.g. BUILD, etc.)

    field mode : int #:
      The mode to be associated with this file.

    field link : BaseFile #:
      If not null, indicates this file is a symlink to the file
      in this field.

    lifecycle params:
      var subpath -> subpath;
      var contents -> contents;
      var metafile -> metafile = null;
      var mapfile -> mapfile = null;
      var mode -> mode = 416 #:
        TODO(wmh): Support octal numbers (0640) in Meta!
      var link -> link = null;
      var bytes -> bytes = null;
    scope:
      /# We ensure that contents is either empty or always end with a newline
      /# and do not have any spurious trailing whitespace.
      if contents:
        if contents[-1] != '\n':
          print('#' * 70)
          print(subpath)
          print(contents)
          raise Error('contents must end with newline')
        if contents[-2] in (' ', '\n'):
          print('=' * 70)
          print(subpath)
          print(contents)
          raise Error('contents should not have spurious trailing whitespace')
      if False:
        print('-' * 70)
        print(subpath)
        print(contents)
    setup:
      contents = 'MetaLanguage Test config:\nend;\n'
      self.base = metax.fs.BaseFile('faux/path', contents)
    end lifecycle;

  end class BaseFile;

  class StrStream #:
    Used when Filesystem has kind 'memory' to properly handle writing to
    string streams via 'with'.  See the Filesystem.open() method for usage.
  scope:
    field fs : Filesystem #:
      Where we will register the BaseFile instance.
    field path : str #:
      The (sub)path of the BaseFile.
    field bytes : io.BytesIO #:
      The bytes stream.

    lifecycle params:
      var fs -> fs;
      var path -> path;
    scope:
    end;

    method __enter__ scope:
      self._bytes = io.BytesIO()
      return self._bytes
    test:
      fs = test.rofs
      stream = metax.fs.StrStream(fs, '/a/b/faux.txt')
      with stream as fp:
        fp.write('hello\n')
      test.iseq('hello\n', stream.bytes().getvalue())
    end;

    method __exit__ params:
      var type : type #:
        The exception type
      var value : str #:
        The exception value;
      var traceback : any #:
        The traceback.
    scope:
      contents = self._bytes.getvalue()
      /# BaseFile instances are to specify paths relative to
      /# Compiler.repositoryPath(), but currently Filesystem instances do not
      /# store a Compiler instance, so we are hacking up the repo-path from
      /# other fields. It would be cleaner to have Filesystem instance store
      /# a Compiler and use self.compiler().repositoryPath()
      fs = self.fs()
      repository_path = fs.normpath(fs.join(fs.rootdir(), fs.metadir()))
      relpath = fs.relpath(self.path(), repository_path)
      basefile = BaseFile(relpath, contents)
      self._fs.addFile(basefile)
    test:
      fs = test.rofs
      stream = metax.fs.StrStream(fs, '/a/b/faux.txt')
      with stream as fp:
        fp.write('hello\n')
      test.iseq('hello\n', stream.bytes().getvalue())
    end method __exit__;

  end class StrStream;

  test
  class TestCase < metax.test.TestCase assocs:
    std assoc metastrap #:
      /# TODO(wmh): This is not actually std, but rather lib ... we need to
      /# establish an appropriate build target for it.
    std assoc os;
    cls assoc metax.c.Compiler;
    cls assoc metax.c.MetaFile;
  scope:
    lifecycle setup:
      test.dirpath = test.metaTestPath(__metafile__, 'testdata', 'tmp')
      test.frozenpath = test.metaTestPath(
        __metafile__, 'testdata', 'tmp', 'frozen.txt')
      test.filepath = test.metaTestPath(
        __metafile__, 'testdata', 'tmp', 'scratch.txt')
      with open(test.frozenpath, 'r') as fp:
        contents = fp.read()
      with open(test.filepath, 'w') as fp:
        fp.write(contents)
      test.linkpath = test.frozenpath.replace('frozen.txt', 'link.txt')
      if os.path.exists(test.linkpath):
        os.unlink(test.linkpath)
      os.symlink(test.frozenpath, test.linkpath)

      test.diskfs = metax.fs.Filesystem(kind='disk', rootdir='/foo')
      test.rofs = metax.fs.Filesystem(kind='memory', rootdir='/bar')
      test.basefile = metax.fs.BaseFile(
        'tmp/a.meta', 'class A scope:\nend class;\n')
    teardown:
      /# We copy this from frozenpath in setup.
      if os.path.exists(test.filepath):
        os.unlink(test.filepath)
    clsetup:
      metastrap.Setup()
    end lifecycle;

    method metafile : metax.c.MetaFile #:
      Return a MetaFile instance with associated compiler
    scope:
      if metax.c.Compiler.CONFIG is None:
        metax.c.Compiler.CONFIG = metax.root.MetaObject.Config()
      compiler = metax.c.Compiler(metal='oopl', basel='python')
      metafile = metax.c.MetaFile('/dummy/path', compiler, 'faux meta file')
      return metafile
    end;

    method hier : Directory #:
      Generate a little hierarchy of instances useful for testing.
    scope:
      /# We do not use Filesystem.Root() because that would pollute a common
      /# object across tests.
      root = metax.fs.Directory('', None)
      home = metax.fs.Directory('home', root)
      bob = metax.fs.Directory('bob', home)
      bobs_readme = metax.fs.File('README', bob)
      alice = metax.fs.Directory('alice', home)
      metax.fs.Symlink('README', alice, bobs_readme)
      return alice
    test:
    end method hier;

  end class TestCase;

end namespace metax.fs;
