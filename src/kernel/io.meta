namespace metax.io #:
  I/O in Meta.

  TODO(wmh): Decide whether metax.fs should be moved into metax.io.
scope:

  class Sink #:
    Experiment in wrapping fp/indent. This will be moved into metax.io.
  assocs:
    std usertest assoc io;
    std assoc os #:
      TODO(wmh): Does this need to use metax.fs???
    std assoc sys;
  scope:

    static
    field Null : Sink #:
      An instance of Sink that writes to /dev/null.

    static
    field Out : Sink #:
      An instance of Sink that writes to stdout.

    static
    field Err : Sink #:
      An instance of Sink that writes to stderr.

    field fp : ostream #:
      Where to write.

    field prefixes : @vec<str> #:
      prefixes[-1] is the indentation that should be added to every line
      written.

    field lastc : char #:
      The last character written the last time anything was written to the
      stream. Will not be updated if someone writes to self.fp() directly.

    field pathmap : map #:
      Maps path prefixes to shorthand (usually an environment variable,
      including the '$ explicitly if appropriate).  Used by Sink.truncate()
      to shorten paths, etc.

    lifecycle params:
      var fp -> fp = out;
      var indent : str = '' #:
        The top-level indentation.
    scope:
      self.prefixes().append(indent)
      /# Important to set this to newline so that first line printed uses same
      /# logic as all other lines.
      self.lastcIs('\n')
    clinit:
      cls.OutIs(Sink(fp=sys.stdout))
      cls.ErrIs(Sink(fp=sys.stderr))
      dfp = open(os.devnull, 'w')
      cls.NullIs(Sink(fp=dfp))
    setup:
      sink = metax.io.Sink(io.StringIO(), indent=u'..')
      test.sinkIs(sink)
    end;

    test field sink : wmh.google.hotels.Sink;

    method clone : Sink #:
      Make a copy of myself
    scope:
      cls = self.__class__
      result = cls(fp=self.fp())
      result.prefixesIs(self.prefixes()[:])
      result.lastcIs(self.lastc())
      result.pathmapIs(self.pathmap())
      return result
    test:
    end method clone;

    method prefix : str #:
      Returns current indentation prefix.
    scope:
      return self._prefixes[-1]
    test:
      test.iseq('..', test.sink().prefix())
    end method prefix;

    method indent : str #:
      Add more indentation to the current value.
    params:
      var value : str #:
        The additional indentation.
        NOTE: Although it would be convenient to provide a default value, we
        intentionally do not do so, to ensure that the similarities between
        indent() and undent() do not pose problems.  indent() requires an
        arg and undent does not have an arg, which avoids subtle bugs related
        to typos.
    scope:
      /# if we want to support newlines in indent, write() will need updating.
      assert '\n' not in value
      newdent = self.prefix() + value
      self.prefixes().append(newdent)
      return newdent
    test:
      sink = test.sink()
      sink.indent('__')
      test.iseq('..__', sink.prefix())
    end method indent;

    method undent : str #:
      Return to previous indentation.

      Returns the new indentation.
    scope:
      prefixes = self.prefixes()
      if len(prefixes) > 1:
        prefixes.pop()
      return prefixes[-1]
    test:
      sink = test.sink()
      test.iseq('..  ', sink.indent('  '))
      test.iseq('..', sink.undent())
      test.iseq('..', sink.undent())
    end method undent;

    method dent : str #:
      The current indentation level
    scope:
      return self.prefixes()[-1]
    test:
      test.iseq('..', test.sink().dent())
    end method dent;

    method newline #:
      Write a newline.

      This differs from self.write('\n') in not inserting indentation
      (useful to avoid blank lines at the end of a line)
    scope:
      self.lastcIs('\n')
      self.fp().write('\n')
    test:
      sink = test.sink()
      sink.writeln('hello')
      sink.writeln('')
      sink.newline()
      sink.writeln('goodbye')
      test.iseqtext("""\
        >|..hello
        >|
        >|
        >|..goodbye
        >|""",
        sink.fp().getvalue())
    end method newline;

    method write : void #:
      Write text to the sink, honoring indent.
    params:
      var text : str #:
        The text to write.  All newlines are replaced with indentation.
      multi var args : vec<any> #:
        A collection of args to apply to the printf template specified by text.
    scope:
      fp = self.fp()
      prefix = self.prefix()

      /# Handle pre-indentation for the new text.
      /#  - if the previous write ended with a newline, we need to add
      /#    'prefix' before we write the text
      /#  - if the previous write did NOT end with a newline, we do NOT
      /#    add 'prefix' before writing text
      if self.lastc() == '\n':
        fp.write(prefix)

      /# Adjust the specified text slightly, according to prefix.
      if text:
        if args:
          text = text % args

        /# We need to insert the prefix at the beginning of each line in text
        lastc = text[-1]
        if lastc == '\n':
          /# We do not want to insert indentation after the last newline.
          try:
            newtext = text[:-1].replace('\n', '\n' + prefix) + '\n'
          except UnicodeDecodeError as e:
            print(
              '**** IN metax.io.Sink.write, found text (%s) and prefix (%s) producing %s (%s)' %
              (type(text), type(prefix), e, sys.version_info))
            newtext = text
        else:
          /# We can perform a simple replace
          newtext = text.replace('\n', '\n' + prefix)
      else:
        /# Text is empty, so we need only write a newline.
        newtext = ''
        lastc = prefix[-1] if prefix else ''
      self.lastcIs(lastc)
      fp.write(newtext)
    test:
      sink = test.sink()

      sink.write('hello.')
      test.iseq('.', sink.lastc())
      test.iseqtext('..hello.', sink.fp().getvalue())

      sink.write(' This is\na test ')
      test.iseq(' ', sink.lastc())
      test.iseqtext('..hello. This is\n..a test ', sink.fp().getvalue())

      sink.write('and now\nanother\n')
      test.iseq('\n', sink.lastc())
      test.iseqtext(
        '..hello. This is\n'
        '..a test and now\n'
        '..another\n',
        sink.fp().getvalue())

      sink.write('to verify newlines\n')
      test.iseq('\n', sink.lastc())
      test.iseqtext(
        '..hello. This is\n'
        '..a test and now\n'
        '..another\n'
        '..to verify newlines\n',
        sink.fp().getvalue())
    end method write;

    method writeln : any #:
      Write text to the sink, honoring indent.
    params:
      var text : str = '' #:
        The text to write.  All newlines are replaces with indentation.
      multi var args : vec<any> #:
        A collection of args to apply to the printf template specified by text.
    scope:
      if text:
        self.write(text, *args)
      if not text or text[-1] != '\n':
        fp = self.fp()
        self.newline()
    test:
      sink = test.sink()
      sink.writeln('hello')
      sink.write('goodbye')
      sink.writeln(' fun world')
      test.iseqtext("""\
        >|..hello
        >|..goodbye fun world
        >|""",
        sink.fp().getvalue())
    end method writeln;

    method flush #:
      Flush the output stream.
    scope:
      self.fp().flush()
    test:
      sink = test.sink()
      sink.write('a test')
      sink.flush()
    end method flush;

    method append #:
      Write text to stream without adding indentation.
    params:
      var phrase : str #:
        Should NOT contain newlines except optionally at the end.
    scope:
      if phrase:
        self.fp().write(phrase)
        self.lastcIs(phrase[-1])
    test:
      sink = test.sink()
      sink.indent('..')
      sink.write('a test')
      sink.append(' and more\n')
      test.iseq('....a test and more\n', sink.fp().getvalue())
    end method append;

    method truncate : str #:
      Truncate a path by using a prefix from prefixes.

      NOTE: This is an experiment. May be moved elsewhere.
    params:
      var path : str #:
        The path to truncate.
      var paths : map = null #:
        The paths to search in addition to self.pathmap
    scope:
      result = path

      pathmap = {}
      if self.pathmap():
        pathmap.update(self.pathmap())
      if paths:
        pathmap.update(paths)

      for prefix in sorted(pathmap, reverse=True):
        if path.startswith(prefix):
          result = pathmap[prefix] + path[len(prefix):]
          break
      return result
    test:
      sink = test.sink()
      test.iseq('/a/b/c/d', sink.truncate('/a/b/c/d'))

      sink.pathmapIs({'/a/b': '$TEST', '/a/b/c': '$TEST2'})
      test.iseq('$TEST2/d', sink.truncate('/a/b/c/d'))
    end method truncate;

    method updatePaths #:
      Update the prefix/abbrev pathmap
    params:
      var pathmap : map #:
        The new prefix/abbrev pairs to add. Overwrites existing prefixes.
    scope:
      if self.pathmap() is None:
        self.pathmapIs({})
      existing = self.pathmap()
      existing.update(pathmap)
    test:
      sink = test.sink()
      test.iseq('/a/b/c/d', sink.truncate('/a/b/c/d'))

      sink.updatePaths({'/a/b': '$TEST'})
      test.iseq('$TEST/c/d', sink.truncate('/a/b/c/d'))
      sink.updatePaths({'/a/b': '$TEST', '/a/b/c': '$TEST2'})
      test.iseq('$TEST2/d', sink.truncate('/a/b/c/d'))
      sink.updatePaths({'/a/b/c': '$TEST3'})
      test.iseq('$TEST3/d', sink.truncate('/a/b/c/d'))
    end method updatePaths;

  end class Sink;

end namespace metax.io;
