namespace metax.oopl scope:

  class MetaxOopl < metax.meta.MetaLanguageConstruct #:
    A subclass of MetaLanguageConstruct representing Meta(Oopl)

    NOTE(wmh): Until we support multiple inheritance, this class is NOT a
    subclass of OoplConstruct, because it needs to be a subclass of
    metax.meta.MetaLanguageConstruct
  scope:

    lifecycle clinit:
      /# TODO(wmh): This needs to be put someplace else (config file, etc).
      /# Preferably, it would be described in meta syntax and available to
      /# programmers to extend.

      /# NATIVE : map
      /#   Each key is the name of a native type supported by Meta. The value
      /#   is a map:
      /#     template : vec<str>
      /#       Number of elements indicates how many parameters this native
      /#       type has. If not present or empty, the type is not templated.
      /#       Each element is a string repr of a meta-level type, and
      /#       represents the default type for the param in question. For
      /#       example, 'map' is short for 'map<str,any>' and 'map<int>'
      /#       is short for 'map<str,int>' because __templates__ for map is
      /#          ['str', 'str']
      /#       If a particular template parameter is required, use a value
      /#       of null within the __template__ list for it.
      /#     alias : vec<str>
      /#       The list of aliases for this metatype.
      /#     scope : map<str,map>
      /#       Keys are method names defined on the conceptual type, values are
      /#       maps describing info about the method:
      /#         args: vec<map>
      /#           If not present or null, the method has no args.
      /#           Each element describes information about an arg of the method
      /#             type: str
      /#               The meta-level type of the arg (template substitutions
      /#               are applied before passing to metax.c.Type.Instance).
      /#             default: str
      /#               Indicates the arg is optional, and specifies the value
      /#               to use if one is not provided (a string representing
      /#               legal Meta expr syntax?)
      /#         alias: vec<str>
      /#           alternate names for the method.
      /#         returns: str
      /#           The meta-level return type. Template substitutions are
      /#           applied before passing to metax.c.Type.Instance.
      /#         expr : bool
      /#           If true, the resulting code can be used in baselang
      /#           expressions. If false or not present, the code returned
      /#           represents a statement.
      /#            - TODO(wmh): Work related to expr vs statement is ongoing
      /#              and needs more details. Need to also add in how the
      /#              return type plays into this (void vs non-void) wrt when
      /#              the code can be assigned to a variable or used in a
      /#              baselang expr.
      /#         code: map
      /#           Keys are baselang suffixes starting with '.'
      /#           Values are strings containing the following special
      /#           substitutions:
      /#             ${rec}   : the receiver
      /#             ${recsep}: the receiver and separator ('val.', 'ptr->',..)
      /#             ${T<k>}  : the kth template type (as a metatype string)
      /#             ${A<k>}  : the kth argument (as baselang code)
      /#
      /#   IMPORTANT: The dict intentionally stores only strings (rather than
      /#   richer types like metax.c.Type instance) so that we can easily move
      /#   the dict into a config file. We can perform optimization on the data
      /#   after it is read in (by converting type strings to Type instances,
      /#   etc.). Note however that because template variable instantiation
      /#   depends on the types at the callsite, some optimizations may not be
      /#   possible.
      /#
      /# TODO(wmh): An alternative way of defining the following would be to
      /# provide a metax.native namespace that defines a class for each
      /# native type. We could extract out the method bodies, etc. to obtain
      /# native code.
      native = {
        'str': {
          'scope': {
            'size': {
              'comment': 'Number of unicode characters in the string.',
              'args': None,
              'alias': ('len', 'length'),
              'returns': 'int',
              'code': {
                '.cc': '%(recsep)ssize()',
                '.js': '%(rec)s.length',
                '.py': 'len(%(rec)s)',
              },
            },
            'bytes': {
              'comment': 'Number of bytes in the string.',
              'args': None,
              'returns': 'int',
              'code': {
                /# TODO(wmh): Fix these!
                '.cc': '%(recsep)ssize()',
                '.js': '%(rec)s.length',
                '.py': "len(%(rec)s.encode('utf8'))",
              },
            },
          }
        },
        'vec': {
          /# cc: http://www.cplusplus.com/reference/vector/vector/
          /# js: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
          /# py: https://docs.python.org/3/tutorial/datastructures.html

          'alias': ['list', 'vector'],
          'template': ['any'],
          'scope': {

            'size': {
              'comment': 'Number of elements in the vector.',
              'args': None,
              'alias': ('len', 'length'),
              'returns': 'int',
              'code': {
                '.cc': '%(recsep)ssize()',
                '.js': '%(rec)s.length',
                '.py': 'len(%(rec)s)',
              },
            },

            /# Add/remove from end of list
            'push': {
              'comment': 'Add an element at the end of a list.',
              'alias': ('add', 'append', 'push_back'),
              'args': [{'type': '%(T1)s'}],
              'returns': 'void',
              'code': {
                '.cc': '%(rec)s.push_back(%(A1)s)',
                '.js': '%(rec)s.push(%(A1)s)',
                '.py': '%(rec)s.append(%(A1)s)',
              },
            },
            'pop': {
              'comment': 'Remove and return an element from the end of a list.',
              'alias': ('pop_back'),
              'args': [],
              'returns': '%(T1)s',
              'code': {
                '.cc': '%(rec)s.pop_back()',
                '.js': '%(rec)s.pop()',
                '.py': '%(rec)s.pop()',
              },
            },

            /# Add/remove from front of list
            'push_front': {
              'comment': 'Add an element at the beginning of a list.',
              /# does NOT support adding multiple elements at front (use splice)
              'alias': ('unshift',),
              'args': [{'type': '%(T1)s'}],
              'returns': 'void',
              'code': {
                '.cc': '%(rec)s.insert(%(rec)s.begin(), %(A1)s)',
                '.js': '%(rec)s.unshift(%(A1)s)',
                '.py': '%(rec)s.insert(0, %(A1)s)',
              },
            },
            'pop_front': {
              'comment': 'Remove and return an element from the beginning of a list.',
              'args': [{'type': '%(T1)s'}],
              'returns': '%(T1)s',
              'alias': ('shift',),
              'code': {
                /# In C++, there is no built-in rvalue way to delete an
                /# arbitrary element by index and return that element. The
                /# vector::erase method does not return the element deleted
                /# (because it can delete multiple elements). We rely on the
                /# existence of G_scratch here. See ./tests/cc/vector/main.cc
                /# for how this works. Meta<C++> needs to ensure G_scratch
                /# is available and thread_local.
                '.cc': '(G_scratch = v[0], v.erase(v.begin()), std::any_cast<int>(G_scratch))',
                '.js': '%(rec)s.shift()',
                '.py': '%(rec)s.pop(0)',
              },
            },

            /# Add/remove to/from specified index of list.
            'insert': {
              'comment': 'Add an element after given index of a list.',
              'args': [{'type': 'int'}, {'type': '%(T1)s'}],
              'returns': 'void',
              'code': {
                '.cc': '%(rec)s.insert(%(rec)s.begin() + %(A1)s, %(A2)s)',
                '.js': '%(rec)s.splice(%(A1)s, 0, %(A2)s)',
                '.py': '%(rec)s.insert(%(A1)s, %(A2)s)',
              },
            },
            'remove': {
              'comment': 'Remove and return the element at given index of a list.',
              'args': [{'type': 'int'}],
              'returns': '%(T1)s',
              'code': {
                /# See pop_front above for C++ limitation here.
                '.cc': '(G_scratch = v[%(A1)s], v.erase(v.begin()+%(A1)s), std::any_cast<int>(G_scratch))',
                '.js': '%(rec)s.splice(%(A1)s, 1)[0]',
                '.py': '%(rec)s.pop(%(A1)s)',
              },
            },

            /# TODO(wmh): Need a 'slice' method
            /#  - Obtain a copy of a subset of element in the vector.
            /#  - Do we provide
            /#      slice(<start>, <count>)
            /#    or
            /#      slice(<start>, <end>)
            /#    or
            /#      slice(<start>, <end_plus_1>)
            /#    or some combination of these?

            /# TODO(wmh): Need a 'splice' method:
            /#  - Remove n elements starting at index i and insert m new elements.
            /#  - Problem: The above syntax does not yet support varargs.
          },
        },
        'map': {
          /# cc: http://www.cplusplus.com/reference/map/map/
          /# js: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
          /# py: https://docs.python.org/3/library/stdtypes.html#typesmapping

          /# TODO(wmh): In Javascript, need to decide whether it is viable to
          /# have the meta-level 'map' type be implemented by Map instead of
          /# Object.
          /#  - problems:
          /#     - the very common idiom:
          /#         var a = {};
          /#       produces an Object
          /#     - initializing a complex datastructure like:
          /#         var data = {a: 1, 'b c': 2, 'd': {'more': [1,2]}}
          /#       produces Object instances not Maps. The above would need
          /#       to be specified as
          /#         var data = Map();
          /#         data.set('a', 1);
          /#         data.set('b c', 2);
          /#         var subdata = Map();
          /#         subdata['more'] = [1,2];
          /#         data.set('d', subdata);
          /#       but we can define a convenience method:
          /#         var data = metax.t.Map.New(
          /#           {a: 1, 'b c': 2, 'd': {'more': [1,2]}})
          /#       which would recursively convert Object to Map
          /#       (but incurs an entire traversal of the Object input
          /#       when creation occurs.
          /#     - do the efficiency benefits gained by Map outweigh the
          /#       syntactic overhead and efficiency deteriments incurred
          /#       by Map?
          /#     - may not be too problematic for greenfield implementations,
          /#       but dealing with legacy javascript could be problematic.
          /#  - The code below is assuming meta 'map' is javascript Map, and
          /#    we'll see if this poses too many problems.

          'alias': ['hash', 'dict'],
          /# TODO(wmh): The 'template' key stores the number of template
          /# parameters for this metatype. It indicates that 'map' is short for
          /# 'map<str,any>'. It would be more convenient for 'map<int>' to
          /# mean 'map<str,int>' than 'map<int,any>', but that would require
          /# that missing params be filled from the left when it is more common
          /# to fill from the right). Look at other multi-param metatypes and
          /# decide whether we need to special-case 'map' or can handle it
          /# more generally. Can we introduce some notation into template to
          /# indicate left-to-rigth assignment of defaults?
          'template': ['str', 'any'],
          'scope': {
            'size': {
              'comment': 'Number of elements in the map',
              'args': None,
              'alias': ('len', 'length'),
              'returns': 'int',
              'code': {
                '.cc': '%(recsep)ssize()',
                '.js': '%(rec)s.size',
                '.py': 'len(%(rec)s)',
              },
            },
            'has': {
              'comment': 'Check if a given key exists in the map.',
              'args': [{'type': '%(T1)s'}],
              'returns': 'bool',
              'code': {
                '.cc': '%(rec)s.find(%(A1)s) != %(rec)s.end()',
                /# '.js': '%(A1)s in %(rec)s',
                '.js': '%(rec)s.has(%(A1)s)',
                '.py': '%(A1)s in %(rec)s',
              },
            },
            'get': {
              'comment': 'Obtain the value for a given key, with default or exception',
              'args': [{'type': '%(T1)s'}],
              'returns': '%(T2)s',
              'alias': ('at',),
              'code': {
                '.cc': '%(rec)s[%(A1)s]',
                /# '.js': '%(rec)s[%(A1)s]',
                '.js': '%(rec)s.get(%(A1)s)',
                '.py': '%(rec)s[%(A1)s]',
              },
            },
            'set': {
              'comment': 'Set the value of a key',
              'args': [{'type': '%(T1)s'}, {'type': '%(T2)s'}],
              'returns': 'void',
              'code': {
                '.cc': '%(rec)s[%(A1)s] = %(A2)s',
                '.js': '%(rec)s.set(%(A1)s, %(A2)s)',
                '.py': '%(rec)s[%(A1)s] = %(A2)s',
              },
            },

            /# TODO(wmh): Do we NOT provide keys() and values() and instead
            /# just provide pairs()? C++ does not provide keys() or values(),
            /# only ::begin() to iterator over pairs.
            'keys': {
              'comment': 'Obtain an iterator over all keys in the map',
              'args': None,
              'returns':'iter<vec<%(T1)s>>',
              'code': {
                /# TODO(wmh): Need to support iterators over keys in C++
                /#  - https://stackoverflow.com/questions/1443793/iterate-keys-in-a-c-map
                /#  - http://www.lonecpluspluscoder.com/2015/08/13/an-elegant-way-to-extract-keys-from-a-c-map/
                /#    and https://ideone.com/k0H8Ei
                '.cc': 'meta::lang::Dictionary::Keys(%(rec)s)',
                '.js': '%(rec)s.keys()',
                '.py': '%(rec)s.keys()',
              },
            },
            'values': {
              'comment': 'Obtain an iterator over all values in the map',
              'args': None,
              'returns':'iter<vec<%(T2)s>>',
              'code': {
                /# TODO(wmh): Need to support iterators over keys in C++
                /#  - https://stackoverflow.com/questions/1443793/iterate-keys-in-a-c-map
                /#  - http://www.lonecpluspluscoder.com/2015/08/13/an-elegant-way-to-extract-keys-from-a-c-map/
                /#    and https://ideone.com/k0H8Ei
                '.cc': 'meta::lang::Dictionary::Values(%(rec)s)',
                '.js': '%(rec)s.values()',
                '.py': '%(rec)s.values()',
              },
            },
            'pairs': {
              'comment': 'Obtain an iterator over all <key,value> pairs in the map',
              'alias': ('entries', 'items'),
              'args': None,
              'returns':'iter<vec<tuple<%(T1)s,%(T2)s>>>',
              'code': {
                '.cc': '%(rec)s.begin()',
                '.js': '%(rec)s.entries()',
                '.py': '%(rec)s.items()',
              },
            },
          },
        },

        're': {
          /# cc: https://en.cppreference.com/w/cpp/regex
          /# js: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
          /# py: https://docs.python.org/3/library/re.html

          'scope': {
            /# TODO(wmh): Any symbol of form (<name>) is not actually a user
            /# visible native method. It is instead something used internally
            /# by Meta to do implicit typecasting. For example, in Meta the
            /# following syntax is valid:
            /#   field vre : re = '(.)(..)';
            /# even though the default value is not of type 're' (it is a str).
            /# The code supports the implicit conversation of str-typed values
            /# instances of 're' because 're' defines '(str)', which provides
            /# the baselang code for converting a string into a regexp.
            '(str)': {
              'args': [{'type': 'str'}],
              'code': {
                '.cc': 'std::regex(%(A1)s)',
                /# TODO(wmh): console.log() is just a hack till we get real
                /# streams in javascript via phantomjs or Meta.
                '.js': 'new Regexp(%(A1)s)',
                '.py': 're.compile(%(A1)s)',
              },
            },
          },
        },

        'meta!ostream': {
          'scope': {
            'write': {
              'alias': ('echo', 'print'),
              'args': [{'type': 'str'}],
              'code': {
                '.cc': '%(rec)s << %(A1)s',
                /# TODO(wmh): console.log() is just a hack till we get real
                /# streams in javascript via phantomjs or Meta.
                '.js': 'console.log(%(A1)s)',
                '.py': '%(rec)s.write(%(A1)s)',
              },
            },
          },
        },
      }
      for ninfo in native.values():
        /# TODO(wmh): Consider converting the elements in ninfo['template']
        /# to metax.c.Type instances (they should never need instantiation,
        /# and this avoids us having to convert every single time we compile
        /# a callsite.

        /# Extend scope with aliases.
        scope = ninfo['scope']
        for method in list(scope.keys()):
          minfo = scope[method]
          for alias in minfo.get('alias', []):
            scope[alias] = minfo

      cls.NATIVE = native
    end;

  end class MetaxOopl;

  abstract
  class OoplConstruct < metax.meta.Construct #:
    @_oopl_: Abstract construct from which all Meta(Oopl) constructs inheret.

    All constructs in Meta(Oopl) inherit from this abstract construct,
    so the Attribute definitions here are available in subconstructs.
    However, note that the existence of an Attribute here does NOT mean it
    is automatically included in the subconstruct ... the subconstruct
    must specify the primary attribute (and any customization of other
    values).
  assocs:
    lib assoc metax.attr;
  scope:

    method myclass : metax.oopl.ClassConstruct #:
      Dummy implementation of myclass for use in constructs that appear
      within a class construct but which do not maintain a myclass field.
    scope:
      return None
    test:
      /# no instance of OoplConstruct available
      pass
    end method myclass;

    method myclassIs #:
      Dummy implementation of myclassIs for use in constructs that appear
      within a class construct but which do not maintain a myclass field.
    params:
      var klass : metax.oopl.ClassConstruct;
    scope:
    test:
      /# no instance of OoplConstruct available
      pass
    end method myclassIs;

    method myexec : metax.oopl.ExecutableConstruct #:
      Dummy implementation of myexec for use in constructs that don't have
      an executable parent.
    scope:
      return None
    test:
      pass
    end method myexec;

    method myexecIs : any #:
      Dummy implementation of myexecIs for use in constructs that do not have
      an executable parent.
    params:
      var executable : metax.oopl.ExecutableConstruct;
    scope:
      /# If this output is seen, it is usually an indication that some class
      /# needs to define a myexec() field or at least a myexecIs() setter.
      print(
        'TEMPORARY: Note that %s is dropping executable %s in myexecIs()' %
        (self.kindfqn(), executable.kindfqn() if executable else None))
    test:
      pass
    end method myexecIs;

    method _statementCode : metax.c.BaseSegment #:
      A service method used by statement-level constructs when implementing
      their translateMeta method.
    params:
      var start_lines : vec<str> #:
        The initial code at the same indentation level as the code above it.
        For example, if we are compiling a for loop, this would represent the
        baselang code for the start of the loop (e.g. 'for i in ...:' in python)
      var scope : metax.attr.BlockAttribute #:
        The block representing the indented code. This may be a simple block
        or complex block.
      var end_lines : vec<str> = null #:
        Code to be added after the lines in 'scope', at the same indentation
        level as start_lines (not the same as scope). If you want to insert
        lines at same indentation as scope, add the indentation to the lines
        in end_lines first.
      var indent : str = '  ' #:
        How much indentation to add for the lines in the scope block. The
        default (two spaces) captures the common case, but in some situations
        there are no start_lines and the scope provides lines at the same
        indentation level as the parent construct, in which case indent will
        be set to '' by the caller.
      var segment : metax.c.BaseSegment = null #:
        The segment to add to. If not specified, obtained from the last chunk in
        the 'current-body' stream.
    scope:
      statement = self

      /# The 'current-body' stream contains all text in the current method,
      /# into which statement-level constructs are to be added. The caller
      /# is required to ensure that the last element of the current-body
      /# stream is ALWAYS a BaseSegment, properly indented, into which
      /# statements are to add their appropriate code.
      if not segment:
        /# TODO(wmh): Can we use myclass()? Would be much more efficient.
        /# TODO(wmh): Replace class-level stream with a method-level one?
        myclass = self.ancestor('class')
        segment = myclass.streamNamed('current-body')[-1]
      assert isinstance(segment, metax.c.BaseSegment)

      /# The 'precount' field of statement establishes how many blank lines
      /# appeared before the statement in the meta code. We print out the same
      /# number of blank lines in the baselang code.
      for i in range(statement.precount()):
        segment.addLine('')

      /# The 'start_lines' arg contains a list of lines to be added at the
      /# same indentation level as the current code.
      /#  - for now we simply add these lines to the current segment, but it
      /#    would be more general/flexible if we created a BaseSegment with zero
      /#    indentation that contains these lines. Doing so would allow nested
      /#    code to insert code *before* the statement in situations where that
      /#    is necessary, by either obtaining the second last entry in the
      /#    current-body stream, or the parent stream of the last stream, if we
      /#    decide to nest them. If the latter, note that we would need to
      /#    extend BaseSegment to allow them to maintain a parent BaseSegment.
      segment.addLines(start_lines)

      /# Now handle the scope.
      if scope.isComplexBlock():
        /# Statements expect that the 'current-body' stream will contain as its
        /# last element a BaseSegment into which the statement is to be
        /# compiled. So we create such a BaseSegment, indented properly, and
        /# recurse.
        subsegment = metax.c.BaseSegment(scope, indent=indent)
        segment.addChunk(subsegment)
        for stmt in scope.value():
          stmt.translateMeta()
      else:
        /# We have a simple block, which means we do not need to recursively
        /# compile sub-statement constructs. However, we do need to make sure we
        /# get the indentation correct. There are two ways we can handle this:
        /#   1. Add each line of the scope to 'segment' with a manually
        /#      inserted two-space indentation .
        /#   2. Create a BaseSegment representing the lines in the scope
        /#      (with the desired indentation passed into the BaseSegment),
        /#      and add this sub-segment to 'segment'.
        /# The pro (and con) of #2 is that it will result in an entry being
        /# added to the mapfile, which both inflates the mapfile significantly
        /# (not so good) and increases the chances that the meta-to-base
        /# line number mapping is kept correct (as long as we pass in the
        /# correct attribute to the sub-segment).  For now, we are going with
        /# #2, and we see how this impacts performance, etc.
        segment.addChunk(
          metax.c.BaseSegment(scope, chunks=scope.value(), indent=indent))

      /# Now the end_lines
      /#  - these are added at the same indentation level as start_lines,
      /#    one indentation level smaller than the lines in scope.
      /#  - caller can add indentation before these lines manually to add
      /#    indentation at the level of scope.
      if end_lines:
        segment.addLines(end_lines)

      return segment
    test:
      test.tpy(statements=True)
      segments = test.klass.streamNamed('current-body')
      segment = metax.c.BaseSegment(None)
      segments.append(segment)

      loop = test.loop
      loop._statementCode(
        ['for i in range(0, 10, 2):'], loop.attr('scope:'))
      test.iseq(
        '\nfor i in range(0, 10, 2):\n  print(i)\n',
        segment.flattenStr())
    end method _statementCode;

    method useSwitch : any #:
      Service method of SwitchConstruct and CaseConstruct for establishing
      whether to use a baselang case statement or not.
    params:
      var switch_ : SwitchConstruct #:
        The switch to check.
      var baselang : BaseLanguageOopl #:
        The baselang being complied to.
    scope:
      on_attr, on = switch_.attrpair('on', default=None)
      if on_attr:
        /# If the on variable has integral type, we can perform an actual
        /# baselang switch statement if the baselang has it. But if the on
        /# variable is any other type, we perform implicit equality testing.

        /# TODO(wmh): Find the variable identified by 'on' in the symbol table
        /# of the parent construct, and obtain its type.
        ontype = metax.c.Type.Instance('nm.sp.A')
        switch_level = baselang.config('switch_level')
        if ontype.isIntegral():
          result = switch_level >= 1
        else:
          result = switch_level >= 2
      else:
        /# No language handles bool expressions via switch statements.
        result = False
      return result
    test:
      test.tpy(statements=True, expand=True)

      /# switch1 is a traditional ordinal test.
      switch1 = test.switch
      scope1 = switch1.attr('scope:')
      case1a = scope1.value()[0]
      case1b = scope1.value()[1]
      test.isfalse(switch1.useSwitch(switch1, test.baselang))
      test.isfalse(case1a.useSwitch(switch1, test.baselang))
      test.isfalse(case1b.useSwitch(switch1, test.baselang))

      /# switch2 is aribtrary expression tests.
      switch2 = test.switch2
      scope2 = switch2.attr('scope:')
      case2a = scope2.value()[0]
      case2b = scope2.value()[1]
      test.isfalse(switch2.useSwitch(switch2, test.baselang))
      test.isfalse(case2a.useSwitch(switch2, test.baselang))
      test.isfalse(case2b.useSwitch(switch2, test.baselang))

      /# TODO(wmh): The above only tests python, in which useSwitch always
      /# returns false because python doesn't have as switch statement. In
      /# C++, switch1 should return true, and switch 2 should return false.
    end method useSwitch;

  end class OoplConstruct;

  abstract
  class SymbolConstruct < OoplConstruct #:
    @_symbol_: Abstract superclass of constructs that maintain a symbol table.
    Maps identifiers to sub-constructs accessible at runtime.
  scope:

    field symbols : metax.c.SymbolTable #:
      The symbols visible from code within the level of this construct.
      For example:
       - namespaces contain the singleton class instances (MetaFoo, MetaBar,
         etc).  They do NOT contain the class names themselves, as not all
         baselangs treat classes as first-class objects.
       - classes contain all method and field names
          - the symboltable of class B should link to the symboltable of
            class A if B is a child of A.
          - if class symbol tables link to parent class symbol tables, does
            that mean that we need to support multiple parents to also support
            'inheriting' from namespaces? We *could* copy parent data into
            symbol tables at time of linking, but this incurs more space
            overhead and makes it more difficult to support dynamic modification
            of classes at runtime within Meta (if symbol tables inherit,
            dynamically adding a field to a class C means it is immediately
            available in subclasses without us having to update symboltables
            other than C).
       - methods contain all params and local vars not within a lexically
         scoped subblock.
       - lexical blocks contain vars introduced within the block

    field streams : @map<str,vec> #:
      This is a mapping from stream name to list of <str|BaseSegment>. See
      the class comment for ClassConstruct, NamespaceConstruct, etc. for
      details on the streams used within that construct.

      TODO(wmh): Remove metax.c.BaseStreams as unnecessary.

      TODO(wmh): Separate out the streams functionality into a StreamConstruct
      superclass. Would be nice if it was defined in Meta(Meta), but it is also
      useful for it to be a subclass of OoplConstruct or a mixin, since
      SymbolConstruct really needs to be a subclass of OoplConstruct. Note that
      stream functionlaity is also needed in Meta(Doc) and will be needed in
      most other metalangs as well.

      TODO(wmh): Decide whether to commit to namespace-level streams for
      namespace-level field/method/native constructs. Currently such
      constructs are required to be attached to a class before/after the
      namespace-level construct, but that is not intuitive and has some
      problems (but is easier to implement than namespace-level constructs,
      which will require us to maintain per-metafile namespace snippets that
      get merged into a single namespace file (in order to support
      separate compilation).

      To understand why we have moved from a single collection of streams
      defined on each Metafile instance to a world where each Class (and
      Namespace/Method) has its own set of streams, consider the situation where
      we have a class construct, followed (outside of the class definition, so
      all at namespace level) by a native construct, a field construct, another
      native construct, and a method construct, all with position 'post'. All of
      these constructs are to be added to the code for the class before them.
      HOWEVER, the code for a class is generated when
      ClassConstruct.translateMeta() is invoked ... which happens BEFORE we
      invoke translateMeta() on any of the constructs after the class. So
      constructs to be attached to a class need to be processed BEFORE
      ClassConstruct.translateMeta() is invoked. To address this, we can perform
      special processing of namespace-level native, field and method constructs
      with position 'post' during expandMeta(), in which we identify the
      previous class and add the code associated with the construct to the
      appropriate class-specific streams() instance. Then when
      ClassConstruct.translateMeta() is invoked, we can check for streams in
      self.streams() and add them to the associates streams in
      metafile.streams() as appropriate.

      Note that we can process cls-pre-* streams the same way, but we can also
      process them within translateMeta() because the streams that
      pre-placement native, field and method constructs write into during
      translateMeta() will be available when the ClassConstruct.translateMeta()
      is entered.

      There are numerous implemention strategies here:
        1. Handle namespace-level native blocks within expandMeta, but
           handle namespace-level pre-position field/method blocks in
           translateMeta and disallow post-position field/method blocks.
            + easy to implement
            - the order in which pre/post native blocks are inserted into the
              class code, relative to field/method code, will often not
              correspond to the order seen in the Meta code (bad!)
            - by writing pre-position native/field/method constructs into
              the metafile stream, they will be added to the metaclass of
              the following user-defined class instead of the user-level
              class because metaclasses are defined first. This is a deal
              breaker, since we do not want to force inclusion of metaclasses
              if they are not used.
        2. Handle pre-position namespace-level native/field/method blocks in
           translateMeta by writing to the appropriate metafile streams,
           and handle post-position namespace-level native blocks in expandMeta
           (by writing to class-specific streams). Disallow post-position
           field/method code.
            + easy to implement
            - one common idiom for dealing with class initialization is to have
              a namespace-level function invoked after all classes have been
              defined. This would need to be post-position.  However, we can
              easily use a native block for such things. Not optimal, but
              doable.
            - same issue as in #1 about pre-position constructs being written
              into the metaclass instead of userclass.
        3. Handle namespace-level pre/post-position native/field/method blocks
           within expandMeta().
            + the most generalized and intuitive solution
            + consistent, localized functionality
            - requires us to perform translateMeta() functionality within
              expandMeta() sometimes, so we'll need to pull translateMeta()
              code into library functions (easy to do though).
        4. Handle namespace-level pre-position native/field/method blocks
           within translateMeta() and namespace-level post-position
           native/field/method blocks within expandMeta().
            + a general and flexible solution
            - similar code needs to reside in two different locations
              (expandMeta for post-position and translateMeta for pre-position)
        5. All class-related streams are defined per-class instead of within
           Metafile.streams().
            + this is looking like the most general and flexible solution

      The current implementation is #5.
    end field streams;

    lifecycle  params:
      var uid : str;
      var parent : metax.attr.ComplexBlock;
      var context : metax.c.Context;
      var precount : int = 0;
    super (uid, parent, context, precount)
    scope:
      /# NOTE: The first arg passed to SymbolTable should be a SymbolTable
      /# instance (for classes, for example, it is the SymbolTable associated
      /# with the parent class). At time of construct creation, we do not
      /# necessarily have such a construct, so the parent field of these symbol
      /# tables must be patched up within *Construct.importMeta() when the
      /# inheritance hierarchy is guaranteed to exist.
      self.symbolsIs(metax.c.SymbolTable(self, None))
    end;

    method registerSymbol #:
      Add a symbol to this construct's symbol table.
    params:
      var name : str #:
        The symbol name.
      var construct : *metax.oopl.Construct #:
        The construct associated with the symbol.
      var note : str = null #:
        Any human-readable notes associated with the symbol.
    scope:
      table = self.symbols()
      /# print('%s registering symbol %s = %s' %
      /#       (self.kindfqn(), name, construct.kindfqn()))
      table.register(name, construct, source=self, note=note)
    test:
      test.defineClassAndMethods('py')
      method = test.method
      test.iseq([], sorted(test.klass.symbols().allSymbols()))
      test.klass.registerSymbol(method.id(), method)
      test.iseq(['show'], sorted(test.klass.symbols().allSymbols()))
    end method registerSymbol;

    method symbolNamed : *metax.oopl.Construct #:
      Obtain a symbol within this construct by name.
    params:
      var name : &str #:
        The name of the symbol desired.
      var kind : str = null #:
        If not null, and the symbol identified by 'name' is not of kind 'kind'
        print an error to the metafile.
    scope:
      result = self.symbols().find(name)
      if kind and (not result or result.kind() != kind):
        metafile = self.metafile()
        if result:
          metafile.error(
            'Expecting %s to be of kind %s' % (result.kindfqn(), kind),
            line=result.primary().line())
        else:
          metafile.error(
            'Expecting to find %s %s within %s' %
            (kind or '', name, self.kindfqn()),
            line=self.primary().line())
        result = None
      return result
    test:
      test.defineClassAndMethods('py')
      method = test.method
      test.isnull(test.klass.symbolNamed('show'))
      test.klass.registerSymbol(method.id(), method)
      test.issame(method, test.klass.symbolNamed('show'))
    end method symbolNamed;

    method streamNamed : vec<any> #:
      Obtain a construct-specific stream of the given name. Implciitly create if
      not present.
    params:
      var name : str #:
        The stream name. Should be cls-post-[decl|defn] for now. Will be
        extended to include cls-pre-[decl|defn] (and [pre|post]-cls-[decl|defn])
        if we decide to perform all namespace-level native/field/method code
        generation (for constructs associated with a class) within expandMeta()
        instead of translateMeta()). See the streams() comment for details on
        the subtleties here.
      var clear : bool = false #:
        If true, clear the stream (returns the new empty list)
    scope:
      streams = self.streams()
      result = streams.get(name, None)
      if result is None or clear:
        result = []
        streams[name] = result
      return result
    test:
      test.tpy()
      segments = test.klass.streamNamed('cls-post-defn')
      test.iseqvec([], segments)
      segments2 = test.klass.streamNamed('cls-post-defn')
      test.issame(segments, segments2)
    end method streamNamed;

    method establishType : *metax.oopl.Type #:
      Given the name of a variable within a particular scope that has a
      symbol table, establish the type of that variable.

      Returns:
        null if the variable does not exist in the symboltable.
    params:
      var varname : str #:
        Name of variable.
    scope:
      result = None
      table = self.symbols()
      construct = table.find(varname)
      if construct:
        try:
          result = construct.effectiveType()
        except AttributeError as e:
          print(
            'WARNING: Failed to find effective type for %s (%s): %s' %
            (construct.kindfqn(), construct.__class__.__name__, str(e)))
          result = None
      return result
    test:
      test.tpy(expand=True, imports=True)
      method = test.method2
      test.issame(metax.c.Type.Instance('str'), method.establishType('indent'))
      test.isnull(method.establishType('not_a_var'))
    end method establishType;

  end class SymbolConstruct;

  class NamespaceConstruct < SymbolConstruct #:
    @namespace: Represents a 'namespace' construct.
  ##:
    Implementation issues:
     - Each user class has additional implicit classes associatied with it:
        - a meta class
        - a test class
        - a meta class for the test class
        - a test class for the meta class
     - Notes
        - meta classes do not have meta classes
        - test classes do not have test classes
        - If a user class is in nm.sp.Class
           - the associated test class is in nm.sp_test.ClassTest
           - the associated meta class is currently placed in nm.sp.Class__Meta
             (i.e. metaclasses share the same namespace as the user class,
              but test classes do not).

    Streams:
      IMPORTANT: ALL of the following are currently speculative and NOT
      IMPLEMENTED. They represent an experiment in formalizing
      namespace-level code not tied to specific classes. ALSO, THEY SHOULD
      BE MOVED into NamespaceConstruct.streams() similar to how most
      class streams have been moved into SymbolConstruct.streams().

      pre-nmsp-decl:
        This represents code to be inserted BEFORE a namespace declaration
        (i.e. before the syntax to start the namespace itself). For
        languages without a distinction between decl/defn, or for which it
        does not make sense to insert before a namespace, this is unused.
      nmsp-pre-decl
        This represents code to be inserted at the beginning of a namespace
        declaration (but within it), before any class code is inserted. For
        languages without a distinction between decl/defn, or for which it
        does not make sense to insert within the namespace directly, this
        is unused. See also 'decl' and 'pre-decl' define in ClassConstruct.
      pre-nmsp-defn:
        This represents code to be inserted BEFORE a namespace definition
        (i.e. before the syntax to start the namespace itself). For
        languages without a distinction between decl/defn, this is where
        all such code is written.
      nmsp-pre-defn:
        This represents code to be inserted at the beginning of a namespace
        definition (but within it), before any class code is inserted. For
        languages without a distinction between decl/defn, this is where
        all such code is written. See also 'defn' and 'pre-defn' define in
        ClassConstruct.
      post-nmsp-decl:
        This represents code to be inserted AFTER a namespace declaration
        (i.e. after the syntax to end the namespace itself). For
        languages without a distinction between decl/defn, or for which it
        does not make sense to insert after a namespace, this is unused.
      nmsp-post-decl:
        This represents code to be inserted at the end of a namespace
        declaration (but within it), after any class code is inserted. For
        languages without a distinction between decl/defn, or for which it
        does not make sense to insert within the namespace directly, this
        is unused. See also 'decl' and 'cls-post-decl' define in
        ClassConstruct.
      post-nmsp-defn:
        This represents code to be inserted AFTER a namespace definition
        (i.e. after the syntax to end the namespace itself). For
        languages without a distinction between decl/defn, this is where
        all such code is written.
      nmsp-post-defn:
        This represents code to be inserted at the end of a namespace
        definition (but within it), after any class code is inserted. For
        languages without a distinction between decl/defn, this is where
        all such code is written. See also 'defn' and 'cls-post-defn'
        define in ClassConstruct.
  assocs:
    std assoc re;
    cls assoc metax.fs.BaseFile;
  scope:

    meta
    method TestifyName : str #:
      Convert a namespace name to a testspace name.
    params:
      var name : str #:
        relative or fully qualified name of namespace to make a test version of.
    scope:
      return name + '_test'
    end method TestifyName;

    meta
    method UntestifyName : str #:
      Convert a testspace name to a namespace name.
    params:
      var name : str #:
        Relative or fully qualified name of testspace name.
    scope:
      assert name.endswith('_test')
      return name[:-5]
    end method UntestifyName;

    field namespace : metax.oopl.NamespaceConstruct #:
      The parent namespace of this namespace. It is not called parentspace
      or something similar because we need it to match the naming expectations
      of Class.namespace, etc. ... all constructs that can appear within
      a namespace are expected to have a 'namespace' field that represents
      their parent.

    field testspace : metax.oopl.NamespaceConstruct #:
      The NamespaceConstruct instance representing the test namespace associated
      with this namespace.
       - if self is a user namespace, testspace is initialized in expandMeta
         to a new namespace
       - if self is a test namespace, testspace is self
       - note that metaclasses and userclasses share the same namespace.

    field userspace : metax.oopl.NamespaceConstruct #:
      The NamespaceConstruct instance representing the user namespace associated
      with a test namespace.
       - if self is a user namespace, userspace is self
       - if self is a test namespace, userspace is the namespace from which
         it was generated.

    field types : @map<str,metax.c.TypeWrapper> #:
      Maps a type string whose base is a relative class to TypeWrapper
      instance.

    lifecycle  params:
      var id : str;
      var parent : metax.attr.ComplexBlock;
      var context : *metax.oopl.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      /# This was an experiment performed on 2017/12/30 to see if we could
      /# get namespaces expanded out so that nm.sp is two namespaces instead
      /# of one. Ran into a few issues:
      /#  - when we do this work in the constructor, code in parseComplexBlock
      /#    after our rejiggering attempts to invoke registerConstruct()
      /#    with the FileConstruct parent (the one we were trying to remap).
      /#  - constructor terminator code starts failing with
      /#       E43: Parsing namespace cards1 but found terminator for\
      /#       namespace demo.cards1
      /#
      /# I'm going to experiment with an alternative solution in which we do
      /# the expansion in NamespaceConstruct.expandMeta() instead.
      if False:
        self.createImplicitParents(id, parent, context)
    end;

    method isNamespace : bool scope:
      return True
    test:
      test.tpy()
      test.istrue(test.namespace.isNamespace())
    end;

    method createImplicitParents : any #:
      An experiment in creating namespace parents. As of 2017/12/30 it is NOT
      being used.  Left in place in case the explorations about implementing
      in expandMeta() don't work out.
    params:
      var id : str;
      var parent : metax.attr.ComplexBlock;
      var context : *metax.oopl.Context;
    scope:
      if '.' in id:
        /# We perform some implicit work here to create a hierarchy of
        /# NamespaceConstruct instances.
        parts = id.split('.')
        final_nmsp = parts.pop()

        /# The only time we should find a '.' in a namespace id is when
        /# the normal parsing flow of MetaFile.parseConstruct finds
        /# a namespace in a meta source file with nested id.
        /# In such a situation, its parent should be a FileConstruct.
        filecons = parent.parent()
        assert filecons.kind() == 'File'

        /# We need to verify the existence of N-1 ancestor namespaces if there
        /# are N parts in the 'id'. If any ancestor namespace does not already
        /# exist, it is created, inheriting from an appropriate scope: block.
        /#
        /# As an example, suppose id is nm.sp2.sub, and that nm.sp1 is already
        /# registered (so 'nm' already exists), but neither 'sp2' nor 'sub'
        /# are registered.
        /#  - we first find the pre-existing 'nm' within the passed in parent
        /#    block
        /#  - we obtain the 'scope:' block of 'nm'
        /#  - we look for 'sp2', and since it is not present, we create it,
        /#    specifying the block we just looked in as its parent. A scope:
        /#    block is created as part of the creation of 'sp2'.
        /#  - we obtain the 'scope:' block of 'sp2'
        /#  - we are now at the final namespace 'sub', which was what this
        /#    method was invoked to create.  The super call has currently
        /#    set its id to 'nm.sp2.sub', and its parent to the FileConstruct
        /#    scope:.  We update the id to be 'sub', and the parent to be the
        /#    scope: block on 'sp2'
        parent_construct = filecons
        parent_scope = parent
        print('scope of filecons path: %s' % parent_scope.path())
        for pid in parts:
          child = parent_scope.cons(pid, default=None)
          if child:
            /# Found a pre-existing ancestor namespace
            assert child.kind() == 'namespace'
            parent_construct = child
          else:
            /# There is no ancestor namespace with given name in its parent,
            /# so we create it.
            parent_construct = metax.oopl.NamespaceConstruct.NewFromData(
              pid, context, parent=parent_scope,
              secondaries=[('scope:', [])])
          print('cons path %s' % parent_construct.path())
          parent_scope = parent_construct.attr('scope:', default=REQUIRED)
          print('scope path %s' % parent_scope.path())

        /# Now we process the final_nmsp by updating self's id and parent.
        self.idIs(final_nmsp)
        self.parentIs(parent_scope)
        print('final nmsp path is %s' % self.path())
        print('HERE with %s vs %s' % (id, self.fqn()))
    test:
      /# This method is not being used.
      pass
    end method createImplicitParents;

    method variant : str #:
      One of 'user' or 'test', indicating which namespace this is.
    scope:
      result = 'user' if self.userspace() is self else 'test'
      return result
    test:
      test.tpy(expand=True)  # needed to set userspace()
      test.iseq('user', test.namespace.variant())
      test.iseq('test', test.namespace.testspace().variant())
    end method variant;

    method isUser : bool #:
      True if this namespace is a user-defined namespace.
    scope:
      return self.variant() == 'user'
    test:
      test.tpy(expand=True)  # expand needed to properly initialize namespace.
      test.istrue(test.namespace.isUser())
      test.isfalse(test.namespace.testspace().isUser())
    end method isUser;

    method isTest : bool #:
      True if this namespace is a testspace.
    scope:
      return self.variant() == 'test'
    test:
      test.tpy(expand=True)  # expand needed to properly initialize namespace.
      test.isfalse(test.namespace.isTest())
      test.istrue(test.namespace.testspace().isTest())
    end method isTest;

    method registerType #:
      Register a type with this namespace for use in making relative
      types absolute.
    params:
      var wtype : metax.c.TypeWrapper;
    scope:
      key = wtype.wrappedRaw()
      if key in self._types:
        raise metax.c.InternalError(
          'Reregistering wrapped type %s in %s' % (key, self.id()))
      self._types[key] = wtype
    test:
      test.tpy()
      test.iseq({}, test.namespace._types)
      tw = metax.c.TypeWrapper(
        metax.c.Type.Instance('demo.tmp.Student'), 'Student')
      test.namespace.registerType(tw)
      test.iseq({'Student': tw}, test.namespace._types)
    end method registerType;

    method getType : metax.c.TypeWrapper #:
      Obtain a previously cached typed
    params:
      var reltypestr : str;
    scope:
      return self._types.get(reltypestr, None)
    test:
      test.tpy()
      test.iseq({}, test.namespace._types)
      tw = metax.c.TypeWrapper(
        metax.c.Type.Instance('demo.tmp.Student'), 'Student')
      test.namespace.registerType(tw)
      tw2 = test.namespace.getType('Student')
      test.issame(tw, tw2)
    end method getType;

    method compilePython : vec<BaseFile> #:
      Compile this namespace into python. Creates __init__.py

      Returns:
       0) basefile : BaseFile
         The __init__.py file
       1) bldfile : BaseFile
         The .__init__.bld file
    params:
      var kind : str = 'merge' #:
        Legal values are:
          merge: merge all class files into __init__.py
          import: import all class files into __init__.py
      var triples : vec<tuple<metax.oopl.ClassConstruct,BaseFile,BaseFile>> = null #:
        Each element is a triple containing a class construct, the
        BaseFile containing the class code, and a BaseFile containing
        the .bld fragment.
    scope:
      fqn = self.id()
      metac = self.compiler()
      baselang = self.baselang()
      metafile = self.metafile()
      variant = self.variant()
      scope_sep = metax.c.Context.Tokens()['scope_sep']
      nameparts = fqn.split(scope_sep)
      nmspbase = nameparts[-1]
      fs = metac.fs()
      /# TODO(wmh): How to establish the actual width?
      width = 80 - 0
      basesuffix = baselang.suffix()
      fqn += scope_sep + '__init__'

      /# comments : vec<str>
      /#   Documentation for the namespace.
      comment_attr, comment = self.attrpair('comment:', default=None)
      comment = baselang.formatComment(comment, width=width)

      /# preports : vec<str>
      /#   This is arbitrary baselang code that should appear before anything
      /#   else in the namespace.  Used to modify path, perform special actions
      /#   like modifying encoding type, etc.
      preports_attr = self.attr('preports:', default=None)
      preports = baselang.simpleToBase(preports_attr)

      /# prelines: vec<str>
      /#   The total set of lines added before classes in the merged
      /#   namespace.
      prelines = ['# -*- coding: utf-8 -*-'] + comment + preports

      /# classes : vec<str>
      /#   The baselang code for importing the classes.
      scope = self.attr('scope:')
      if kind == 'merge':

        mapfile = metax.c.MapFile(
          metac.basePath(fqn, prefix='.', suffix=basesuffix + '.map'),
          fs.realpath(fs.abspath(metafile.path())),
          [])
        all_lines, targets = self._mergeClassesPython(
          triples, mapfile, prelines)

      elif kind == 'import':
        all_lines, targets = self._importClassesPython(triples)
      else:
        raise metax.c.Error(
          'NamespaceConstruct.compilePython: Invalid kind "%s"' % kind)

      /# IMPORTANT: We are currently NOT using the Template constructs
      /# in the namespace construct for python.  They should either
      /# be removed, or we should move to a mechanism whereby we do use
      /# them.  The difficulty is in getting the line numbers from the
      /# mapfile initialized by _mergeClassesPython() to reflect reality,
      /# but it would certainly be possible with a bit of effort.
      if self.isTest():
        all_lines.extend([
          '',
          '',
          "if __name__ == '__main__':",
        ])
        testsuite = self.attr('testsuite:', default=None)
        if testsuite:
          tmp = []
          baselang.simpleToBase(testsuite, output=tmp, strip_empty=True)
          for line in tmp:
            all_lines.append('  ' + line)
        else:
          all_lines.append('  metax.test.main()')

      else:
        /# Experimenting with the introduction of a 'Meta()' method in each
        /# user namespace. TODO(wmh): Why did I introduce this???

        /# CODETANGLE(implicit_objectmeta)
        if False:
          all_lines.append('')
          all_lines.append('')
          all_lines.append('def Meta():')
          all_lines.append('  return metax.root.MetaObject')

      basefile = metax.fs.BaseFile(
        metac.basePath(fqn, suffix=basesuffix),
        '\n'.join(all_lines) + '\n', metafile=metafile, mapfile=mapfile)
      metafile.registerFile(basefile)

      /# Create the .__init__.bld file:
      bldpath = metac.basePath(fqn, prefix='.', suffix='.bld')
      istest = self.isTest()
      if False:
        /# Useful during debugging.
        print(bldpath)
        print('  Targets:')
        for target in targets:
          print('    ' + target)

      rule, build_data = baselang.createBuildFragment(
        self, targets, test=istest,
        name=nmspbase, src='__init__.py')
      if istest:
        /# Bazel expects a py_test with name 'cards_test' to have its source
        /# in 'cards_test.py', but in our case it is in '__init__.py'. We
        /# can fix this by adding a 'main' target.
        build_data['main'] = '__init__.py'
      bldfile = None
      if rule is not None:
        fragment = baselang.formatBuildRule(rule, build_data)
        bldfile = metax.fs.BaseFile(
          bldpath, '\n' + fragment + '\n', metafile=metafile)
        metafile.registerFile(bldfile)

      /# Ensure that all package directories have a __init__.py file.
      pqn = ''
      for base in nameparts[:-1]:
        if pqn: pqn += scope_sep
        pqn += base
        subpath = fs.join(metac.basePath(pqn), '__init__.py')
        initpath, _ = fs.subfilePath(subpath)
        if not fs.exists(initpath):
          initfile = metax.fs.BaseFile(subpath, '', metafile=metafile)
          metafile.registerFile(initfile)

      return basefile, bldfile
    test:
      test.tpy(expand=True)
      end_start = '##########  End Imports  ##########\n'
      basefile, bldfild = test.namespace.compilePython(
        kind='merge',
        triples=[
          (test.nscope.cons('Person'),
           metax.fs.BaseFile(
             'base1',
             'import sys\n' + end_start + '\n# Person body\n',
             mapfile=metax.c.MapFile('/dummy/path2.map', 'dummy/path2.meta'),
           ),
           None),
          (test.nscope.cons('Student'),
           metax.fs.BaseFile(
             'base2',
             'import os\n' + end_start + '\n# Student body\n',
             mapfile=metax.c.MapFile('/dummy/path3.map', 'dummy/path3.meta'),
           ),
           None),
        ]
      )
      test.contains('import sys\nimport os\n', basefile.contents())
    end method compilePython;

    method _setClassVariant : str #:
      Set the variant field of a class construct.
    params:
      var child : *metax.oopl.Construct #:
        The child of this namespace whose variant is to be set.
    scope:
      /# We are in the user-provided namespace. The class construct
      /# is one of:
      /#   user:
      /#     a standard user-provided class
      /#   testuser:
      /#     a user-provided class to put in the autogened test namespace
      /#   metauser:
      /#     a user-provided metaclass
      location = child.attrval('location', default=metax.c.LOOKUP)
      variant = 'user'
      if location != 'user':
        variant = location + variant
      child.variantIs(variant)
      return variant
    test:
      test.tpy()
      person = test.klass
      test.isnull(person.variant())
      test.namespace._setClassVariant(person)
      test.iseq('user', person.variant())
    end method _setClassVariant;

    method _mergeClassesPython : tuple<vec<str>,vec<str>> #:
      Generate the lines in a namespace file by merging all class files.

      Returns:
        0. The list of lines in the namespace file
        1. The list of build targets needed by the namespace.
    params:
      var triples : vec<tuple<metax.oopl.ClassConstruct,BaseFile,BaseFile>> #:
        Each element is a triple containing a class construct, the
        BaseFile containing the class code, and a BaseFile containing
        the .bld fragment.
      var mapfile : *metax.oopl.MapFile #:
        The merged mapfile across all base files.
      var prelines : vec<str> #:
        The list of lines appearing before imports in the namespace
        (e.g. comment, preports, etc.)
    scope:
      debug = 0

      /# TODO(wmh): Move elsewhere
      impre = re.compile(
        r'import\s+(?P<import>\S+)'
        r'(?: as (?P<alias>\S+))?'
        r'(?:\s*#\s*target=(?P<target>\S+))?')
      optre = re.compile(r'#.* optional=(\S+)')
      optional_fqns = set()

      /# TODO(wmh): Make these less fragile. Any changes to the 'End Imports'
      /# or 'Start Harness' lines in templates will raise an Error.
      end_start = '##########  End Imports  ##########\n'
      start_end = '########## Start Harness ##########\n'

      fqn = self.id()

      /# chunks contains (offset, lines) pairs
      chunks = []

      /# The class iniitalization lines.
      clinit_lines = []

      def PatchImport(all_lines, fqn, special=False):
        /# This method is used for two related purposes:
        /#  - some imports are marked as optional, and the line
        /#      import nm.sp
        /#    is to be replaced with:
        /#      try:
        /#        import nm.sp
        /#      except ImportError as e:
        /#        pass
        /#  - Within module nm.sp.ace, we want users to be able to make
        /#    referenceto both SomeClass and nm.sp.ace.SomeClass, but by default
        /#    only the former is legal (nm.sp is not, by default, available in
        /#    the namespace defining nm.sp). To define it, we need to perform
        /#    exactly the conditional import syntax mentioned above, plus some
        /#    additional special work.
        try:
          my_index = all_lines.index('import ' + fqn)
          /# We need to add some lines of code after myindex to ensure the
          /# module is available fully qualified. It is important that this
          /# special code occur before we import any namespaces within this
          /# namespace, so that they too have access to the fully qualified
          /# namespace (so we cannot insert the special code at the end of
          /# all_lines).
          new_lines = []
          new_lines.append('try:')
          new_lines.append('  import ' + fqn)
          new_lines.append('except ImportError:')
          new_lines.append('  pass')

          if special:
            parent_nmsp, base_nmsp = fqn.rsplit('.', 1)
            new_lines.append(
              "if not getattr(%s, '%s', None):" % (parent_nmsp, base_nmsp))
            if 'import sys' not in new_lines:
              new_lines.append('  import sys')
            new_lines.append('  %s = sys.modules[__name__]' % fqn)

            if False:
              /# TODO(wmh): This is new code based on
              /#   src/kernel/tests/py/importsex.py
              /# but it isn't working as expected for unittests.
              /# Need to add a test namespace in
              /#   src/kernel/tests/py/nm/sp/ace_test/__init__.py
              /# and establish how to get it working there.
              nmparts = fqn.split('.')
              new_lines.append('import sys')
              new_lines.append(
                "%s = sys.modules['%s']" % (nmparts[0], nmparts[0]))
              for i in range(1, len(nmparts)):
                pmod = '.'.join(nmparts[:i])
                mod = nmparts[i]
                new_lines.append(
                  "setattr(%s, '%s', sys.modules['%s.%s'])" %
                  (pmod, mod, pmod, mod))

            /# Now some future-proofing imports to allow code to work in both
            /# python2 and python3. See
            /#   http://python-future.org/compatible_idioms.html
            /# for useful discussion.
            /# CODETANGLE(metaclass_support)
            new_lines.append('from future.utils import with_metaclass')

          n = len(all_lines)
          my_index += 1
          all_lines = all_lines[:my_index-1] + new_lines + all_lines[my_index:]
          assert len(all_lines) == n + len(new_lines) - 1
        except ValueError:
          pass
        return all_lines

      /# imports : vec<str>
      /#  - Accumulates all the import lines from individual classes, to be
      /#    inserted at the top of the namespace file. Preserves order of
      /#    imports (based on first time seen), hence the vec instead of set.
      imports = []
      /#  - Individual import statements may have ' # target=' comments
      /#    specifying associated targets. These are extracted.
      targets = set()
      for klass, basefile, bldfild in triples:
        /# We merge all of the class files into the __init__.py.
        /#  - if we are defining namespace nm.sp, we need to find all
        /#    references to nm.sp.<class> and replace them with <class>
        /#    (alternatively, we can ensure that nm.sp is available within
        /#    nm.sp).
        /#      - IMPORTANT: replacing nm.sp.<class> with <class> is
        /#        non-trivial, as we do NOT want to replace <class> within
        /#        strings, only when it is an actual class reference. Better
        /#        to get 'nm.sp.<class>' working within <class>. Disabling
        /#        replacement for now.
        /#  - the per-class file maps need to be merged and modified into
        /#    .__init__.py.map
        r = re.compile(
          r'([^a-zA-Z0-9_])%s\.([a-zA-Z0-9_]+)' % re.escape(fqn))
        /# DISABLED 2017-12-23 as flawed (replaces occurences in strings,
        /# which breaks metax.root.Object.Resource(..., fqn='...').
        /# contents = r.sub(r'\1\2', basefile.contents().rstrip())

        contents = basefile.contents().rstrip()

        /# We check if the last line is an invocation of Meta__Initialize().
        /#  - if so, we remove it from end of contents and add it to
        /#    clinit_lines
        /#  - by inserting all such calls at the bottom of the namespace file,
        /#    all classes in the namespace are defined before any class
        /#    initialization occurs, which means the class initializers can
        /#    rely on all other classes in the namespace.
        ridx = contents.rfind('\n')
        last_line = contents[ridx+1:]
        if last_line.endswith('.Meta__Initialize()'):
          contents = contents[:ridx]
          clinit_lines.append(last_line)

        istestcase = klass.isTestCase()
        submapfile = basefile.mapfile()

        /# All python class files are required to have a line containing
        /# end_start.
        start_index = contents.find(end_start)
        if start_index == -1:
          raise metax.c.Error(
            'Failed to find "%s" in\n%s' % (end_start, contents))
        start_index += len(end_start)
        assert contents[start_index-1] == '\n'
        import_lines = contents[:start_index-1].split('\n')
        start_removed = len(import_lines)
        for line in import_lines:
          /# Parse the import line (into import, target, optional, etc.).
          /#  - May need to generalize to support
          /#      'from nm.sp import X as Y'
          /#  - The order in which imports appear is sometimes critically
          /#    important, so we maintain the order (based on when first seen).
          /#  - If optional=<fqn> exists in the comment, it means the import
          /#    is optional and should be guarded with a
          /#       try ... except ImportError
          /#    block.
          if line and line[0] == '#': continue
          m = impre.match(line)
          if m:
            impline = 'import %s' % m.group('import')
            alias = m.group('alias')
            if alias:
              impline += ' as ' + alias
            if impline not in imports:
              imports.append(impline)
            target = m.group('target')
            if target and target != 'None':
              targets.add(target)
            om = optre.search(line)
            if om:
              optional_fqns.add(om.group(1))
          else:
            raise metax.c.Error(
              'Not currently supporting imports of form "%s"' % line)

        if debug > 3:
          print('#' * 80)
          print('Removed from start')
          sys.stdout.write(contents[:start_index])
          print('-' * 80)

        /# All python test class files are required to have a line containing
        /# start_end.
        if istestcase:
          /# The class in question is a test class, so we require it to have
          /# the end_start and start_end lines.
          end_index = contents.rfind(start_end)
          if end_index == -1:
            raise metax.c.Error(
              'Failed to find "%s" in\n%s' % (start_end, contents))
          assert contents[end_index] == '#', (
            'Expecting index %d of contents to be "#" not "%s"' %
            (end_index, contents[end_index-5:end_index+5]))
          end_removed = contents[end_index:].count('\n')
          if debug > 3:
            print('#' * 80)
            print('Removed from end')
            print(contents[end_index:])
            print('=' * 80)
          /# By decrementing end_index to position ourselves on the newline,
          /# we ensure that when we split the resulting content into lines,
          /# we do not introduce a spurious newline at the end.
          end_index -= 1
          assert contents[end_index] == '\n'
        else:
          end_index = len(contents)
          end_removed = 0

        lines = contents[start_index:end_index].split('\n')
        chunks.append((start_removed, lines, submapfile))

        if debug > 2:
          print('#' * 80)
          print(contents)
        if debug > 1:
          print('-' * 80)
        if debug:
          fs = self.compiler().fs()
          print(
            '%-25s: removed %d start lines and %d end lines leaving %d lines' %
            (fs.basename(basefile.subpath()), start_removed, end_removed,
             len(lines)))
        if debug > 1:
          submapfile.serialize()

      /# We add some special importation code to ensure that one can access all
      /# classes within the namespace fully-qualified (by default, python does
      /# not add 'sp' to 'nm' until after 'nm.sp' has been parsed).
      all_lines = prelines + imports
      all_lines = PatchImport(all_lines, fqn, special=True)

      for optfqn in optional_fqns:
        all_lines = PatchImport(all_lines, optfqn, special=False)

      /# Now obtain the merged collection of lines, and associated mapfile.
      /#  - starts with the sorted list of imports
      /#  - we add the (stripped) lines for each class in sequence. The
      /#    final mapfile adds the contents of the associated submapfile with
      /#    the following adjustments to baseline nums in the submapfile
      /#     - subtract 'removed' lines
      /#     - add current length of 'all_lines'
      for removed, lines, submapfile in chunks:
        mapfile.addSubFile(submapfile, len(all_lines) - removed)
        all_lines.extend(lines)

      /# We add the class initialization calls here.
      all_lines.append('')
      all_lines.append('# Class initialization methods')
      all_lines.extend(clinit_lines)

      parts = fqn.split('.')
      mytarget = '//%s:%s' % (fqn.replace('.', '/'), parts[-1])
      targets.discard(mytarget)

      return (all_lines, sorted(targets))
    test:
      test.tpy(expand=True)  # needed to merge Student into namespace
      mapfile = metax.c.MapFile(
        '/dummy/path.map', '/dummy/path.meta')
      prelines = []
      end_start = '##########  End Imports  ##########\n'
      test.iseq(
        (
          ['import sys', 'import os',
           '', '# Person body',
           '', '# Student body',
           '', '# Class initialization methods',
          ],
          [],
        ),
        test.namespace._mergeClassesPython(
          [
            (test.nscope.cons('Person'),
             metax.fs.BaseFile(
               'base1',
               'import sys\n' + end_start + '\n# Person body\n',
               mapfile=metax.c.MapFile('/dummy/path2.map', 'dummy/path2.meta'),
             ),
             None),
            (test.nscope.cons('Student'),
             metax.fs.BaseFile(
               'base2',
               'import os\n' + end_start + '\n# Student body\n',
               mapfile=metax.c.MapFile('/dummy/path3.map', 'dummy/path3.meta'),
             ),
             None),
          ],
          mapfile, prelines))
    end method _mergeClassesPython;

    method _importClassesPython : tuple<vec<str>,vec<str>> #:
      Generate the lines in a namespace file by importing class files.

      Returns:
        0. The list of lines in the namespace file
        1. The list of build targets needed by the namespace.
    params:
      var triples
      type vec<tuple<metax.oopl.ClassConstruct,BaseFile,BaseFile>> = null #:
        Each element is a triple containing a class construct, the
        BaseFile containing the class code, and a BaseFile containing
        the .bld fragment.
    scope:
      classes = []
      targets = []
      for klass, _, _ in triples:
        /# We are to import each class file into __init__.py
        /#  - this is currently problematic. Suppose we have classes A and B
        /#    and nm/sp/__init__.py contains
        /#      from .A import *
        /#      from .B import *
        /#    then the following:
        /#      import nm.sp.A
        /#    will yield the *module* nm.sp.A (the class is at nm.sp.A.A).
        /#    Need to learn more about how to import symbols, the use
        /#    of __all_, relative vs absolute imports, etc.
        classes.append('from .%s import *' % klass.id())
        targets.append(':' + klass.id())
      return (classes, targets)
    test:
      test.tpy(expand=True)  # needed to merge Student into namespace
      test.iseq(
        (['from .Person import *', 'from .Student import *'],
         [':Person', ':Student']),
        test.namespace._importClassesPython(
          [(test.nscope.cons('Person'), None, None),
           (test.nscope.cons('Student'), None, None)]))
    end method _importClassesPython;

  end class NamespaceConstruct;

  abstract
  class ClassicConstruct < SymbolConstruct #:
    @_classic_: Abstract parent of all constructs that appear within a class.

    Includes field, method, lifecycle, behavior, entry and class.

    Note that there are various constructs that can appear within the 'scope:'
    of a class that are NOT subclasses of ClassicConstruct, including remark,
    category and native (they are more general, and do not need a 'myclass'
    field).
  scope:

    field myclass : metax.oopl.ClassConstruct #:
      The class this construct belongs to.

    postx
    method changeParent #:
      Move myself out of my current parent into the new parent.
    params:
      var new_parent : metax.attr.ComplexBlock #:
        The parent to move this construct into.
      var position : str = null #:
        The name of some construct in the new parent preceeded by '+'
        (insert after) or '-' (insert before).  If the position is '+' or
        null, insert at end.  If the position is '-', insert at beginning.
    super (new_parent, position=position)
    scope:
      oldklass = self.myclass()
      klass = new_parent.parent().ancestor('class', proper=False)
      self.myclassIs(klass)
      /# print(
      /#   '**** NOTE: Changed parent of %s which changes class from %s to %s'
      /#  % (self.fqn(), oldklass.fqn() if oldklass else None, klass.fqn()))
    test:
      /# TODO(wmh): Test this!
      pass
    end method changeParent;

    method updateClass : tuple<metax.oopl.ClassConstruct,bool> #:
      Decide if this construct needs to be moved to an auto-generated class,
      and if so, move it.

      SideEffects:
        The myclass. field is updated.

      Returns:
        0. The class of the construct after the move (may or may not change).
        1. True if the construct was moved to a different class, false if not.
    scope:
      myclass = self.ancestor('class')
      if myclass is None:
        /# This particular instance of the classic construct is NOT within a
        /# class (e.g. directly within a namespace).
        return (None, False)

      metafile = myclass.metafile()
      assert myclass is not None
      variant = myclass.variant()
      moved = False
      autogen = myclass.autogenInfo()

      if variant in ('user', 'testuser'):
        /# This is the only variant within which we pay attention to the
        /# 'location' feature attribute:
        /#   - fields with location 'test' are moved to the test class
        /#   - fields with location 'meta' are moved to the meta class.
        /# TODO(wmh): For other variants, if the location is explicitly
        /# provided and different from the default, report a warning/error?
        location = self.attrval('location')

        if location == 'user':
          /# Everything is where it should be
          pass

        elif location == 'test':
          if variant == 'testuser':
            /# The construct has been marked as location 'test' when it resides
            /# within a test class. For now, we treat this as an error, although
            /# we may reduce it to a warning in the future.
            metafile.error(
              'Test classes cannot have test %ss' % self.kind(),
              attr=self.primary())
            /# print('**** HERE with %s %s in %s' % (location, self.kindfqn(), myclass.kindfqn()))
          else:
            /# Move this construct to the test class
            testclass = myclass.testclass()
            moved = True
            if autogen['test']:
              assert testclass is not None
              testscope = testclass.attr('scope:')
              self.changeParent(testscope)
              myclass = self.myclass()
              assert myclass is testclass
            else:
              assert testclass is None
              metafile.error(
                'Cannot specify test %s when test class is disabled' %
                self.kindfqn(),
                line=self.primary().line())

        elif location == 'meta':
          /# Move this field to the meta class
          metaclass = myclass.metaclass()
          moved = True
          if autogen['meta']:
            assert metaclass is not None
            metascope = metaclass.attr('scope:')
            self.changeParent(metascope)
            myclass = self.myclass()
            assert myclass is metaclass
          else:
            assert metaclass is None
            metafile.error(
              'Cannot specify meta %s when meta class is disabled' %
              self.kindfqn(),
              line=self.primary().line())

        self.myclassIs(myclass)

      else:
        /# If this construct is already in a non-user class, the myclass
        /# field should already be initialized.
        /#  - TODO(wmh): Verify this is always true (and if not, fix it,
        /#    either here or upstream).
        /#  - NOTE(wmh): As of 2017/12/04 the above hypothesis is proved
        /#    incorrect ... classes with location 'test' have variant 'testuser'
        /#    and myclass is not initialized.
        /# print(
        /#   'HERE with %s and %s and %s' %
        /#   (self.fqn(), self.myclass(), myclass.fqn()))
        assert self.myclass() is myclass

      return myclass, moved
    test:
      /# TODO(wmh): some subtle logic in here ... how to test this?
      pass
    end method updateClass;

  end class ClassicConstruct;

  class ClassConstruct < ClassicConstruct #:
    @class: Represents a 'class' construct.

    The userclass, testclass and metaclass fields are set in expandMeta:

                                            class
                   -----------------------------------------------------------
       variant     user  under       test            meta
       -------     ----  -----       ----            ----
       user        Name  null        NameTest        Name__Meta
       test        Name  Name        null            NameTest__Meta
       testmeta    Name  Name__Meta  null            null
       testuser    null  null        null            null
       meta        Name  Name        Name__MetaTest  null
       metatest    Name  NameTest    null            null
       metauser    null  null        null            null

     TODO(wmh): We should probably support test classes on metauser classes
     (e.g. create a testclass for metauser classes).
  ##:
    Streams used within classes:
      cls-decl:
        For classes that have a distinction between declaration and
        definition, this represents the declaration (public interface).
        For classes without a distinction between declaration and
        definition, this is unused (all code is written to 'defn' below).
      cls-defn:
        For classes that have a distinction between declaration and
        definition, this represents the definition of the class (actual
        implementation). For classes without a distinction, this is where
        all code is written.
      cls-pre-decl:
        This represents namespace-level code affiliated with a class, to
        be inserted before the class declaration but within the namespace.
        For baselangs without decl/defn distinction, this is added to the
        same location as cls-pre-defn.
      cls-pre-defn:
        This represents namespace-level code affiliated with a class, to
        be inserted before the class definition but within the namespace.
      cls-post-decl:
        This represents namespace-level code affiliated with a class, to
        be inserted after the class declaration but within the namespace.
        For baselangs without decl/defn distinction, this is added to the
        same location as cls-post-defn.
      cls-post-defn:
        This represents namespace-level code affiliated with a class, to
        be inserted after the class definition but within the namespace.

      pre-cls-decl:
        This is only relevant in baselangs whose per-class syntax has a
        distinction between 'outside of namespace' and 'inside of
        namespace'.  It represents namespace-generic code affiliated with
        a class to appear in the declaration of the class before the
        namespace. This can be useful to insert code in a .h file in C++
        (before the namespace is defined, eg add include), but makes no
        sense in Python. The 'decl:' block of a 'native' construct with
        position 'pre' is written into this stream.
      pre-cls-defn:
        Like pre-cls-defn but for declaration. Useful for inserting code
        into a .cc file in C++ before the namespace is entered but makes
        no sense in Python. The 'scope:' (aka 'defn:') block of a 'native'
        construct with position 'pre' is written into this stream.
      post-cls-decl:
        Like pre-cls-decl but after the namespace instead of before it.
        This can be useful to insert code in a .h file in C++ (after the
        namespace is closed), but makes no sense in Python.
        The 'decl:' block of a 'native' construct with position 'post' is
        written into this stream.
      post-cls-defn:
        Like post-cls-decl but for definition not declaration.
        The 'scope:' (aka 'defn:') block of a 'native' construct with
        position 'post' is written into this stream.

    The above streams are sufficiently general to handle almost all
    use-cases, including being able to insert native code in various
    locations of declarations and definitions. However, when it comes to
    namespace-level code, the above streams require that the
    namespace-level code be affiliated with some class (for example the
    'position' feature attribute of the 'native' construct affiliates
    namespace-level raw code with a class before it (position post) or
    after it (position pre).
  scope:
    meta
    method TestifyName : str #:
      Convert a class name to a testclass name.
    params:
      var name : str #:
        relative or fully qualified name of class to make a Test version of.
    scope:
      return name + 'Test'
    end method TestifyName;

    meta
    method UntestifyName : str #:
      Convert a testclass name to a userlass name.
    params:
      var name : str #:
        relative or fully qualified name of testclass name.
    scope:
      assert name.endswith('Test')
      return name[:-4]
    end method UntestifyName;

    meta
    method IsTestName : bool #:
      Check if a name is a testclass name
    params:
      var name : str;
    scope:
      return name.endswith('Test')
    end method;

    meta
    method MetaifyName : str #:
      Convert a class name to a metaclass name.
    params:
      var name : str #:
        relative or fully qualified name of class to make a Meta version of.
    scope:
      return name + 'Meta'
    end method MetaifyName;

    meta
    method MetaInstifyName : str #:
      Convert a class name to a metaclass instance name.
      TODO(wmh): Can we make this an instance method, or is it used in
      situations where an instance isn't avialable?
    params:
      var name : str #:
        relative or fully qualified name of class to make a Meta version of.
    scope:
      parts = name.split('.')
      parts[-1] = 'Meta' + parts[-1]
      return '.'.join(parts)
    end method MetaInstifyName;

    meta
    method UnmetaifyName : str #:
      Convert a metaclass name to a userclass name.
    params:
      var name : str #:
        relative or fully qualified name of metaclass to obtain userclass for
    scope:
      assert name.endswith('Meta')
      return name[:-4]
    end method UnmetaifyName;

    meta
    method UnmetainstifyName : str #:
      Convert a metaclass instance name to a userclass name.
    params:
      var name : str #:
        relative or fully qualified name of metaclass to obtain userclass for
    scope:
      parts = name.split('.')
      assert parts[-1].startswith('Meta')
      parts[-1] = parts[-1][4:]
      return '.'.join(parts)
    end method UnmetainstifyName;

    meta
    method IsMetaName : bool #:
      Check if a name is a metaclass name
    params:
      var name : str;
    scope:
      return name.endswith('Meta')
    end method;

    meta
    method IsMetaInstName : bool #:
      Check if a name is a metaclass name
    params:
      var name : str;
    scope:
      parts = name.split('.')
      return parts[-1].startswith('Meta')
    end method;

    meta
    method CanonicalizeClassName : str #:
      Canonicalize a class name, handling various special syntaxes.
       - Return null if name is 'void'
       - Fully qualified relative names unless prefixed with '^'

      Returns:
        Fully qualified class name (in meta syntax, not baselang syntax).
    params:
      var name : str #:
        The meta-level class name.
      var namespace : metax.oopl.NamespaceConstruct = null #:
        The namespace within which the class type resides.
    scope:
      if name[0] == metax.c.Context.Tokens()['explicit_class_indicator']:
        /# A class that starts with '^' is a verbatim request from user.
        fqn = name[1:]
      elif name == 'void':
        fqn = None
      else:
        if '.' not in name:
          /# We have a relative class name ... prepend the namespace.
          if namespace is None:
            raise metax.c.Error(
              'No namespace provided: cannot qualify "%s"' % name)
          fqn = namespace.id() + metax.c.Context.Tokens()['scope_sep'] + name
        else:
          fqn = name
      return fqn
    test:
      _, _, context, _ = self.cachedInfo()
      CanonicalizeClassName = metax.oopl.ClassConstruct.CanonicalizeClassName
      test.iseq('object', CanonicalizeClassName('^object'))
      test.iseq(
        'demo.cards1.Card', CanonicalizeClassName('demo.cards1.Card'))
      namespace = metax.oopl.NamespaceConstruct.NewFromData(
        'demo.cards1', context)
      test.iseq(
        'demo.cards1.Card',
        CanonicalizeClassName('Card', namespace=namespace))
      test.raises(metax.c.Error, CanonicalizeClassName, 'Card')
    end method CanonicalizeClassName;

    field fields : @vec<metax.oopl.FieldConstruct> #:
      The list of field constructs in this class. Maintains order in which
      fields are defined. Use self.symbols() to obtain fields by name.

    field packed : map<str,map<str,tuple<int,int>>> #:
      Maps names of special 'packed' fields to field name to tuple
      (starting bit position, num bits).

    field namespace : metax.oopl.NamespaceConstruct #:
      The namespace this class belongs to.

    field parentclasses : vec<map> #:
      A parsed version of the 'parent' (or 'parents:') attribute.
      Each element is for a different parent (currently focusing on single
      parents, but will want to extend in the future).  The element contains:
        raw: str
          The raw parent string as found in the meta source code.
        fqn: str
          The fully qualified name of the parent class in baselang syntax
        metafqn: str
          The fully qualified name of the parent class in meta syntax
        external: bool
          True if the parent class is NOT defined within Meta. Somewhat
          redundant relative to 'class' except that this can be determined
          earlier in parsing than the class can be.
        class: ClassConstruct
          The ClassConstruct instance representing the parent. Is null for
          all classes until ClassConstruct.importMeta() is invoked, and is
          always null for a parent not defined in Meta.

    field childclasses : @map<str,metax.oopl.ClassConstruct> #:
      Maps class ids to ClassConstruct, for those classes that inherit
      directly from this class.

    field underclass : metax.oopl.ClassConstruct #:
      The ClassConstruct that this class is based upon.

    field testclass : metax.oopl.ClassConstruct #:
      The auto-generated test class associated with this class. This is set
      for user classes and for auto-generated metaclasses of userclasses,
      and is null for all other variants.

    field metaclass : metax.oopl.ClassConstruct #:
      The auto-generated meta class associated with this class. This is set
      for user classes and auto-generated test classes of userclasses, and is
      null for all other variants.

    field userclass : metax.oopl.ClassConstruct #:
      The user class.
      See class comment for details on what value this takes on.

    field variant : str #:
      Indicates the class variant.  Legal values are:
        user: the user defined class
        test: the implicitly generated test class associated with a user class
        meta: the implicitly generated meta class associated with a user class
        metatest: the implicit metaclass of an implicit test class for a user
                  class
        testmeta: the implicit testclass of an implicit meta class for a user
                  class
        testuser: a user-provided test class
        metauser: a user-provided meta class
        testmetauser: an implicit metaclass for a user-provided test class
        metatestuser: an implicit testclass for a user-provided meta class
        null: not yet initialized

    field resources : @map #:
      Maps resource names to absolute paths to resource, for resources
      defined in the 'associations' attribute of this class.

    field deps : @map #:
      The dependencies of this class.  Maps fully-qualified name to map
      containing:
        kind: str
          One of 'std', 'cls', 'lib', etc.
        target: str
          The bazel target to use for the dependency.
        fqn: str
          The fully qualified name of the dependency
        reason: str
          Why the dependency exists.
        abbrev: str (optional)
          The name by which the import is known locally.

    field commands : @vec<CommandConstruct> #:
      The toplevel command constructs. Used to produce executables.

    field initializer : metax.oopl.MethodConstruct #:
      The initializer associated with this ClassConstruct.

    field clinit : metax.oopl.MethodConstruct #:
      The method initializing the static fields of this class.  Often null.

    field suppress : @map #:
      Maps suppress commands to strings explaining why the error is being
      suppressed.

    field receivers : @map<str,VarConstruct> #:
      Maps certain special receiver names to VarContruct instances, to be
      used within MethodConstructs when registering receivers in symboltables.

    lifecycle  clinit:
      /# TODO(wmh): These should not be ExprAttribute, but rather WordAttribute
      /# or some such.
      cls.DummySuperAttribute = metax.attr.ExprAttribute(None, 'super', None)
      cls.DummyNonSuperAttribute = metax.attr.ExprAttribute(None, 'hack', None)

    method isClass : bool scope:
      return True
    test:
      test.tpy()
      test.istrue(test.klass.isClass())
      test.isfalse(test.method.isClass())
    end method isClass;

    method receiver : VarConstruct #:
      Obtain the receiver VarConstruct associated with a conceptual receiver.
    params:
      var name : str #:
        One of 'self', 'meta' or 'test' optionally prefixed with '#' to indicate
        a const receiver.
    scope:
      receivers = self.receivers()
      result = receivers.get(name, None)
      if result is None:
        metafile = self.metafile()
        context = metafile.context()
        /# TODO(wmh): Normally the parent of a Var is an ExecutableConstruct,
        /# but for these special receivers it makes sense to use a
        /# ClassConstruct if it isn't too hacky to support it (avoids us having
        /# to create a separate set of receiver instances for every method).
        /# For now we add the class scope: as the parent of this var.
        scope = self.attr('scope:')
        const_mark = '#' if name[0] == '#' else ''
        prefix = '&'
        if name.endswith('self'):
          varname = 'self'
          basetype = self.fqn()
        elif name.endswith('this'):
          varname = 'this'
          basetype = self.fqn()
          prefix = '#*'
        elif name.endswith('test'):
          /# Do we need to verify that self is a test class? We shouldn't need
          /# this receiver on non-test classes, right?
          varname = 'test'
          basetype = self.fqn()
        elif name.endswith('meta'):
          varname = 'meta'
          basetype = ClassConstruct.MetaifyName(self.fqn())
        else:
          raise metax.c.Error('Invalid receiver name %s' % name)

        vtype = metax.c.Type.Instance(
          '%s%s%s' % (prefix, const_mark, basetype))
        result = VarConstruct.NewFromData(
          varname, context,
          /# We do NOT pass 'scope' as parent because that would cause the new
          /# instance to be registered with that parent, and we do NOT want
          /# that for these pseudovars.
          parent=None,
          secondaries=[(':', vtype)],
          termcode=1)
        /# We link the new var to its parent block, but we do NOT register
        /# the var within that block.
        result.parentIs(scope)
        receivers[name] = result
      return result
    test:
      test.tpy()

      selfvar = test.klass.receiver('self')
      selfvar.write(fp=test.fp())
      test.iseq('var self : &demo.tmp.Person;\n', test.out())
      selfvar2 = test.klass.receiver('self')
      test.issame(selfvar, selfvar2)

      test.klass.receiver('#self').write(fp=test.fp())
      test.iseq('var self : &#demo.tmp.Person;\n', test.out())

      test.klass.receiver('this').write(fp=test.fp())
      test.iseq('var this : #*demo.tmp.Person;\n', test.out())

      test.klass.receiver('#this').write(fp=test.fp())
      test.iseq('var this : #*#demo.tmp.Person;\n', test.out())

      test.klass.receiver('meta').write(fp=test.fp())
      test.iseq('var meta : &demo.tmp.PersonMeta;\n', test.out())

      test.klass.receiver('#meta').write(fp=test.fp())
      test.iseq('var meta : &#demo.tmp.PersonMeta;\n', test.out())
    end method receiver;

    method __repr__ : str scope:
      return '<%s>' % self.kindfqn()
    test:
      test.tpy()
      test.iseq('<class demo.tmp.Person>', repr(test.klass))
    end method;

    method showDebug : any #:
      Write out some state of this class useful during debugging.
    params:
      var fp : ostream = out;
    scope:
      fp.write(u'%s: %s\n' % (self.kindfqn(), self.variant()))
      for ckind, construct in (
        ('underclass', self.underclass()),
        ('testclass', self.testclass()),
        ('metaclass', self.metaclass()),
        ('userclass', self.userclass()),
        ('initializer', self.initializer()),
      ):
        fp.write(
          '  %-12s: %s\n' %
          (ckind, construct.kindfqn() if construct else 'null'))
      fields = self.fields()
      if fields:
        fp.write(u'  fields:\n')
        for field in fields:
          fp.write(u'    %s\n' % field.kindfqn())

    test:
      test.tpy(expand=True)  # vars printed are initialized by expandMeta
      test.klass.showDebug(fp=test.fp())
      out = test.out()
      test.contains('initializer : method demo.tmp.Person.__init__', out)
    end method showDebug;

    method isUser : bool #:
      True if this class is a user class.
    params:
      var full : bool = false #:
        If true, a user-provided test class or meta class also applies.
    scope:
      variant = self.variant()
      if full:
        result = variant in ('user', 'testuser', 'metauser')
      else:
        result = variant == 'user'
      return result
    test:
      test.tpy(expand=True)  # variant initialized in expandMeta
      test.istrue(test.klass.isUser())
      test.isfalse(test.klass.testclass().isUser())
    end method isUser;

    method isTest : bool #:
      True if this class is a test class.
    scope:
      return self.variant() in ('test', 'testmeta', 'testuser')
    test:
      test.tpy(expand=True)  # variant initialized in expandMeta
      test.istrue(test.klass.testclass().isTest())
      test.isfalse(test.klass.isTest())
    end method isTest;

    method isTestCase : bool #:
      True if this class inherits from metax.test.TestCase.

      TODO(wmh): I suspect this method is being used for two mutually exclusive
      purposes and it needs to be cleaned up.
       1. Does this class inherit from metax.test.TestCase.
           - this includes autogenerated test classes and namespace specific
             testcase classes
       2. Is this class one that will be instantiated in the testsuite.
          - this includes autogenerated test classes but does NOT include
            namespace specific testcase classes.
    scope:
      /# There are two different kinds of classes in the test namespace:
      /# those that are to be instantiated as part of the test harness, and
      /# those that are service classes used indirectly (not directly) by
      /# the test harness.
      /#
      /# Note that the distinction is NOT as simple as "does the class inherit
      /# from metax.test.TestCase", because namespace-specific TestCase classes
      /# inherit from this class but are NOT classes to be tested (instead,
      /# they are superclasses of classes to be tested).
      result = False
      name = self.id()
      underclass = self.underclass()
      if underclass:
        username = underclass.id()
        if name == metax.oopl.ClassConstruct.TestifyName(username):
          result = True
      return result
    test:
      test.tpy(expand=True, imports=True)  # underclass set in expandMeta
      test.isfalse(test.klass.isTestCase())

      /# TODO(wmh): Decide whether this should be true or not.
      if False:
        testcase = test.namespace.testspace().attr('scope:').cons('TestCase')
        print(testcase.underclass())
        test.istrue(testcase.isTestCase())
    end method isTestCase;

    method isMeta : bool #:
      True if this class is a meta class.
    scope:
      return self.variant() in ('meta', 'metatest', 'metauser', 'metatestuser')
    test:
      test.tpy(expand=True)  # variant set in expandMeta
      test.isfalse(test.klass.isMeta())
      test.istrue(test.klass.metaclass().isMeta())
    end method isMeta;

    method addDependency #:
      Add a dependency on this class.
    params:
      var fqn : str #:
        The fully-qualified name of the dependency.
      var kind : str #:
        One of 'std', 'cls', 'lib', etc.
      var reason : str #:
        Why the dependency exists.
      var target : str = '<auto>' #:
        The bazel target associated with the dependency. If it is null,
        no target is generated.  If it is '<auto>', the standard target
        associated with fqn is used.
      var alias : str = null #:
        The name by which the dependency is to be referenced locally.
      var optional : bool = false #:
        If true, this dependency is optional (i.e. guard the import).
    scope:
      if kind == 'std':
        target = None
      elif target == '<auto>':
        target = self.baselang().nameToBuildTarget(fqn, lib=kind=='lib')

      deps = self.deps()
      if fqn in deps:
        info = deps[fqn]
        if info['kind'] != kind:
          print(
            '**** WARNING: for %s dep %s has kind %s vs %s' %
            (self.kindfqn(), fqn, kind, info['kind']))
        if target and info['target'] != target and kind != 'std':
          /# CODETANGLE(std_target): note that registerDependencies passes
          /# in a target for 'std' even though target isn't needed. But
          /# other calls to addDependency (like in OoplPython.autogenPrint)
          /# do not bother with a target since 'std' assocs by definition
          /# do not need one.  Can we clean this up so we don't need to
          /# make the test against 'std' above?
          print(
            '**** WARNING: for %s dep %s has target %s vs %s' %
            (self.kindfqn(), fqn, target, info['target']))
        /# TODO(wmh): Do we need to validate alias?
      else:
        dep = {
          'fqn': fqn, 'kind': kind, 'target': target, 'reason': reason,
        }
        if alias:
          dep['alias'] = alias
        if optional:
          dep['optional'] = True
        deps[fqn] = dep
        metafile = self.metafile()
        if target:
          metafile.registerDependentClass(fqn)
          /# print('Adding %s as dependency of %s' % (fqn, metafile.path()))
        else:
          /# print('NOT adding %s as dependency of %s' % (fqn, metafile.path()))
          pass
    test:
      test.tpy()
      test.iseq({}, test.klass.deps())
      test.klass.addDependency('sys', 'std', 'needed by autogened printMeta')
      test.iseq(
        {
          'sys': {
            'reason': 'needed by autogened printMeta', 'kind': 'std',
            'fqn': 'sys', 'target': None,
          },
        },
        test.klass.deps())
    end method addDependency;

    method showDependencies #:
      Print out the dependencies of this class.
    params:
      var fp : ostream = out #:
        Where to write output.
    scope:
      deps = self.deps()
      fp.write(u'%s dependencies\n' % self.kindfqn())
      for fqn in sorted(deps):
        info = deps[fqn]
        alias = info.get('alias', None)
        alias_str = '(%s) ' % alias if alias else ''
        fp.write(u'  %-40s : %-10s = %-40s %s[%s]\n' % (
          fqn, info['kind'], info['target'], alias_str, info['reason']))
    test:
      test.tpy(expand=True)
      test.klass.showDependencies(fp=test.fp())
      out = test.out()
      test.contains(
        '[implicit import in ClassConstruct.translateMeta()]', out)
    end method showDependencies;

    method validate #:
      Perform consistency checks on this construct to ensure that the
      various fields are internally consistent.

      IMPORTANT: This method is not meant to be used in production code,
      but rather is meant to be inserted during debugging. It can be
      expensive to execute.
    scope:
      meta = self.__class__

      /# The variant should be determined by the values of userclass,
      /# underclass, testclass and metaclass.
      userclass = self.userclass()
      underclass = self.underclass()
      testclass = self.testclass()
      metaclass = self.metaclass()
      variant = self.variant()
      autogen = self.autogenInfo()

      kfqn = self.kindfqn()

      if testclass is not None:
        assert meta.IsTestName(testclass.id())
      if metaclass is not None:
        assert meta.IsMetaName(metaclass.id()), (
          '%s does not have proper Meta name (%s)' % metaclass.id())

      if variant == 'user':
        assert userclass is self
        assert underclass is None
        if autogen['test']:
          if not self.isErrorClass():
            assert testclass is not None
            assert testclass.userclass() is self
        else:
          assert testclass is None

        if autogen['meta']:
          assert metaclass is not None, (
            'Expecting metaclass for %s (%s)' % (kfqn, self.isErrorClass()))
        else:
          assert metaclass is None

      elif variant == 'test':
        assert userclass is not None
        assert userclass.testclass() is self
        assert underclass is userclass
        assert testclass is None
        if metax.c.Compiler.IMPL['metatestclass']:
          assert metaclass is not None
          assert metaclass.underclass() is self
        else:
          assert metaclass is None

      elif variant == 'testmeta':
        assert userclass is not None
        assert userclass.metaclass() is underclass
        assert testclass is None
        assert metaclass is None

      elif variant == 'testuser':
        assert userclass is None
        /# TODO(wmh): These may need updating
        assert underclass is None
        assert testclass is None
        assert metaclass is not None

      elif variant == 'meta':
        assert userclass is not None
        assert userclass.metaclass() is self
        assert underclass is userclass
        assert metaclass is None
        assert testclass is not None
        if metax.c.Compiler.IMPL['testmetaclass']:
          assert testclass.underclass() is self
        else:
          assert testclass.underclass() is self.underclass()

      elif variant == 'metatest':
        assert userclass is not None
        assert userclass.testclass() is underclass
        assert testclass is None
        assert metaclass is None

      elif variant == 'metauser':
        /# TODO(wmh): These may need updating
        if False:
          for cn, c in (
            ('user', userclass),
            ('under', underclass),
            ('test', testclass),
            ('meta', metaclass),
          ):
            if c:
              print('%s = %s' % (cn, c.kindfqn()))
            else:
              print('%s = %s' % (cn, c))
        if True:
          assert userclass is None
          assert underclass is None
          assert testclass is None
          assert metaclass is None

    test:
      test.tpy()
      test.klass.validate()
    end method validate;

    method testClassInfo
    : tuple<metax.oopl.NamespaceConstruct,metax.attr.ComplexBlock,str,str> #:
      Obtain test class information.

      Returns:
       0) NamespaecConstruct
         The namespace within which the test class is to be added
       1) ComplexBlock
         The scope within the namespace within which the test class is to be added.
       2) str
         The (relative) name of the test class
       3) str
         The name of the parent of the test class (relative or absolute).
    scope:
      namespace = self.namespace()
      userblock = namespace.attr('scope:')
      testspace = namespace.testspace()
      testblock = testspace.attr('scope:') if testspace else None
      testparent = self.attrval('testparent', default=metax.c.LOOKUP)
      if testparent == '<special>':
        /# If there is a TestCase class defined within testblock, we use
        /# that as the parent, else we use metax.test.TestCase
        testcase_in_test = testblock.cons('TestCase', default=None) if testblock else None
        testcase_in_user = userblock.cons('TestCase', default=None)
        if (
          testcase_in_test or
          (testcase_in_user and testcase_in_user.attrval('location') == 'test')
        ):
          testparent = 'TestCase'
        else:
          testparent = 'metax.test.TestCase'
        /# print('**** HERE!!! %s = %s' % (self.kindfqn(), testparent))
      testname = metax.oopl.ClassConstruct.TestifyName(self.id())
      assert testspace is not None
      return (testspace, testblock, testname, testparent)
    test:
      test.tpy(expand=True)  # testClassInfo relies on class namespace being set.
      testspace = test.namespace.testspace()
      test.iseq(
        (testspace,
         testspace.attr('scope:'),
         'PersonTest', 'TestCase'),
        test.klass.testClassInfo())
    end method testClassInfo;

    method metaClassInfo
    : tuple<metax.oopl.NamespaceConstruct,metax.attr.ComplexBlock,str,str> #:
      Obtain the meta namespace and metaclass name.

      Returns:
       0) NamespaceConstruct
         The namespace within which the meta class is to be added
       1) ComplexBlock
         The scope within the namespace within which the meta class is to be added.
       2) str
         The (relative) name of the meta class
       3) str
         The name of the parent of the meta class (relative or absolute).
    scope:
      metaspace = self.namespace()
      metablock = metaspace.rawattr('scope:') if metaspace else None
      metaparent = self.attrval('metaparent', default=metax.c.LOOKUP)

      if metaparent == '<special>':
        /# We did not find an explicit metaparent, so we compute it dynamically:
        /#  - if the parent of the userclass is meta-defined, that parent
        /#    has an auto-generated metaclass and the parent of this class
        /#    should be that class.
        /#  - if the parent of the userclass is not meta-defined, we use
        /#    metax.root.ObjectMetaRoot
        /#     - this assumes the non-meta parent does not have a metaclass
        /#       of its own (if it does, the user will need to provide
        /#       that nonmeta metaclass explicitly via metaparent)
        /#     - TODO(wmh): Rewrite root.meta as root.meta2, and use namespace
        /#       metaxy.root (we cannot use 'meta' because we are using
        /#       that as the receiver variable of metaclass methods).
        parentdata = self.parentclasses()[0]
        if parentdata.get('external', False):
          /# nonmeta class
          /#metaparent = ClassConstruct.MetaifyName('metax.root.ObjectMetaRoot')
          metaparent = 'metax.root.ObjectMetaRoot'
        else:
          /# TODO(wmh): Update this to use parentdata['class'] when we've
          /# implemented importMeta().
          metaparent = metax.oopl.ClassConstruct.MetaifyName(
            parentdata['metafqn'])
      else:
        pass

      /# TODO(wmh): Delete following when we are using root.meta2
      /# if metaparent == 'metax.root.Object__Meta':
      /#   metaparent = 'metax.root.ObjectMetaClass'

      metaname = metax.oopl.ClassConstruct.MetaifyName(self.id())
      assert metaspace is not None

      return (metaspace, metablock, metaname, metaparent)
    test:
      /# parentclasses() iniitalized in importMeta
      test.tpy(expand=True, imports=True)
      test.iseq(
        (test.namespace,
         test.namespace.rawattr('scope:'),
         'PersonMeta', 'metax.root.ObjectMeta'),
        test.klass.metaClassInfo())
    end method metaClassInfo;

    method autogenInfo : map #:
      Establish which autogenerated classes should and should not be produced.
    scope:
      /# TODO(wmh): Extend to support testmeta and metatest
      result = {'test': True, 'meta': True}
      autogen = self.attrval('autogen')
      if autogen != 'std':
        if 'notest' in autogen:
          result['test'] = False
        if 'nometa' in autogen:
          result['meta'] = False

      /# Some additional logic:
      /# - classes inheriting from Error are considered implicitly nometa
      /#   and notest if they have no scope: or only 0-1 constructs in scope:
      if self.isErrorClass():
        scope, lines = self.attrpair('scope:', default=None)
        if scope is None or len(lines) < 2:
          result['test'] = False
          result['meta'] = False

      return result
    test:
      test.tpy()
      test.iseq({'test': True, 'meta': True}, test.klass.autogenInfo())
      /# TODO(wmh): Define some nometa and notest classes.
    end method autogenInfo;

    method suppressInfo : tuple<vec<str>,vec<str>> #:
      Parses the suppress() map to identifies two sets of suppression
      lists, local and global.  The local list is suitable for inclusion
      in (for example, using javascript, @fileoverview @suppress), while
      the global list is suitable for inclusion in a BUILD target rule
      (for example, using javascript, in the 'suppress' attribute of a
      closure_js_library target).
    scope:
      suppress = self.suppress() or {}
      local_list = []
      global_list = []
      for key in sorted(suppress):
        if key == key.upper():
          global_list.append(key)
        else:
          local_list.append(key)
      return (local_list, global_list)
    test:
      test.tjs()
      test.iseq(
        ([], []),
        test.klass.suppressInfo())
      /# TODO(wmh): Introduce suppress syntax info a faux metafile and
      /# verify suppressInfo.
    end method suppressInfo;

    method isErrorClass : bool #:
      True if this class inherits from metax.root.Error.
    scope:
      /# TODO(wmh): Need a 'is subclass of' mechanism in Meta. In the interim,
      /# this is heuristic in nature.
      result = False
      if self.id().endswith('Error'):
        result = True
      else:
        pcs = self.parentclasses()
        if pcs:
          if pcs[0]['id'].endswith('Error'):
            result = True
      return result
    test:
      /# file-level classes moved into namespace in expandMeta
      test.tpy(expand=True)
      test.isfalse(test.klass.isErrorClass())
      errorclass = test.nscope.cons('Error')
      test.istrue(errorclass.isErrorClass())
    end method isErrorClass;

    method typeOfSelf : metax.oopl.Type #:
      Return the meta Type of 'self' for this class (or 'this' if dothis True)
    params:
      var dothis : bool = false #:
        If True, type 'this' instead of 'self'.  The hope is that we can make
        'self' be &<class>, and keep 'this' as '#*<class>' but languages may
        be inconsistent in their treatment of the type of receiver objects ...
        we'll see.
      var isconst : bool = false #:
        If True, return the version of the type in which the object is const.
    scope:
      if dothis:
        tstr = '#*%s%s' % ('#' if isconst else '', self.fqn())
      else:
        tstr = '&%s%s' % ('#' if isconst else '', self.fqn())
      result = metax.c.Type.Instance(tstr)
      return result
    test:
      /# Result is baselang-independent.
      test.tpy()
      test.iseq(
        metax.c.Type.Instance('&demo.tmp.Person'), test.klass.typeOfSelf())
    end method typeOfSelf;

    method initParentClasses #:
      Establish the parent classes of this class.
    scope:
      /# TODO(wmh): Why not add this as a lazy: block of parentclasses?

      parentclasses = []
      /# parents_attr, parents = self.attrpair('parents:', default=None)
      parents_attr = None
      if parents_attr is None:
        namespace = self.namespace()
        metafile = self.metafile()
        parent_attr, parent = self.attrpair('parent', default=metax.c.LOOKUP)
        fqn, metafqn = self.baselang().formatClassType(
          metafile, parent, namespace)

        /# fqn will be None if parent is 'void'
        if fqn:
          parts = metafqn.split('.')
          pdata = {
            'raw': parent,
            'fqn': fqn,
            'id': parts[-1],
            'metafqn': metafqn,
            'class': None}
          if parent[0] == metax.c.Context.Tokens()['explicit_class_indicator']:
            pdata['external'] = True
          parentclasses.append(pdata)
        else:
          /# For the special case of 'no parent', we have the choice of
          /#  1) adding a pdata in which 'fqn' is 'void'
          /#  2) returning an empty vector.
          /# Both require special casing, but #2 is more accurate, so that's
          /# what we do.
          pass
      else:
        /# TODO(wmh): Support multiple inheritance.
        pass
      self.parentclassesIs(parentclasses)
    test:
      test.tpy()
      test.isnull(test.klass.parentclasses())
      test.klass.initParentClasses()
      test.iseq(
        [{'raw': 'metax.root.Object',
          'class': None,
          'fqn': 'metax.root.Object',
          'id': 'Object',
          'metafqn': 'metax.root.Object'}],
        test.klass.parentclasses())
    end method initParentClasses;

    new
    method ancestors : vec<metax.oopl.ClassConstruct> #:
      Obtain the ancestors of this class (does NOT include self).
      TODO(wmh): Need to support ancestors that are outside Meta.
       - create a special ExternalClassConstruct subclass of ClassConstruct?
    scope:
      result = []
      klass = self
      while klass is not None:
        parentclasses = klass.parentclasses()
        if parentclasses:
          parent_info = parentclasses[0]
          klass = parent_info['class']
          if klass is None:
            raise metax.c.Error('Should never reach here')
          else:
            result.append(klass)
        else:
          klass = None
      result.reverse()
      return result
    test:
      /# TODO(wmh): Fix this. Same problem as ClassConstruct.importMeta(),
      /# wherein the 'class' key of parentclasses() is not being properly
      /# initialized in tests, but appears to be initialized in production
      /# code.
      if False:
        test.tpy(expand=True, imports=True)  # parentclasses set in expand
        test.iseq(test.klass.ancestors())
    end method ancestors;

    method parentclass : metax.oopl.ClassConstruct #:
      Obtain a parent class by index in superclass list.

      NOTE: Until ClassConstruct.importMeta() is invoked on this class,
      this method will return null.
    params:
      var index : int = 0 #:
        The index in self.parentclasses() of desired parent.
    scope:
      parentclasses = self.parentclasses()
      if index < len(parentclasses):
        result = parentclasses[index]['class']
      else:
        /# TODO(wmh): Raise exception?
        result = None
      return result
    test:
      test.tpy(expand=True, imports=True)
      test.iseq('metax.root.Object', test.klass.parentclass(0).fqn())
      test.isnull(test.klass.parentclass(1))
    end method parentclass;

    method idfqn : str #:
      Return id or fqn depending on whether this class is in same nmsp as
      parent.

      WARNING: Should only be invoked after ClassConstruct.importMeta() has
      been invoked!
    scope:
      parent = self.parentclass()
      pspace = parent.namespace() if parent else None
      if pspace and pspace.fqn() == self.namespace().fqn():
        result = self.id()
      else:
        result = self.fqn()
      return result
    test:
      test.tpy(expand=True)  # parentclass and namespace set in expandMeta()
      test.iseq('demo.tmp.Person', test.klass.idfqn())
    end method idfqn;

    method registerPacked : tuple<int,int,bool> #:
      Register a packed field
    params:
      var field : str #:
        The id of the field being packed.
      var pack : str #:
        The name of the pack field.
      var bits : int #:
        The number of bits the field takes up.
      var signed : bool = false #:
        If true, the field is to be treated as a signed int rather than
        an unsigned int.
    scope:
      packed = self.packed()
      if packed is None:
        packed = {}
        self.packedIs(packed)
      pdata = packed.setdefault(pack, {})
      if field in pdata:
        raise metax.c.InternalError('This is borked')
      /# Obtain the fields in bit-position order.
      if pdata:
        keys = sorted(pdata, key=lambda k: pdata[k][0])
        last_bit, last_size, _ = pdata[keys[-1]]
        start_bit = last_bit + last_size
      else:
        start_bit = 0
      result = (start_bit, bits, signed)
      pdata[field] = result
      return result
    test:
      test.tpy()
      test.iseq(
        (0, 3, False),
        test.klass.registerPacked('a', 'packer', 3))
      test.iseq(
        (3, 5, True),
        test.klass.registerPacked('b', 'packer', 5, signed=True))
      test.iseq(
        {'packer': {'a': (0, 3, False), 'b': (3, 5, True)}},
        test.klass.packed())
    end method registerPacked;

    method _autogenAll #:
      Autogenerate various methods on this class.
    scope:
      baselang = self.baselang()
      baselang.autogenStr(self)
      baselang.autogenPrint(self)
      baselang.autogenWrite(self)
      baselang.autogenSize(self)
    test:
      test.tpy()
      test.iseq(
        ['field name', 'field height', 'field weight', 'lifecycle Person',
         'method bmi', 'method show', 'method ClassMethod',
         'method StaticMethod'],
        [c.kindid() for c in test.cscope.value()])
      test.klass._autogenAll()
      test.iseq(
        ['field name', 'field height', 'field weight', 'lifecycle Person',
         'method bmi', 'method show', 'method ClassMethod',
         'method StaticMethod', 'method strMeta', 'method printMeta',
         'method writeMeta', 'method sizeMeta'],
        [c.kindid() for c in test.cscope.value()])
    end method _autogenAll;

    method registerDependencies #:
      Populate the 'deps' field by adding explicit and implicit dependencies to
      this class.
    scope:
      baselang = self.baselang()
      basel = baselang.id()
      metaclass = self.metaclass()
      namespace = self.namespace()
      assocs = self.attrval('associations:', default=metax.c.EMPTY)
      istest = self.isTest()

      /# Parent imports
      parent_classes = self.parentclasses()
      if parent_classes:
        parentdata = parent_classes[0]
        if not parentdata.get('external', False):
          pfqn = parentdata['metafqn']
          self.addDependency(pfqn, 'cls', 'parent')

      /# Explicit imports
      for dep in assocs:
        /# dep can be either 'assoc' or 'resource'
        akind = dep.kind()
        if akind == 'resource':
          self.registerResource(dep)
        elif akind == 'assoc':
          /# assoc
          aid = dep.id()
          lookup = metax.c.LOOKUP
          aloc = dep.attrval('location', default=lookup)
          akind = dep.attrval('kind', default=lookup)
          alias = dep.attrval('alias', default=lookup)
          status = dep.attrval('status', default=lookup)

          if self.variant() == 'testuser':
            /# We do not filter out any assocs if we are in an explicit test
            /# class.  Do we want to warn if aloc isn't the default?
            pass
          elif istest and 'test' not in aloc:
            continue
          elif 'user' not in aloc:
            continue

          if akind == 'std':
            fqn = aid
          else:
            fqn = metax.oopl.ClassConstruct.CanonicalizeClassName(
              aid, namespace=namespace)

          atarget = dep.attrval('target', default=None)
          /#print('*** HER with %s' % atarget)

          if atarget is None:
            /# TODO(wmh): If akind is 'std' we could set atarget to null, but we
            /# would need to still register the dependency. Currently, we handle
            /# setting target to null in Oopl*.formatDependency instead.
            /# CODETANGLE(std_target)
            atarget = baselang.nameToBuildTarget(fqn)
          else:
            atarget = atarget.asStr(unquote=True)
          if atarget:
            self.addDependency(
              fqn, akind, 'in assocs', alias=alias, target=atarget,
              optional=status == 'optional',
            )

      /# Implicit imports
      if metaclass is not None:
        /# This is a user-defined user-level class.  Each such class defines
        /# a 'meta' method that returns the singleton instance of the
        /# metaclass describing the class.
        mfqn = metaclass.fqn()
        if basel == 'javascript':
          /# TODO(wmh): Clean up the special-casing in javascript ... the
          /# current implementation is too messy!
          /#  - the nm.sp.FooMeta module exports both nm.sp.FooMeta and
          /#    nm.sp.MetaFoo
          /#  - if one wants to import either nm.sp.FooMeta or nm.sp.MetaFoo,
          /#    special code must be generated in
          /#    OoplJavascript.formatDependency.
          /#  - when importing nm.sp.MetaFoo, one uses assoc kind 'cls' even
          /#    though MetaFoo is an instance of FooMeta, not a class.
          metaclass_instname = metax.oopl.ClassConstruct.MetaInstifyName(
            self.id())
          mifqn = '.'.join(mfqn.split('.')[:-1] + [metaclass_instname])
          self.addDependency(
            mifqn, 'cls', 'implicit import in ClassConstruct.translateMeta()')
        else:
          self.addDependency(
            mfqn, 'cls', 'implicit import in ClassConstruct.translateMeta()')

        /# Every class depends on metax.root.ObjectMeta.
        /# TODO(wmh): Determine if this can be commented out now that the
        /# other 'implicit_objectmeta' reference is commented out.
        self.addDependency(
          /# CODETANGLE(implicit_objectmeta)
          'metax.root.ObjectMeta', 'cls', 'every class depends on ObjectMeta')

      /# If this class is a test class, we always import:
      /#  - the class it tests.
      /#  - metax.test (for metax.test.main()) ... in python
      if self.isTest():
        underclass = self.underclass()
        if underclass:
          /# All implicit test classes will have underclass set, but
          /# explicit user-provided test classes will not.
          ufqn = underclass.fqn()
          self.addDependency(
            ufqn, 'cls', 'implicit import in ClassConstruct.translateMeta()')

          if basel == 'javascript':
            tsfqn = 'goog.testing.testSuite'
            self.addDependency(
              tsfqn, 'cls', 'implicit import in ClassConstruct.translateMeta()',
              target=None)

          /# In python, the metax.test module is needed because
          /# metax.test.main() is invoked to start the test suite.
          if basel == 'python':
            self.addDependency(
              'metax.test', 'lib',
              'implicit import of metax.test so metax.test.main() is available',
              target=None)
        else:
          /# Means we have an explicit user-provided test class.
          pass
    test:
      test.tpy()
      test.iseq({}, test.klass.deps())
      test.namespace.expandMeta()
      test.iseq(
        {
          'sys': {
            'reason': 'needed by autogened printMeta', 'kind': 'std',
            'fqn': 'sys', 'target': None},
          'metax.root.Object': {
            'reason': 'parent', 'kind': 'cls', 'fqn': 'metax.root.Object',
            'target': '//metax/root:Object'},
          'metax.root.ObjectMeta': {
            'reason': 'every class depends on ObjectMeta', 'kind': 'cls',
            'fqn': 'metax.root.ObjectMeta',
            'target': '//metax/root:ObjectMeta'},
          'os': {
            'reason': 'in assocs', 'kind': 'std', 'fqn': 'os',
            'target': None},
          'demo.tmp.PersonMeta': {
            'reason': 'implicit import in ClassConstruct.translateMeta()',
            'kind': 'cls', 'fqn': 'demo.tmp.PersonMeta',
            'target': '//demo/tmp:PersonMeta'},
        },
        test.klass.deps())
    end method registerDependencies;

    method generateMetaClass : metax.oopl.ClassConstruct #:
      Create a metaclass associated with this class.

      May be applied to user-level or test-level classes.
    scope:
      name = self.id()
      fqn = self.fqn()
      context = self.context()
      metaspace, metablock, metaname, metaparent = self.metaClassInfo()
      metaclass = metax.oopl.ClassConstruct.NewFromData(
        /# TODO(wmh): Verify that meta class should share same context as
        /# user class.
        metaname, context, parent=metablock,
        features=[('location', 'meta')],
        secondaries=[
          ('parent', metaparent),
          /# We are not expanding the resulting class, so we don't bother
          /# ('testparent', testmetaparent),
          ('assocs:', []),
          ('comment:', ['Auto-generated meta class for %s.' % fqn]),
          ('scope:', []),
        ],
        position='-' + name,
        precount=1)
      return metaclass
    test:
      test.tpy(expand=True)
      /# Note that expandMeta() invokes generateMetaClass(), but we do so
      /# again since it has no side-effects.
      metaclass = test.klass.generateMetaClass()
      metaclass.write(fp=test.fp())
      test.iseqtext("""
       >|meta class PersonMeta parent metax.root.ObjectMeta assocs:
       >|comment:
       >|  Auto-generated meta class for demo.tmp.Person.
       >|scope:
       >|end class PersonMeta;
       >|""",
       test.out())
    end method generateMetaClass;

    method generateImplicitMeta : metax.oopl.MethodConstruct #:
      Generate a 'meta' method for this class.
    scope:
      result = None
      /# TODO(wmh): Once confident that the generation of this method is
      /# working properly in all baselangs, some optimizations can be
      /# performed:
      /#  - the method does NOT need to be defined in every python class ...
      /#    we can simply define it in metax.root.Object as:
      /#      def meta(self):
      /#        return self.__class__
      /#    (assuming we continue to set the __metaclass__ of every class
      /#    in Python ... if we do not, we will need to continue to define
      /#    meta() in each class).
      name = self.id()
      fqn = self.fqn()
      scope = self.attr('scope:', default=None)
      baselang = self.baselang()
      context = self.context()
      metaclass = self.metaclass()
      if metaclass is None:
        /# TODO(wmh): Determine when this is an error, and when this is working
        /# as intended!
        if metax.c.Compiler.IMPL['metatestclass']:
          raise metax.c.InternalError(
            'Must initialize metaclass of %s before invoking '
            'generateImplicitMeta().' % fqn)
        else:
          /# Do not generate a 'meta' method.
          scope = None

      if scope:
        /# We do not create a 'meta' method if there is no explicit scope:
        /# in the class.  This deals with the common case of someting like
        /#   class Error < metax.root.Error;
        /# and also situations where no metaclass exists for the class.
        /#
        /# However, this may pose problems in other situations ... we can
        /# reconsider how to handle this if it is an issue. Added because
        /# NewFromData() was failing when parent=None and position!=null.

        /# Define an implicit method named 'meta' that returns the
        /# singleton instance of the metaclass defining this class.
        /#  - if metaclasses have been disabled, the method should return null.
        /# TODO(wmh): When statement-level constructs exist, define this
        /# method in Meta<*>:
        metaclass_instname = metax.oopl.ClassConstruct.MetaInstifyName(name)
        test_body = ["%s noop" % metax.c.Context.Tokens()['remark']]
        if baselang.id() == 'python':
          test_body.append('pass')
        meta_body = baselang.metaMethodBody(metaclass_instname, metaclass)

        /# We need to establish whether the 'meta' method is defined on an
        /# ancestor or not. Once we have full hierarchy info we can establish
        /# this directly, but for now the following heuristic:
        /#  - if fqn is metax.root.Object, inheritance new
        /#  - if fqn is metax.root.ObjectMetaRoot, inheritance new
        /#  - if fqn is metax.test.TestCase, inheritance new
        /#  - if class does not inherit from any of the above, inheritance new
        /#  - otherwise inheritance override
        if fqn in (
          'metax.root.Object',
          'metax.root.ObjectMetaRoot',
          'metax.test.TestCase'
        ):
          inheritance = 'new'
        else:
          inheritance = 'override'
        features = [
          ('inheritance', inheritance),
          ('autogen', 'notest'),
        ]
        secondaries = [
          /# We use * instead of & because we want to support the conditional
          /# inclusion of metaclasses.
          ('returns', metax.c.Type.Instance('*metax.root.ObjectMetaRoot')),
          ('scope:', meta_body),
          ('test:', test_body)
        ]

        result = metax.oopl.MethodConstruct.NewFromData(
          'meta', context, parent=scope, precount=1,
          features=features, secondaries=secondaries,
          primary_line=-1, position='+')

      return result
    test:
      test.tpy(expand=True)
      meta = test.klass.generateImplicitMeta()
      meta.write(fp=test.fp())
      test.iseqtext("""
       >|override notest method meta returns *metax.root.ObjectMetaRoot scope:
       >|  result = self.__class__
       >|  assert issubclass(result, Person)
       >|  assert issubclass(result, MetaPerson)
       >|  return result
       >|test:
       >|  /# noop
       >|  pass
       >|end method meta;
       >|""",
       test.out())
    end method generateImplicitMeta;

    method registerResource #:
      Register a resource.
    params:
      var resource : *metax.oopl.Construct #:
        The reource construct to register.
    scope:
      metafile = self.metafile()
      metac = self.compiler()
      fs = metac.fs()
      baselang = metac.baselang()

      /# Establish the path storing the resource.
      path_attr, subpath_expr = resource.attrpair(
        'path', default=metax.c.LOOKUP)
      subpath = fs.expandvars(subpath_expr.asStr(unquote=True))

      src_path = fs.join(fs.dirname(metafile.path()), subpath)
      if not fs.exists(src_path):
        metafile.error(
          '%s does not exist' % src_path, line=resource.primary().line())
      else:
        klass = resource.ancestor('class')
        assert klass is self

        /# Create a filename that encodes the class name and the resource name.
        resname = resource.id()
        class_name = klass.id()
        /# CODETANGLE(resource_dir): See metax.root.Object.Resource.
        filename = '%s_%s' % (class_name, resname)

        /# Establish the path within the generated python code hierarchy from
        /# which we will symlink to the src path. It has to be in the same
        /# hierarchy as the generated code for bazel to be happy.
        namespace = self.namespace()
        dest_dir = fs.join(
          /# CODETANGLE(resource_dir)
          metac.repositoryPath(), metac.basePath(namespace.fqn()),
          metax.c.RESOURCES_SUBDIR)
        dest_base = fs.basename(dest_dir)
        dest_path = fs.join(dest_dir, filename)

        if not fs.exists(dest_dir):
          fs.makedirs(dest_dir, 0o755)
        target = fs.join(dest_base, filename)

        /# print('src_path %s' % src_path)
        /# print('dest_path %s' % dest_path)
        /# print('target %s' % target)

        /# Create the symlink from src_path to dest_path.
        if not fs.lexists(dest_path):
          print('NOTE: Linking %s to %s' % (src_path, dest_path))
          fs.symlink(src_path, dest_path)
        else:
          /# The file already exists ... verify it is a symlink and points where
          /# it should.
          if fs.islink(dest_path):
            curr_src_path = fs.readlink(dest_path)
            if curr_src_path != src_path:
              /# It does not point where it should. For now, we report an error
              /# and tell the user how to fix the problem (by removing the
              /# incorrect symlink). We may want to automatically do this in the
              /# future (but we want to avoid deleting an important file while
              /# doing
              metafile.error(
                'Resource %s is stored in\n'
                '  %s\nwhich currently links to\n'
                '  %s\ninstead of\n'
                '  %s\nRemove\n'
                '  %s\n'
                'and reinvoke metac to proceed.' %
                (resname, dest_path, curr_src_path, src_path, dest_path),
                line=resource.primary().line())
              print('WARNING: Deleted %s' % dest_path)
              fs.unlink(dest_path)
          else:
            metafile.warning(
              'Resource %s is stored in\n'
              '  %s\n'
              'which is currently a non-symlink when it should be a symlink to\n'
              '  %s\n'
              'You can remove\n'
              '  %s\n'
              'and reinvoke metac to clean up.' %
              (resname, dest_path, src_path, dest_path),
              line=resource.primary().line())

        /# Store a mapping from resource name to target for use in
        /# createBuildFragment().
        self.resources()[resname] = target
    test:
      test.tpy()
      klass = test.klass
      assocs = klass.attr('associations:')
      if False:
        /# TODO(wmh): Verify that when the resource path *does* exist, that
        /# the resource is registered.

        /# I had defined
        /#    resource tmp path "./not/a/path";
        /# on the Person class within the 'oopl' sample, but I'm concerned
        /# that the error produced by the path not existing might be
        /# affecting subsequent parsing, so I've removed it.
        resource = assocs.cons('tmp')
        test.iseq([], sorted(test.klass.resources()))
        test.klass.registerResource(resource)
        test.iseq(
          [{'message': '/faux/./not/a/path does not exist',
            'line': 9,
            'kind': 'E',
            'col': -1}],
          test.metafile.errors())
        test.iseq([], sorted(test.klass.resources()))
    end method registerResource;

    method registerInitializer #:
      Register an initializer with this class.
    params:
      var initializer : metax.oopl.MethodConstruct;
    scope:
      /# TODO(wmh): it is very possible that the MethodConstruct instance
      /# will never be properly GCed because of all the circular links.
      /# Implement __del__ on Construct, and/or start using weakptrs in
      /# some places.  Relevant because we are tromping any pre-existing
      /# initializer and hoping the old instance gets GCed ... it may not!
      current = self.initializer()
      if current:
        current.myclassIs(None)
      self.initializerIs(initializer)

      if initializer:
        initcls = initializer.myclass()
        if initcls and initcls is not self:
          raise metax.c.Error(
            '%s already has initializer %s and now %s' %
            (self.fqn(), initcls.kindfqn(), initializer.kindfqn()))
        initializer.myclassIs(self)
    test:
      test.tpy(expand=True)  # registerInitializer invoked by class expandMeta
      initializer = test.cscope.cons('__init__')
      test.issame(initializer, test.klass.initializer())
    end method registerInitializer;

    method registerStaticInitializer #:
      Register a static initializer with this clas.
    params:
      var initializer : metax.oopl.MethodConstruct #:
        The method defining the static initializer.
        TODO(wmh): Not all baselangs implement static initializers via
        methods (e.g. Java). This will need to be generalized.
    scope:
      self.clinitIs(initializer)
    test:
      test.tpy()
      test.isnull(test.klass.clinit())
      method = metax.oopl.MethodConstruct.NewFromData(
        'Initialize', test.context, parent=None, precount=1)
      test.klass.registerStaticInitializer(method)
      test.issame(method, test.klass.clinit())
    end method registerStaticInitializer;

    meta
    method CreateAssocs : metax.attr.ComplexBlock #:
      Create a 'associations:' attribute given assoc info.
    params:
      var assoclist : vec<map> #:
        Each element is a map containing:
          id: str
          features : vec<tuple<str,str>>
          secondaries : vec<tuple<str,any>>
          termcode : int
      var context : *metax.oopl.Context;
    scope:
      assocs = metax.attr.ComplexBlock(None, 'associations:', [])
      for assocdata in assoclist:
        assoc = metax.oopl.AssocConstruct.NewFromData(
          assocdata['id'], context, parent=assocs,
          features=assocdata.get('features', None),
          secondaries=assocdata.get('secondaries', None),
          termcode=assocdata.get('termcode', 1))
      return assocs
    test:
      _, schema, context, compiler = test.cachedInfo()

      assocs = metax.oopl.ClassConstruct.CreateAssocs([], context)
      test.iseq('associations:', assocs.key())
      test.iseq([], assocs.value())

      assocs = metax.oopl.ClassConstruct.CreateAssocs(
        [
          {'id': 'sys', 'features': [('kind', 'std')]},
          {'id': 'code', 'features': [('kind', 'std'), ('location', 'test')]},
          {'id': 'nm.sp.Class',
           'features': [('kind', 'cls')],
           'secondaries': [
             ('target',
              metax.c.Expr(
                'str', '"//faux@nm.sp:Class"', '"//faux@nm.sp:Class"'))]},
        ],
        context)
      test.iseq('associations:', assocs.key())
      test.iseq(
        ['std assoc sys;\n',
         'std test assoc code;\n',
         'cls assoc nm.sp.Class target "//faux@nm.sp:Class";\n'],
        [assoc.asStr() for assoc in assocs.value()])
    end method CreateAssocs;

    method inheritsFromTestCase : bool #:
      Returns true if this class inherits from metax.test.TestCase

      IMPORTANT: Currently implementation is NOT complete ... assumes all such
      subclasses contain 'TestCase' in them. Need a more robust implementation.
      Assuming we've invoked importMeta(), we can traverse the inheritance
      hierarchy to establish this.
    scope:
      /# TODO(wmh): Fix this!!!! Lookup inheritance hierarchy if importMeta()
      /# has been invoked.
      return 'TestCase' in self.id()
    test:
    end method inheritsFromTestCase;

  end class ClassConstruct;

  class FieldConstruct < ClassicConstruct #:
    @field: The field construct.
  scope:

    field namespace : metax.oopl.NamespaceConstruct #:
      The namespace this field belongs to. Note that this has been added to
      allow 'field' constructs to appear directly within namespaces. Further
      exploration of the impact of this is needed.

    field rawfield : str #:
      The rawfield name for this field.  This is usually some minor variant
      of self.id(), but for packed fields it can be completely different.

    field packed : tuple<int,int> #:
      Will be null if the field is not packed, otherwise the first integer
      is the lowest bit position in rawfield of this field, and the second
      integer is the number of bits used by the field.

    field accessors : *map<str,metax.oopl.AccessorConstruct> #:
      Maps accessor name to accessor construct. This is just a pointer to
      the map() field of the scope: block of the field.  It is null if there
      is no explicit scope:

    lifecycle clinit:
      /# TODO(wmh): Find a way to allow the regexps defined in schema files
      /# to be visible in the source code (or to reference within schema files
      /# the regexps defined in source code). This regexp needs to be exactly
      /# the same as the one definedd for the 'accessors' feature attribute
      /# of the 'field' construct.
      cls.AccessorSpecRE = re.compile('^([!+#~-][rwxa@])+$')
      cls.AccessorOneRE = re.compile('([!+#~-][rwxa@])')
      cls.AccessorMap = {
        'r': 'get',
        'w': 'set',
        'x': 'ref',
        'a': 'adj',
        '@': 'field',
      }
      cls.AccessorVis = {
        '+': 'public',
        '#': 'protected',
        '-': 'private',
        /# CODETANGLE(visnmsp): If we change the 'package' value in the
        /# 'visibility' attribute to 'nsmp' or something else, this will need
        /# changing.
        '~': 'package',
        '!': None,
      }
    end lifecycle;

    method establishAccessors : map #:
      Determine which accessors to generate, and at what visibility.
    params:
      var type : metax.c.Type #:
        The type of the field.
    scope:
      /# The 'accessors' feature attribute has a regexp-based value that
      /#  matches FieldConstruct.AccessorSpecRE and consists of 1 or more
      /#  matches against FieldConstruct.AccessorOneRE.
      /#
      /# The 'access' feature attribute is legacy, and will be phased out
      /# when 'accessors' is working properly.
      access = self.attrval('access')
      accessors = self.attrval('accessors')
      genacc = {}
      if access == 'raw':
        /# By definition of 'raw', there are no accessors for raw fields.
        genacc['get'] = None
        genacc['set'] = None
        genacc['ref'] = None
      elif accessors != '+r#w!x-@':
        /# We have a non-default accessors specification, so we use it.

        /# print('NOTE: Found non-default accessor: %s = %s' % (self.kindfqn(), accessors))
        accre = FieldConstruct.AccessorOneRE
        accmap = FieldConstruct.AccessorMap
        accvis = FieldConstruct.AccessorVis
        for spec in accre.findall(accessors):
          vis = accvis.get(spec[0], False)
          if vis is False:
            /# No visibility was provided, which is the same as '+'
            vis = accvis['+']
            adex = 0
          else:
            adex = 1
          acc = accmap[spec[adex]]
          genacc[acc] = vis
      else:
        /# We generate accessors. However, if the field has const type,
        /# we don't generate a setter or reffer.
        isconst = type.isBaseConst()
        genacc['get'] = 'public'
        genacc['set'] = None if isconst else 'protected'
        genacc['ref'] = 'protected' if 'w' in access else None
      return genacc
    test:
      _, _, context, compiler = test.cachedInfo(basel='python', metal='oopl')
      field = metax.oopl.FieldConstruct.NewFromData(
        'height', context, parent=None,
        features=[('accessors', '+r#w!x+a-@')],
        secondaries=[('type', metax.c.Type.Instance('float'))])
      type = field.attrval('type')
      res = field.establishAccessors(type)
      test.iseqmap(
        {
          'get': 'public', 'set': 'protected', 'ref': None, 'adj': 'public',
          'field': 'private',
        },
        res)
    end method establishAccessors;

  end class FieldConstruct;

  class AccessorConstruct < OoplConstruct #:
    @accessor: An accessor associated with a field.

    Appears in the 'scope:' block of the 'field' construct.
  scope:

  end class AccessorConstruct;

  abstract
  class ExecutableConstruct < ClassicConstruct #:
    @Executable: Abstracut superclass of executable constructs.
  scope:

    field namespace : metax.oopl.NamespaceConstruct #:
      The namespace this method belongs to. Only really needed for methods
      defined directly within namespace scope.
      TODO(wmh): Consider whether there is a different way to handle this, so
      we aren't wasting a slot in every instance when few need it. For
      example, mark this field optional?

    field returntype : *metax.oopl.Type #:
      The return type of this Executable. Represents a cached version of
      the 'returns' or 'returns:' attributes.
      NOTE: Initialized in translateMeta(), not available before then.

    field params : *map #:
      A parsed representation of the 'params:' attribute.  Contains:
        attr: Attribute
          The params attribute
        data: vec<map>
          name: str
          type: Type
          default: any (optional)
          provides: str (optional)
          comment: vec<str>
        fields: map
          maps (high-level) field names to parameter names, for all fields
          that are to be initialized directly from a parameter (i.e. via
          the 'provides' syntax).
        varvec: map
          name: str
            The name of the catch-all vec-based param
          comment: vec<str>
        varmap: map
          name: str
            The name of the catch-all map-based param
          comment: vec<str>

    meta
    method TestifyName : str #:
      Obtain the test method naem corresponding to a user method.
    params:
      var name : str;
    scope:
      /# CODETANGLE(methtest)
      return 'test_' + name
    end method TestifyName;

    meta
    method IsTestName : bool #:
      Check if a name is a test.
    params:
      var name : str;
    scope:
      /# CODETANGLE(methtest)
      return name.startswith('test_')
    end method;

    meta
    method UntestifyName : str #:
      Obtain the user method name corresponding to a test method name.
    params:
      var name : str;
    scope:
      assert name.startswith('test_')
      return name[5:]
    end method UntestifyName;

    private
    method methodInfo
    returns tuple<metax.attr.ComplexBlock,vec<str>,vec<str>,vec<str>,vec<str>,str> #:
      Obtain various aspects of the method:

      Returns:
       0) scope_attr: metax.attr.ComplexBlock
            The scope block. This may be null (but does not imply anything
            by itself ... see 'scope' below for null-ness).
       1) scope: vec<str>
            The baselang lines in the user-provided scope. If this is None,
            we are NOT to generate anything for the executable (and all other
            return values are ignored).
       2) preamble: vec<str>
            The baselang lines in the scope before user content.
       3) postamble: vec<str>
            The baselang lines in the scope after user content.
       4) retamble: vec<str>
            The return line for the method.
       4) comment: vec<str>
            The baselang comment associated with the method.
       5) params: str
            The baselang syntax for declaring params.
    scope:

      if self.kind() != 'method':
        /# lifecycle and behavior should be expanded away, no?
        print('%s in %s' % (self.kindfqn(), self.parentConstruct().kindfqn()))
        print('@' * 70)
        self.write()
        print('@' * 70)
        raise metax.c.Error('Expecting only methods not %s' % self.kindfqn())

      metac = self.compiler()
      myclass = self.myclass()
      metafile = self.metafile()
      baselang = self.baselang()
      /# TODO(wmh): How to establish the actual width?
      width = 80 - 0
      scope_lines = None

      scope_attr, _ = self.attrpair('scope:', default=None)
      if scope_attr is None:
        scope_lines = []
        span = self.attrval('span')
        presence = self.attrval('presence')
        /# No 'scope:' is present.

        if span == 'specific':
          /# We do not expect a scope, and are to NOT generate a method.
          scope_lines = None

        elif presence == 'abstract':
          /# This is handled when emptyBlockCode() is invoked below.
          pass

        elif (
          /# It is common for test classes to not have initializers and to
          /# instead have 'setup' blocks.
          self.myclass().variant() == 'user'
        ):
          if metac.cli().implicit_scopes:
            /# If --implicit_scopes is specified, we are to generate a dummy
            /# scope block rather than report a warning.
            scope_lines = baselang.emptyBlockCode(self)
          else:
            metafile.warning(
              '%s is general but missing scope<%s>' %
              (self.kindfqn(), baselang.suffix()[1:]),
              line=self.primary().line())
      elif scope_attr.isSimpleBlock():
        /# We strip empty lines in case the user has added spurious emptiness.
        /# This is needed because BaseFile() expects final content to never
        /# have blank lines at the end, and raises an exception if found.
        scope_lines = baselang.simpleToBase(
          scope_attr, strip_empty=True, replace_receiver=True)
      else:
        /# TODO(wmh): Compile the meta-level statement constructs.
        scope_lines = []

      if scope_lines is None:
        /# We've established that we should not generate this method.
        params = None
        comment = None
        preamble = None
        postamble = None
        inamble = None
        retamble = None
      else:
        preamble = []
        postamble = []
        inamble = []
        retamble = None
        attrkind = self.attrval('kind')
        inheritance = self.attrval('inheritance')
        calls_super = False

        /# Handle inheritance (prex and postx).
        if attrkind == 'initializer':
          /# Various special functionality is generated in initializers:
          /#  - invocation of parent initializers (default postx semantics)
          /#  - implicit initialization of fields not explicitly initialized
          /#    in scope_lines.

          /# TODO(wmh): Currently, we are assuming that iniitalizers always
          /# have inheritance 'postx', but we probably want to generalize
          /# this.
          /# TODO(wmh): IMPORTANT: In oopl/schema.meta, the 'lifecycle'
          /# construct has defined 'Attribute inheritance = postx', but
          /# the '= postx' does not appear to be overriding the '= new'
          /# defined up in _executable_.
          calls_super = True
          if inheritance == 'superx':
            /# This is a request to NOT generate the super code ... it is
            /# up to the user to perform the call themselves.
            pass
          else:
            baselang.superCode(self, preamble)
            /# We do NOT invoke baselang.initCode() here because we need to do
            /# formatParams() first, as it may add code to 'preamble' to define
            /# a new receiver variable (one that is used in initCode()).
        else:
          /# TODO(wmh): Check whether the super method has a void return
          /# value (in which case return_var should be null).
          /# TODO(wmh): If return_var is not null, we should add a return
          /# statement to the end of the method (either as guaranteed last line
          /# of postamble or a special retamble value).
          /# TODO(wmh): Define a OoplBaseLanguage.returnCode() method for
          /# generating return code given a particular variable or expression.
          returntype = self.returntype()
          if returntype is None:
            raise metax.c.InternalError('returntype is uninitialized')
          if returntype.isVoid():
            return_var = None
          else:
            return_var = 'meta__super'
            /# TODO(wmh): Some more work is needed here. If returntype is not
            /# void, and the METAX_CALL_SUPER is indented within a conditional
            /# block, we must initialize return_var in preamble to ensure it is
            /# always safe to return it in postamble. Easy to do in python, but
            /# more difficult to establish the proper default value in C++.
            /# Certainly doable, as the needed code is used various other places
            /# ... just need to do it.
            if False:
              preamble.append('%s = None' % return_var)
          if inheritance == 'postx':
            baselang.superCode(self, preamble, return_var=return_var)
            calls_super = True
          elif inheritance == 'prex':
            baselang.superCode(self, postamble, return_var=return_var)
            calls_super = True
          elif inheritance == 'superx':
            baselang.superCode(self, inamble, return_var=return_var)
            calls_super = True
            old_lines = scope_lines
            superx_re = BaseLanguageOopl.SuperxRE()
            super_index = None
            super_ws = None
            for i, line in enumerate(old_lines):
              m = superx_re.match(line)
              if m:
                super_index = i
                super_ws = m.group('ws')
                break
            if super_index is None:
              metafile.error(
                'Missing required <METAX_CALL_SUPER> for superx method',
                attr=scope_attr)
            else:
              scope_lines = old_lines[:super_index]
              for line in inamble:
                scope_lines.append(super_ws + line)
              scope_lines.extend(old_lines[super_index+1:])

          if calls_super and return_var:
            /# TODO(wmh): How to guarantee that this is always the last
            /# line of output?
            if retamble:
              metafile.error(
                'Found multiple return statements',
                line=self.primary().line())
            else:
              /# TODO(wmh): This needs to be made baselang-specific (define a
              /# OoplBaseLanguage.returnCode() behavior).
              /# TODO(wmh): If the user-provided code provides a 'return'
              /# statement that is guaranteed to be executed by end-of-method,
              /# we do NOT need to insert this line.
              /# TODO(wmh): Consider making this a list of lines instead of
              /# a single line.
              if return_var is None:
                return_var = baselang.pseudovar('null')
              retamble = ['return ' + return_var]

          if len(scope_lines) == 0:
            scope_lines = baselang.emptyBlockCode(self)

        /# Obtain params and comment.
        params = baselang.formatParams(self, preamble)
        comment = baselang.formatMethodComment(self, width=width)

        /# Now add implicit field initialization code to the preamble.
        if attrkind == 'initializer':
          baselang.initCode(self, preamble)

          /# Initializers are candidates for being optimzied away. If the
          /# following are all true, we do not need to define the initializer:
          /#  - scope_lines is empty
          /#  - postamble is empty
          /#  - preamble is empty or contains only a super() call.
          if (
            False and
            not scope_lines
            and not postamble
            and (
              not preamble
              /# TODO(wmh): Testing for 'super(' is baselang specific.
              /# Generalize this code.
              or (len(preamble) == 1 and preamble[0].startswith('super('))
            )
          ):
            msg = '%s has been optimized away' % self.kindfqn()
            /#print('NOTE: ' + msg)
            metafile.info(msg, line=self.primary().line())

            /# Setting scope_lines to None means "do not generate method".
            scope_lines = None
            /# Remove the initializer from the class.
            /#  - TODO(wmh): Is there any reason to keep the initializer
            /#    construct around?  We could use a different field to
            /#    indicate that it has been optimized out, rather than
            /#    killing it.
            myclass.registerInitializer(None)

        /# Check if we need to introduce a special local variable for receivers
        /#  - note that we used to rewrite variable references, replacing
        /#    'test' and 'meta' with 'self' (this was done in behavior
        /#    simpleToBase). However, it is not possible to guarantee a proper
        /#    replacement of receiver references without a full parse of the
        /#    source code. A better solution is to introduce a local variable.
        /#  - TODO(wmh): Make this baselang-general!
        if scope_attr:
          scope_parent = scope_attr.parent()
          if isinstance(scope_parent, metax.oopl.ExecutableConstruct):
            /# We introduce 'self' or 'meta' or 'test' into the scope.
            metarec = baselang.receiverStr(scope_parent, style='meta')[0]
            baserec, specrec = baselang.receiverStr(scope_parent, deref=True)
            if baserec is None:
              /# There is no variable we can initialize.
              pass
            elif baserec != metarec and len(scope_lines) > 0:
              /# TODO(wmh): If any parameter is defined with same name as
              /# metarec, we need to report warning or not tromp! Same for
              /# local vars (do we disallow?)
              /# TODO(wmh): Only insert this if metarec is used within the
              /# method!
              text = baselang.defineBaseVar(
                metarec, baseval=baserec, mtype=None)
              preamble.append(text)

      return (
        scope_attr, scope_lines, preamble, postamble, retamble, comment, params)
    tests:
      testx cc ::
        /# methodInfo relies on translation
        test.tcc(expand=True, imports=True, translate=True)
        test.iseqvec(
          (
            test.method.attr('scope:'),
            /# TODO(wmh): Fix this ... should not be returning None!
            ['return 0.0;'],
            ['auto& self = (*this);'],
            [],
            None,
            [
              '// Calculate body mass index of this person.',
              '// Result is unitless, but relies on height in meters and',
              '// weight in kilograms.',
            ],
            '()',
          ),
          test.method.methodInfo())

      testx py ::
        /# methodInfo relies on translation
        test.tpy(expand=True, imports=True, translate=True)
        test.iseqvec(
          (
            test.method.attr('scope:'),
            /# lines
            ['return 0.0'],
            /# preamble
            [],
            /# postamble
            [],
            /# retamble
            None,
            /# comment
            ['"""Calculate body mass index of this person.',
             'Result is unitless, but relies on height in meters and',
             'weight in kilograms.', '"""',
            ],
            /# params
            '(self)'
          ),
          test.method.methodInfo())
    end method methodInfo;

    method isTestCase : bool #:
      True if this method is defined within a class that is a test case
      and looks like a test method.
    scope:
      return (
        self.myclass().isTestCase()
        and metax.oopl.ExecutableConstruct.IsTestName(self.id()))
    test:
      test.tpy()
      test.isfalse(test.method.isTestCase())
    end method isTestCase;

    meta
    method CreateParams : metax.attr.ComplexBlock #:
      Create a 'params:' attribute given var info.
    params:
      var varlist : vec<map> #:
        Each element is a map containing:
          var: str
          features : vec<tuple<str,str>>
          secondaries : vec<tuple<str,any>>
          termcode : int
      var context : *metax.oopl.Context;
    scope:
      params = metax.attr.ComplexBlock(None, 'params:', [])
      for vardata in varlist:
        var = metax.oopl.VarConstruct.NewFromData(
          vardata['var'], context, parent=params,
          features=vardata.get('features', None),
          secondaries=vardata.get('secondaries', None),
          termcode=vardata.get('termcode', 1))
      return params
    test:
      Type = metax.c.Type

      _, schema, context, compiler = test.cachedInfo()

      params = metax.oopl.ExecutableConstruct.CreateParams([], context)
      test.iseq('params:', params.key())
      test.iseq([], params.value())

      params = metax.oopl.ExecutableConstruct.CreateParams(
        [
          {'var': 'name',
           'secondaries': [('type', metax.c.Type.Instance('int'))]},
          {'var': 'age',
           'secondaries': [
             (':', metax.c.Type.Instance('int')),
             ('=', metax.c.Expr('int', '77', 77))]},
          {'var': 'rest', 'features': [('multiplicity', 'multi')],
           'secondaries': [(':', metax.c.Type.Instance('vec'))]},
        ],
        context)
      test.iseq('params:', params.key())
      test.iseq(
        ['var name type int;\n',
         'var age : int = 77;\n',
         'multi var rest : vec;\n'],
        [v.asStr() for v in params.value()])
    end method CreateParams;

    method parsedParams : map #:
      Parse the 'params:' attribute.

      Returns:
        See the 'params' field for details.
    params:
      var force : bool = false #:
        If true, recompute params even if already pre-computed.
    scope:
      result = self.params()
      if result is None or force:
        metafile = self.metafile()
        params = self.attr('params:', default=None)
        data = []
        fields = {}
        result = {'attr': params, 'data': data}
        if params:
          for var in params.value():
            if var.kind() == 'remark':
              /# TODO(wmh): Insert the remark into the generated code
              continue
            name = var.id()
            provides_attr, provides = var.attrpair(
              'provides', default=metax.c.LOOKUP)
            /# If 'provides' is given, should not specify 'type', 'multiplicity'
            /# or 'comment:' (but can specify 'default')
            missing = None if provides else metax.c.LOOKUP
            typeattr, type = var.attrpair('type', default=missing)
            multattr, multiplicity = var.attrpair(
              'multiplicity', default=missing)
            comattr, comlines = var.attrpair('comment:', default=None)
            default = var.attrval('default', default=metax.c.LOOKUP)

            if provides:
              myclass = self.myclass()
              field = myclass.symbolNamed(provides)
              if not field:
                metafile.error(
                  'Failed to find field %s in %s' %
                  (provides, myclass.kindfqn()),
                  line=provides_attr.line())
              elif field.kind() != 'field':
                metafile.error(
                  'Expecting %s to be of kind field not %s' %
                  (field.kindfqn(), field.kind()),
                  line=provides_attr.line())
              else:
                if typeattr:
                  metafile.error(
                    'Cannot specify both provides and type',
                    line=typeattr.line())
                if comattr:
                  /# TODO(wmh): Look into whether there is any utility in
                  /# allow such a comment. For example, explaining what
                  /# the default value associated witht the 'provides' means
                  /# (something that doesn't make sense to put in the field
                  /# comment in all cases).
                  metafile.info(
                    'Not currently using var comment '
                    '(using field comment instead)',
                    line=comattr.line())
                if multattr:
                  metafile.error(
                    'Cannot specify both provides and multiplicity',
                    line=multattr.line())
                /# We obtain type and comment from the field.
                typeattr, type = field.attrpair('type', default=missing)
                comattr, comlines = field.attrpair('comment:', default=None)

                /# We record a mapping from field to param name for use in
                /# BaseLanguageOopl.initCode()
                fields[provides] = name

            if multiplicity == 'multi':
              traw = type.raw()
              if traw.startswith('vec'):
                varvec = {'name': name}
                if comlines:
                  varvec['comment'] = comlines
                result['varvec'] = varvec
              elif traw.startswith('map'):
                varmap = {'name': name}
                if comlines:
                  varmap['comment'] = comlines
                result['varmap'] = varmap
              else:
                metafile.error(
                  'Invalid type %s for multi var %s' % (traw, name),
                  line=typeattr.line())
            else:
              item = {'name': name, 'type': type}
              if provides:
                item['provides'] = provides
              /# CODETANGLE(special_expr): TODO(wmh): Decide whether <special>
              /# is indicated by an Expr with value() None, or by an Expr that
              /# is None. Depending on which is decided, default below is either
              /# never None, or never '<special>'.
              if default is not None and default != '<special>':
                item['default'] = default
              if comlines:
                item['comment'] = comlines
              data.append(item)
        if fields:
          result['fields'] = fields
        self.paramsIs(result)
      return result
    test:
      test.tpy()
      test.iseq(
        {'data': [], 'attr': None},
        test.method.parsedParams())
      method2 = test.method2
      params, plist = method2.attrpair('params:')
      test.iseq(
        {
          'data': [
            {
              'default': plist[0].attrval('default', default=metax.c.LOOKUP),
              'type': metax.c.Type.Instance('ostream'),
              'name': 'fp',
            },
            {
              'default': plist[1].attrval('default', default=metax.c.LOOKUP),
              'type': metax.c.Type.Instance('str'),
              'name': 'indent',
            },
          ],
          'attr': params,
        },
        test.method2.parsedParams())
    end method parsedParams;

  end class ExecutableConstruct;

  class MethodConstruct < ExecutableConstruct #:
    @method: The method construct.
  scope:

    field supermethod : metax.oopl.MethodConstruct #:
      The method being overridden in an ancestor by this definition. Will be
      null if no ancestor defines the method (it will also always be null before
      importMeta() has been invoked on this instance).

    method isMethod : bool scope:
      return True
    test:
      test.tpy()
      test.istrue(test.method.isMethod())
      test.isfalse(test.klass.isMethod())
    end;

  end class MethodConstruct;

  class LifecycleConstruct < ExecutableConstruct #:
    @lifecycle: A merging of initializer/finalizer/copy&move-semantics/etc.

    Most of the attributes of lifecycle apply to the initializer (a
    MethodConstruct) implicitly generated by lifecycle. The other implicit
    methods (finalizer, cloner, mover, setup, teardown, etc.) do not take params
    and have pre-defined semantics in other ways.

    TODO(wmh): Should the lifecycle construct maintain pointers to all of the
    implicitly created MethodConstruct instances (for initializer, finalizer,
    setup, teardown, etc.)? Or at least a method for obtaining those methods
    constructs when desired?
  scope:

  end class LifecycleConstruct;

  class BehaviorConstruct < ExecutableConstruct #:
    @behavior: An executable defined on a collection of receivers.
  ##:
    TODO(wmh): This is currently inheriting from ExeutableConstruct, but I
    suspect it can inherit from ClassicConstruct instead, as the executable
    aspects of behaviors are handled by generating MethodConstruct instances
    that are inserted in classes.  At least, that is true for single-receivers.
    When we start supporting multi-method dispatch, we may actually need
    BehaviorConstruct instances to support executablity, unless we implement
    via double-dispatch, etc.
  assocs:
    std assoc collections;
    std assoc copy;
  scope:

    field namespace : *metax.oopl.NamespaceConstruct #:
      The namespace this behavior belongs to.

  end class BehaviorConstruct;

  class ReceiverConstruct < OoplConstruct #:
    @receiver: A class (or class tuple) that a behavior is defined on.
  scope:
  end class ReceiverConstruct;

  class CategoryConstruct < OoplConstruct #:
    @category: A virtual grouping of constructs within a parent.

    TODO(wmh): Decide whether this class should inherit from ClassicConstruct
    or just provide the same interface
     - note that duck typing won't work if we implement Meta in Meta<C++>
     - the concern here is that category constructs could be legal at other
       levels (namespace, method, etc.) and having CategoryConstruct be a
       subclass of ClassicConstruct is misleading and wasteful in those
       situations (although ClassicConstruct defines few fields currently,
       I expect its state to grow significantly).

    TODO(wmh): Decide whether this construct is even worth the complexities it
    imposes.
     - need to ensure uniqueness of all symbols defined transitively down
       all nested categories (pretty easy to do by registering every
       non-category child of a category with the namespace/class/method the
       category is residing in).
  scope:

  end class CategoryConstruct;

  class RemarkConstruct < OoplConstruct #:
    @remark: A comment as a construct.
  scope:

  end class RemarkConstruct;

  class NativeConstruct < OoplConstruct #:
    @native: A means of dumping raw base-language code into a compilation
    stream.
  scope:

    field namespace : *metax.oopl.NamespaceConstruct #:
      Every construct that can appear in a namespace must have a
      namespace field.  Not really needed for Native.

  end class NativeConstruct;

  class AssocConstruct < OoplConstruct #:
    @assoc: An association/dependency of a class.
  scope:

  end class AssocConstruct;

  class TestxConstruct < OoplConstruct #:
    @testx: A construct allowing multiple test methods to be assigned to a
    method.

    It would be better if this was called 'test', but we are already using
    'test' as a feature value and a secondary key, and we cannot have a
    primary key and feature value with same text.  We would need to rename
    the feature value if we want to rename this to testx (we *can* have
    the same value used for both primary key and secondary key).
  scope:

  end class TestxConstruct;

  class ResourceConstruct < OoplConstruct #:
    @resource: A non-code (aka data) dependency of a class.
  scope:

  end class ResourceConstruct;

  class CommandConstruct < ClassicConstruct #:
    @command: A CLI script (if toplevel) or subcommand.
  scope:

    lifecycle setup:
      test.prepMeta(name='cmds')
      test.file.expandMeta()
      test.main = test.file.child('/demo.tmp/Test/testmain')
      test.flag = test.main.child('bool@interface')
      test.flag2 = test.main.child('ival@interface')
      test.arg = test.main.child('first@interface')
      test.arg2 = test.main.child('second@interface')
      test.sub = test.main.child('sub@interface')
    end;

    method generatePython #:
      Generate python code that will create a metax.cli.Command
      instances representing this command construct.
    params:
      var command_var : str #:
        The name of the variable storing a metax.cli.Command instance
        that is to contain the Flag instance.
      var parent_var : str #:
        The name of the parent.  Is null if this is the top-level construct.
        Note that top-level construct does not necessarily mean top-level
        Command instance (depends on value of 'parent' in the generated code).
      var output : &vec<str> #:
        Where to write output.
    scope:
      indent = ''
      toplevel = parent_var is None

      aliases = self.attrval('aliases', default=None)

      if toplevel:
        /# We are at top-level, so we need to create a Command directly.
        creation_cmd = 'metax.cli.Command'
      else:
        /# We are not at top-level, so we can create a subcommand using
        /# newCommand() on the parent.
        creation_cmd = '%s.newCommand' % parent_var

      summary, desc = self.splitComment()
      output.append("%s%s = %s(" % (indent, command_var, creation_cmd))
      output.append("%s  '%s'," % (indent, self.id()))
      /# Removed 2018-10-29 as part of cli cleanup.
      /# if toplevel:
      /#   output.append('%s  parent=meta__parent,' % indent)
      if aliases:
        /# the 'aliases' attribute of 'command' is of type 'str' so it is
        /# an Expr with kind 'str'.
        aval = aliases.asStr(unquote=True)
        output.append("%s  aliases='%s'," % (indent, aval))
      output.append(
        "%s  summary='%s'," % (indent, summary.replace("'", "\\'")))
      lines = desc.split('\n')
      if len(lines) == 0:
        output.append("%s  desc='')" % indent)
      elif len(lines) == 1:
        output.append(
          "%s  desc='%s')" %
          (indent, desc.replace('\n', '\\n').replace("'", "\\'")))
      else:
        output.append("%s  desc=(" % indent)
        last = lines.pop()
        for line in lines:
          output.append("%s    '%s\\n'" % (indent, line.replace("'", "\\'")))
        output.append("%s    '%s'))" % (indent, last.replace("'", "\\'")))
    test:
      output = []
      test.sub.generatePython('cmd', 'pcmd', output)
      test.iseq(
        ['cmd = pcmd.newCommand(',
         "  'sub',",
         "  summary='',",
         "  desc='')"],
        output)
    end method generatePython;

    method createExecutableBinary : metax.fs.BaseFile #:
      Create the simple executable stub that calls into a class-specific entry
      point. Generated by top-level 'command' constructs.

      Returns:
        The BaseFile representing the binary.
    params:
      var auto : bool = false #:
        If true, invocations of the binary should auto-compile meta code.
    scope:
      metafile = self.metafile()
      klass = self.ancestor('class')
      metac = klass.compiler()
      fs = metac.fs()
      nmsp = klass.namespace()

      /# Establish the binary to use.
      binaryexpr = self.attrval('binary')
      python_binary = binaryexpr.asStr(unquote=True) or metac.Config()['python']
      /# print('%s = %s' % (self.kindfqn(), python_binary))

      /# Create the content of the binary file.
      cmdlines = [
        /# TODO(wmh): Use some template that is user-customizable
        '#!%s' % python_binary,
        'import metastrap',
        'metastrap.Setup(%s)' % ('auto=True' if auto else ''),
        /# TODO(wmh): How to allow for binary-specific imports?
        /# Most scripts do not need metagae, but those that interact with
        /# WAE may. And metagae is a wmh-ism, not a meta-ism!
        '#import metagae',
        'import sys',
        'import %s' % nmsp.fqn(),
        'try:',
        '  %s.%s(sys.argv)' % (klass.fqn(), metax.c.METAX_ENTRY_NAME),
        'except Exception:',
      ]
      if False:
        cmdlines.extend([
          '  import io',
          '  import traceback',
          '  compiler_class, command, cli = metastrap.ImportMeta()',
          '  import metax.c',
          '  metax.c.Compiler.Initialize()',
          "  metac = metax.c.Compiler(metal='oopl', basel='python')",
          '  metax.c.Compiler.CurrentIs(metac)',
          '  text = traceback.format_exc()',
          '  ifp = io.StringIO(text)',
          "  baselang = metac.metalang().baselangNamed('python')",
          '  metac.filterMetaOutput(baselang=baselang, ifp=ifp, debug=False)',
        ])
      else:
        cmdlines.append('  metastrap.RecoverMeta(None)')

      /# Create the file:
      /#  - for now, we place it in the namespace subdir of the repository
      /#  - we could put it in a class subdir, but we do not need class subdirs
      /#    for anything else currently ... maybe later.
      cmdpath = metac.basePath(nmsp.fqn() + '.' + self.id())
      cmdfile = metax.fs.BaseFile(
        cmdpath, '\n'.join(cmdlines) + '\n',
        metafile=metafile, mapfile=None, mode=0o755)
      metafile.registerFile(cmdfile)

      /# Now we make a symlink from oopl/bin/<id> to the above cmdpath.
      /#  - if the symlink file already exists
      /#     - if it is not a symlink, raise exception
      /#     - if it does not link to the same thing as we expect, report
      /#       warning, do nothing
      /#     - if it does link to same thing as we expect, do nothing
      /#  - else create ite.
      /#  - we do the same thing for any aliases of the command.
      linkdir = fs.join(metac.repositoryPath(), 'bin')
      if not fs.exists(linkdir):
        fs.makedirs(linkdir, 0o755)

      basenames = [self.id()]
      aliases = self.attrval('aliases', default=None)
      if aliases:
        aval = aliases.asStr(unquote=True).split(',')
        basenames.extend(aval)

      for basename in basenames:
        linkpath = fs.join(linkdir, basename)
        relpath = fs.join('..', cmdpath)

        if fs.exists(linkpath):
          if not fs.islink(linkpath):
            raise metax.c.Error(
              'Expecting %s to be a symlink to %s' % (linkpath, relpath))
          currpath = fs.readlink(linkpath)
          f1 = fs.realpath(currpath)
          f2 = fs.realpath(relpath)
          if False and f1 != f2:
            /# TODO(wmh): This is giving spurious warnings and is thus disabled.
            /# May be useful sometimes, in which case it needs fixing.
            metafile.warning(
              'For %s we have\n  %s\n  %s' % (linkpath, f1, f2),
              line=self.primary().line())
        else:
          linkfile = metax.fs.BaseFile(
            linkpath, None, metafile=metafile, mapfile=None,
            link=cmdfile)
          metafile.registerFile(linkfile)
      return cmdfile
    test:
      /# TODO(wmh): Create a memory-only fs so that writing this file does not
      /# affect production!
      cmdfile = test.main.createExecutableBinary()
      test.contains(
        '  demo.tmp.Test.MetaxEntry(sys.argv)',
        cmdfile.contents())
    end method createExecutableBinary;

  end class CommandConstruct;

  class FlagConstruct < OoplConstruct #:
    @flag: A commmand-line flag (or positional arg)
  scope:

    lifecycle setup:
      test.prepMeta(name='cmds')
      test.file.expandMeta()
      test.main = test.file.child('/demo.tmp/Test/testmain')
      test.flag = test.main.child('bool@interface')
      test.flag2 = test.main.child('ival@interface')
      test.arg = test.main.child('first@interface')
      test.arg2 = test.main.child('second@interface')
      test.sub = test.main.child('sub@interface')
    end;

    method isArg : bool #:
      True if this instance is a positional arg
    scope:
      return self.primary().litkey() == 'arg'
    test:
      test.istrue(test.arg.isArg())
      test.isfalse(test.flag.isArg())
    end method isArg;

    method generatePython #:
      Generate python code that will create a metax.cli.Flag
      instances representing this flag construct.
    params:
      var command_var : str #:
        The name of the variable storing a metax.cli.Command instance
        that is to contain the Flag instance.
      var output : &vec<str> #:
        Where to write output.
    scope:
      indent = ''
      metac = self.compiler()
      metafile = self.metafile()
      baselang = metac.baselang()
      aliases = self.attrval('aliases', default=None)
      type = self.attrval('type', default=None) or metax.c.Type.Instance('str')
      default = self.attrval('default', default=None)
      if default is None:
        baselang_default = 'None'
      else:
        baselang_default, type2 = baselang.compileExpr(
          default, metafile, executable=self, metatype=type)
      summary, desc = self.splitComment()

      /# Establish if this is a flag or arg.
      /#  - TODO(wmh): When aliases for primary constructs are working,
      /#    we can distinguish between flag and arg by the construct kind.
      /#  - For now, if the id starts with 'arg_', it is an arg and we
      /#    strip the prefix.
      name = self.id()
      primary = self.primary()
      /# The 'flag' construct has 'arg' as an alias for the primary key.
      /# If 'arg' was specified, we know to generate an arg vs a flag.
      isarg = primary.litkey() == 'arg'

      /# Clean up type issues
      typestr = type.raw()
      if typestr.startswith('vec<'):
        typestr = typestr.replace('vec<', 'list<')

      /# Generate the code.
      output.append(
        "%s%s.new%s(" % (indent, command_var, 'Arg' if isarg else 'Flag'))
      /# baselang_default = baselang.metabaseValue(default)
      output.append(
        "%s  '%s', mytype='%s', default=%s," % (
          indent, name, typestr, baselang_default))
      if aliases:
        aval = aliases.asStr(unquote=True)
        output.append("%s  aliases='%s'," % (indent, aval))
      if summary:
        output.append(
          "%s  summary='%s'," % (indent, summary.replace("'", "\\'")))
      if desc:
        output.append(
          "%s  desc='%s'," %
          (indent, desc.replace('\n', '\\n').replace("'", "\\'")))
      if isarg and typestr.startswith('list<'):
        output.append("%s  multi=True," % indent)
      output.append("%s)" % indent)
    test:
      output = []
      test.flag.generatePython('cvar', output)
      test.iseq(
        ['cvar.newFlag(',
         "  'bool', mytype='bool', default=False,",
         "  aliases='b',", ')',
        ],
        output)
    end method generatePython;

  end class FlagConstruct;

  abstract
  class StatementConstruct < OoplConstruct #:
    @_statement_: abstract superconstruct for all statement constructs

    These are constructs in Meta(Oopl)* that can appear within complex
    blocks representing statement level code.

    TODO(wmh): Consider removing StatementConstruct, or at least address the
    various special cases that pose problems using single-inheritance:
     - VarConstruct
        - is a statement but also appears in params: and does not need
          symboltables.
     - SetConstruct
        - is a statement but does not need a symboltable.
     - LoopConstruct
        - is a statement and introduces a new scoping level so it needs a
          symboltable for vars defined within it.
     - SwitchConstruct
        - is a statement but vars cannot be introduced within it so no need
          for a symboltable.
     - CallConstruct
        - is optimized away by the specialized expr syntax for it.
     - BlockConstruct
        - can appear in statements, but does not inherit from
          StatementConstruct as it can also appear in almost all other
          scopes.
        - does need a symboltable (and inherits from SymbolConstruct)
  scope:

    field myexec : ExecutableConstruct #:
      The executable this statement is a part of. This implements the
      interface defined in OoplConstruct.

    method isStatement : bool scope:
      return True
    test:
      pass

  end class StatementConstruct;

  class BlockConstruct < SymbolConstruct #:
    @block: A meta-level means of introducing lexical scoping.

    One common use of this construct is to move from Meta(Oopl)* to Meta<X>
    within a complex method block.

    Note that although this is a statement-level construct, it does
    not inherit from StatementConstruct because it is better
    considered a SymbolConstruct (it can introduce new symbols and
    needs a symboltable).

    Examples:
      method f *:
        var a : int = 2;
        block py:
          print('hello')
        js:
          console.log('hello')
        cc:
          // TODO: fix emacs highlighting when double-quotes used in comments
          cout << 'Hello' << endl;
      end method;
  scope:

    field myexec : metax.oopl.ClassConstruct #:
      Since BlockConstruct is not a subclass of StatementConstruct we need
      to explicitly define the myexec field.

    lifecycle setup:
      test.scope = test.constructInCode(
        '/demo.tmp/Test/test/@scope', name='statements')
      test.block1 = test.scope.cons('b1')
      test.block2 = test.scope.cons('b2')
    end;

  end class BlockConstruct;

  class VarConstruct < StatementConstruct #:
    @var: A variable declaration (used in parameters and complex method blocks).

    TODO(wmh): This should NOT inherit from StatementConstruct because:
     1. It can also appear in params: blocks (not purely statement-level)
     2. StatementConstruct defines symboltable fields that are not needed in
        VarConstruct.

    If we do move VarConstruct away from StatementConstruct, make sure to
    implement myexec() and myexecIs(), presumably by defining the 'myexec'
    field like it is defined in StatementConstruct.
  scope:

    field implicitType : metax.oopl.Type #:
      The implicit type of this var based on, for example, the type of the
      value specified in a default attribute.  May be (and usually is) null.

    lifecycle setup:
      test.tpy(statements=True, expand=True)
      test.var1 = test.mscope.cons('f')
      test.var2 = test.mscope.cons('g')
      test.var3 = test.mscope.cons('v')
    end;

    method effectiveType : metax.oopl.Type #:
      The type of this var.
    scope:
      result = self.attrval('type')
      if result.isAny():
        implicit = self.implicitType()
        if implicit:
          result = implicit
      return result
    test:
      Typ = metax.c.Type.Instance
      test.iseq(Typ('int'), test.var1.effectiveType())
      test.iseq(Typ('vec<int>'), test.var3.effectiveType())
    end method effectiveType;

  end class VarConstruct;

  class SetConstruct < StatementConstruct #:
    @set: A generalization of all looping syntax.

    Kinds of sets supported:
     - set i = 1;

    To support:
     - set [i,j,k] = someVec;
     - set [k1,k2,k3] = someMap;
    similar to javascript destructuring assignment: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
  scope:

    lifecycle setup:
      test.scope = test.constructInCode(
        '/demo.tmp/Test/test/@scope', name='statements')
      test.set1 = test.scope.cons('s1')
    end;

  end class SetConstruct;

  class LoopConstruct < StatementConstruct #:
    @loop: A generalization of all looping syntax.

    Kinds of loops supported:
     - for i in enumerable ...
         loop over <expr>

     - for (i = 0; i < 10; ++i)
         loop i from <expr> to <expr> by <expr>
     - while expr ...
         loop while <bool_expr>
     - do ... while expr
         loop until <bool_expr>
  scope:

    lifecycle setup:
      test.scope = test.constructInCode(
        '/demo.tmp/Test/test/@scope', name='statements')
      test.loop1 = test.scope.cons('l1')
    end;

  end class LoopConstruct;

  class SwitchConstruct < StatementConstruct #:
    @if: A generalization of all branching/conditional syntax.

    Kinds of conditionals supported:
     - if .. elif ... else
     - switch a:  case 0: ... case 1: ... default: ...
  scope:
    lifecycle setup:
      test.scope = test.constructInCode(
        '/demo.tmp/Test/test/@scope', name='statements')
      test.switch1 = test.scope.cons('sw1')
      /# NOTE: The actual id is somewhat fragile ... if the code in the
      /# statements sample is extended and implicit ids are assign, this could
      /# change.
      /# test.switch2 = test.scope.cons('h')
      /# test.switch2 = test.scope.cons('Meta__4__')
    end;

  end class SwitchConstruct;

  class CaseConstruct < StatementConstruct #:
    @case: A clause in an 'if' statement.
  scope:

  end class CaseConstruct;

  class CallConstruct < StatementConstruct #:
    @call: A placeholder for callsites.

    This is not intended to be used as a normal construct. Instead, the
    special '@' syntax is handled specially in parseConstruct() and a
    CallConstruct is implicitly created.
  scope:

    method write : int #:
      Serialize this construct.

      Returns:
        For now, always -1, but this may change in the future.
    params:
      var fp : ostream = out #:
        Where to write output.
      var indent : str = '' #:
        How much indentation before each line.
      var mode : map = null #:
        A mechanism for controlling how the output is generated.
        See metax.meta.Construct.write() for details.
    scope:
      /# If this CallConstruct came from the common short-hand notation
      /# (parser finds '@' when expecting construct primary), then
      /# the call construct will have an auto-assigned index and we can
      /# write out the short-hand syntax again. If the id is not auto-assigned,
      /# we print out the full construct.

      if not metax.c.Context.IsAutoId(self.id()):
        /# id not auto-assigned, so we print out the full construct.
        super(CallConstruct, self).write(fp=fp, indent=indent, mode=mode)
      else:
        /# Auto-assigned index means short-hand notation used to describe,
        /# so we print out short-hand notation again.
        term_str = self.termStr(
          mode=mode, lastattr=None, indent=indent, update=True)
        expr = self.attr('expr')
        expr.writeValueLines(fp=fp, indent=indent, mode=mode)
        fp.write(term_str)
    end method write;

  end class CallConstruct;

  class ExternalClassConstruct < metax.oopl.ClassConstruct #:
    A class defined external to Meta, in baselang-space.

    There are admittedly a massive number of unused fields declared and
    initialized by inheriting from ClassConstruct, but there will presumably be
    a relatively small number of classes, never mind non-meta classes, so I'm
    assuming it won't be an issue. Enterprise scale may need a different
    solution (eg. ClassInterface above ClassConstruct and
    ExternalClassConstruct)
  scope:

    lifecycle  params:
      var id : str;
      var parent : metax.oopl.ClassConstruct;
      var context : *metax.oopl.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.variantIs('baselang')
      /# TODO(wmh): We could do baselang introspection (for those languages
      /# supporting it) to initialize fields like parentclasses(), deps(),
      /# testclass(), namespace(), fields(), etc.  For now, we do not do so.
      self.parentclassesIs([])
    end;

    method parentclass : metax.oopl.ClassConstruct #:
      Obtain a parent class by index in superclass list.

      NOTE: Until ClassConstruct.importMeta() is invoked on this class,
      this method will return null.
    params:
      var index : int = 0 #:
        The index in self.parentclasses() of desired parent.
    scope:
      /# TODO(wmh): We could use baselang introspection to obtain the
      /# actual parent class of this baselang class, and dynamically
      /# create a new ExternalClassConstruct.
      return None
    test:
      test.tpy()
      eclass = metax.oopl.ExternalClassConstruct(
        'faux', None, test.context, precount=1)
      test.isnull(eclass.parentclass())
    end method parentclass;

  end class ExternalClassConstruct;

  behavior kind #:
    The kind of a construct.

    Note that although the implemention in OoplConstruct would be sufficient,
    since this method is called often (and not cached), we provide per-subclass
    optimizations even though they are trivial. We could just store the kind as
    a field (which was initially avoided to save space, but given how huge
    the Construct class is now, one more field is irrelevant).
  scope:

    receiver OoplConstruct ::
      name = self.__class__.__name__
      if not name.endswith('Construct'):
        raise metax.c.Error(
          'OoplConstruct.kind() expects %s to end with Construct' % name)
      kind = name[:-len('Construct')].lower()
      return kind
    test:
      loop = test.constructInCode(
        '/demo.tmp/Test/test/l1', name='statements')
      test.iseq('loop', loop.kind())
      method = loop.parentConstruct()
      test.iseq('method', method.kind())
      klass = method.parentConstruct()
      test.iseq('class', klass.kind())
      namespace = klass.parentConstruct()
      test.iseq('namespace', namespace.kind())
      /# Note that FileConstruct is outside Meta(Oopl) and uses different
      /# logic than constructs in Meta(Oopl) for establishing name from class.
      file = namespace.parentConstruct()
      test.iseq('File', file.kind())
    end receiver OoplConstruct;

    receiver NamespaceConstruct ::
      return 'namespace'
    test:
      pass

    receiver ClassConstruct ::
      return 'class'
    test:
      pass

    receiver FieldConstruct ::
      return 'field'
    test:
      pass

    receiver AccessorConstruct ::
      return 'accessor'
    test:
      pass

    receiver ExecutableConstruct ::
      return '_executable_'
    test:
      pass

    receiver MethodConstruct ::
      return 'method'
    test:
      pass

    receiver LifecycleConstruct ::
      return 'lifecycle'
    test:
      pass

    receiver BehaviorConstruct ::
      return 'behavior'
    test:
      pass

    receiver ReceiverConstruct ::
      return 'receiver'
    test:
      pass

    receiver CategoryConstruct ::
      return 'category'
    test:
      pass

    receiver RemarkConstruct ::
      return 'remark'
    test:
      pass

    receiver NativeConstruct ::
      return 'native'
    test:
      pass

    receiver AssocConstruct ::
      return 'assoc'
    test:
      pass

    receiver TestxConstruct ::
      return 'testx'
    test:
      pass

    receiver ResourceConstruct ::
      return 'resource'
    test:
      pass

    receiver CommandConstruct ::
      return 'command'
    test:
      pass

    receiver FlagConstruct ::
      return 'flag'
    test:
      pass

    receiver BlockConstruct ::
      return 'block'
    test:
      pass

    receiver VarConstruct ::
      return 'var'
    test:
      pass

    receiver SwitchConstruct ::
      return 'switch'
    test:
      pass

    receiver CaseConstruct ::
      return 'case'
    test:
      pass

  end behavior kind;

  behavior expandMeta params:
    var output : vec<metax.c.Construct> = null #:
      Where to write constructs created during expansion.
  scope:

    abstract
    receiver OoplConstruct #:
      Each subclass overrides this method to perform expansion of the
      construct associated with the subclass. The code in these
      implementations are mostly baselang-agnostic, since they deal with the
      creation of implicit Meta-level constructs, moving constructs around,
      etc. However, some special-casing is needed based on esoteria of
      individual baselangs.

      IMPORTANT ISSUES TO KEEP IN MIND:
       - each construct should be expanded exactly once (not counting
         situations where an expandMeta() method is invoked on a construct and
         it is determined that nothing should be done for the instance in
         question (this can happen, for example, when invoking expandMeta() on
         class-level constructs ... if the location is 'meta' or 'test' the
         construct is moved to a different class and the current invocation
         should NOT do any further expansion (expansion will happen when the
         other class is expanded).
       - each construct is reponsible for invoking expandMeta() on its
         children
       - if an expandMeta() method creates new sub-constructs, whether or
         not the new construct should have expandMeta() invoked on it depends
         on the following:
          - if the new construct is added to a different class or namespace,
            it should NOT need to be immediately expanded, as it will be
            expanded when that other class/namespace is expanded (as long
            as that other class/namespace hasn't already been expanded).
          - if the new construct is added to the same class, and the new
            construct has an expandMeta() defined, one should in most cases
            invoke expandMeta() on that sub-construct at the time it is
            created.

       - NamespaceConstruct.expandMeta(), when invoked on a user-defined
         namespace, creates a test namespace, then expands all subconstructs
         of the user-defined namespace (which populates the test namespace
         with various constructs).
          - At the end of this expandMeta(), the test namespace is expanded
            via a call to expandMeta().
          - No construct needs to expand any autogened subconstruct that is
            placed into the test namespace ... it will be expanded when the
            test namespace is expanded.

       - ClassConstruct.expandMeta(), when invoked on a user-defined
         namespace, creates a metaclass then expands all subconstructs of the
         user-defined class (which populates the metaclass with meta-level
         constructs, and populates the test namespace with test-level
         constructs).
          - At the end of ClassConstruct.expandMeta(), the metaclass is
            expanded via another call to expandMeta()
          - No construct needs to expand any autogened subconstruct that is
            placed into the metaclass ... it will be expanded when the
            metaclass is expanded.
    end receiver OoplConstruct;

    receiver NamespaceConstruct ::
      /# Expand the namespace:
      /#  - Create test namespace
      /#  - Recurse to children.
      metax.c.D.expand.sinfo(self.kindfqn())
      name = self.id()
      fqn = self.fqn()
      parent = self.parent()
      context = self.context()
      children = self.attrval('scope:')

      if fqn.endswith('_test'):
        /# We are expanding the auto-generated test namespace.
        istest = True
        test_name = None
        testspace = None

      else:
        istest = False
        test_name = name + '_test'

        /# TODO(wmh): Create multiple namespaces, one for each part in
        /# the id. This will be a good transition test for doing something
        /# similar for the user namespace.

        /# Create the test namespace
        secondaries = [
          ('comment:', ['Auto-generated test namespace for %s.' % name]),
          ('scope:', [])
        ]
        testpreports_attr = self.attr('testpreports:', default=None)
        if testpreports_attr:
          secondaries.append(('preports:', testpreports_attr.value()))
        testsuite_attr = self.attr('testsuite:', default=None)
        if testsuite_attr:
          secondaries.append(('testsuite:', testsuite_attr.value()))
        testspace = metax.oopl.NamespaceConstruct.NewFromData(
          /# TODO(wmh): Verify that the implicit testspace should share the
          /# same context as the user namespace.
          test_name, context, parent=parent,
          secondaries=secondaries,
          precount=1,
        )
        self.testspaceIs(testspace)
        self.userspaceIs(self)
        testspace.userspaceIs(self)
        testspace.testspaceIs(testspace)
        if output is not None:
          output.append(testspace)

        /# TODO(wmh): If 'name' (aka self.id()) contains dots, we need to
        /# modify the chain of parents
        /#  - find/create NamespaceConstruct instances for each component of
        /#    the id, with proper parent and a new 'scope:' attribute.
        /#  - unregister self from its current parent, register within the
        /#    new parent, and update self.id().

      /# Register this namespace with the FileConstruct so that ClassConstructs
      /# can properly insert themselves into implicit namespaces.
      /#  - we also create a scope block if one does not exist.
      if self.isUser():
        file_construct = self.ancestor('File')
        file_construct.currentIs(self)
        /# print(
        /#   'Setting current of %s to %s' %
        /#   (file_construct.kindfqn(), self.kindfqn()))

      /# Invoke expandMeta() on child constructs.
      /#  - we make a copy of children so that we do NOT expand the classes
      /#    added to children by calls to child.expandMeta().
      user_children = list(children)
      for child in user_children:
        /# All constructs within namespace should have a namespace field
        /# within which we can cache the namespace.
        child.namespaceIs(self)

        /# Some child classes need to be expanded now, while others should NOT
        /# be expanded now because they will be expanded later (expanding a
        /# class twice can cause problems).
        expand = True

        /# If the child is a class
        /#  - if we are processing a user-level namespace:
        /#      - the class is either a 'user' class, a 'metauser'
        /#        class or a 'testuser' class.
        /#  - if we are processing a test namespace:
        /#      - the class is either an auto-generated test class associated
        /#        with a user class, or is a user-provided test class.
        /#  - It is important to set variant before invoking expandMeta.
        if child.kind() == 'class':
          if istest:
            /# We are in a autogened testspace.
            /#
            /# The testspace is not expanded until after the user namespace has
            /# been expanded, which means all user classes have been expanded
            /# and the various autogenerated classes have been created. Since
            /# ClassConstruct.expandMeta() sets the 'variant' field of the
            /# autogenerated fields, we can use the variant to distinguish
            /# between autogenerated classes and user-specified test classes.
            /#  - autogen test classes will have variant 'test'
            /#  - user-provided test classes will have variant 'testuser'
            testvariant = child.variant()
            if testvariant == 'test':
              /# auto-generated test class associated with user class.
              pass
            elif testvariant == 'metatest':
              /# autogened metaclass for autogened testclass of user class.
              pass
            elif testvariant == 'testuser':
              /# user-provided test class.
              pass
            elif testvariant == 'testmeta':
              /# autogened testclass for autogened metaclass of user class.
              pass
            else:
              child.write()
              raise metax.c.Error('Unhandled testvariant "%s"' % testvariant)
          else:
            self._setClassVariant(child)

        /# Expand the child (class, etc.)
        if expand:
          child.expandMeta()

      if testspace:
        /# The testspace variable is defined only if we are in the user
        /# namespace and have finished expanding the user code base.  By
        /# invoking expandMeta() on testspace we ensure that any constructs
        /# added to that namespace are properly expanded next.
        testspace.expandMeta()
      metax.c.D.expand.end()
    test:
      test.tpy()
      test.isnull(test.namespace.testspace())
      output = []
      test.namespace.expandMeta(output=output)
      test.notnull(test.namespace.testspace())
      test.iseq(
        ['namespace demo.tmp_test'],
        [o.kindfqn() for o in output])
    end receiver NamespaceConstruct;

    receiver ClassConstruct ::
      /# Expansion depends on variant
      /#  - user:
      /#     - create test class, meta class, test metaclass and meta testclass.
      /#        - test class: nm.sp_test.ClassTest
      /#        - meta class: nm.sp.Class__Meta
      /#        - test class for metaclass: nm.sp.Class__MetaTest
      /#        - meta class for testclass: nm.sp_test.ClassTest__Meta
      /#     - expand children
      /#  - meta or test or metatest or testmeta or metauser:
      /#     - expand children
      /#  - testuser:
      /#     - if we are currently in the user namespace
      /#        - move the class into the test namespace
      /#        - DO NOT expand children, do not create initializer, etc.
      /#     - else (we are in the testspace)
      /#       - expand children
      metax.c.D.expand.sinfo('%s variant %s' % (self.kindfqn(), self.variant()))

      name = self.id()
      fqn = self.fqn()
      variant = self.variant()
      baselang = self.baselang()
      basel = baselang.id()
      metafile = self.metafile()
      metac = metafile.compiler()
      context = self.context()
      namespace = self.namespace()
      incnmsp = namespace.fqn() in ('metax.c', 'metax.meta')

      /# We first parse the parent specification into self.parentclasses().
      /#  - TODO(wmh): Support 'parents:' in addition to 'parent' (along
      /#    with 'testparents:' and 'metaparents:')
      /#  - It is important that we initialized parentclasses() before
      /#    moving on to variant-specific functionality because some of
      /#    that code needs to call metaClassInfo() which relies on
      /#    parentclasses() being initialized.
      /#  - This is somewhat problematic because it means that user-provided
      /#    test classes will execute this code twice (once when expanding the
      /#    class within the user namespace, and again when it is expanded
      /#    in the test namespace).
      self.initParentClasses()

      newclasses = []
      metaclass = None
      proceed = None

      scope, children = self.attrpair('scope:', default=None)
      span = self.attrval('span')
      presence = self.attrval('presence')
      autogen = self.autogenInfo()

      if not scope and span != 'specific' and presence != 'abstract':
        if self.isErrorClass():
          /# It is common for error classes to not need a scope. We create
          /# a dummy empty scope.
          /# TODO(wmh): There are probably other examples of classes not
          /# needing scopes ... do we want to generalize, or is this the only
          /# case that is commonly without a scope?
          children = []
          scope = metax.attr.ComplexBlock(
            self, 'scope:', children, line=self.primary().line())
          self.registerAttribute(scope)
          /# TODO(wmh): By inserting this scope, canonicalization will produce
          /# the scope unless we somehow mark it as implicit and avoid
          /# printing implicit attributes during canonicalization.
          proceed = True
        else:
          metafile.error(
            'The concrete general %s has no scope' % self.kindfqn())
          proceed = False

      if not scope and span == 'specific':
        /# This class is only defined for baselangs that provide a scope, and
        /# no scope is present, so we remove the class entirely.
        /#  - TODO(wmh): Is complete removal the right approach? Or should we
        /#    introduce a 'disabled' field in class constructs instead?
        self.parent().unregisterConstruct(self)
        proceed = False

      elif variant is None:
        raise metax.c.Error(
          'ClassConstruct.expandMeta: invoked before variant set')

      elif variant == 'user':
        /# We are in the user-provided class.
        /# userclass = self.userclass()
        /# testclass = self.testclass()
        /# metaclass = self.metaclass()

        /# We disallow user-level classes from starting or ending with
        /# 'Meta' because:
        /#   - <Class>Meta represents the metaclass of <Class>
        /#   - Meta<Class> represents the singleton instance of <Class>Meta
        /#   - we don't want to introduce conflicts between user-defined
        /#     classes starting/ending with 'Meta' and the above symbols.
        /# CODE TANGLE: meta-disallowed
        if name.endswith('Meta') and not incnmsp:
          metafile.warning(
            'User-level class "%s" should not end with "Meta"' % name,
            line=self.primary().line())
        if name.startswith('Meta') and not incnmsp:
          metafile.info(
            'User-level class "%s" should not start with "Meta"' % name,
            line=self.primary().line())

        testspace, testblock, testname, testparent = self.testClassInfo()
        if autogen['test']:
          /# Create the auto-generated test class
          /#  - we also explicitly create an initializer, as we need to pass in
          /#    a special name parameter.
          /#  - TODO(wmh): verify there isn't a race-condition here if
          /#    the special TestCase class is defined with location 'test' in
          /#    user code. Does it need to appear BEFORE the classes it is
          /#    meant to affect?
          testclass = metax.oopl.ClassConstruct.NewFromData(
            /# TODO(wmh): Verify that test class should share same context as
            /# user class.
            testname, context, parent=testblock,
            features=[('location', 'test')],
            secondaries=[
              ('parent', testparent),
              /# TODO(wmh): Test classes can have metaclasses ... what should
              /# the metaparent of the testclass be?
              /# ('metaparent', '?'),
              ('assocs:', []),
              ('comment:', ['Auto-generated test class for ' + fqn]),
              ('scope:', [])
            ],
            precount=1)

          /# Create the auto-generated metaclass for the auto-generated
          /# testclass
          if metax.c.Compiler.IMPL['metatestclass']:
            metatestname = metax.oopl.ClassConstruct.MetaifyName(testname)
            metatestblock = testblock
            metatestparent = metax.oopl.ClassConstruct.MetaifyName(testparent)
            metatestparent2 = metax.oopl.ClassConstruct.MetaifyName(
              'metax.test.TestCase')
            metatestclass = metax.oopl.ClassConstruct.NewFromData(
              /# TODO(wmh): Verify that metatest class should share same context
              /# as user class.
              metatestname, context, parent=metatestblock,
              features=[('location', 'meta')],
              secondaries=[
                ('parent', metatestparent),
                ('comment:',
                 ['Auto-generated meta class for auto-generated test class '
                  + testclass.fqn()]),
                ('scope:', []),
              ],
              position='-' + testname,
              precount=1,
              primary_line=self.primary().line(),
            )
          else:
            metatestclass = None
        else:
          testclass = None
          metatestclass = None

        /# Create the auto-generated meta class
        if autogen['meta']:
          metaclass = self.generateMetaClass()
          metaname = metaclass.id()

          if not metax.c.Compiler.IMPL['testmetaclass']:
            /# There is very little benefit to creating an auto-generated test
            /# class associated with the auto-generated meta-class of a user
            /# class. Rather, methods defined on metaclasses can have their test
            /# methods defined on the auto-generated test class of the user
            /# class. This makes things conceptually simpler without loss of
            /# generality.
            testmetaclass = None
          else:
            /# Create the auto-generated testclass for the auto-generated
            /# metaclass
            testmetaname = metax.oopl.ClassConstruct.TestifyName(metaname)
            testmetablock = testblock
            testmetaparent = testparent
            testmetaclass = metax.oopl.ClassConstruct.NewFromData(
              /# TODO(wmh): Verify that test class should share same context as
              /# user class.
              testmetaname, context, parent=testmetablock,
              features=[('location', 'test')],
              secondaries=[
                ('parent', testmetaparent),
                ('comment:',
                 ['Auto-generated test class for auto-generated '
                 'meta class %s.' % metaclass.fqn()]),
                ('scope:', []),
              ],
              precount=1)
        else:
          metaclass = None
          testmetaclass = None

        /# Move/copy assoc constructs to test/meta classes.
        assocs_attr, assocs = self.attrpair('associations:', default=None)
        if assocs_attr:
          test_assocs = testclass.attr('associations:') if testclass else None
          meta_assocs = metaclass.attr('associations:') if metaclass else None
          /# NOTE(wmh): Important to iterate over list(assocs) because we may
          /# modify 'assocs' by moving constructs to test_assocs or meta_assocs.
          for dep in list(assocs):
            /# Each dep is either 'assoc' or 'resource'. Both constructs
            /# have a 'location' field that indicates where the construct
            /# belongs. The 'assoc' location is special in that 'usertest'
            /# is also meaningful.
            /# TODO(wmh): implement this as a multi-valued feature value
            /# instead).
            akind = dep.kind()
            if akind == 'remark': continue
            aloc = dep.attrval('location')

            if aloc == 'user':
              /# Things are fine just as they are.
              pass
            elif aloc == 'test':
              if test_assocs:
                dep.changeParent(test_assocs)
              else:
                metafile.error(
                  'Cannot specify location test for construct %s when '
                  'testclass disabled' % kind,
                  line=dep.primary().line())
            elif aloc == 'meta':
              if meta_assocs:
                dep.changeParent(meta_assocs)
              else:
                metafile.error(
                  'Cannot specify location meta for construct %s when '
                  'metaclass disabled' % kind,
                  line=dep.primary().line())
            elif aloc == 'usertest':
              if akind == 'resource':
                metafile.error(
                  'resource constructs do not support location %s' % aloc,
                  line=dep.primary().line())
              else:
                /# This is a special case ... we need the construct to stay
                /# in the user class but also appear in the test class. We
                /# clone and register.
                if test_assocs:
                  testdep = dep.clone(test_assocs)
                  /# TODO(wmh): Consider deleting the 'location' attribute
                  /# from testdep, but it is actually fine as-is (not used
                  /# in translateMeta()) and may serve a useful purpose.
                  test_assocs.registerConstruct(testdep)
                else:
                  metafile.error(
                    'Cannot specify location usertest for construct %s when '
                    'testclass disabled' % kind,
                    line=dep.primary().line())

            else:
              raise metax.c.InternalError('Invalid assocs child kind %s' % kind)

        /# Initialize class fields of user class
        self.userclassIs(self)
        self.underclassIs(None)
        self.testclassIs(testclass)
        self.metaclassIs(metaclass)

        /# Initialize class fields of test class
        if testclass:
          testclass.variantIs('test')
          testclass.userclassIs(self)
          testclass.underclassIs(self)
          testclass.testclassIs(None)
          testclass.metaclassIs(metatestclass)
          testclass.namespaceIs(testspace)
          /#newclasses.append(testclass)

        /# Initialize class fields of meta class
        if metaclass:
          metaclass.variantIs('meta')
          metaclass.userclassIs(self)
          metaclass.underclassIs(self)
          if metax.c.Compiler.IMPL['testmetaclass']:
            metaclass.testclassIs(testmetaclass)
          else:
            /# We are not generating test clases for metaclasses of userclasses,
            /# and are instead adding test methods for meta-methods to the
            /# testclass of the userclass.
            metaclass.testclassIs(testclass)
          metaclass.metaclassIs(None)
          metaclass.namespaceIs(namespace)
          newclasses.append(metaclass)

        /# Initialize class fields of metatest class
        if metatestclass:
          metatestclass.variantIs('metatest')
          metatestclass.userclassIs(self)
          metatestclass.underclassIs(testclass)
          metatestclass.testclassIs(None)
          metatestclass.metaclassIs(None)
          metatestclass.namespaceIs(testspace)
          /#newclasses.append(metatestclass)

        /# Initialize class fields of testmeta class
        if testmetaclass:
          testmetaclass.variantIs('testmeta')
          testmetaclass.userclassIs(self)
          testmetaclass.underclassIs(metaclass)
          testmetaclass.testclassIs(None)
          testmetaclass.metaclassIs(None)
          testmetaclass.namespaceIs(testspace)
          /#newclasses.append(testmetaclass)

        if autogen['meta']:
          self.generateImplicitMeta()

        /# We not recurse if there isn't any scope.
        proceed = True if scope else False

      elif variant == 'testuser':
        /# We are in a user-provided test class
        /#  - the class is moved into the test scope.
        /#  - no further class-level expansion is needed (but child
        /#    constructs need expanding).
        /#  - the location is 'test', and stays as test even when we move
        /#    to the test namespace (used to determine what the receiver
        /#    should be).
        if namespace.variant() == 'user':
          /# We are expanding the user-provided test class within the
          /# user namespace.  Move to the testspace and do NOT do any
          /# further expansion of the class (it will be done when the
          /# testspace is expanded).
          testspace = namespace.testspace()
          testblock = testspace.attr('scope:')
          /# If an explicit user-provided test class named 'TestCase' exists
          /# in a namespace, then all implicitly generated test classes in
          /# the namespace will inherit from this class. In order for this
          /# to work, the TestCase class needs to appear at the top of the
          /# testspace.
          position = '-' if self.id() == 'TestCase' else None
          self.changeParent(testblock, position=position)
          proceed = False
        else:
          /# We are expanding the user-provided test class now that it has
          /# been moved to the testspace ... full expansion is needed.
          proceed = True

          /# We need to generate a metaclass for the user-provide testclass.
          /# - note that this is NOT guarded by Compiler.IMPL['metatestclass']
          /#   because this is an explicit test class, not an implicit one,
          /#   and we always support meta fields/methods on explicit test
          /#   classes because such classes are often providing a test version
          /#   of a user-class, and should have all the same functionality as
          /#   those user-classes.
          metatestclass = self.generateMetaClass()
          metatestclass.variantIs('metatestuser')
          metatestclass.namespaceIs(namespace)
          metatestclass.initParentClasses()
          self.metaclassIs(metatestclass)
          newclasses.append(metatestclass)

      elif variant == 'metatestuser':
        /# The auto-generated meta class of a user-defined test class.
        proceed = True

      elif variant == 'metauser':
        /# We are in a user-provided meta class
        /#  - this looks exactly like a normal class except that the receiver
        /#    is 'meta'
        /#  - stays in same namespace
        proceed = True

      elif variant in ('test', 'meta', 'testmeta', 'metatest'):
        /# A class with any of these variants does not require any class-level
        /# expansion (they were expanded when the underlying user
        /# class was encountered)

        if variant == 'test':
          self.generateImplicitMeta()

        proceed = True

      else:
        raise metax.c.Error('Unknown class variant ' + variant)

      if proceed is None:
        raise metax.c.InternalError('Failed to initialize proceed')

      elif proceed:
        /# We are to perform actual expansion on this class.

        /# Invoke expandMeta() on child constructs.
        /#  - we make a copy of children so that we do NOT expand the implicit
        /#    children added to children by calls to child.expandMeta().
        if children is None:
          children = []
        for child in list(children):
          child.myclassIs(self)
          child.expandMeta()

        if output is not None:
          output.extend(newclasses)

        /# If this class has any packed fields, we generate
        /#  - a method for obtaining all unpacked values
        /#  - a getter for the pack field itself???
        /#  - a method for setting all packed fields???
        packed = self.packed()
        if packed:
          /# TODO(wmh): Fix this ... use
          /#   baselang.receiverStr(method, style='base', sep=True)
          recsepstr = 'self.'
          stmtend = ''
          for pack in packed:
            rawpack = '_' + pack
            packmap = packed[pack]
            lines = []
            lines.append('value = %s%s%s' % (recsepstr, rawpack, stmtend))
            /# fields with pack are sorted ascending by bit position within
            /# pack.
            fnames = sorted(packmap, key=lambda f: packmap[f][0])
            tlist = []
            for fld in fnames:
              start_bit, bits, signed = packmap[fld]
              mask = (1 << bits) - 1
              if signed:
                halfval = 1 << (bits-1)
                lines.append(
                  '%s = (value & 0x%x) - %d%s' % (fld, mask, halfval, stmtend))
              else:
                lines.append('%s = value & 0x%x%s' % (fld, mask, stmtend))
              lines.append('value >>= %d%s' % (bits, stmtend))
              tlist.append('int' if signed else 'uint')
            lines.append(
              'return (%s)%s' % (', '.join(reversed(fnames)), stmtend))
            /# TODO(wmh): Make this a tuple of ints and uints according to
            /# whether each field above is signed or unsigned.
            anytype = metax.c.Type.Instance(
              'tuple<%s>' % ','.join(reversed(tlist)))
            spreader = metax.oopl.MethodConstruct.NewFromData(
              '%sSpread' % pack, context, parent=scope,
              features=[],
              secondaries=[
                (':', anytype),
                ('scope:', lines)
              ])
            spreader.myclassIs(self)

        context = self.context()
        initializer = self.initializer()

        if initializer:
          if basel == 'javascript':
            use_es2015_classes = baselang.config('use_es2015', False)
            if not use_es2015_classes:
              /# In Javascript, if one is defining classes by explict function
              /# definition, the initializer needs to be the first construct
              /# generated.  However, if ES2015 classes are used, it does not
              /# need to be first.
              for i, child in enumerate(list(children)):
                if child is initializer:
                  if i != 0:
                    children.pop(i)
                    children.insert(0, initializer)
                  break
        else:
          /# If there is no explicit initializer, we define one.
          /#  - In javascript, required if not using ES2015 classes, since
          /#    the initializer function is what actually defines the class.
          /#  - useful in other languages because we often need to insert
          /#    implicit field initialization code.
          /#     - we can optimize unnecessary initializers out of the code
          /#       in translateMeta().
          /#  - the metafile line number is set to -1 because there is no
          /#    actual meta code associated with this implicit initializer.
          initname = baselang.initializerName(self)
          secondaries = []

          /# TODO(wmh): Need a cleaner way of determining whether a test class
          /# does NOT inherit from metax.test.TestCase.
          if (variant == 'user' or
              (variant == 'testuser' and self.id() != 'TestCase')):
            /# We need to ensure that we accept the same args as the parent, and
            /# pass those args up via super(). For meta and test classes the
            /# param list is not user-provided (so we don't provide params
            /# for them here either), but for user classes we must pass args
            /# up to parent.
            /#
            /# An implementation that works for all baselangs relies on Meta
            /# implicitly compiling all .meta files needed in order to have
            /# a complete transitive understanding of the inheritance hierarchy
            /# dictated by the source .meta files.  That will give us
            /# ClassConstruct instances for every ancestor, and allow us to
            /# establish the exact signature of the initializer.
            /#
            /# As a stop-gap implementation that will work only for Python,
            /# we add some *arg,**kwds delegation.
            /#
            /# TODO(wmh): Get this working in all baselangs.  Note that the
            /# alternative is to require that a lifecycle construct (and
            /# associated scope:) always be explicitly defined in user classes,
            /# and leave it up to the user to properly delegate up the
            /# stack.
            secondaries.append((':', metax.c.Type.Instance('void')))
            if basel == 'python':
              params = metax.oopl.ExecutableConstruct.CreateParams(
                [
                  {'var': 'args',
                   'features': [('multiplicity', 'multi')],
                   'secondaries': [(':', metax.c.Type.Instance('vec'))]},
                  {'var': 'kwds',
                   'features': [('multiplicity', 'multi')],
                   'secondaries': [(':', metax.c.Type.Instance('map'))]},
                ],
                context)
              secondaries.append(('params:', params))
              super_expr = metax.c.Expr.FromStr(
                '(args, kwds)', attribute=ClassConstruct.DummySuperAttribute)
              secondaries.append(('super', super_expr))
            elif basel == 'cpp':
              /# TODO(wmh): How do we invoke the parent constructor with
              /# all the same args?
              pass
            elif basel == 'javascript':
              /# TODO(wmh): Use the 'arguments' variable to handle this.
              pass
            else:
              raise metax.c.Error(
                'Not yet handling implicit initializers for %s' % basel)

          secondaries.append(('scope:', [], -1))
          initializer = metax.oopl.MethodConstruct.NewFromData(
            initname, context, parent=scope,
            features=[('kind', 'initializer')],
            secondaries=secondaries,
            primary_line=-1,
            position='-')

          /# print(
          /#   'WARNING: created implicit %s (%s)' %
          /#   (initializer.fqn(), self.isTest()))
          /# initializer.write()
          self.registerInitializer(initializer)

          /# In situations where we have classes like:
          /#    class Error < metax.root.Error;
          /#    class InternalError < Error;
          /# note that the termcode for both of the above is 1. After inserting
          /# the implicit initializer, it is not very readable to terminate with
          /# just a semicolon, so we upgrade the termcode. Similarly, we insert
          /# an empty line before such constructs in the interests of
          /# readability.
          if self.termcode() == 1:
            self.termcodeIs(3)
          if self.precount() == 0:
            self.precountIs(1)

        /# Perform auto-generation of serializers, sizers, etc.
        if self.isUser():
          if False and metac.importlist():
            /# If this metafile is being parsed implicitly (not explicitly
            /# specified on the command line), we do not need to generate
            /# the various auto methods. HOWEVER, although we can determine
            /# whether we are currently performing an import by looking at
            /# importlist(), we do not currently have a convenient way of
            /# establishing whether the current metafile is ALSO explicitly
            /# specified on the commandline. This is important because of the
            /# following:
            /#  - suppose we do:
            /#     % metac a.meta b.meta
            /#  - support further that a.meta depends on b.meta and will thus
            /#    parse b.meta as part of parsing itself.
            /#  - if, when invoking expandMeta() on b.meta during the processing
            /#    of a.meta, they will be missing from the output even though
            /#    if b.meta were compiled by itself the autogen methods would
            /#    be added.
            /# Some solutions:
            /#  1. Do not disable autogen for implicit methods (easy)
            /#  2. Invoke _autogenAll() somewhere more general, such that it
            /#     is always invoked on explicitly specified metafiles.
            /#      - probably quite easy, but not verified
            /#  3. Maintain the list of explicitly specified metafiles someplace
            /#     accessible from this code point, and conditionally invoke
            /#     _autogenAll based on whether the metafile is also explicitly
            /#     specified.
            /#
            /# Currently implementing 1. but 2. is probably easy and 3. is
            /# not preferred.
            print(
              'No  %s, doing import so not invoking _autogenAll' %
              self.kindfqn())
          elif self.isErrorClass():
            /# no autogen
            pass
          else:
            /# For now, we do not generate these methods for classes found
            /# during importMeta.
            /# TODO(wmh): Determine whether the above optimization is safe, or
            /# if there are situations where it is important for such methods to
            /# be autogened for dependended-on classes too.
            self._autogenAll()
            /# print('Yes %s, invoking _autogenAll' % self.kindfqn())

        if self.isTest():
          /# There are two different kinds of classes that can appear within a
          /# testspace, those that inherit from metax.test.TestCase and those
          /# that do not. For the former, the initializer of such classes should
          /# never have an explicit params: or 'super' specified, and an
          /# implicit params: containing a single 'var meta__name : &str' is to
          /# be added (and passed up via an auto-inserted 'super (meta__name)'.
          /# However, the latter kind of class can have an initializer with
          /# arbitrary signature and is not modified by this code.
          /#
          /# TODO(wmh): Remember that inheritsFromTestCase() is currently
          /# hacky .. .need to fix it!
          if self.inheritsFromTestCase() or metax.oopl.ClassConstruct.IsTestName(name):
            /# We assume this class inherits from metax.test.TestCase and thus
            /# needs a special params
            params = initializer.attr('params:', default=None)
            if params is not None:
              print(params)
              params.write()
              metafile.warning(
                'testclass initializer %s '
                '(assumed to inherit from metax.test.TestCase) '
                'should not specify params:' %
                initializer.fqn())
            else:
              /# We add an explicit 'super' and 'params:' attributes.
              super_expr = metax.c.Expr.FromStr(
                '(meta__name)', attribute=ClassConstruct.DummySuperAttribute)
              super = metax.attr.ExprAttribute(initializer, 'super', super_expr)
              /# Create a 'params:' attribute.
              params = metax.oopl.ExecutableConstruct.CreateParams(
                [{'var': 'meta__name',
                  'secondaries': [
                    /# TODO(wmh): In order to get unittesting in C++ working
                    /# with gtest, I needed to make the meta__name arg be
                    /# optional because the TEST_F macro relies on there
                    /# being a constructor that takes no arguments. This
                    /# means that the name of the test method is NOT being
                    /# passed (at least not via the constructor). We can fix
                    /# this by introducing a TEST_M macro that invokes the
                    /# constructor with the method name (after which we could
                    /# remove the default value below).
                    (':', metax.c.Type.Instance('&str')),
                    ('=', metax.c.Expr('str', '""', '""'))]},
                    /# TODO(wmh): In Meta, we need a baselang-independent
                    /# mechanism for initializing a variable to the empty
                    /# value of its type (e.g. "" for string, [] for vec,
                    /# {} for map, etc.). Consider introducing the
                    /# meta-level pseudovar 'empty'. Then we could do:
                    /#   method f : int params:
                    /#     var s : str = empty;
                    /#     var v : vec = empty;
                    /#     var m : map = empty;
                ],
                context)
              initializer.registerAttribute(
                super, position='+' + initializer.primary().key())
              initializer.registerAttribute(params, position='-super')
        else:
          /# The class does NOT inherit from metax.test.TestCase and its
          /# initializer has whatever signature the user specified.
          pass

        if self.isMeta():
          /# For metaclasses, regardless of whether an initializer was
          /# explicitly provided or not, there should never be an explicit
          /# params: attribute. Instead, this code implicitly defines a
          /# 'params:' attribute of a pre-determined signature, and an
          /# associated 'super' attribute to call up the inheritance chain. The
          /# only meta class that does NOT get this implicit treatment is
          /# metax.root.ObjectMetaRoot, which is the special parent of all
          /# meta-defined metaclasses. If a user defines a metaclass with a
          /# parent that is not a subclass of metax.root.ObjectMetaRoot, it is
          /# their responsibility to have the parent initializer accept the same
          /# signature.

          params = initializer.attr('params:', default=None)
          if self.fqn() == 'metax.root.ObjectMetaRoot':
            /# This is the sole exception to implicit params: ... we leave
            /# the class exactly as-is.
            pass
          elif params is not None:
            print('#' * 70)
            print('HERE with %s = %s' % (self.kindfqn(), self.variant()))
            initializer.write()
            print('#' * 70)
            metafile.error(
              'metaclass initializer %s should not specify params:' %
              initializer.fqn(),
              line=initializer.primary().line())
          else:
            /# Currently, metaclass initializers in all baselangs must have
            /# the same signature:
            /#   var name : &str #:
            /#     The name of the class being created
            /#   var bases : &vec<class> #:
            /#     The parent classes of the class
            /#   var symbols : &map #:
            /#     The symbols available within the class.
            /# This signature may need to evolve as more baselangs are added
            /# and we see how the metaclass support in those baselangs
            /# interact with the mandates of Meta.
            /#
            /# All metaclasses should inherit from metax.root.ObjectMetaRoot,
            /# which expects the above params, so we invoke super().

            /# Create a 'params:' attribute
            params = metax.oopl.ExecutableConstruct.CreateParams(
              [
                {'var': 'name',
                 'secondaries': [(':', metax.c.Type.Instance('&str'))]},
                {'var': 'bases',
                 'secondaries': [(':', metax.c.Type.Instance('&#vec<class>'))]},
                {'var': 'symbols',
                 'secondaries': [(':', metax.c.Type.Instance('&#map'))]},
              ],
              context)

            /# Create a 'super' attribute
            if True:
              /# TODO(wmh): Now that Expr.FromStr() exists, we should use it
              /# instead of this hardcoded solution.

              /# Explicit creation
              super_expr = metax.c.Expr(
                'plist', '(name, bases, symbols)',
                [
                  metax.c.Expr('var', 'name', 'name'),
                  metax.c.Expr('var', 'bases', 'bases'),
                  metax.c.Expr('var', 'symbols', 'symbols')
                ]
              )
            else:
              /# Indirect and slow creation
              super_expr = metax.c.Expr.FromStr(
                '(name, bases, symbols)',
                attribute=metax.oopl.ClassConstruct.DummySuperAttribute)
            super = metax.attr.ExprAttribute(initializer, 'super', super_expr)

            iscope = initializer.attr('scope:', default=None)
            if iscope:
              initializer.registerAttribute(super, position='-scope:')
              initializer.registerAttribute(params, position='-super')
            else:
              metafile.error('Missing scope', line=initializer.primary().line())

        if True:
          /# TODO(wmh): Disable this when we go production!
          self.validate()
          metax.c.D.expand.info(
            'Validated %s (%s)' % (self.kindfqn(), self.variant()), level=2)

        /# Register this class with the compiler.
        metac.registerClass(self)

        /# Compute dependencies for this class.
        self.registerDependencies()

        /# Sub-expansions
        /#  - if we are processing a user class, the code above creates four
        /#    autogened classes (metaclass, testclass, metatestclass and
        /#    testmetaclass).
        /#  - The first of these (metaclass) resides in the same namespace as
        /#    the user class, and needs to be explicitly expanded.
        /#  - The rest of the autogened classes reside in the testspace
        /#    associated with the namespace that the user class belongs to, so
        /#    we do NOT need to expand them here (they will be expanded when the
        /#    testspace is expanded at the end of
        /#    NamespaceConstruct.expandMeta().
        for cls in newclasses:
          cls.expandMeta()

      metax.c.D.expand.end()
    test:
      test.tpy()
      test.iseq({}, test.klass.deps())
      test.namespace.expandMeta()  # expand namespace will expand class.
      /# TODO(wmh): Perform tests.
      test.iseq(
        ['demo.tmp.PersonMeta', 'metax.root.Object', 'metax.root.ObjectMeta',
         'os', 'sys'],
        sorted(test.klass.deps()))
    end receiver ClassConstruct;

    receiver FieldConstruct ::
      /# Expand the field
      /#  - produce accessor methods (getter, setter, reffer, etc.)
      /#    in appropriate class depending on level.
      /#  - generate test methods for those fields that request it (when
      /#    accessors are defined).
      /#  - leave the field construct in the user class no matter what
      /#    (translateMeta can decide whether to ignore or not on a per-baselang
      /#    basis).
      metax.c.D.expand.sinfo(self.kindfqn())

      myclass, moved = self.updateClass()
      /# D.expand.info('moved = %s' % moved)

      if moved:
        /# We only expand fields if we haven't moved the field to a different
        /# class (if we have moved it, it will be expanded later when that
        /# class is expanded).
        metax.c.D.expand.info('moved (no further expansion)', level=2)
      else:
        name = self.id()
        fqn = self.fqn()
        if myclass:
          clsname = myclass.id()
          fqcn = myclass.fqn()
          namespace = myclass.namespace()
        else:
          clsname = None
          fqcn = None
          namespace = self.ancestor('namespace')
        nmspfunc = lambda: namespace
        baselang = self.baselang()
        metafile = self.metafile()
        context = self.context()

        kind = self.attrval('kind')
        scope, accessors = self.attrpair('scope:', default=None)
        pack = self.attrval('pack')
        tmpvis = self.attrval('visibility')
        typeattr, type = self.attrpair('type', default=metax.c.LOOKUP)
        if type is None:
          metafile.error('Must provide a type', line=self.primary().line())
          return

        /# We establish the receiver to use for accessors
        /#  - use the receiver dictated by the baselang so that we don't
        /#    incur inefficiencies introducing a variable unlikely to be used
        /#    by the user
        /#  - HOWEVER, when user defines accessors in field scope:, they
        /#    need to know which variable to use to reference the receiver.
        /#    We need to either be consistent, document inconsistencies, or
        /#    auto-insert receiver variables as needed.
        /#  - Note that some baselangs do not have a specific receiver variable
        /#    (e.g. Python and Perl), in which case we use the meta-level
        /#    receiver variable.
        if myclass:
          location = (
            'test' if myclass.isTest()
            else ('meta' if myclass.isMeta() else 'user'))
          receiver_code, receiver_special = (
            baselang.receiverStr(
              self, style='base', sep=True, location=location, myclass=myclass))
          if receiver_code is None:
            receiver_code = receiver_special
        else:
          location = None
          receiver_code = ''

        /# print('FieldConstruct.expandMeta: %s' % fqn)

        /# Register this field with the class.
        if myclass:
          myclass.fields().append(self)

        /# Establish the rawfield of this field
        /# CODETANGLE(fieldinit):
        tokens = metax.c.Context.Tokens()
        packinfo = None
        if pack:
          tbase = type.base()
          tparams = type.params()
          if tbase not in ('int', 'uint') or len(tparams) != 1:
            metafile.error('Invalid packed field', line=typeattr.line())
          else:
            signed = tbase == 'int'
            bits = int(tparams[0])
            packinfo = myclass.registerPacked(name, pack, bits, signed)
          rawfield = tokens['field_prefix'] + pack + tokens['field_suffix']
        elif tmpvis == 'tmppublic':
          rawfield = name
        else:
          rawfield = tokens['field_prefix'] + name + tokens['field_suffix']
        self.rawfieldIs(rawfield)
        stmtend = baselang.config('stmtend')

        /# Establish the default accessor code.
        field_code = '%s%s' % (receiver_code, rawfield)
        legal_accessors = ('get', 'set', 'ref', 'format', 'write', 'size')

        /# Determine if there are any explicit accessors.
        xmap = {}   # explicit accessor code
        lazylines = None
        if scope:
          testclass = myclass.testclass()
          testscope = testclass.attr('scope:') if testclass else None
          for accessor in accessors:
            acc = accessor.id()
            if acc not in legal_accessors:
              metafile.error(
                'Invalid accessor %s' % acc, attr=accessor.primary())
            else:
              acclines = accessor.attrval('scope:', default=None)
              lazy_attr, lazylines = accessor.attrpair('lazy:', default=None)
              if acclines is not None:
                if lazylines is not None:
                  metafile.error(
                    'accessor %s should specify only scope or lazy, not both' %
                    accessor.id(), line=lazy_attr.line())
                xmap[acc] = acclines
              elif lazylines is not None:
                /# We process the lazylines after we've created a getter method
                /# below.
                pass

              /###
              /# Check for explicit test method(s) for this accessor.
              testattr, testlines = accessor.attrpair('test:', default=None)
              testsattr, testxlist = accessor.attrpair('tests:', default=None)
              testdata = []
              if testattr and testsattr:
                metafile.error(
                  'Cannot define both test: and tests:', attr=testsattr)

              elif location == 'test' and (testattr or testsattr):
                metafile.error(
                  'Cannot define test: or tests: attribute on test-level '
                  'fields',
                  attr=testattr or testattr)

              elif testattr:
                /# Simple block of lines.
                testbase = metax.oopl.ExecutableConstruct.TestifyName(self.id())
                if len(testlines) == 0:
                  testlines = baselang.emptyBlockCode(None)
                testdata.append({
                  'name': testbase,
                  'features': [],
                  'secondaries': [],
                  'scope': testlines,
                  'line': testattr.line(),
                })

              elif testsattr:
                /# TODO(wmh): See the expand: code in construct _executable_
                /# for generating test method(s) for methods. We should be able
                /# to use the exact same code for both methods and fields for
                /# generating test methods.
                metafile.error('Not yet handling tests: blocks for fields')

              for testinfo in testdata:
                secondaries = testinfo['secondaries']
                assert 'scope:' not in [p[0] for p in secondaries]
                tscope = testinfo['scope']
                assert tscope is not None
                secondaries.append(('scope:', tscope, testinfo.get('line', -1)))
                unittest = metax.oopl.MethodConstruct.NewFromData(
                  testinfo['name'], context, parent=testscope,
                  features=testinfo['features'],
                  secondaries=secondaries,
                  /# Add at end of test scope. Since we are processing fields
                  /# in order, the test methods will have the same order.
                  position=None)
                unittest.myclassIs(testclass)

        /# Establish which accessors to generate
        genacc = self.establishAccessors(type)

        /# The line number in the metafile at which the field is defined. It
        /# is used for:
        /#  - indicating the (faux) metafile line number of the accessor method
        /#  - indicating the (faux) metafile line number of the accessor scope
        primary_line = self.primary().line()
        dest_scope = self.parent()

        /# Getter
        getvis = genacc.get('get', None)
        if getvis:
          features = [
            ('optimization', 'inline'),
            ('visibility', getvis),
            ('kind', None if kind == 'instance' else kind),
          ]
          getname = name + ':get'
          getter_return = baselang.accessorType(
            type, 'get', namespace_function=nmspfunc)
          gcode = xmap.get(
            'get',
            baselang.accessorCode(
              'get', type, field_code, packinfo=packinfo))
          getter = metax.oopl.MethodConstruct.NewFromData(
            getname, context,
            features=features + [('mutability', 'const')],
            secondaries=[
              (':', getter_return),
              ('scope:', gcode, primary_line),
            ],
            primary_line=primary_line)
          getter.myclassIs(myclass)
          metax.c.D.expand.info('Created getter ' + getter.fqn(), level=2)

          if lazylines:
            /# Each baselang knows how to generate a method body given a lazy
            /# attribute.
            newlines = baselang.lazyLines(
              metafile, getter, lazy_attr, type, rawfield)
            gscope = getter.attrval('scope:')
            del gscope[:]
            gscope.extend(newlines)
        else:
          getter = None

        /# Define the setter
        /#  - See ../../README.md section 'Accessors' for a discussion about
        /#    setter return types. Setters return void.
        /#  - We don't define a setter if the field is const.
        setvis = genacc.get('set', None)
        if setvis:
          features = [
            ('optimization', 'inline'),
            ('visibility', setvis),
            ('kind', None if kind == 'instance' else kind),
          ]
          setret = 'void'
          setname = name + 'Is:set'
          scode = xmap.get(
            'set',
            baselang.accessorCode(
              'set', type, field_code, packinfo=packinfo))
          /# print('%s = %s' % (self.kindfqn(), features))
          setter = metax.oopl.MethodConstruct.NewFromData(
            setname, context,
            features=features,
            secondaries=[
              (':', metax.c.Type.Instance(setret)),
              ('scope:', scode, primary_line),
            ],
            primary_line=primary_line)
          params = metax.oopl.ExecutableConstruct.CreateParams(
            [
              {'var': 'value',
               'secondaries': [
                 ('type', baselang.accessorType(
                   type, 'setarg', namespace_function=nmspfunc))]},
            ], context)
          setter.registerAttribute(params, position='-scope:')
          setter.myclassIs(myclass)
          metax.c.D.expand.info('Created setter ' + setter.fqn(), level=2)
        else:
          setter = None

        /# Define the reffer
        /#  - we don't define a reffer if the field is const.
        refvis = genacc.get('ref', None)
        if refvis:
          features = [
            ('optimization', 'inline'),
            ('visibility', refvis),
            ('kind', None if kind == 'instance' else kind),
          ]
          refname = name + 'Ref:ref'
          rcode = xmap.get(
            'ref',
            baselang.accessorCode(
              'ref', type, field_code, packinfo=packinfo))
          reffer = metax.oopl.MethodConstruct.NewFromData(
            refname, context,
            features=features,
            secondaries=[
              ('returns', baselang.accessorType(
                type, 'ref', namespace_function=nmspfunc)),
              ('scope:', rcode, primary_line),
            ],
            primary_line=primary_line)
          reffer.myclassIs(myclass)
          metax.c.D.expand.info('Created reffer ' + reffer.fqn(), level=2)
        else:
          reffer = None

        /# We insert all accessor methods after the field construct.
        /#  - by inserting reffer, then setter, then getter, we end up
        /#    putting them in the order getter, setter, reffer.
        /#  - we also register the accessors in the symbol table of
        /#    myclass.
        position = '+' + name
        if reffer:
          dest_scope.registerConstruct(reffer, position=position)
          if myclass:
            myclass.registerSymbol(reffer.id(), reffer)
        if setter:
          dest_scope.registerConstruct(setter, position=position)
          if myclass:
            myclass.registerSymbol(setter.id(), setter)
        if getter:
          dest_scope.registerConstruct(getter, position=position)
          if myclass:
            myclass.registerSymbol(getter.id(), getter)

        /# QUESTION: Do we register rawfield or field?
        /#  - From a practical perspective, it is cleaner to register rawfield,
        /#    as that would allow us to register the getter with the :get suffix
        /#    (but doing so means we have to map user-provided field names to
        /#    raw names when resolving -> provide references).
        /#  - From a conceptual perspective, it depends on whether symbols in
        /#    the symbol-table represent what is actually visible to the
        /#    baselang, or whether the symboltable stores conceptual symbols
        /#    that get mapped down to baselang representations later.
        /#
        /#  - Symbols are conceptual names:
        /#    + implementing -> provide semantics is easy
        /#    + in namespace, conceptual symbols would be classnames (baselang
        /#      symbols would require us using the MetaFoo singleton instance,
        /#      at least in languages without first-class classes). Being able
        /#      to refer to classes instead of metaclasses is intuitive, and
        /#      makes it viable for us to define the auto-generator for
        /#        /mem/<metafile>/<namespace>/<class>/<method>
        /#      to be "show the symbol table of the current construct", which
        /#      is pretty convenient.
        /#    + we get to use a high-level receiver string instead of the
        /#      receiver varying from baselang to baselang (admittedly though,
        /#      there is still the 'self'/'meta'/'test' ambiguity).
        /#    - fields use field id not rawfield, at getter needs to be
        /#      suffixed with :get
        /#    - we need to define a means of mapping high-level symbols to
        /#      baselang level.
        /#    - The most intuitive "conceptual" name for a field is its id.
        /#      The most intuitive "conceptual" name for a getter is its id.
        /#      There is an inherent conflict here that is resolved if we use
        /#      the rawname for fields.
        /#  - Symbols are baselang names:
        /#    + no need to perform high-level-to-baselang mapping of symbols,
        /#      since the symbols are already in baseang syntax.
        /#
        /#  - The current implementation is to have the symbol table store
        /#    conceptual names.  We can revisit if we find problems with this.
        /# CODETANGLE(highlevel_symbols):
        if myclass:
          myclass.registerSymbol(name, self)

        if scope:
          self.accessorsIs(scope.map())

      metax.c.D.expand.end()
    test:
      test.tpy()
      /# Before expandMeta, field accessors do not exist.
      test.isnull(test.cscope.cons('name:get', default=None))
      test.isnull(test.cscope.cons('nameIs:set', default=None))

      /# Need to expand from namespace down.
      output = []
      test.namespace.expandMeta(output=output)

      /# After expandMeta, field accessors exists.
      test.notnull(test.cscope.cons('name:get', default=None))
      test.notnull(test.cscope.cons('nameIs:set', default=None))
    end receiver FieldConstruct;

    receiver ExecutableConstruct ::
      /# Expand the executable
      /#  - if level is meta, move method to metaclass
      /#  - if level is test, move method to testclass
      /#  - currently, we do NOT recurse to children, as the children in
      /#    scope: are either lines (simple block) or statement level constructs
      /#    that do not need expansion.
      metax.c.D.expand.sinfo('%s (%s)' % (self.kindfqn(), self))

      myclass, moved = self.updateClass()
      /# D.expand.info('moved = %s' % moved)

      if moved:
        /# We only expand methods if we haven't moved the method to a different
        /# class (if we have moved it, it will be expanded later when that
        /# class is expanded).
        metax.c.D.expand.info('moved (no further expansion)', level=2)

        /# TODO(wmh): In Python, due to some unfortunate ways that metaclasses
        /# interact with @classmethod, we need to provide a @classmethod
        /# implementation of meta methods within the userclass, which means
        /# we need to create some wrapper method.
        /#  - How to establish whether the current method is a meta method
        /#    within user scope?
        /#  - Do we have the @classmethod method defined on the userclass
        /#    call the meta method, or vice-versa?
        /#  - How do we handle class variables vs meta variables?
        pass

      else:
        metafile = self.metafile()
        context = self.context()
        fqn = self.fqn()
        variant = myclass.variant()
        baselang = self.baselang()

        kind = self.attrval('kind')
        span = self.attrval('span')
        scope_attr, scope = self.attrpair('scope:', default=None)
        autogen = self.attrval('autogen')

        if span == 'specific' and scope is None:
          /# This method does not apply to the current baselang, so we remove
          /# it entirely.
          self.parent().unregisterConstruct(self)

        else:
          /# If this is an initializer, record it with the class.
          if kind == 'initializer':
            myclass.registerInitializer(self)

          /# Establish the receiver variable to use.
          rec = baselang.receiverStr(self, style='meta')[0]

          /# We register this executable as a symbol within its class.
          /#  - TODO(wmh): Think more carefully about how symbols should be
          /#    handles for meta and test classes.
          if variant == 'user':
            myclass.registerSymbol(self.id(), self)

          /# If this is a complex block, we initialize myexec() for each
          /# top-level statement within the block.
          if scope_attr is not None and scope_attr.isComplexBlock():
            for stmt in scope:
              stmt.myexecIs(self)

          /# Now initialize the symbol table of the method.
          /#  - for methods with simple blocks, we only have access to the
          /#    params.
          /#  - for methods with complex blocks, we have all vars specified at
          /#    top-level within the method as well.
          /# Note that even though lifecycle constructs create MethodConstruct
          /# instances during expandMeta(), we can still initialize symbols
          /# in the generated MethodConstructs within expandMeta (rather than
          /# importMeta or translateMeta) because expandMeta() is invoked on
          /# the generated method constructs.
          params = self.attrval('params:', default=None) or []
          for i, pvar in enumerate(params):
            self.registerSymbol(pvar.id(), pvar, note='From param #%d' % (i+1))
          /# Now register the receiver.
          /#  - if this is an instance method, the receiver is 'self' or 'this'
          /#  - if this is a meta method, the receiver is 'cls' etc.
          /#  - if this is a static method, there is no receiver.
          /#     - TODO(wmh): In python, I'm defining 'cls' in static methods.
          /#       Should we be calling this 'meta', and defining it in all
          /#       metalangs? It won't be a receiver, but can still be a
          /#       local variable present in static methods.
          /# TODO(wmh): Define a 'var' construct representing 'self' (or 'this')
          /# and 'cls' (or 'meta') stored in ExecutableConstruct, for use in
          /# each method. For now using null.
          mutability = self.attrval('mutability')
          const_mark = '' if mutability == 'mutable' else '#'
          recvar = myclass.receiver(const_mark + rec)
          self.registerSymbol(
            rec, recvar, note='%s for %s' % (rec, self.kindfqn()))

          /# TODO(wmh): In python, due to some unfortunate ways that metaclasses
          /# interact with @classmethod, we need to provide a @classmethod
          /# implementation of meta methods within the userclass (it delegates
          /# to the implementation in the metaclass).
          /#  - How do we establish if this is a meta-method within a user
          /#    class? (

          /# We expand 'test:' and 'tests:' blocks in methods within classes of
          /# the following variants:
          /#   user
          /#   meta
          /#   metauser ???
          /# We do NOT expand test blocks in
          /#   test      (test classes do not have tests)
          /#   testmeta  (test classes do not have tests)
          /#   metatest  (meta classes of test classes do not have tests)
          /#   testuser  (test classes do not have tests)

          testclass = myclass.testclass()
          if (
            (variant in ('user', 'meta'))
            and testclass
            and autogen != 'notest'
            /# TODO(wmh): Find a better way to identify auto-generated methods!
            and not self.id().startswith('metax')
          ):
            /# Define one (or more) test methods within the test class
            /# associated with the class this method is defined within.
            testscope = testclass.attr('scope:')
            testattr, testlines = self.attrpair('test:', default=None)
            testsattr, testxes = self.attrpair('tests:', default=None)

            /# The code below creates one or more entries in testdata based on
            /# data in testattr and testsattr.
            /#  - if neither a test: nor tests: block is found, we create one
            /#    test method printing "test not yet implemented".
            /#  - if test: and tests: are both defined, it is an error
            /#  - if test: is defined, create one test method
            /#  - if tests: is defined, create one test method for each testx
            /#    construct in tests:
            /#  - each element of testdata contains:
            /#      name : str
            /#        The name of the test method
            /#      features : vec<tuple<str,str>>
            /#        The key/value features in order
            /#      secondaries : vec<tuple<str,str>>
            /#        The key/value secondary attributes (except scope:)
            /#      scope : vec<str> or vec<Construct>
            /#        The value to assign to the scope: of the test method.
            /#  - some general observations about feature and secondary
            /#    attributes of test methods:
            /#     - feature attributes are almost always:
            /#        - level instance
            /#        - location user
            /#        - visibility public
            /#        - presence concrete
            /#        - mutability mutable
            /#        - extensibility extendable
            /#        - dispatch autodispatch
            /#        - inheritance new
            /#       (which are the default values for all of these feature
            /#        attrs, so feature attributes are rarely needed).
            /#     - secondary attributes are almost always:
            /#        - no params
            /#        - return type void
            /#        - no tests
            /#        - no super
            /#        - no comment
            /#        - no config
            /#      (e.g. no secondaries are needed)
            testdata = []
            testbase = metax.oopl.ExecutableConstruct.TestifyName(self.id())
            /# TODO(wmh): Generalize to all baselangs
            if testbase == 'test___init__':
              testbase = metax.oopl.ExecutableConstruct.TestifyName(
                myclass.id())

            voidtype = metax.c.Type.Instance('void')

            if (
              variant == 'meta'
              or kind == 'initializer'
            ):
              /# For meta classes, initializer, and abstract methods, we do
              /# not produce a warning message.
              missing_message = None
            else:
              missing_message = '%s does not yet have a unittest' % fqn

            if testattr and testsattr:
              metafile.error(
                'Cannot define both test: and tests:', attr=testsattr)

            elif testattr:
              /# We have a single test, which is usually a simple block (but
              /# may be a complex block of <*>ed).
              if testattr.isComplexBlock():
                /# testlines is a misnomer ... it is really a list of Construct,
                /# not lines.
                metafile.error(
                  'Not yet handling complex test: blocks', attr=testattr)
              else:
                /# Simple block of lines.
                if len(testlines) == 0:
                  testlines = baselang.emptyBlockCode(
                    None, message=missing_message)

                testdata.append({
                  'name': testbase,
                  'features': [],
                  'secondaries': [],
                  'scope': testlines,
                  'line': testattr.line(),
                })

            elif testsattr:
              /# We have one or more testx constructs.
              for testx in testxes:
                testname = testbase + '_' + testx.id()
                tscope, testlines = testx.attrpair('scope:', default=None)
                if testlines is None or len(testlines) == 0:
                  testlines = baselang.emptyBlockCode(
                    None, message=missing_message)
                testdata.append({
                  'name': testname,
                  'features': [],
                  'secondaries': [],
                  'scope': testlines,
                  'line': tscope.line() if tscope else -1,
                })

            else:
              /# Neither 'test:' nor 'tests:' was defined.
              /#  - we add an empty test block for non-abstract methods.
              presence = self.attrval('presence', default=metax.c.LOOKUP)
              if presence == 'concrete':
                /# TODO(wmh): This is a unfortunately very specific to python.
                /# A better way of dealing with this would be better.
                if (
                  self.id() in
                  ('setUp', 'setUpClass', 'tearDown', 'tearDownClass')):
                    pass
                else:
                  /# print('HERE2 with %s' % self.id())
                  testdata.append({
                    'name': testbase,
                    'features': [],
                    'secondaries': [],
                    'scope': baselang.emptyBlockCode(
                      None, message=missing_message),
                  })

            for testinfo in testdata:
              secondaries = testinfo['secondaries']
              assert 'scope:' not in [p[0] for p in secondaries]
              tscope = testinfo['scope']
              assert tscope is not None
              secondaries.append(('scope:', tscope, testinfo.get('line', -1)))
              unittest = metax.oopl.MethodConstruct.NewFromData(
                testinfo['name'], context, parent=testscope,
                features=testinfo['features'],
                secondaries=secondaries,
                /# Add at end of test scope. Since we are processing methods
                /# in order, the test methods will have the same order.
                position=None)
              unittest.myclassIs(testclass)

      metax.c.D.expand.end()
    test:
      test.tpy()
      method = test.method
      test.namespace.expandMeta()
      /# TODO(wmh): many things can be tested here, but we'll need examples
      /# of specialized methods.
    end receiver ExecutableConstruct;

    receiver LifecycleConstruct ::
      /# Expand the lifecycle
      /#  - move to testclass or metaclass if location indicates such
      /#  - create initializer method based on params, scope and most other
      /#    attrs.
      /#  - create finalizer method based on 'finalize:'
      /#  - create baselang-specific setup/teardown methods based on 'setup:'
      /#    and teardown: (and location).
      /#     - if location is 'user', setup and teardown to not make sense
      /#       except in the very special case of defining metax.test.TestCase
      /#     - if location is 'meta', setup and teardown do not make sense

      /# Move to testclass or metaclass if appropriate
      myclass, moved = self.updateClass()

      metax.c.D.expand.sinfo(
        '%s in %s variant %s location %s moved %s metaclass %s' %
        (self.kindfqn(), myclass.kindfqn(), myclass.variant(),
         self.attrval('location'), moved, myclass.metaclass()))
      /# if False and myclass.id() == 'TestCase':
      /#   myclass.showDebug()

      if moved:
        /# We only expand lifecycles if we haven't moved the lifecycle to a
        /# different class (if we have moved it, it will be expanded later when
        /# that class is expanded).
        metax.c.D.expand.info('moved (no further expansion)', level=2)
      else:
        /# A 'lifecycle' construct is a generalization of an initializer, and
        /# can thus be found in every class.
        /#  - when used within a test class that inherits from
        /#    metax.test.TestCase, the 'setup:' and 'teardown:' block attributes
        /#    correspond to the baselang-specific and location-specific
        /#    setUp and tearDown methods.
        /#  - the setup*/teardown* attributes do not normally make sense for
        /#    user-defined classes (at normal or meta level, even if they are
        /#    service test classes). The one exception is when one is defining
        /#    a subclass of metax.test.TestCase (or a subclass of a subclass).
        /#  - the setup/teardown attributes do make sense (and are common) for
        /#    lifecycles with location 'test'. They are also common in
        /#    lifecycles appearing in user-defined test classes, but only if the
        /#    test class inherits from metax.test.TestCase, not if it is a
        /#    service test class that doesn't inherit from metax.test.TestCase.
        /#  - setup is invoked before each test method is executed, teardown is
        /#    invoked after each test method is executed.
        /#  - clsetup is invoked once before any of the test methods within a
        /#    testcase are invoked, and clteardown is invoked once after all
        /#    of the testmethods within a testcase have been invoked.
        /#
        /# Some reminder notes about Meta and unittests (and how lifecycles
        /# interact)
        /#  - Most baselangs that support xUnit testing will have a root
        /#    TestCase class with setup-each, teardown-each, setup-once and
        /#    teardown-once methods (exact names depend on baselang) and a
        /#    constructor that accepts a string representing the name of the
        /#    method to test.
        /#  - Meta defines metax.test.TestCase which inherits from this
        /#    baselang-specific root TestClass, and whose initializer has a
        /#    method-name arg passed to the parent.
        /#  - For user-defined class <C>, we implicitly create <C>Test which is
        /#    a subclass of metax.test.TestCase, whose initializer accepts a
        /#    method name that is passed to its parent.
        variant = myclass.variant()
        baselang = self.baselang()
        metafile = myclass.metafile()

        /# Create an initializer method.
        /#  - initializer name is determined by baselang.initializerName()
        /#  - insert just before the lifecycle construct.
        /#  - the test method(s) should use the name of the class, NOT the
        /#    baselang-specific initname (this allows us to ensure that
        /#    the initializer unittest can be accessed by a baselang-independent
        /#    name.
        initname = baselang.initializerName(myclass)
        position = '-' + self.id()
        context = self.context()
        class_scope = myclass.attr('scope:', default=metax.c.REQUIRED)
        scope = self.attr('scope:', default=None)

        features = []
        for fkey in (
          'presence', 'visibility', 'mutability', 'extensibility', 'dispatch',
          /# The location attribute of the generated initializer method will
          /# not be used, but we include it for readability purposes. May
          /# want to consider introducing a 'ignore' value to 'location' that
          /# we can set it to instead of taking the value from the lifecycle.
          'location',
          /# The inheritance feature attribute defaults to 'postx' for
          /# lifecycle constructs, and the code currently assumes this value
          /# always.  However, it is often useful to allow initialization of
          /# values before invoking the parent.  Supporting this in C++
          /# and Java will result in some inefficiency, but should be possible.
          /# There are also times where we want to be able to disable calls
          /# to the parent constructor in python (e.g. when we are inheriting
          /# from an old-school class), in which case superx is useful.
          'inheritance',
        ):
          fval = self.attrval(fkey, default=None)
          if fval is not None:
            features.append((fkey, fval))
        secondaries = []
        for skey in (
          'returns', 'returns:', 'comment:', 'params:', 'super',
          'pres:', 'posts:', 'scope:', 'test:', 'tests:',
        ):
          secondary = self.attr(skey, default=None)
          if secondary is not None:
            secondaries.append(secondary)

        if scope:
          /# We create an explicit initializer, and copy over many of the
          /# attributes from the lifecycle to the initializier.
          features.append(('kind', 'initializer'))
          primary_line = self.primary().line()
          initializer = metax.oopl.MethodConstruct.NewFromData(
            initname, context, parent=class_scope,
            features=features,
            primary_line=primary_line,
            position=position)
          /# Now move all the secondary attributes from the lifecycle to the
          /# initializer.
          for secondary in secondaries:
            secondary.changeParent(initializer)
          myclass.registerInitializer(initializer)

          /# Now expand the newly created initializer (to move the test
          /# attribute, etc.)
          initializer.expandMeta()
        else:
          /# IMPORTANT: If there is no scope block, we do NOT create an
          /# initializer construct here, which means the code in
          /# ClassConstruct.expandMeta() for creating a default initializer will
          /# be exercised.
          /#
          /# HOWEVER, if any of the feature or secondary attributes of
          /# 'lifecycle' that would be moved to the initializer are present, we
          /# warn the programmer that they will be ignored.
          /#
          /# TODO(wmh): Certain feature attributes in this list should probably
          /# be except from warnings (like location).
          if features:
            fvals = [pair[1] for pair in features]
            try:
              fvals.remove('test')
            except ValueError:
              pass
            if fvals:
              metafile.warning(
                '%s has no scope but has features that will be dropped when '
                'implicit initializer is created: %s' %
                (self.kindfqn(), ' '.join(fvals)),
                attr=self.primary())
          if secondaries:
            skeys = [sec.key() for sec in secondaries]
            try:
              skeys.remove('comment:')
            except ValueError:
              pass
            if skeys:
              /# TODO(wmh): if --implicit_scope, we should be generating the
              /# scope instead of complaining about it being missing. Easy to
              /# implement, as it is always an empty block.
              metafile.warning(
                '%s has no scope but has secondaries that will be dropped when '
                'implicit initializer is created: %s' %
                (self.kindfqn(), ' '.join(skeys)),
                attr=self.primary())

        /# Create a finalizer method if there is a 'finalize' attribute in this
        /# lifecycle.
        /#   - TODO(wmh): Determine if there is something that can be done about
        /#     __del__ problems in Python within Meta. Note that __del__ is the
        /#     mirror of __new__, NOT of __init__. See
        /#       http://www.algorithm.co.il/blogs/programming/\
        /#         python-gotchas-1-__del__-is-not-the-opposite-of-__init__/
        finalize_attr, finalize_lines = self.attrpair('finalize:', default=None)
        if finalize_attr is not None:
          finalname = baselang.finalizerName(myclass)
          finalizer = metax.oopl.MethodConstruct.NewFromData(
            finalname, context, parent=class_scope,
            features=[],
            secondaries=[('scope:', finalize_lines)],
            primary_line=finalize_attr.line())
          /# Remove 'finalize:' from self so that if we print out constructs
          /# after expansion, the state is properly reflected.
          self.unregisterAttribute(finalize_attr)
          /# TODO(wmh): Define registerFinalizer!
          /#myclass.registerFinalizer(finalizer)

        /# Handle the 'clinit' block.
        /#  - create a Meta__Initialize method whose body is the scope of
        /#    clinit:
        /#  - invoke the method after the class is defined.
        clinit_attr, clinit_lines = self.attrpair('clinit:', default=None)
        if clinit_attr is not None:
          /# TODO(wmh): Generalize to all baselangs
          if baselang.id() == 'python':
            clinit_lines.insert(0, 'cls = %s' % myclass.id())
          elif baselang.id() == 'cpp':
            clinit_lines.insert(0, 'auto* cls = %s;' % myclass.id())
          else:
            metafile.error(
              'Not yet supporting clinit: for baselang %s' % baselang.id(),
              line=clinit_attr.line())
          /# We create a Meta__Initialize() method.
          clinit = metax.oopl.MethodConstruct.NewFromData(
            'Meta__Initialize', context, parent=class_scope,
            features=[('kind', 'static')],
            secondaries=[('scope:', clinit_lines)],
            primary_line=clinit_attr.line(),
            position='+' + initname)
          myclass.registerStaticInitializer(clinit)

        /# Handle meta-level secondary attributes:
        /#  - if this is a user class, move the meta-specific blocks to an
        /#    implicitly created lifecycle with location 'meta'
        meta_attrs = {}
        meta_attr_list = (('metainit', 'scope'), ('metafinalize', 'finalize'))
        for attr, canattr in meta_attr_list:
          block = self.attr(attr + ':', default=None)
          if block:
            if ((variant == 'metauser') or (variant == 'meta')):
              metafile.warning(
                'For explicit meta lifecycles use scope: and finalize: not '
                'metainit: or metafinalize:',
                line=self.primary().line())
            else:
              /# This is a user-level lifecycle ... we remember the block so we
              /# can move it to an implicitly created lifecycle with location
              /# eta.
              meta_attrs[attr] = block
        if meta_attrs:
          /# We create a location=meta lifecycle construct and recursively
          /# expand it.
          /# TODO(wmh): Verify a meta lifecycle doesn't already exist!
          meta_lifecycle = metax.oopl.LifecycleConstruct.NewFromData(
            context.autoId(), context, parent=class_scope,
            features=[('location', 'meta')])
          for attrbase, canattr in meta_attr_list:
            attr = meta_attrs.get(attrbase)
            if attr:
              key = canattr + ':'
              parent = attr.parent()
              parent.unregisterAttribute(attr)
              attr.keyIs(key)
              attr.litkeyIs(key)
              meta_lifecycle.registerAttribute(attr)
          /# TODO(wmh): Should we pass output into this call to expandMeta?
          meta_lifecycle.expandMeta()

        /# Handle test-level secondary attributes:
        /#  - if this is a user class, move the blocks to an implicitly
        /#    created lifecycle with location 'test'
        /#  - if this is a test class, create baselang-specific setup/teardown
        /#    methods depending on which of 'setup', 'clsetup', 'teardown' and
        /#    'clteardown' exists as attributes on this lifecycle.
        test_attrs = {}
        test_attr_list = ('setup', 'clsetup', 'teardown', 'clteardown')
        for attr in test_attr_list:
          block = self.attr(attr + ':', default=None)
          if block:
            /# IMPORTANT: We need a accurate way to answer the question
            /# "Does this class inherit from metax.test.TestCase?". If it
            /# does, we allow these attributes (which are normally reserved
            /# for test classes) to reside in user classes (and not get moved).
            /# For now, using a very heuristic solution that requires users
            /# to know to put TestCase in the names of these classes.
            if (
              (variant == 'testuser') or
              (variant == 'test') or
              (variant == 'user' and myclass.inheritsFromTestCase())
            ):
              /# We are processing a test class, so we generate special methods
              /# within this class scope.
              tinfo = baselang.config(attr)
              tname = tinfo['name']
              tlevel = tinfo.get('level', 'instance')
              tkind = None
              if tlevel == 'static':
                tkind = 'static'
                features.append(('kind', 'static'))
              elif tlevel == 'meta':
                tkind = 'cls'
              features = []
              if tkind:
                features.append(('kind', tkind))
              if tkind != 'static':
                features.append(
                  ('inheritance', 'prex' if 'teardown' in attr else 'postx'))

              tmethod = metax.oopl.MethodConstruct.NewFromData(
                tname, context, parent=class_scope,
                features=features,
                secondaries=[('scope:', block.value())],
                primary_line=block.line())
              tmethod.myclassIs(myclass)
              tmethod.expandMeta()
            else:
              /# This is a user-level lifecycle ... we remember the block so we
              /# can move it to an implicitly created lifecycle with location
              /# test.
              test_attrs[attr] = block
        if test_attrs:
          /# We create a location=test lifecycle construct and recursively
          /# expand it.
          /# TODO(wmh): Verify a test lifecycle doesn't already exist!
          test_lifecycle = metax.oopl.LifecycleConstruct.NewFromData(
            context.autoId(), context, parent=class_scope,
            features=[('location', 'test')])
          for attrbase in test_attr_list:
            attr = test_attrs.get(attrbase)
            if attr:
              attr.changeParent(test_lifecycle)

          /# TODO(wmh): Should we pass output into this call to expandMeta?
          test_lifecycle.expandMeta()
      metax.c.D.expand.end()
    test:
      test.tpy()
      lifecycle = test.lifecycle

      /# No initializer before expandMeta
      test.isnull(test.cscope.cons('__init__', default=None))

      /# Must expand from namespace downward, as lifecycle.expandMeta() expects
      /# the class and namespace to be expanded.
      output = []
      test.namespace.expandMeta(output=output)

      /# Initializer exists after expandMeta
      test.notnull(test.cscope.cons('__init__'))

      /# TODO(wmh): Lots more testing possible here.
    end receiver LifecycleConstruct;

    receiver BehaviorConstruct ::
      /# Expand the behavior into a collection of methods defined on
      /# classes identified by the 'receiver' constructs within the behaviors
      /# scope.
      name = self.id()
      baselang = self.baselang()
      metafile = self.metafile()
      context = self.context()
      comment_lines = self.attrval('comment:', default=None)
      params_attr, params = self.attrpair('params:', default=None)
      returns_attr, mtype = self.attrpair('returns', default=None)
      parent_block = self.parent()
      location = self.attrval('location')

      if False:
        print('#' * 70)
        print(self.kindfqn())
        self.write()

      fkey_order = (
        'visibility', 'span', 'level', 'nature', 'mutability', 'kind',
        'dispatch')
      default_feature_map = {}
      for fkey in fkey_order:
        fattr, fval = self.attrpair(fkey, default=None)
        if fval is not None:
          default_feature_map[fkey] = fval

      prerec, prerec_lines = self.attrpair('prerec:', default=None)
      if prerec_lines is None:
        prerec_lines = []
      postrec, postrec_lines = self.attrpair('postrec:', default=None)
      if postrec_lines is None:
        postrec_lines = []

      scope, receivers = self.attrpair('scope:', default=None)
      for receiver in receivers:

        /# IMPORTANT: we want to support the receiver id being a fqn, but there
        /# are issues to be resolved:
        /#  - do we need two levels of import, one before expand and one after?
        /#  - it appears some external classes exist in self.compiler().classes()
        /#    even without importMeta() being invoked (how is this happening?)
        /#  - if we are instrument a class outside of the current metafile, we
        /#    must detect that fact and only allow things to proceed if the
        /#    metafile defining the class is explicitly listed as one of the
        /#    files for which code is being regenerated (else we will not
        /#    write the changes for the class even if we instrument it).
        clsname = receiver.id()

        feature_map = copy.copy(default_feature_map)
        presence = receiver.attrval('presence', default=None)
        if presence is not None:
          feature_map['presence'] = presence

        /# scope may be null if receiver is abstract
        receiver_scope, rec_lines = receiver.attrpair(
          'scope:', default=None)
        if rec_lines is None:
          rec_lines = []
        receiver_lines = prerec_lines + rec_lines + postrec_lines
        if not receiver_scope:
          receiver_lines = baselang.emptyBlockCode(receiver)
          receiver_linenum = receiver.primary().line()
        else:
          receiver_linenum = receiver_scope.line()

        /# test can definitely be null.
        receiver_test, test_lines = receiver.attrpair(
          'test:', default=None)
        receiver_tests, tests_block = receiver.attrpair(
          'tests:', default=None)

        /# Find the class_construct matching 'clsname'
        /#  - TODO(wmh): This needs to be generalized to support classes
        /#    in a different namespace than the behavior.
        /#  - Easily accomplished for classes in the same metafile (we have
        /#    access to the entire hierarchy by fqn via self.compiler().classes()),
        /#    but more complicated if the referenced class is in a separate
        /#   metafile.
        proceed = False
        targetclsname = (
          metax.oopl.ClassConstruct.MetaifyName(clsname) if location == 'meta'
          else clsname)

        if '.' in clsname:
          /# We have an fqn (note that we assume that any id with one or more
          /# '.' is absolute ... the only relative ids supported currently are
          /# those within the same namespace as the behavior, not any other
          /# namespace in the namespace hierarchy.
          metac = self.compiler()
          receiver_class = metac.classes().get(targetclsname, None)
          if receiver_class is None:
            print('BIG ERROR: %s does not exist anywhere' % targetclsname)
          else:
            /# TODO(wmh): There is more work to do here.
            /#  - must ensure that the class is in a metafile that is being
            /#    actively compiled (not just one that was implicitly loaded
            /#    and will thus not be written).
            /#  - in experiments, if proceed is set True, the instrumentation
            /#    code causes
            /#       InternalError: Failed to find stream named "defn" in ['command_body', 'command_init']
            print('NOTE: Found %s ... must verify we are generating code for it' % targetclsname)
            proceed = False
        else:
          /# A local class name (defined in same namespace as the behavior).
          receiver_class = parent_block.cons(targetclsname, default=None)
          if receiver_class is None:
            /# The receiver is not a class defined in the same namespace as the
            /# 'behavior'
            print('ERROR: Failed to find %s in %s' % (clsname, parent_block.parent().fqn()))
          else:
            proceed = True

        if proceed:
          /# feature attributes
          features = []
          for k in fkey_order:
            if k in feature_map:
              features.append((k, feature_map[k]))
          /# secondary attributes
          secondaries = []
          if mtype:
            /# We set the return type of the method.
            secondaries.append((':', mtype))
          if comment_lines:
            secondaries.append(('#:', comment_lines))
          if params_attr:
            /# Note that we cannot just move 'params:' because there can be
            /# multiple receivers, each needing the params: attribute.
            params_copy = params_attr.clone(None)
            secondaries.append(('params:', params_copy))
          secondaries.append(('scope:', receiver_lines, receiver_linenum))
          class_scope = receiver_class.attr('scope:', default=metax.c.REQUIRED)
          /# method creation
          method = metax.oopl.MethodConstruct.NewFromData(
            name, context, parent=class_scope, features=features,
            secondaries=secondaries, primary_line=receiver.primary().line())
          method.myclassIs(receiver_class)
          assert method.primary().line() == receiver.primary().line()

          /# Create a test method regardless of whether a 'test' attribute
          /# exists (but only if not abstract).
          if presence != 'abstract':
            receiver_test_class = receiver_class.testclass()
            if receiver_test_class is None:
              print(
                'WARN: Compiler.BehaviorConstruct.expandMeta: Failed to find '
                '%s in %s test block' %
                (self.kindfqn(),
                 clsname + 'Test', test_block.parent().kindfqn()))
            else:
              if receiver_tests:
                if receiver_test:
                  metafile.error('Cannot specify both tests: and test:')
                else:
                  metafile.error(
                    'Not yet handling tests: for behaviors',
                    attr=receiver_tests)
              elif receiver_test and receiver_test.isComplexBlock():
                metafile.error(
                  'Not yet handling complex test: blocks', attr=receiver_test)
              else:
                /# This tests for both empty test_lines and null test_lines.
                if not test_lines:
                  missing_message = (
                    '%s (for %s) does not yet have a unittest' %
                    (self.kindfqn(), receiver_class.id()))
                  test_lines = baselang.emptyBlockCode(
                    None, message=missing_message)

                class_test_scope = receiver_test_class.attr(
                  'scope:', default=metax.c.REQUIRED)
                test_secondaries = [
                  ('scope:', test_lines,
                   receiver_test.line() if receiver_test
                   else self.primary().line())
                ]
                test_method = metax.oopl.MethodConstruct.NewFromData(
                  'test_' + name, context, parent=class_test_scope,
                  secondaries=test_secondaries,
                  primary_line=receiver.primary().line())
    test:
      test.tpy()
      behavior = test.behavior
      person = test.klass
      cscope = person.attr('scope:')

      /# uid does not exist in person before we expand the behavior
      test.isnull(cscope.cons('uid', default=None))

      test.namespace.expandMeta()

      /# uid does exist in person after we expand the behavior
      test.notnull(cscope.cons('uid', default=None))
    end receiver BehaviorConstruct;

    receiver CategoryConstruct ::
      /# Expand the field
      /#   - produce accessor methods (getter, setter, reffer, etc.)
      /#    in appropriate class depending on level.
      /#  - leave the field construct in the user class no matter what
      /#    (translateMeta can decide whether to ignore or not on a per-baselang
      /#    basis).
      metax.c.D.expand.sinfo(self.kindfqn())

      /# We want the effect to be the same as if the category construct
      /# wasn't present, while still maintaining the grouping provided
      /# by categories.
      /#  - construct ids must be unique across entire nested category
      /#    hierarchy

      /# TODO(wmh): Note that we cannot just move the child constructs up
      /# to the top-level, as this will lose the grouping provided by category.
      /# But we do need to maintain uniqueness, so each class (and any other
      /# consstruct that supports categories) should maintain a 'symbol_closure'
      /# field for aggregating constructs across the category hierarchy.

      scope = self.attrval('scope:', default=None)
      if scope:
        for child in scope:
          child.expandMeta(output=output)

      metax.c.D.expand.end()
    test:
      pass
    end receiver CategoryConstruct;

    receiver RemarkConstruct ::
      metax.c.D.expand.sinfo(self.kindfqn())
      /# No expansion needed.
      metax.c.D.expand.end()
    test:
      pass
    end receiver RemarkConstruct;

    receiver NativeConstruct ::
      parent_construct = self.parentConstruct()
      if parent_construct.kind() == 'namespace':
        /# For native blocks within namespace scope, the native construct is
        /# (at least currently) attached to either the preceeding class
        /# construct (if position is 'post') or succeeding class construct
        /# (if position is 'pre').

        /# IMPORTANT: See the comment associated with the SymbolConstruct.streams
        /# field for a discussion of some subtleties in how namespace-level
        /# native constructs need to be handled and why they are handled here
        /# in expandMeta() instead of translateMeta().
        position = self.attrval('position')

        metafile = self.metafile()
        baselang = self.baselang()
        scope_attr, scope = self.attrpair('scope:', default=None)
        decl_attr, decl_lines = self.attrpair('decl:', default=None)

        /# Establish the class construct to attach this native construct to.
        parent = self.parent()
        block = parent.value()
        index = block.index(self)
        class_construct = None

        if position == 'post':
          /# This native block is associated with the class ABOVE it, and
          /# is written into that class' post streams.
          direction = 'above'
          while index > 0:
            index -= 1
            cons = block[index]
            if cons.kind() == 'class':
              class_construct = cons
              break
        elif position == 'pre':
          /# This native block is associated with the class BELOW it, and
          /# is written into that class' pre streams.
          direction = 'below'
          m = len(block) - 1
          while index < m:
            index += 1
            cons = block[index]
            if cons.kind() == 'class':
              class_construct = cons
              break

        if not class_construct:
          metafile.error(
            'Failed to find a class %s %s' % (direction, self.fqn()),
            line=self.primary().line())
        else:
          /# Now we check the 'location' attribute to see if the code is
          /# to be put in the test class or meta class instead.
          target_class = None
          locattr, location = self.attrpair('location', default=metax.c.LOOKUP)
          /# TODO(wmh): Fix this issue with attrpair ... if we need to LOOKUP,
          /# then locattr will by definition not have a proper line number
          /# in the meta source file.  We should fall back to some default
          /# (the primary attribute line number, for example).
          if location == 'user':
            /# We are good as-is
            target_class = class_construct
          elif location == 'test':
            /# The test class may be disabled or otherwise missing.
            testclass = class_construct.testclass()
            if testclass is None:
              metafile.error(
                'native block requests placement in non-existent test class',
                line=self.primary().line())
            else:
              target_class = testclass
          elif location == 'meta':
            /# The meta class may be disabled or otherwise missing.
            metaclass = class_construct.metaclass()
            if metaclass is None:
              metafile.error(
                'native block requests placement in non-existent meta class',
                line=self.primary().line())
            else:
              target_class = metaclass
          else:
            metafile.error(
              'Unknown location %s' % location, line=self.primary().line())

          /# Write the native lines to the appropriate location.
          if target_class:
            if decl_attr:
              comment = self.attr('comment:', None)
              segment = baselang.segmentForBlockAndComment(
                decl_attr, comment=comment)
              sname = (
                'cls-post-decl' if position == 'post' else 'cls-pre-decl')
              target_class.streamNamed(sname).append(segment)

            if scope_attr:
              icomment = self.attr('icomment:', None)
              segment = baselang.segmentForBlockAndComment(
                scope_attr, comment=icomment)
              sname = (
                'cls-post-defn' if position == 'post' else 'cls-pre-defn')
              target_class.streamNamed(sname).append(segment)
    test:
      /# TODO(wmh): Test this.
      pass
    end receiver NativeConstruct;

    receiver CommandConstruct ::
      /# Expand the command.
      /#
      /# A 'command' construct within a class representing a class-specific
      /# entry point into the codebase, with support for parsing command-line
      /# flags/args/subcommands. To expand a 'command', we need to create two
      /# methods on the class within which the command resides:
      /#
      /# 1. A method with name metax.c.METAX_CMD_NAME (aka 'MetaxCLI') that
      /#    creates an instance of metax.cli.Command, properly initialized
      /#    with metax.cli.Flag, metax.cli.Arg, and metax.cli.Command
      /#    instances representing the 'flag', 'arg' and 'command' constructs
      /#    found within the 'interface:' attribute of this 'command'.
      /#     - TODO(wmh): This method is currently meta, but should be static.
      /#
      /# 2. A method with name metax.c.METAX_ENTRY_NAME (aka 'MetaxEntry')
      /#    that accepts a collection of strings representing command-line
      /#    arguments and identifiers a fully instantiated metax.cli.Command
      /#    instance (within the metax.cli.Command instance returned by
      /#    'MetaxCLI') based on those args. This method also invokes the
      /#    code in the 'scope:' portion of the identified 'command'.
      /#
      /# TODO(wmh): This code is invoked on every command defined in any
      /# transitively included meta source file, which is unnecessary (we only
      /# need to generate the entry method for metafiles that have explicitly
      /# specified for compilation.
      metax.c.D.expand.sinfo(self.kindfqn())

      metafile = self.metafile()
      /# TODO(wmh): CommandConstruct are subclasses of ClassicConstruct and thus
      /# have a myclass() field. If it is being properly initialized during
      /# expandMeta(), we can use it instead of ancestor (more efficient)
      klass = self.ancestor('class')
      metaclass = klass.metaclass()
      metaclass_scope = metaclass.attr('scope:', default=metax.c.REQUIRED)
      userclass = metaclass.underclass()
      assert userclass is not None
      assert userclass is klass
      class_scope = userclass.attr('scope:', default=metax.c.REQUIRED)

      command_kind = self.attrval('kind')
      context = metaclass.context()
      metafile = self.metafile()
      baselang = self.baselang()
      rem = baselang.config('rem')

      /# For the top-level command within a class, we pass the comment of the
      /# command on as the comment of the method.
      comment_lines = self.attrval('comment:', default=None)
      if comment_lines is None:
        comment_lines = [
          'Auto-generated entry point for %s' % klass.fqn()]

      scope_attr, command_list = self.attrpair('scope:', default=None)
      if scope_attr and scope_attr.isComplexBlock():
        /# This is the old style, in which the scope: block contains
        /# commands, flags, args and 'block'.
        subconstructs = command_list[:]

        /# Find the 'block:' within the subconstructs, if one exists.
        block = None
        for child in subconstructs:
          kind = child.kind()
          if kind == 'block':
            if block is None:
              block = child
            else:
              raise metax.c.Error('Found multiple blocks: %s vs %s' % (block.kindfqn(), child.kindfqn()))
        if block:
          blines = block.attrval('scope:', default=metax.c.REQUIRED)
          primary_line = block.primary().line()
        else:
          blines = []
          primary_line = -1
      else:
        /# This is the new style, in which scope: is simple and contains only
        /# the code for the command.  All flags, args and subcommands are in
        /# the 'interface' construct.
        subconstructs = []
        block = scope_attr
        blines = command_list or []
        primary_line = self.primary().line()

      /# We add the constructs in the 'interface:' block to the beginning of
      /# subconstructs (when we are fully migrated, subconstructs will just
      /# contains the interface: block).
      interface_scope = self.attrval('interface:', default=None)
      if interface_scope:
        subconstructs = interface_scope + subconstructs

      command_code = []
      special_default_command = '__default__'

      def VarName(names, start=1, end=None):
        if end is None:
          end = len(names)
        result = '_'.join(names[start:end])
        if result:
          result += '_'
        result += 'command'
        return '_' + result

      /# Establish the level of command construct.
      clist = []
      cnames = []
      cmd = self
      while cmd.kind() == 'command':
        clist.insert(0, cmd)
        cnames.insert(0, cmd.id())
        cmd = cmd.parentConstruct()
      level = len(clist) - 1
      toplevel = level == 0
      indent = '  ' * level
      sub_var = 'meta__names[%d]' % (level + 1)

      command_fullname = VarName(cnames)
      if toplevel:
        parent_fullname = None
      else:
        parent_fullname = VarName(cnames, end=-1)

      if toplevel:
        /# This first invocation creates the command_body. Subsequent
        /# invocations will use the same vec<str> as created here.
        klass.streamNamed('command_body')
        klass.streamNamed('command_init')
        /# TODO(wmh): Determine why the following produces a problem in
        /# importMeta() when we specify ('metax.cli', 'lib', ...). This yields
        /# class path .../metax/.cli.py (instead of metax/cli/__init__.py) and
        /# thus a null meta path. Note that it is not strictly sufficient
        /# to import metax.cli.Command ... also need Flag and Arg and Values.
        /# Works fine for Python, but may not for other baselangs.
        metaclass.addDependency(
          'metax.cli.Command', 'cls', 'needed for entry point')
        /# Register this top-level command with the class. These will be used
        /# to generate executable binaries within ClassConstruct.compileMeta().
        userclass.commands().append(self)

      command_init = klass.streamNamed('command_init')
      command_body = klass.streamNamed('command_body')

      /# We need to add code to command_init to create a new
      /# metax.cli.Command instance.
      self.generatePython(command_fullname, parent_fullname, command_init)

      special_receiver = 'the%s' % klass.id()
      if blines:
        clines = self.attrval('comment:', default=None) or []

        if command_kind == 'named':
          /# We create a method to implement this block.
          if self.id() == special_default_command:
            metafile.error(
              'The default command cannot be named',
              line=block.primary().line())
          else:
            methname = command_fullname

            /# Generate the method call locally.
            command_body.append('%s%s.%s()' % (indent, special_receiver, methname))

            /# Create the method that does the actual work.
            /#  - note that although the toplevel MetaxEntry method is
            /#    a meta method (and thus defined on the meta class),
            /#    named blocks are generated as instance methods on
            /#    the underlying user class.
            method = metax.oopl.MethodConstruct.NewFromData(
              methname, context, parent=class_scope,
              features=[],
              secondaries=[
                ('#:', clines or None),
                ('scope:', blines),
              ],
              primary_line=primary_line)

        else:
          /# We write the contents of the block into command_code.
          /# TODO(wmh): Should use BlockConstruct.translateMeta() if possible!
          /# TODO(wmh): Is there a way to force a new lexical scope in
          /# python3 within a method, so that a variable defined inside
          /# the lexical scope does not affect its value outside that scope?
          for line in clines:
            /# TODO(wmh): Generalize to all baselangs.
            if line:
              command_code.append(indent + rem + ' ' + line)
            else:
              command_code.append(indent + rem)
          for line in blines:
            if not line:
              command_code.append('')
            else:
              command_code.append(indent + line)
          command_body.extend(command_code)

      /# Now parse the scope
      subcmds = []
      args = []
      default_encountered = False
      has_optargs = False

      for child in subconstructs:
        kind = child.kind()

        if kind == 'flag':
          /# Generate flag code in command_init.
          child.generatePython(command_fullname, command_init)
          if child.isArg():
            cdef = child.attr('default', default=None)
            if cdef is not None:
              has_optargs = True

        elif kind == 'command':
          if len(subcmds) == 0:
            /# This is the first subcommand ... insert an initial block that
            /# handles help requests.
            command_body.append('')
            command_body.append(
              "%sif cli.rest and cli.rest[0].startswith('help'):" % indent)
            command_body.append(
              '%s  meta__command.help'
              "(mode='helpfull' if 'ful' in cli.rest[0] else 'help', commands=cli.rest[1:])" % indent)
          elif default_encountered:
            /# We previously encountered the special default command, which
            /# must occur after all other commands, so the current one is
            /# in error.
            /# TODO(wmh): Use a less hacky mechanism here.
            metafile.error(
              'The special %s command must occur last' %
              special_default_command, line=child.primary().line())
            break

          /# Insert a check to ensure that sub_var (i.e. meta__names[1] or
          /# meta__names[2], etc.) exists
          command_body.append('')
          command_body.append(
            '%selif len(meta__names) < %d:' % (indent, level+2))
          command_body.append(
            '%s  print("ERROR: unrecognized command \\\"%%s\\\"" %% " ".join(meta__args))' %
            indent)
          command_body.append('%s  sys.exit(1)' % indent)

          subcmds.append(child)
          command_body.append('')
          if child.id() == special_default_command:
            command_body.append('%selse:' % indent)
            default_encountered = True
          else:
            command_body.append(
              "%selif %s == '%s':" % (indent, sub_var, child.id()))
          /# We encode within the baselang output stream some information about
          /# where within the .meta file the upcoming code block resides.
          cscope = child.attr('scope:', default=None)
          if cscope:
            command_body.append(
              '%s  %s ^METAFILE^ %s' % (indent, rem, metafile.path()))
            command_body.append(
              '%s  %s ^METALINE^ %s:command %d' %
              (indent, rem, child.fqn(), cscope.line()))
          /# We recursively expand the child command construct, which will write
          /# lines into the command_body and command_init streams.
          child.expandMeta()

        elif kind == 'block':
          pass
        else:
          raise metax.c.Error(
            'Unexpected child %s of %s' % (child.kindid(), self.kindfqn()))

      if subcmds:
        if default_encountered:
          /# A default command was encountered, so a final 'else has been
          /# generated.
          pass
        else:
          /# There were subcommands, so we close the if ... elif ... block
          /# with an error if command is unknown.
          command_body.append('')
          command_body.append('%selse:' % indent)
          command_body.append(
            indent + "  print('ERROR: Unrecognized command \"%s\"' % " + sub_var + ')')

      /# Now insert the postamble if it exists.
      postamble = self.attrval('postamble:', default=None)
      if postamble:
        command_body.append('')
        for line in postamble:
          command_body.append(indent + line)

      if (not subcmds or toplevel) and not has_optargs:
        /# There were no subcommands or optional args (or, alternatively, this
        /# is the top-level command). In either case, we want to add a
        /# 'catch-all' arg.
        /#  - for non-toplevel commands, if there were any 'arg' constructs
        /#    specified within this command, they are assumed to constitute all
        /#    desired args.
        /#  - as a convenience, if no args are specified, we defined a
        /#    multi-valued 'rest' arg that consumes all subsequent args.
        /#  - TODO(wmh): Consider removing this special arg when we have args
        /#    working properly as constructs ... abide by exactly what the
        /#    user wants. May still need it for toplevel though.
        command_init.append('%s.newArg(' % command_fullname)
        command_init.append("  'rest', multi=True, summary='Leftover args.')")

      if toplevel:
        command_init.append('cli = None')
        command_init.append('instcmd = None')
        command_init.append('if argv:')
        command_init.append(
          '  instcmd = %s.instantiate(argv, start=True)' % command_fullname)
        command_init.append('  if instcmd:')
        command_init.append('    cli = instcmd.asValues()')
        /#command_init.append('    if cli.verbose and cli.verbosity == 0: cli.verbosity = 1')
        /#command_init.append('    elif cli.verbosity > 0 and not cli.verbose: cli.verbose = True')
        command_init.append('return (%s, instcmd, cli)' % command_fullname)

        /# Create the MetaxCLI method, which returns a metax.cli.Command instance.
        cmd_method_name = metax.c.METAX_CMD_NAME
        cmd_params = metax.oopl.ExecutableConstruct.CreateParams(
          [{'var': 'argv',
            'secondaries': [
              (':', metax.c.Type.Instance('&vec<str>')),
              ('#:', ['The list of command line args (including executable)']),
              ('=', metax.c.Expr('var', 'null', 'null')),
            ]},
          ],
          context)
        cmd_method = metax.oopl.MethodConstruct.NewFromData(
          cmd_method_name, context, parent=metaclass_scope,
          /# We do not bother setting location because we are creating the
          /# method within the metaclass (location is only relevant during
          /# expansion and we are skipping that step by defining in metaclass
          /# directly).
          secondaries=[
            (':', metax.c.Type.Instance('metax.cli.Command')),
            ('#:', ['Create Command instance for %s.' % klass.fqn()]),
            ('params:', cmd_params),
            ('scope:', command_init),
          ])
        cmd_method.myclassIs(klass)

        /# Insert code that creates and instantiates a metax.cli.Command instance.
        command_preamble = []
        command_preamble.append('# Parse the command line args')
        command_preamble.append(
          '%s, meta__command, cli = %s.%s(argv=meta__args)' %
          (command_fullname, klass.id(), cmd_method_name))
        command_preamble.append('if meta__command is None:')
        command_preamble.append('  return')
        command_preamble.append('meta__names = meta__command.names()')
        /# TODO(wmh): Add metax.c as a dependency so it is imported early and
        /# will therefore work in bazel.
        if False:
          command_preamble.append('import metax.c')
          command_preamble.append('metax.c.Compiler.Initialize()')
          command_preamble.append('metax.root.Object.Init(cli=cli)')
        command_preamble.append('')

        /# We create the entry method.
        /#  - it can be either a 'meta' method or a 'static' method
        /#  - originally it was implemented as 'meta', but that precludes certain
        /#    functionality from being used (aspects of the class are not yet
        /#    defined within the code in the metaclass is executed).
        /#  - as of 2018-11-07, it is a static method instead.
        if False:
          /# meta method defined on meta-class
          features = []
          entry_pscope = metaclass_scope
        else:
          /# static method defined on class
          features = [('kind', 'static')]
          entry_pscope = class_scope

        method_name = metax.c.METAX_ENTRY_NAME
        body = command_preamble + command_body
        params = metax.oopl.ExecutableConstruct.CreateParams(
          [{'var': 'meta__args',
            'secondaries': [
              (':', metax.c.Type.Instance('&vec<str>')),
              ('#:', ['The list of command line args (including executable)']),
            ]},
           {'var': 'meta__parent',
            'secondaries': [
              (':', metax.c.Type.Instance('metax.root.Command')),
              ('#:', ['A parent command. Usually null.']),
              ('=', metax.c.Expr('var', 'null', 'null')),
            ]},
           /# TODO(wmh): meta__kwds is currently unused ... delete it?
           {'var': 'meta__kwds', 'features': [('multiplicity', 'multi')],
            'secondaries': [
              (':', metax.c.Type.Instance('map')),
              ('#:', ['Catchall arg for special-casing.']),
            ]},
          ],
          context)
        entry_method = metax.oopl.MethodConstruct.NewFromData(
          method_name, context, parent=entry_pscope,
          /# We do not bother setting location because we are creating the
          /# method within the metaclass (location is only relevant during
          /# expansion and we are skipping that step by defining in metaclass
          /# directly).
          features=features,
          secondaries=[
            (':', metax.c.Type.Instance('int')),
            ('#:', comment_lines),
            ('params:', params),
            ('scope:', body),
          ])
        entry_method.myclassIs(klass)

      metax.c.D.expand.end()
    test:
      pass
    end receiver CommandConstruct;

    receiver FlagConstruct ::
      /# Expand the flag (nothing to do).
      metax.c.D.expand.sinfo(self.kindfqn())
      /# I don't believe we ever use this, right?
      raise metax.c.Error('Should never get here')
      metax.c.D.expand.end()
    test:
      pass
    end receiver FlagConstruct;

    receiver BlockConstruct ::
      metax.c.D.expand.sinfo(self.kindfqn())
      /# No expansion currently needed for block constructs.
      /# TODO(wmh): If we support kind='named' for statement-level blocks,
      /# the auto-generated method would need to be created/registered here.
      metax.c.D.expand.end()
    test:
      pass
    end receiver BlockConstruct;

    receiver VarConstruct ::
      print('Here with %s' % self.kindfqn())
    test:
      /# Noop
      pass
    end receiver VarConstruct;

    receiver SetConstruct ::
      /# This is not being invoked because we currently do not bother
      /# invoking expandMeta on statement-level constructs within
      /# method blocsk. Should we? That would slow down compilation,
      /# so let's avoid it unless it provides some utility. For
      /# example, supporting function and class definitions within
      /# method blocks would be one good justification for invoking
      /# expandMeta here. Most statement subclasses would just noop
      /# their expandMeta implementation.
      print('SetConstruct.expandMeta: Here with %s' % self.kindfqn())
    test:
      /# Noop
      pass
    end receiver SetConstruct;

    receiver LoopConstruct ::
      /# noop.
    test:
      /# noop
      pass
    end receiver LoopConstruct;

    receiver SwitchConstruct ::
      /# noop.
    test:
      /# noop
      pass
    end receiver SwitchConstruct;

    receiver CaseConstruct ::
      /# noop.
    test:
      /# noop
      pass
    end receiver CaseConstruct;

  end behavior expandMeta;

  behavior importMeta scope:

    receiver NamespaceConstruct ::
      metax.c.D.imports.sinfo(self.id())

      /# print('**** HERE importing %s' % self.kindfqn())

      /# For namespaces, importMeta is primarily a means to invoke
      /# ClassConstruct.importMeta(), which does more heavy lifting. However,
      /# this method is also where we register each class within the namespace
      /# in the symboltable of the namespace.
      table = self.symbols()
      assert table.construct() is self
      scope, children = self.attrpair('scope:')
      for child in children:
        child.importMeta()

        /# CODETANGLE(highlevel_symbols): For namespaces, what resides in the
        /# symboltable are the names of classes within the namespace, and the
        /# names of other namespaces that have been specified as required.
        /#  - highlevel symbols for classes = class ids (which represent the
        /#    metaclass).
        /#  - baselang symbols for classes = singleton instance of metaclass,
        /#    at least in baselangs without first-class classes).
        /#  - We are currently implementing high-level semantics.
        if child.isClass():
          if not child.isMeta():
            table.register(child.id(), child, source=self)
      metax.c.D.imports.end()
    test:
      test.tpy(expand=True)  # expand before import
      namespace = test.namespace
      table = namespace.symbols()
      test.iseq([], sorted(table.symbols()))
      namespace.importMeta()
      test.iseq(['Error', 'Person', 'Student'], sorted(table.symbols()))
    end receiver NamespaceConstruct;

    receiver ClassConstruct ::
      /# Link this class with all of its ancestor classes, now that all dependent
      /# metafiles have been transitively parsed, expanded and imported.
      metax.c.D.imports.sinfo(self.id())

      metafile = self.metafile()
      metac = metafile.compiler()

      /# Establish the ClassConstruct instances of parents
      /#  - initialize self.parentclasses[i]['class']
      /#  - add entry to parent_construct.childclasses() for self
      /#  - patch up the parent() field in self.symbols() table.
      parentclasses = self.parentclasses() or []
      for index, parent_info in enumerate(parentclasses):
        fqn = parent_info['metafqn']
        parent_class = metac.classes().get(fqn, None)
        if parent_class is None:
          /# This can mean various things:
          /#  - the parent class was not defined within Meta
          /#  - the parent class is incorrectly specified by the user
          /#  - there is a bug in Meta
          if not parent_info.get('external', False):
            /# TODO(wmh): There are certain situations where this is happening
            /# (and not being surfaced if no errors occur!). In particular,
            /# the unittests for NamespaceConstruct.importMeta and
            /# ExecutableConstruct.methodInfo_cc.
            /#
            /# print('PARENT INFO: %s' % str(parent_info))
            metafile.warning(
              'Failed to import parent %s for %s' % (fqn, self.fqn()),
              line=self.primary().line())
          else:
            /# The parent is defined in the baselang, not in Meta. We create
            /# an ExternalClassConstruct instance to represent it.
            parent_class = metax.oopl.ExternalClassConstruct(
              /# Passing null context poses problems, so passing self's
              /# context even though it isn't entirely accurate.
              parent_info['id'], None, self.context(), precount=0)
            parent_info['class'] = parent_class
            parent_class.childclasses()[self.id()] = self
        else:
          /# We have successfully identified a ClassConstruct for the parent.
          parent_info['class'] = parent_class
          parent_class.childclasses()[self.id()] = self
          if index == 0:
            /# For now, there is only one parent symbol table, but we should
            /# probably allow SymbolTable to have arbitrary numbers of parents.
            symbols = self.symbols()
            assert symbols.parent() is None
            symbols.parentIs(parent_class.symbols())

      /# We now recurse down to constructs within the class so that they can
      /# update any state that relies on full resolution of the class
      /# inheritance change.
      scope, children = self.attrpair('scope:')
      for child in children:
        child.importMeta()

      metax.c.D.imports.end()
    test:
      /# TODO(wmh): Determine why the metax.root.Object parent is not being
      /# properly populate below. I suspect it is a test setup issue rather
      /# than a real issue, since code works.
      if False:
        test.tpy(expand=True)
        parent = test.klass.parentclasses()[0]
        print(parent)
        test.isnull(parent['class'])
        /# test.iseq(parent.childclasses())
        print(test.metafile._logmap)
        test.namespace.importMeta()
        print(test.metafile._logmap)
        test.iseq(parent['class'])
    end receiver ClassConstruct;

    receiver ExecutableConstruct ::
      /# NOTE: This code applies to lifecycle and behavior but not method
      /# (MethodConstruct defines its own importMeta).
      scope = self.attrval('scope:')
      for child in scope:
        child.importMeta()
    test:
      test.tpy(expand=True)   # expand before import
      test.lifecycle.importMeta()

    end receiver ExecutableConstruct;

    receiver MethodConstruct ::
      /# TODO(wmh): Move up into ExecutableConstruct?

      /# Look up the inheritance chain for a method with the same name.
      /#  - allows us to enforce 'new'/'override' semantics
      /#  - allows us to implement 'super var' semantics in parameters by being
      /#    able to identify the types of params from their parent equivalents
      name = self.id()
      metax.c.D.imports.sinfo(name)

      myclass = self.myclass()
      if myclass:
        attrkind = self.attrval('kind')
        parentclass = myclass.parentclass()
        if parentclass is not None:
          psymbols = parentclass.symbols()
          super_method = psymbols.find(name)
          if super_method:
            self.supermethodIs(super_method)
            attrkind = self.attrval('kind')
            if attrkind == 'initializer':
              /# Knowing the parent initializer will be useful for many
              /# purposes.
              pass
            else:
              /# TODO(wmh): methods from behaviors are not showing up as being
              /# overridden.
              if name != 'meta':
                /# print('  In %s found parent definition %s' % (self.kindfqn(), super_method.kindfqn()))
                pass

        scope = self.attr('scope:', default=None)
        if scope:
          if scope.isComplexBlock():
            /# TODO(wmh): Do we add all top-level 'var' constructs now? A
            /# variable cannot be used until declared in most baselangs, so
            /# pre-populating the symbol table is problematic unless we add an
            /# 'inactive' field that allows us to indicate when a symbol is and
            /# is not active.
            pass
          else:
            /# TODO(wmh): We could do some heuristic analysis of the baselang
            /# source code fairly easily. Or, if we have access to a
            /# statement-level parser for each baselang, we can identify all
            /# variable declarations.
            pass
      else:
        /# If myclass is None, we have a method (including accessor) defined
        /# at namespace level.
        pass

      metax.c.D.imports.end()
    test:
      test.tpy(expand=True)  # expand before import
      /# TODO(wmh): We probably need to invoke importMeta() from the namespace
      /# down, rather than just invoking it on the method without first
      /# invoking on class/namespace.
      test.method.importMeta()
      /# TODO(wmh): Perform tests here that lookup succeeded.
    end receiver MethodConstruct;

  end behavior importMeta;

  behavior translateMeta #:
    Convert a construct to baselang syntax.
  scope:

    abstract
    receiver OoplConstruct #:
      Each subclass overrides this method to perform compilation of the
      construct associated with the subclass. The code in these implementations
      should be baselang-agnostic, but may invoke code on the BaseLanguageOopl
      subclass stored in the compiler to perform baselang-specific actions.
      TODO(wmh): Switch this to be abstract to force children to define the
      method.

    receiver NamespaceConstruct ::
      /# Namespace compilation code.
      /#  - compile all classes into separate files
      /#  - handle namespace-level native constructs properly, in
      /#    both languages that merge decl/defn and those that
      /#    separate them.
      /#  - for languages that are namespace-primary (e.g. Python), create a
      /#    file representing the namespace (aka module)
      /#  - create a BUILD file containing all targets for building the classes
      /#    in the namespace, and for building the namespace itself.
      metax.c.D.translate.sinfo(self.kindfqn())

      fqn = self.id()
      metac = self.compiler()
      baselang = self.baselang()
      metafile = self.metafile()
      scope_sep = metax.c.Context.Tokens()['scope_sep']
      nameparts = fqn.split(scope_sep)
      nmspbase = nameparts[-1]
      fs = metac.fs()

      /###
      /# Process the scope.  Children include:
      /#   class
      /#   native
      /#   static method (in the future)
      /#   static field (in the future)
      scope, children = self.attrpair('scope:')
      triples = []
      blds = []
      test_classes = []
      namespace_primary = baselang.config('namespace_primary')
      for child in children:
        basefiles = child.translateMeta()
        if len(basefiles) == 0:
          /# We are to ignore this child.
          continue
        assert len(basefiles) == 2
        basefile, bld = basefiles
        if child.kind() == 'class':
          triples.append((child, basefile, bld))
          if child.isTestCase():
            test_classes.append(child)
        if bld is not None:
          /# print('%s = %d' % (basefile.subpath(), len(basefile.contents())))
          assert bld.subpath().endswith('.bld'), bld.subpath()
          blds.append(bld)

      /# Perform baselang-specific namespace processing.
      /#  - instantiate the template representing a namespace in the baselang.
      /#  - most languages do not have syntax for defining a namespace in
      /#    aggregate, but python does.
      /#  - if a baselang doesn't have a namespace-specific syntax, it should
      /#    simply not define a Template in the 'namespace' construct.
      basel = baselang.id()
      if basel == 'python':
        basefiles = self.compilePython(kind='merge', triples=triples)
        bld = basefiles[-1]
        assert bld.subpath().endswith('.bld'), bld.subpath()
        blds.append(bld)

      /# Create the BUILD file
      bfqn = fqn + scope_sep + 'BUILD'
      buildpath = metac.basePath(bfqn)
      contents = baselang.buildPreambleText()
      for bld in blds:
        contents += bld.contents()
      if self.isTest() and not baselang.config('namespace_primary'):
        /# For baselangs that are NOT namespace_primary, the leaf-level
        /# namespace target ('//nm/sp_test:sp_test') is implemented as a
        /# test_suite that invokes each of the per-class test targets.
        /# On the other hand, in namespace_primary languages we do something
        /# different (see the NamespaceConstruct.compilePython.__init__.bld()
        /# method).
        build = {
          'name': nmspbase,
          'tests': [':%s' % k.id() for k in test_classes]}
        contents += '\n' + baselang.formatBuildRule('test_suite', build) + '\n'

      buildfile = metax.fs.BaseFile(buildpath, contents, metafile=metafile)
      metafile.registerFile(buildfile)

      /# TODO(wmh): Now that namespaces are nested within namespaces, determine
      /# whether this should be returning something meaningful!
      return [None, None]

      metax.c.D.translate.end()
    test:
      test.tpy(expand=True, imports=True)
      fs = test.compiler.fs()
      test.iseq([], list(fs.filemap().keys()))
      res = test.namespace.translateMeta()
      test.iseq([None, None], res)
      test.iseq(
        [
          'oopl/python/demo/tmp/.Error.py',
          'oopl/python/demo/tmp/.Person.py',
          'oopl/python/demo/tmp/.PersonMeta.py',
          'oopl/python/demo/tmp/.Student.py',
          'oopl/python/demo/tmp/.StudentMeta.py',
          'oopl/python/demo/tmp/.__init__.bld',
          'oopl/python/demo/tmp/BUILD',
          'oopl/python/demo/tmp/__init__.py',
        ],
        sorted(fs.filemap().keys()))
    end receiver NamespaceConstruct;

    receiver ClassConstruct ::
      /# Baselang-independent class compilation code.
      /#
      /# Notes:
      /#
      /#  - There are three separate ClassConstruct instances associated with
      /#    every user-specified class: 1) the user class, 2) a test class,
      /#    3) a meta class. Each of these is compiled separately.
      /#
      /#  - A class with name nm.sp.Ex has the following associated files:
      /#
      /#     1a. class definition
      /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$defn
      /#         where $defn is the baselang-specific suffix for definitions.
      /#
      /#     1b. line map for class definition
      /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.$defn.map
      /#         defining the mapping from line numbers in source .meta file and
      /#         line numbers in
      /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$defn.
      /#
      /#     2a. class declaration
      /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$decl
      /#         where $defn is the baselang-specific suffix for declarations.
      /#         Most languages, $decl == $defn, but in languages likes C++
      /#         they differ.
      /#
      /#     2b. line map for class declaration
      /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.$decl.map
      /#         defining the mapping from line numbers in source .meta file and
      /#         line numbers in
      /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$decl.
      /#
      /#     3.  build fragment for class
      /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.bld
      /#         containing a bazel ${basel}_library rule defining how to
      /#         compile the class and listing all deps (other Bazel targets),
      /#         and all data (aka resources).
      /#
      /# Actions:
      /#
      /#  - identify all dependencies that need importing (assocs plus implicit
      /#    dependencies like parent classes, baselang std library, etc.)
      /#     - produce baselang specific import syntax for these dependencies
      /#
      /#  - create the BUILD fragment representing the class
      /#    (in <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.bld)
      /#
      /#  - compile all class-level constructs to obtain the contents of the
      /#    class, writing baselang text to BaseStream instances and populating
      /#    the ClassConstruct instance with relevant data identified during
      /#    child processing (symbol tables, etc.)
      /#
      /#  - initialize a VarSet and instantiate the baselang class Template to
      /#    create <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$defn
      /#    (and, where needed,
      /#    <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$decl). The same
      /#    VarSet should be used to instantiate all source files associated
      /#    with the class, and all baselangs use the same variable names in
      /#    their templates.
      /#
      /# Returns:
      /#   The list of BaseFile instances created. This is normally null, since
      /#   most constructs do not produce files. However, claseses and
      /#   namespaces do.
      metax.c.D.translate.sinfo(self.kindfqn())

      metac = self.compiler()
      context = self.context()
      baselang = self.baselang()
      basel = baselang.id()
      metafile = self.metafile()
      consinfo = context.consinfo('class')
      namespace = self.namespace()
      fs = metac.fs()
      has_decl = baselang.config('definition_separate')
      variant = self.variant()
      suppress = self.suppress()

      /# TODO(wmh): How to establish the actual width?
      width = 80 - 0

      /###
      /# Process the scope. Subconstructs include:
      /#   field
      /#   method/initializer/finalizer/lifecycle/function
      /#   native
      /#   category

      /# See NamespaceConstruct.translateMeta() for a discussion of (and
      /# creation of) the many different streams that are defined for use while
      /# translating classes.
      /#  - we do not pass in create=True below because all streams should
      /#    have been created in NamespaceConstruct.translateMeta()
      /#  - we do need to clear the per-class streams for each class, but
      /#    the 'cls-pre-*' streams are special in that they are written by
      /#    constructs found BEFORE this class that are to be affiliated with
      /#    this class. Note that we obtain the pre-existing value and ignore
      /#    the new value, because for this class it is the pre-existing value
      /#    that is relevant (the new, empty, value is used by the next class,
      /#    not this one).
      /#  - the 'cls-post-*' streams are NOT obtained from metafile streams
      /#    because they are written during translateMeta(), and any data
      /#    written to such streams by constructs found AFTER this class
      /#    construct will not affect the code generated for this class. TO
      /#    handle this, NativeConstruct.expandMeta() inserts code into
      /#    class-specific streams for post-position native blocks. Something
      /#    similar may be implemented for post-position namespace-level
      /#    fields and methods if we decide to support them (see the discussion
      /#    in the SymbolConstruct.streams field for more details.
      defn_segments = self.streamNamed('cls-defn')
      decl_segments = self.streamNamed('cls-decl')
      pre_decl_segments = self.streamNamed('cls-pre-decl')
      pre_defn_segments = self.streamNamed('cls-pre-defn')
      post_decl_segments = self.streamNamed('cls-post-decl')
      post_defn_segments = self.streamNamed('cls-post-defn')

      /# special streams (useful in C++, probably not other baselangs)
      /#  - code that appears before or after the namespace syntax within
      /#    which this class is defined.
      if basel == 'cpp':
        nmsp_pre_decl_segments = self.streamNamed('pre-cls-decl')
        nmsp_pre_defn_segments = self.streamNamed('pre-cls-defn')
        nmsp_post_decl_segments = self.streamNamed('post-cls-decl')
        nmsp_post_defn_segments = self.streamNamed('post-cls-defn')

      scope, children = self.attrpair('scope:')
      for construct in children:
        construct.translateMeta()

      /# parentspec: str
      /#   the baselang syntax needed to define all parents (extends/implements)
      parentspec = baselang.formatParentSpec(self)

      /# Instantiate the template using the varset
      istestcase = self.isTestCase()
      basesuffix = baselang.suffix()
      template_name = baselang.id()
      if istestcase: template_name += '_test'
      if has_decl:
        /# For baselangs with two files per class, we print out the
        /# definition using the same flow as in other baselangs, and
        /# handle the declaration file specially.
        template_name += '_defn'

      /# Now we initialized [pre|post]class_[decl|defn], which are vectors
      /# strings and BaseSegment instances representing
      /#   preclass_decl:
      /#     code to insert before class declaration.
      /#     ignored for classes that do not distinguish decl/defn.
      /#   preclass_defn:
      /#     code to insert before class definition.
      /#   postclass_decl:
      /#     code to insert after class declaration.
      /#     ignored for classes that do not distinguish decl/defn.
      /#   postclass_defn:
      /#     code to insert after class definition.

      if has_decl:
        /# This baselang distinguishes between decl and defn.
        preclass_defn = pre_defn_segments
        postclass_defn = post_defn_segments
        preclass_decl = pre_decl_segments
        postclass_decl = post_decl_segments

        /# Now process dependencies into targets and imports
        imports_decl, targets = baselang.formatDependencies(self)
        imports_defn = []

      else:
        /# This class does not distinguish between decl and defn, so
        /# preclass_defn is a merging of pre_defn_segments and pre_decl_segments
        /# (usually empty), and postclass_defn is a merging of
        /# post_defn_segments and post_decl_segments (usually empty).
        preclass_defn = []
        postclass_defn = []
        /# Unused (but potentially modified in the second augmentVarset()).
        preclass_decl = []
        postclass_decl = []

        /# preclass_defn is a merging of pre_defn_segments and pre_decl_segments
        /# (the latter of which will usually be empty).
        if pre_decl_segments:
          /# print('#' * 80)
          /# print('Found pre decl:\n%s' % pre_decl_segments[0].flattenStr())
          preclass_defn.extend(pre_decl_segments)
        if pre_defn_segments:
          /# print('#' * 80)
          /# print('Found pre defn:\n%s' % pre_defn_segments[0].flattenStr())
          preclass_defn.extend(pre_defn_segments)
        if post_decl_segments:
          /# print('#' * 80)
          /# print('Found post decl:\n%s' % post_decl_segments[0].flattenStr())
          postclass_defn.extend(post_decl_segments)
        if post_defn_segments:
          /# print('#' * 80)
          /# print('Found post defn:\n%s' % post_defn_segments[0].flattenStr())
          postclass_defn.extend(post_defn_segments)

        /# Now process dependencies into targets and imports
        imports_defn, targets = baselang.formatDependencies(self)
        imports_decl = None  # unused

      /# comment: vec<str>
      /#   potentially multi-line string  representing documentation
      /#   associated with the class as a whole.
      /#
      /#   Note that formatClassComment() also modifies suppress, providing a
      /#   way for 'Meta:suppress <label>' syntax within a class or method
      /#   comment block to be added to a @fileoverview, method or BUILD target.
      /#
      /#   Note that by passing in a default value, we do not need to deal
      /#   with inserting a 'pass' in an empty class in Python.
      comment_attr = self.attr('comment:', default=None)
      comment = baselang.formatClassComment(
        comment_attr, suppress=suppress, default=['Undocumented.'])

      /# Create the VarSet of variables.
      varset = metax.c.VarSet()
      varset.addVar('imports', imports_defn)
      varset.addVar('imposts', [])   # unused?
      varset.addVar('preclass', preclass_defn)
      varset.addVar('postclass', postclass_defn)
      varset.addVar('preamble', [])  # may be modified in augmentVarset
      varset.addVar('postamble', [])  # may be modified in augmentVarset
      varset.addVar('namespace', namespace.id())
      varset.addVar('class', self.id(), attribute=self.primary())
      varset.addVar('parentspec', parentspec)
      varset.addVar('comment', comment, attribute=comment_attr)
      varset.addVar('scope', defn_segments, attribute=scope)
      /# varset.show()

      /# TODO(wmh): Is there a better way of providing baselang-specific
      /# augmentation of varsets?  By putting the code in BaseLanguage, we
      /# hide the code away from user modification.
      /#  - what we really want is multi-dispatch on construct and baselang
      /#  - could define augmentPythonVarset, augmentJavascriptVarset, etc.
      /#    in each construct class?
      baselang.augmentVarset(self, varset)

      /# Create the defn base file and associated mapfile
      template = consinfo.templateNamed(template_name)
      segment = metax.c.BaseSegment(self.primary())
      fqn = self.fqn()
      segment.instantiate(template, varset, self.kind(), fqn)
      mapfile = metax.c.MapFile(
        metac.basePath(fqn, prefix='.', suffix=basesuffix + '.map'),
        fs.realpath(fs.abspath(metafile.path())), [])
      contents = []
      segment.flattenLines(contents, mapfile, strip_special=True)
      basesubpath = baselang.classSubPath(self)
      basefile = metax.fs.BaseFile(
        basesubpath, '\n'.join(contents) + '\n',
        metafile=metafile, mapfile=mapfile)
      metafile.registerFile(basefile)

      /# If the baselang separates definition from declaration, do declaration.
      if has_decl:
        /# We have already written the declaration file (above), so now we
        /# instantiate the declaration file.
        template_name = template_name.replace('_defn', '_decl')
        template = consinfo.templateNamed(template_name)
        segment = metax.c.BaseSegment(self.primary())
        fqn = self.fqn()
        declsuffix = baselang.suffix(location='decl')

        /# Create the VarSet of variables.
        varset = metax.c.VarSet()
        varset.addVar('imports', imports_decl)
        varset.addVar('imposts', [])  # unused?
        varset.addVar('preclass', preclass_decl)
        varset.addVar('preamble', [])  # fixme
        varset.addVar('namespace', namespace.id())
        varset.addVar('class', self.id(), attribute=self.primary())
        varset.addVar('parentspec', parentspec)
        varset.addVar('comment', [])  # fixme
        varset.addVar('scope', decl_segments, attribute=scope)
        varset.addVar('postamble', [])  # fixme
        varset.addVar('postclass', postclass_decl)
        baselang.augmentVarset(self, varset, decl=True)
        /# varset.show()

        segment.instantiate(template, varset, self.kind(), fqn)
        mapfile = metax.c.MapFile(
          metac.basePath(fqn, prefix='.', suffix=declsuffix + '.map'),
          fs.realpath(fs.abspath(metafile.path())), [])
        contents = []
        segment.flattenLines(contents, mapfile, strip_special=True)
        basesubpath = baselang.classSubPath(self, location='decl')
        basefile = metax.fs.BaseFile(
          basesubpath, '\n'.join(contents) + '\n',
          metafile=metafile, mapfile=mapfile)
        metafile.registerFile(basefile)

      /# Create the .bld BUILD fragment
      /#  - until we can find a way to implement python namespaces in terms
      /#    of per-class files, we do NOT create .bld files for each class
      /#    in python
      bldfile = None
      if basel != 'python':
        bldpath = metac.basePath(fqn, prefix='.', suffix='.bld')
        if False:
          /# Useful during debugging.
          print(bldpath)
          self.showDependencies()
          print('  Targets:')
          for target in targets:
            print('    ' + target)
        rule, build_data = baselang.createBuildFragment(
          self, sorted(targets), test=istestcase)
        if rule is not None:
          fragment = baselang.formatBuildRule(rule, build_data)
          bldfile = metax.fs.BaseFile(bldpath, '\n' + fragment + '\n', metafile=metafile)
          metafile.registerFile(bldfile)

      metax.c.D.translate.end()
      return [basefile, bldfile]
    test:
      test.tpy(expand=True, imports=True)  # expand/import before translate
      test.klass.translateMeta()
      /# TODO(wmh): Lots of testing possible here.
    end receiver ClassConstruct;

    receiver FieldConstruct ::
      /# Field compilation code.
      /#  - for languages (like Python and Javascript) that define fields in
      /#    initializers, there is nothing to do in
      /#    FieldConstruct.translateMeta(), since it is all handled in the
      /#    initializer, which has been populated in FieldConstruct.expandMeta.
      /#  - for languages (like C++ and Java) for which there is an explicit
      /#    syntax for defining fields, we generate appropriate code here
      /#    (only for the field itself, not the accessors ... MethodConstruct
      /#    instances have been created/registered to deal with them in
      /#    FieldConstruct.expandMeta())
      metax.c.D.translate.sinfo(self.kindfqn())

      baselang = self.baselang()
      metafile = self.metafile()
      myclass = self.myclass()

      ftype = self.attrval('type', default=metax.c.LOOKUP)
      comment_attr, comlines = self.attrpair('comment:', default=None)

      /# TODO(wmh): Would be nice to use
      /#    BaseLanguageOopl.segmentForBlockAndComment()
      /# here, but we do not have a SimpleBlock representing the field code,
      /# so we would either need to fake up a SimpleBlock or provide other
      /# support.
      rem = baselang.config('rem')
      first_line = '%s field %s : %s' % (rem, self.id(), ftype)
      field_lines = baselang.formatFieldDefinition(self)

      if True:
        /# Manual formatting (repeats logic found in segmentForBlockAndComment).
        clines = []
        clines.append('')
        clines.append(first_line)
        if comlines:
          k = len(comlines) - 1
          while k > 0 and not comlines[k].strip():
            k -= 1
          for i in range(0, k+1):
            line = comlines[i]
            if line:
              clines.append(rem + '   ' + line)
            else:
              clines.append(rem)
        lines = clines[:]
        lines.extend(field_lines)

      if False:
        /# Formatting based on segmentForBlockAndComment.
        /#  - there is unfortunately some inefficiency and hackery involved in
        /#    this approach
        /#     - need to create a creating tmp SimpleBlock that is promptly
        /#       thrown away.
        /#     - need to insert first_line into index 1 of the resulting
        /#       segment (index 0 is a blank line). Fragile and hacky.
        /#  - may not be worth it to reuse segmentForBlockAndComment().
        field_scope = metax.attr.SimpleBlock(self, 'scope:', field_lines, line=-3)
        field_segment = baselang.segmentForBlockAndComment(
          field_scope, comment_attr, cdent='  ')
        field_segment.chunks().insert(1, first_line)
        field_segment.metalineIs(field_segment.metaline() - 1)

      if False:
        /# Compare the output produced by the above two blocks.
        text1 = '\n'.join(lines) + '\n'
        text2 = field_segment.flattenStr()
        if text1 != text2:
          print('#' * 80)
          print(text1)
          print('=' * 80)
          print(text2)
          print('LINE is %d' % field_segment.metaline())

      /# In most languages, the field definition occurs in the merged defn/decl
      /# stream, but in languages with separated decl/defn (at least in C++),
      /# the field declaration is written into the declaration stream (and
      /# is initialized in the definition).
      /# TODO(wmh): Define a method on BaseLanguageOopl for determining which
      /# stream to write field declarations to?
      has_decl = baselang.config('definition_separate')
      if lines:
        /# TODO(wmh): Make this a segment!
        /# Use BaseLanguageOopl.segmentForBlockAndComment().
        if has_decl:
          myclass.streamNamed('cls-decl').extend(lines)
        else:
          myclass.streamNamed('cls-defn').extend(lines)

      if has_decl:
        defn_lines = baselang.formatFieldDefinition(self, defn=True)
        /# TODO(wmh): Make this a segment!
        /# Use BaseLanguageOopl.segmentForBlockAndComment().
        myclass.streamNamed('cls-post-defn').extend(defn_lines)

      metax.c.D.translate.end()
    test:
      test.tpy()
      segments = test.klass.streamNamed('cls-defn')
      test.field.translateMeta()
      test.iseqvec(['', '# field name : str'], segments)
    end receiver FieldConstruct;

    receiver ExecutableConstruct ::
      /# Executable compilation code.
      /#  - format the signature
      /#  - format the comment
      /#  - insert auto-generated preamble (initialize fields, super calls,
      /#    typechecking)
      /#  - insert user-provided code (or implicit stub)
      /#  - insert postamble
      metax.c.D.translate.sinfo(self.kindfqn())

      attrkind = self.attrval('kind')
      presence = self.attrval('presence')
      optimization = self.attrval('optimization')
      returntype = self.attrval('returns')
      self.returntypeIs(returntype)
      myclass = self.myclass()
      metafile = self.metafile()

      /# modifiers : vec<str>
      /#   The modifiers to add before the class
      modifiers = []

      /# scope_attr : SimpleBlock or ComplexBlock
      /#   The scope: attribute
      /# scope_lines : vec<str>
      /#   The lines making up the executable body.
      /# preamble : vec<str>
      /#   The lines of baselang text to insert within scope before user code.
      /# postamble : vec<str>
      /#   The lines of baselang text to insert within scope after user code.
      /# retamble : str or null
      /#   The line to add to the very end of the method (return).
      (scope_attr, scope_lines, preamble, postamble, retamble, comment,
       params_str) = self.methodInfo()

      /# method constructs have simplex scopes, which means they can be either
      /# SimpleBlocks or ComplexBlocks. If we have a complex block, we need to
      /# recursively compile to obtain scope lines.
      if scope_attr and scope_attr.isComplexBlock():
        /# TODO(wmh): By tromping on this each time, we preclude having 'method'
        /# constructs within method scopes (something we want to support). We
        /# need to conditionally initialize the stream so that we don't tromp on
        /# a stream already in place (but we *do* want to reset the stream if
        /# this is a top-level method within a class). Consider maintaining a
        /# stack of streams. Note that in the new implementation, if we
        /# continue to allow MethodConstruct instances to have a streams field,
        /# it will be easy ... just find the top-level method and ask for
        /# the streamNamed('current-body') on it. For now we just use a
        /# stream defined on ClassConstruct (and reset each time).
        segments = myclass.streamNamed('current-body', clear=True)
        /# Every nested block in the method is represented by a BaseSegment, and
        /# sub-constructs add to the last segment found in current-body. This
        /# allos us to handle arbitrary levels of indentation, as long as
        /# the order of lines in the meta source correspond to order of lines
        /# in baselang.
        segment = metax.c.BaseSegment(scope_attr, indent='')
        segments.append(segment)

        /# The 'current-body' stream will be updated by the following loop.
        for stmt in scope_attr.value():
          /# print('HERE with %s' % stmt.kindfqn())
          stmt.translateMeta()

        /# Now we have all segments making up the complex block.
        scope_lines = myclass.streamNamed('current-body')
        assert scope_lines is segments

      /# postmethod : vec<str>
      /#   The lines of baselang text to insert after scope.
      postmethod = []

      if scope_lines is None:
        /# This method is not to be generated.
        pass

      else:
        baselang = self.baselang()
        rem = baselang.config('rem')
        comment_attr = attribute=self.attr('comment:', default=None)

        /# Establish the baselang-level name of the method.
        if attrkind == 'initializer':
          execname = baselang.initializerName(self)
        else:
          /# We currently have some hackery in place around getter method ids,
          /# which are the same as the underlying field. To avoid having the
          /# field and getter conflict, we add a special ':get' to the getter
          /# in FieldConstruct.expandMeta() and a special clause in
          /# ExprParser.ID_RE.  We remove it here.
          /#
          /# To make it less hacky, the following code is sufficiently general
          /# to convert <name>:get to <name>, <name>Is:set to <name>Is, and
          /# <name>Ref:ref to <name>Ref. In particular, it strips off a suffix
          /# of the form ':(get|set|ref)$'.
          execname = self.id()
          m = metax.c.ExprParser.ID_RE.match(execname)
          if m and m.group(3):
            /# print('***** HERE with %s' % execname)
            execname = (m.group(1) or '') + m.group(2)

        /# Establish baselang syntax for method return type.
        return_str = baselang.typeToBase(returntype, class_construct=myclass)

        /# Create the VarSet of variables.
        varset = metax.c.VarSet()
        varset.addVar('modifiers', modifiers)
        varset.addVar('method', execname, attribute=self.primary())
        varset.addVar('fqn', myclass.fqn())
        varset.addVar('class_base', myclass.id())
        varset.addVar('params', params_str)
        varset.addVar('returns', return_str)
        varset.addVar('comment', comment, comment_attr)
        varset.addVar('preamble', preamble)
        varset.addVar('scope', scope_lines, attribute=scope_attr)
        varset.addVar('postamble', postamble)
        varset.addVar('postmethod', postmethod)

        if metax.oopl.ExecutableConstruct.IsTestName(execname):
          varset.addVar(
            'method_base', metax.oopl.ExecutableConstruct.UntestifyName(execname))

        /# Allow baselangs to modify the varset
        /#  - they may modify 'preamble'
        baselang.augmentVarset(self, varset)
        if preamble:
          /# This must be the last line in the preamble in order for
          /# base-to-meta line numbers to be correct!
          preamble.append('%s User-provided code follows.' % rem)

        /# This should be empty if the scope is NOT being inlined.
        /# Currently the code only supports inlining for definition_separate
        /# baselangs.
        inline = ''
        has_decl = False
        has_defn = True
        if baselang.config('definition_separate'):
          /# For baselangs with two files per class, we print out the
          /# declaration using the same flow as in other baselangs, and handle
          /# the definition file specially.
          has_decl = True
          if presence == 'abstract':
            has_defn = False

          if scope_lines:
            /# If this is an accessor being defined, we want to inline the code.
            /# If it is a single line, we do so more concisely than we otherwise
            /# would.
            if optimization == 'inline' and len(scope_lines) == 1:
              if rem not in scope_lines[0]:
                /# Until we can test whether this method is an accessor or not,
                /# we must avoid lines with comments if we want to put the
                /# text on a single line ending with '}'.
                inline = ' { %s }' % scope_lines[0]
            else:
              /# TODO(wmh): Allow any number of lines!
              pass

        template_name = baselang.establishTemplateName(self, defn=True)
        consinfo = self.context().consinfo(self.kind())

        /# Add a return line if one has been identified.
        if retamble:
          /# It is critical that these line be the very last in postamble.
          /# TODO(wmh): If the user-provided content unambiguously invokes
          /# a return statement before end-of-method, we do NOT need to
          /# insert these implicit lines.
          postamble.extend(retamble)

        /# The normal action is to write the method to 'defn'
        /#  - the only time we do not do this is if the baselang has a
        /#    separation between decl and defn and the method is inlined (in
        /#    which case we put it only in decl, not in defn). Note that this
        /#    logic is C++-centric, but the distinction between defn and decl is
        /#    probably C++ specific too.
        if has_defn and (not has_decl or not inline):
          template = consinfo.templateNamed(template_name)
          segment = metax.c.BaseSegment(None)
          segment.instantiate(template, varset, self.kind(), self.fqn())
          myclass.streamNamed('cls-defn').append(segment)

        if has_decl:
          /# This baselang has different syntax for declaring a method and
          /# defining it (in separate files). We've already written the
          /# definition to the 'cls-defn' stream, and now we write the
          /# declaration to the 'cls-decl' stream.
          template_name = baselang.establishTemplateName(self, defn=False)
          template = consinfo.templateNamed(template_name)
          segment = metax.c.BaseSegment(None)

          /#varset.addVar('inline', inline, attribute=scope)
          if not inline:
            inline = ';'
          varset.addVar('inline', inline)

          dummy = []
          params_str_decl = baselang.formatParams(self, dummy, decl=True)
          varset.setValue('params', params_str_decl)

          segment.instantiate(template, varset, self.kind(), self.fqn())
          myclass.streamNamed('cls-decl').append(segment)

      metax.c.D.translate.end()
    test:
      test.tpy(expand=True, imports=True)
      segments = test.klass.streamNamed('cls-defn')
      test.method.translateMeta()
      test.iseqtext('''
        >|def bmi(self):
        >|  """Calculate body mass index of this person.
        >|  Result is unitless, but relies on height in meters and
        >|  weight in kilograms.
        >|  """
        >|  return 0.0
        >|''',
        segments[0].flattenStr())
    end receiver ExecutableConstruct;

    receiver LifecycleConstruct ::
    test:
      pass
    end receiver LifecycleConstruct;

    receiver BehaviorConstruct ::
      return (None, None)
    test:
      pass
    end receiver BehaviorConstruct;

    receiver CategoryConstruct ::
      /# Field compilation code.
      /#  - generate
      /#  - for languages that are namespace-primary (e.g. Python), create a
      /#    file representing the namespace (aka module)
      /#  - create a BUILD file containing all targets for building the classes
      /#    in the namespace, and for building the namespace itself.
      metax.c.D.translate.sinfo(self.kindfqn())
      scope = self.attrval('scope:', default=None)
      if scope:
        for child in scope:
          child.translateMeta(output=output)
      metax.c.D.translate.end()
    test:
      pass
    end receiver CategoryConstruct;

    receiver RemarkConstruct ::
      metax.c.D.translate.sinfo(self.kindfqn())
      /# TODO(wmh): Write a baselang comment here!
      metax.c.D.translate.end()
    test:
      /# noop
      pass
    end receiver RemarkConstruct;

    receiver NativeConstruct ::
      /# verbatim dump
      parent_construct = self.parentConstruct()
      kind = parent_construct.kind()

      if kind == 'class':
        metafile = self.metafile()
        baselang = self.baselang()
        scope = self.attr('scope:', default=None)
        if scope:
          precount = self.precount()
          /# We adjust metaline down by precount so that an error on line
          /# precount corresponds to scope.line() ... e.g. the blank lines
          /# inserted should not break line mapping.
          metaline = scope.line() - precount
          lines = []
          for i in range(0, precount):
            lines.append('')
          baselang.simpleToBase(scope, output=lines)
          segment = metax.c.BaseSegment(scope, metaline=metaline, chunks=lines)
          /# TODO(wmh): scope: goes in cls-defn, but if decl: exist it should
          /# go in 'cls-decl'.
          parent_construct.streamNamed('cls-defn').append(segment)

      elif kind == 'namespace':
        /# All native constructs are processed in expandMeta().
        /# See the SymbolConstruct.streams field comment for details.
        pass

      return (None, None)
    test:
      pass
    end receiver NativeConstruct;

    receiver CommandConstruct ::
      /# Translate.  Write baselang comment.
      metax.c.D.translate.sinfo(self.kindfqn())
      /# This is currently a noop, as we form a 'method' in expandMeta and
      /# rely on MethodConstruct.translateMeta() to do its thing.
      metax.c.D.translate.end()
    test:
      pass
    end receiver CommandConstruct;

    receiver FlagConstruct ::
      /# Translate.  Write baselang comment.
      metax.c.D.translate.sinfo(self.kindfqn())
      /# I don't believe we ever use this, right?
      raise metax.c.Error('Should never get here')
      metax.c.D.translate.end()
    test:
      pass
    end receiver FlagConstruct;

    receiver BlockConstruct ::
      metax.c.D.translate.sinfo(self.kindfqn())
      /# IMPORTANT: It is assumed this code is only invoked for
      /# statement-level blocks. Blocks are also used within commands,
      /# but the command-compiling code handles them directly without
      /# delegating to this method.
      metafile = self.metafile()
      metac = metafile.compiler()
      baselang = metac.baselang()
      basel = baselang.id()

      start_lines = []
      end_lines = []

      ok = True
      method = self.myexec()
      if not method:
        metafile.error('failed to find parent method for block %s' % self.fqn())
        ok = False
      else:
        myclass = method.myclass()
        bkind = self.attrval('kind')
        if bkind == 'virtual':
          /# No start/end lines, and the scope is compiled at same indentation
          /# level as containing code.
          indent = ''
        elif bkind == 'scoped':
          /# TODO(wmh): Rename scoped to nested or at least provide an alias.
          indent = '  '
          if basel == 'python':
            start_lines.append('if True:')
          elif basel == 'javascript':
            start_lines.append('if (true) {')
            end_lines.append('}')
          elif basel == 'cpp':
            start_lines.append('{')
            end_lines.append('}')
          else:
            ok = False
            raise metax.c.InternalError(
              'BlockConstruct.translateMeta needs work for %s' % basel)
        elif bkind == 'named':
          /# For now we do not support named blocks within statements. However,
          /# it is possible this could be a useful idea.
          metafile.error(
            'failed to find parent method', attr=self.primary())
          ok = False

      /# TODO(wmh): Confirm this supports baselang qualifiers!
      scope_attr, scope = self.attrpair('scope:', default=None)
      if scope_attr is None:
          metafile.error(
            'failed to find required scope', attr=self.primary())
          ok = False

      if ok:
        assert indent is not None
        self._statementCode(
          start_lines, scope_attr, end_lines=end_lines, indent=indent)

      metax.c.D.translate.end()
    test:
      /# Test virtual and scoped blocks.
      test.checkStatement("""\
        >|namespace hack.stmts scope:
        >|  class A scope:
        >|    method f scope<*>:
        >|      block b1 scope<py>:
        >|        print('hello')
        >|      scope<js>:
        >|        console.log('hello')
        >|      scope<cc>:
        >|        std::cout << "Hello" << std::endl;
        >|      end;
        >|
        >|      scoped block b2 scope<py>:
        >|        print('hello')
        >|      scope<js>:
        >|        console.log('hello')
        >|      scope<cc>:
        >|        std::cout << "Hello" << std::endl;
        >|      end;
        >|""",
        /# Path
        '/hack.stmts/A/f',
        /# Output
        expected={
          'cc': """\
            >|std::cout << "Hello" << std::endl;
            >|
            >|{
            >|  std::cout << "Hello" << std::endl;
            >|}
            >|""",
          'js': """\
            >|console.log('hello')
            >|
            >|if (true) {
            >|  console.log('hello')
            >|}
            >|""",
          'py': """\
            >|print('hello')
            >|
            >|if True:
            >|  print('hello')
            >|""",
        }
      )
    end receiver BlockConstruct;

    receiver VarConstruct ::
      metafile = self.metafile()
      metac = metafile.compiler()
      baselang = metac.baselang()
      basel = baselang.id()
      /# TODO(wmh): Use a stream within the method instead (and have statements
      /# cache their method??)
      method = self.myexec()
      myclass = method.myclass()

      /# Register the variable in the method's symbol table
      method.registerSymbol(self.id(), self, note='Local variable')

      segments = myclass.streamNamed('current-body')
      expr = self.attrval('default', None)

      /# Every statement is added to the last BaseSegment in segments, which
      /# is required to exist and be a BaseSegment, not a string.
      segment = segments[-1]
      assert isinstance(segment, metax.c.BaseSegment)
      code, codetype = baselang.compileExpr(
        expr, metafile, metatype=self.attrval('type'), indent='')

      if basel == 'python':
        line = '%s = %s' % (self.id(), code)
      elif basel == 'javascript':
        /# TODO(wmh): Decide whether we want to support a similar distinction
        /# between method-level and block-level variables as javascript
        /# supports via 'var' and 'let'.  For now always using block-level.
        /# Note that it will be difficult to emulate block-level scoping in
        /# python.
        line = 'let %s = %s;' % (self.id(), code)
      else:
        raise metax.c.InternalError(
          'SetConstruct.translateMeta not implemented for %s' % basel)

      segment.addLine(line)
    test:
      metafile = test.metafile

      /# We must first ensure that the 'current-body' stream has a BaseSegment
      /# at the end, into which the vars will be compiled.
      klass = test.var1.parentConstruct().parentConstruct()
      segments = klass.streamNamed('current-body')
      segment = metax.c.BaseSegment(None)
      segments.append(segment)

      test.var4 = test.mscope.cons('v2')

      test.var1.translateMeta()
      test.var2.translateMeta()
      test.var3.translateMeta()
      test.var4.translateMeta()
      test.iseq(['f = 0', 'g = 17', 'v = None', 'v2 = []'], segment.chunks())
      /# TODO(wmh): Lots more can be tested here as the code is made more
      /# robust.
    end receiver VarConstruct;

    receiver SetConstruct #:
      Assign a value to a variable.
    scope:
      metafile = self.metafile()
      baselang = self.baselang()
      basel = baselang.id()

      /# TODO(wmh): Verify that replacer semantics is working properly.
      /#  - The syntax 'set i = 1;' is shorthand for 'set varname i = 1;'
      /#    with an implicit id assigned.
      varname = self.attrval('varname', default=None)
      if varname is None:
        print('*********** HERE IN SET WITH FAILED REPLACER!')
        varname = self.id()

      /# Obtain the value of the expression to assign to.
      value_attr, value_expr = self.attrpair('value', default=None)
      if not value_attr:
        metafile.error('must provide value on set')
      else:
        value_code, codetype = baselang.compileExpr(
          value_expr, metafile, metatype=None, indent='')

        /# TODO(wmh): Do this part in BaseLanguageOoopl subclasses.
        if basel == 'python':
          line = '%s = %s' % (varname, value_code)
        elif basel == 'javascript':
          line = '%s = %s;' % (varname, value_code)
        else:
          raise metax.c.InternalError(
            'SetConstruct.translateMeta not implemented for %s' % basel)

        myclass = self.ancestor('class')
        segment = myclass.streamNamed('current-body')[-1]
        segment.addLine(line)
    test:
      /# Test set.
      test.checkStatement("""\
        >|namespace hack.stmts scope:
        >|  class A scope:
        >|    method f scope<*>:
        >|      var a = 1;
        >|      set s1 varname a = 2;
        >|      set varname a = 3;
        >|      set a = 4;
        >|""",
        /# Path
        '/hack.stmts/A/f',
        /# Output
        expected={
          'py': """\
            >|a = 1
            >|a = 2
            >|a = 3
            >|a = 4
            >|""",
          'js': """\
            >|let a = 1;
            >|a = 2;
            >|a = 3;
            >|a = 4;
            >|""",
        }
      )
    end receiver SetConstruct;

    receiver LoopConstruct #:
      Resources:
        For javascript:
          https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration
    scope:
      metafile = self.metafile()
      /# There are numerous variants of a loop, dictated by which secondary
      /# attributes exist.  Existence is checked for in the following order:
      /#  - If 'to' exists, a numeric loop is generated, with 'from' and 'by'
      /#    considered and taking on values 0 and 1 respectively if not given
      /#    (all other non-scope attributes ignored).
      /#  - If 'over' exists, an iteration of a container is generated, and
      /#    both 'while' and 'until' are ignored.
      /#  - If 'while' exist, compile the expr and loop, checking at start of
      /#    loop for the bool. Still deciding whether an 'until' clause can
      /#    be added to a 'while' or if they are exclusive.
      /#  - If 'until' exist, compile the expr and loop infinitely, checking
      /#    at end of loop for the bool (if the baselang doesn't support
      /#    until directly).
      scope_attr, scope = self.attrpair('scope:', default=metax.c.EMPTY)
      baselang = self.baselang()
      basel = baselang.id()

      /# TODO(wmh): The 'loop' construct specifies that the primary attribute
      /# has replacer semantics (the id is implicitly transfered to the 'on'
      /# attribute and the id is auto-assigned if there is no explicit 'on'.
      /# However, that is not working ... fix it and clean up this code.
      name = self.attrval('on', default=None)
      if name is None:
        name = self.id()

      /# One or both to be initialized below.
      start_lines = None
      end_lines = None
      invalid = False

      /# If 'to' exists, generate numeric loop (consider 'from' and 'by', ignore
      /# all others).
      to_attr, to_expr = self.attrpair('to', default=None)
      if to_attr:
        to_val = to_expr.value()
        from_expr = self.attrval('from', default=None)
        from_val = from_expr.value() if from_expr else '0'
        by_expr = self.attrval('by', default=None)
        by_val = by_expr.value() if by_expr else '1'

        /# TODO(wmh): Do this part in BaseLanguageOoopl subclasses.
        if basel == 'python':
          start_lines = [
            'for %s in range(%s, %s, %s):' % (name, from_val, to_val, by_val)
          ]
        elif basel == 'javascript':
          /# TODO(wmh): Insert a 'let' if name isn't already defined in
          /# the block, but do not insert it if it is defined.
          letstr = 'let ' if True else False
          start_lines = [
            'for (%s%s = %s; %s < %s; %s += %s) {' % (
              (letstr, name, from_val, name, to_val, name, by_val))
          ]
          end_lines = ['}']
        else:
          raise metax.c.InternalError(
            'LoopConstruct.translateMeta (to) not implemented for %s' % basel)

      else:
        over_attr, over_expr = self.attrpair('over', default=None)
        if over_attr:
          /# If 'over' exists, generate loop over enumration, ignoring all
          /# other attributes.

          if basel == 'python':
            start_lines = ['for %s in %s:' % (name, over_expr.value())]
          elif basel == 'javascript':
            /# TODO(wmh): Insert a 'let' if name isn't already defined in
            /# the block, but do not insert it if it is defined.
            letstr = 'let ' if True else False
            start_lines = [
              'for (%s%s of %s) {' % (letstr, name, over_expr.value()),
            ]
            end_lines = ['}']
          else:
            raise metax.c.InternalError(
              'LoopConstruct.translateMeta (over) not implemented for %s' % basel)

        else:
          while_attr, while_expr = self.attrpair('while', default=None)
          if while_attr:
            /# If 'while' exists, generate while loop, ignoring all others.
            /# TODO(wmh): Consider allowing both 'while' and 'until' in same
            /# statement.
            assert while_expr.kind() == 'bool'
            boolstr, mtype = baselang.compileExpr(while_expr, metafile)
            /# TODO(wmh): If the result is multilined, we need to split it into
            /# lines. Would be better if compileExpr or some variant returned
            /# a list of lines.
            assert '\n' not in boolstr

            if basel == 'python':
              start_lines = ['while %s:' % boolstr]
            elif basel == 'javascript':
              start_lines = ['while %s {' % boolstr]
              end_lines = ['}']
            else:
              raise metax.c.InternalError(
                'LoopConstruct.translateMeta (while) not implemented for %s' % basel)

          else:
            until_attr, until_expr = self.attrpair('until', default=None)
            if until_attr:
              /# Generate do ... until loop.
              assert until_expr.kind() == 'bool'
              boolstr, btype = baselang.compileExpr(until_expr, metafile)
              assert '\n' not in boolstr

              if basel == 'python':
                start_lines = ['while True:']
                end_lines = ['  if %s: break' % boolstr]
              elif basel == 'javascript':
                start_lines = ['do {']
                end_lines = ['} while %s;' % boolstr]
              else:
                raise metax.c.InternalError(
                  'LoopConstruct.translateMeta (until) not implemented for %s' % basel)

            else:
              metafile.error('Useless loop', line=self.primary().line())
              invalid = True

      /# Generate the actual code based on start lines, scope and end lines.
      if not invalid:
        self._statementCode(start_lines, scope_attr, end_lines=end_lines)

    test:

      /# Test loop from ... to ...
      test.checkStatement("""\
        >|namespace hack.stmts scope:
        >|  class A scope:
        >|    method f scope<*>:
        >|      loop l1 on i from 1 to 10 scope<py>:
        >|        print(i)
        >|      scope<js>:
        >|        console.log(i);
        >|""",
        /# Path
        '/hack.stmts/A/f/l1',
        /# Output
        expected={
          'py': """\
            >|for i in range(1, 10, 1):
            >|  print(i)
            >|""",
          'js': """\
            >|for (let i = 1; i < 10; i += 1) {
            >|  console.log(i);
            >|}
            >|""",
        }
      )

      /# Test loop from ... to ...
      test.checkStatement("""\
        >|namespace hack.stmts scope:
        >|  class A scope:
        >|    method f scope<*>:
        >|      loop l2 on j over values scope<py>:
        >|        print(j)
        >|      scope<js>:
        >|        console.log(j);
        >|""",
        /# Path
        '/hack.stmts/A/f/l2',
        /# Output
        expected={
          'py': """\
            >|for j in values:
            >|  print(j)
            >|""",
          'js': """\
            >|for (let j of values) {
            >|  console.log(j);
            >|}
            >|""",
        },
      )

      /# Test while.
      test.checkStatement("""\
        >|namespace hack.stmts scope:
        >|  class A scope:
        >|    method f scope<*>:
        >|      loop while ((3 < i < 10) and (j == 10)) scope<py>:
        >|        print(i)
        >|        i += 1
        >|      scope<js>:
        >|        console.log(i);
        >|        i += 1;
        >|""",
        /# Path
        '/hack.stmts/A/f/Meta__1__',
        /# Output
        expected={
          'py': """\
            >|while ((3 < i) and (i < 10) and (j == 10)):
            >|  print(i)
            >|  i += 1
            >|""",
          'js': """\
            >|while ((3 < i) and (i < 10) and (j == 10)) {
            >|  console.log(i);
            >|  i += 1;
            >|}
            >|""",
        },
        verbose=False,
      )

      /# Test until.
      /#  - TODO(wmh): Note the 'loop _' (without it, parsing fails when
      /#    scope<py> appears after 'loop' rather than just 'scope:'.
      test.checkStatement("""\
        >|namespace hack.stmts scope:
        >|  class A scope:
        >|    method f scope<*>:
        >|      loop _ scope<py>:
        >|        print(i)
        >|        i += 1
        >|      scope<js>:
        >|        console.log(i);
        >|        i += 1;
        >|      until ((3 < i < 10) and (j == 10));
        >|""",
        /# Path
        '/hack.stmts/A/f/Meta__1__',
        /# Output
        expected={
          'py': """\
            >|while True:
            >|  print(i)
            >|  i += 1
            >|  if ((3 < i) and (i < 10) and (j == 10)): break
            >|""",
          'js': """\
            >|do {
            >|  console.log(i);
            >|  i += 1;
            >|} while ((3 < i) and (i < 10) and (j == 10));
            >|""",
        },
        verbose=False,
      )
    end receiver LoopConstruct;

    receiver SwitchConstruct ::
      metafile = self.metafile()
      baselang = metafile.compiler().baselang()

      /# There are numerous variants of a switch, dictated by which secondary
      /# attributes are explicitly defined on the construct.
      /#  - If 'on' is specified, we will be comparing the value of the
      /#    variable identified by 'on' in each case.
      /#  - If 'on' is not specified (or specified with a special value to
      /#    indicate it is not really there ... needed in situations where we
      /#    want an explicit id (e.g. not auto-assigned) but do not want an
      /#    'on' attribute, which the id is replacer'ed to).
      scope_attr, scope = self.attrpair('scope:', default=None)
      if scope_attr is None:
        metafile.error(
          'Must provide at least one case', attr=self.primary())
        return None

      /# Establish the variable we are switching on, if any, and the else.
      /#  - TODO(wmh): Consider removing the 'else' attribute in favor of
      /#    a case with no expr. There are pros and cons both ways:
      /#     - using a case allows for easy switching of order, but if one
      /#       doesn't add an expr the no-expr case will grab all results
      /#       (unless we have Meta verify that no-expr case only appears as
      /#       last one).
      /#     - using else clearly highlights the specialness of the default
      on_attr, on = self.attrpair('on', default=None)
      else_attr, else_lines = self.attrpair('else:', None)

      /# Generate the iniital switch code and recurse over case children.
      /#  - need to know whether baselang supports switch or not.
      use_switch = self.useSwitch(self, baselang)
      if use_switch:
        /# TODO(wmh): baselangs have different syntax.
        segment = self._statementCode(['switch (%s) {' % on], scope_attr)
      else:
        /# There is no switch-level lines, each case is implemented as an
        /# if/elif, and they are not indented relative to the current segment.
        segment = self._statementCode([], scope_attr, indent='')

      /# Handle the default.
      if else_attr:
        if use_switch:
          self._statementCode(['default:'], else_attr)
        else:
          /# TODO(wmh): Exact syntax is baselang specific.
          self._statementCode(['else:'], else_attr)

      /# Add termination.
      if use_switch:
        /# TODO(wmh): Exact syntax is baselang specific.
        segment.addLine('}')

    test:
      /# NOTE: We cannot rely on test.checkStatement(), as that method only
      /# expands/translates the low-level construct identified by mxpath.
      /# A switch needs a properly initialized parent method, which means that
      /# expand/translate must be invoked at least on the class. We do
      /# everything.
      metafile, _, _ = test.compiler.processMeta(
        '/dummy/path65.meta',
        text="""\
        >|namespace hack.stmts scope:
        >|  class A scope:
        >|    method f scope<*>:
        >|      switch input scope:
        >|        case 1 ::
        >|          v = 2
        >|        case 2 ::
        >|          v = 7
        >|""",
        expand=True, imports=False, translate=True, compile=False)

      /# We intentionally are not naming the switch statement using
      /#   switch somename on input scope:
      /# as that isn't remotely going to be a common case. But it does
      /# mean we cannot access the node directly via Construct.child().
      /# We obtain the method scope, and grab the first construct within it.
      scope = metafile.construct().child('/hack.stmts/A/f/@scope')
      switch = scope.value()[0]
      test.iseq('switch', switch.kind())
      test._checkStatement(
        metafile, switch, expected="""\
         >|if input == 1:
         >|  v = 2
         >|elif input == 2:
         >|  v = 7
         >|""")

      /# TODO(wmh): Support the following syntax!
      /#  - note that there is no explicit scope: on the switch, and the
      /#    case constructs are at the same level as the 'switch'.
      /#  - Meta should support this kind of syntactic short-hand:
      /#     - register certain constructs allowed within the scope: to also
      /#       be allowed to appear at same indentation as the construct
      /#     - when encountered, they are implicitly added to the scope:
      /#     - code must remember the implicitness so that write() can recreate
      /#       the verbatim syntax.
      /#     - only makes sense for constructs with complex-valued scope blocks.
      /#     - could be extended to apply to attributes other than scope:, for
      /#       example:
      /#         method f : int params:
      /#           var a : int;
      /#           var b : str = null;
      /#         scope:
      /#         end;
      /#       could become:
      /#         method f : int
      /#         var a : int;
      /#         var b : str = null;
      /#         scope:
      /#         end;
      return
      metafile, _, _ = test.compiler.processMeta(
        '/dummy/path65.meta',
        text="""\
        >|namespace hack.stmts scope:
        >|  class A scope:
        >|    method f scope<*>:
        >|      switch input
        >|      case 1 ::
        >|        v = 2
        >|      case 2 ::
        >|        v = 7
        >|""",
        expand=True, imports=False, translate=True, compile=False)
    end receiver SwitchConstruct;

    receiver CaseConstruct ::
      metafile = self.metafile()
      baselang = metafile.compiler().baselang()

      /# TODO(wmh): We need a method that obtains the nearest ancestor of self
      /# that has a symboltable.
      symcons = self.parentConstruct().parentConstruct()

      /# Must have an 'expr' attribute.
      /#  - or do we want to have a case without 'expr' be the final 'else'
      /#    clause?
      expr_attr, expr = self.attrpair('expr', default=None)
      if expr_attr is None:
        metafile.error('missing required expr', attr=self.primary())
        return
      estr, etype = baselang.compileExpr(
        expr, metafile, executable=symcons)

      /# Must have a 'scope' attribute
      scope_attr = self.attr('scope:', default=None)
      if scope_attr is None:
        metafile.error('missing required scope', attr=self.primary())
        return

      /# Whether the parent 'switch' has an 'on' attribute controls how this
      /# case will be translated.
      switch_ = self.parentConstruct()
      if switch_.kind() != 'switch':
        metafile.error('expecting switch parent', attr=self.primary())
        return
      on_attr, on = switch_.attrpair('on', default=None)
      if not on_attr and expr.kind() != 'bool':
        /# No 'on' variable means each expr is a boolexpr that guards the
        /# case block.
        metafile.error('expecting bool expr', attr=self.primary())
        return

      /# Most code paths below require us to know whether this is the first
      /# case in the parent or not.
      switch_scope = switch_.attrval('scope:')
      isfirst = self is switch_scope[0]

      /# Establish whether to use switch...case or if..elif..else.
      use_switch = self.useSwitch(switch_, baselang)

      /# Now generate the code.
      if use_switch:
        /# We are generating a switch/case statement.
        /# TODO(wmh): The exact case syntax differs between baselangs.
        self._statementCode('case %s:' % estr, scope_attr)
      else:
        /# TODO(wmh): Define ifelseSyntax behavior in BaseLanguageOopl and
        /# subclasses. Returns list of lines representing the if or elif block
        /# depending on if first or not
        if expr.kind() != 'bool':
          estr = '%s == %s' % (on, estr)
        ifsyn = ['%sif %s:' % ('' if isfirst else 'el', estr)]
        /# ifsyn = baselang.ifelseSyntax(estr, isfirst)
        self._statementCode(ifsyn, scope_attr)
    test:
      code = """\
        >|namespace hack.stmts scope:
        >|  class A scope:
        >|    method f scope<*>:
        >|      switch s1 on h scope:
        >|        case is 1 :<py>:
        >|          f = 1
        >|        case is 2 :<py>:
        >|          f = 7
        >|"""

      test.checkStatement(
        code,
        /# Path
        '/hack.stmts/A/f/s1/Meta__1__',
        /# Output
        expected={
          'py': """\
            >|if h == 1:
            >|  f = 1
            >|""",
        },
      )

      test.checkStatement(
        code,
        /# Path
        '/hack.stmts/A/f/s1/Meta__2__',
        /# Output
        expected={
          'py': """\
            >|elif h == 2:
            >|  f = 7
            >|""",
        },
      )

      code2 = """\
        >|namespace hack.stmts scope:
        >|  class B scope:
        >|    method f scope<*>:
        >|      var h : map;
        >|      var i : int;
        >|      switch i ::
        >|        case expr (@h.has('a')) :<py>:
        >|          f = 1
        >|        case is 2 :<py>:
        >|          f = 7
        >|"""

      test.checkStatement(
        code2,
        /# Path
        '/hack.stmts/B/f',
        /# Output
        expected={
          'py': """\
            >|h = None
            >|i = 0
            >|if 'a' in h:
            >|  f = 1
            >|elif i == 2:
            >|  f = 7
            >|"""
        },
      )

    end receiver CaseConstruct;

  end behavior translateMeta;

  behavior compileMeta #:
    Compile baselang syntax into final forms (usually relies on bazel).
  scope:

    receiver NamespaceConstruct ::
      metax.c.D.compile.sinfo(self.id())
      /# TODO(wmh): Implement this.
      /# - In python
      /#   - create .pyc file to detect syntax errors
      /#   - can we create optimized .par file?
      /#   - do we generate implicit binaries or invoke 'bazel build' on
      /#     py_binary build targets?
      /# - In Javascript
      /#   - Invoke 'bazel build' on js_closure_binary targets
      /# - In C++
      /#   - Invoke 'bazel build' on cc_binary targets
      scope, children = self.attrpair('scope:')
      for child in children:
        child.compileMeta()
      metax.c.D.compile.end()
    test:
      if False:
        /# Expensive, and writes to prod repo.
        test.tpy(expand=True, imports=True, translate=True)  # needed before compile
        test.namespace.compileMeta()
    end receiver NamespaceConstruct;

    receiver ClassConstruct ::
      metax.c.D.compile.sinfo(self.id())
      /# TODO(wmh): Implement this.
      /# - In python
      /#   - Handle per-class Entry points (but since Python is namespace-centric),
      /#     it may be handle in NamespaceConstruct.compileMeta() instead.
      /# - In Javascript
      /#   - Handle per-class Entry points.
      /# - In C++
      /#   - Handle per-class Entry points.
      scope, children = self.attrpair('scope:')
      for child in children:
        child.compileMeta()

      /# Generate binaries.
      for command in self.commands():
        compilation = command.attrval('compilation')
        command.createExecutableBinary(auto=compilation == 'implicit')

      metax.c.D.compile.end()
    test:
      test.tpy(expand=True, imports=True, translate=True) # before compile
      test.klass.compileMeta()
      /# TODO(wmh): Verify compilation. Is it safe to invoke compileMeta on
      /# a class without invoking on namespace first?
    end receiver ClassConstruct;

  end behavior compileMeta;

  abstract
  class BaseLanguageOopl < metax.meta.BaseLanguageConstruct #:
    The abstract superclass of all base languages in Meta(Oopl).

    The following config variables should be given values in subclasses via
    self.updateConfigs():
      namespace_primary : bool
        true if this baselang treats namespaces as primary (e.g. does not have
        per-class source files). ex. python is namespace_primary. javascript
        can be either namespace_primary or not. C++ and Java are not
        namespace_primary.
      definition_separate : bool
        true if this baselang has a separate source file for declarations.
        ex: C++ is definition_separate, while python, javascript and java are
        not.
      rem : str
        The character sequence used to start a one-line comment.
        TODO(wmh): Must add endrem for those languages that do not have a
        comment syntax for one-line comments (e.g. CSS has no such thing, so
        some OOPL may also).
      self : str
        The variable used to refer to the receiver within instance methods.
      cls : str
        The variable used to refer to the receiver within class methods.
      selfsep : str
        What separates the receiver variable from a method invocation.
        Ex. In Java and Python, this is '.', while in C++ and Perl it is '->'.
      staticsep : str
        What separates the class and method/field for static references.
        Ex. In Java and Python, this is '.', while in C++ and Perl it is '::'.
      stmtend : str
        What character(s) end statements in this baselang.
        ex: In python, this is empty.  In C++, Java and Javscript it is ';'.

      setup : map
        name : str
          The name of the method used to initialize a test before invoking
          a test method.
        level : str
          One of 'user', 'meta' or 'static'. Note that this is really a mixture
          of the 'location' and 'kind' attributes within a field, but is a
          more concise shorthand.
      teardown : map
        same as setup but represents the method used to cleanup after a test
        method has been run.
      clsetup : map
        same as setup but represents the method used to initialize an entire
        TestCase instance before invoking the tests on it.
      clteardown : map
        same as setup but represents the method used to cleanup an entire
        TestCase instance after invoking all tests on it.

      switch_level: int
        indicates what kind of switch statement is supported by the baselang:
          0 = no switch (e.g. Python)
          1 = ordinal switch only (e.g. C++)
          2 = generic value switch (e.g. javascript)
  scope:

    field metatypes : map #:
      Maps meta-level primitive/native types to base-lang information
      about those types. Some metatypes require a parameter (e.g. int<32>,
      real<64>), in which case the value is a recursive map ... this is
      determined by whether key 0 exists with value True or not). The value
      maps contain:
        base: str or two-tuple of str
          The base-language base type associated with the metatype.
          For Java, two base types are provided, raw and boxed.
        default: str or None
          This should always be a string, not a python int or bool or anything
          else. This is the base-language syntax to use for a meaningful
          default value for variables of the specified meta (and base) type.
          If None, it means there is no meaningful default value for the type
          in question.
    end field metatypes;

    static
    field SpecialRE : re #:
      A regexp to apply to each line in comment blocks. A matching line is
      a request to suppress some Meta (or base-lang) warning.

    static
    field SuperxRE : re #:
      Required text if a method is marked superx.

    static
    field CommentRE : re #:
      A regexp to apply to each line in a block to capture meta-level comment
      references (so we can convert to baselang comment).

    static
    field InterpolateRE : re #:
      A regexp matching a single meta-level string literal interpolation
      request. Examples:
        ${name}
        ${.name}
        ${!name}
        ${rec.name}
        ${rec!name}
        ${=name}
        ${name<10d}
        ${name>10d!}
    end field InterpolateRE;

    static
    field PseudoVars : map<@str,metax.c.Type> #:
      This static field has the same keys as BaseLanguageOopl.SPECIALS and its
      children, but instead of the value being a baselang representation of the
      meta identifier specified by the key, the value here is the Type instance
      that the value is an instance of.

    static
    field Templates : map<@str,pair<@str,metax.c.Type>> #:
      Keys are native types, values are tuples of two-tuples, specifying
      the allowed template args (conceptual-name, type). An empty tuple
      means an arbitrary number of template args are allowed, and they will
      be named 'T1', 'T2', etc. and have type any.

    lifecycle #:
      TODO(wmh): Add params: (to pass to super) and a scope: block that
      provides default values for every config variable.
    clinit:
      cls.SpecialREIs(re.compile(
        r'^(?P<indent>\s*)Meta:(?P<action>[a-zA-Z0-9_<>]+):\s*(?P<text>.*)'))

      cls.SuperxREIs(re.compile(r'^(?P<ws>\s+)<METAX_CALL_SUPER>\s*$'))

      cls.CommentREIs(
        re.compile(
          r'^( *)%s( ?)(.*)' % re.escape(metax.c.Context.Tokens()['remark'])))

      cls.InterpolateREIs(
        re.compile(
          r'\$\{'
          r'(?P<prefix>[=#])?'
          r'(?:'
          r'(?P<receiver>[a-zA-Z0-9_]+)?'
          r'(?P<sep>[.!])'
          r')?'
          r'(?P<id>[a-zA-Z0-9_]+)'
          /# TODO(wmh): Consider supporting (...) params.
          r'(?:'
          r'(?P<align>[<>~])'
          r'(?P<width>\d+)(?P<fraction>\.\d+)?'
          r'(?P<type>[sdf])?'
          r'(?P<strict>!)?'
          r')?'
          r'\}'
        )
      )

      /# Note that the meta-level types of pseudovars are not
      /# baselang-dependent, so they are defined a static field here in
      /# BaseLanguageOopl. The keys here should, however, parallel the keys
      /# in self.pseudovars(), instance fields defined in the BaseLanguageOopl
      /# hierarchy.
      /# CODETANGLE(pseudovars)
      cls.PseudoVarsIs({
        /# TODO(wmh): With the advent of TypeWrapper, should we have these be
        /# TypeWrapper instances whose underlying type is the fqcn of the actual
        /# class?
        'out': metax.c.Type.Instance('meta.ostream'),
        'err': metax.c.Type.Instance('meta.ostream'),
        'in': metax.c.Type.Instance('meta.istream'),
        /# TODO(wmh): What is the type of null in Meta??
        'null': metax.c.Type.Instance('meta.Null'),
        'nan': float,
        'false': metax.c.Type.Instance('bool'),
        'true': metax.c.Type.Instance('bool'),
        /# These are special ... the exact context is needed to establish type.
        'self': metax.c.SELF,
        'test': metax.c.SELF,
        'this': metax.c.SELF,
      })

      /# TODO(wmh): Change to std::any
      any = metax.c.Type.Instance('any')
      cls.TemplatesIs({
        'vec': (('TV', any),),
        /# NOTE: In C++, we need the map key to be 'std::string' (rather than
        /# std::string* or std::string&) if we are using std::string to
        /# implement 'str' (will be better when we move to IStr). It is possible
        /# that javascript instead expects *str ... TBD. Note also that
        /# std::string_view helps here.
        'map': (('TK', metax.c.Type.Instance('@str')), ('TV', any)),
        'pair': (('T1', 'any'), ('T2', any)),
        /# NOTE: An entry in Templates() that is empty implies any number of
        /# params, each with default any.
        'tuple': tuple(),
      })
    end lifecycle;

    method metabase : any #:
      Obtain base-lang info for a given (base) metatype.

      If you want to convert an arbitrary meta-level type to a baselang,
      use typeToBase() instead. This method is lower-level.

      Returns:
        Returns a dict if kind is null
        Returns a string if kind is 'base' or 'default'
        Returns null if mtypestr or params is invalid.
    params:
      var mtypestr : str #:
        A primitive or native meta-type (usually without any prefixes,
        although in special situations certain prefixed types may also have
        info).  One of the keys in self.__class__.METATYPES
      var param : str = null #:
        For types like 'int' and 'real', a numeric param is allowed. If None,
        and one is required, 32 is used.
      var kind : str = 'base' #:
        If None, returns the entire dict, else returns the value of key
        'kind' within the base dict.  Keys are: base, default.
      var metatypes : map = null #:
        Where to find the metatype info.  If None, uses self.metatypes()
    scope:
      if metatypes is None:
        metatypes = self.metatypes()
      baseinfo = metatypes.get(mtypestr, None)
      /# print('metabase: mtypestr=%s param=%s kind=%s baseinfo=%s' % (mtypestr, param, kind, baseinfo))
      if not baseinfo:
        /# The given mtypestr is not a hardcoded meta type ... return None
        result = None
      else:
        if 0 in baseinfo:
          /# This metatype accepts a (numeric) param. If one is given, we find the
          /# closest integer in baseinfo equal-greater the specified param. If one
          /# is not given, we use the info from baseinfo[None].
          if param is None:
            arg = None
          else:
            arg = int(param)
            while arg < 65 and arg not in baseinfo:
              arg += 1
            if arg > 64:
              raise metax.c.Error('Invalid type %s<%d>' % (mtypestr, arg))
              return None
          baseinfo = baseinfo[arg]
        if kind is None:
          result = baseinfo
        elif kind in ('base', 'boxed'):
          result = baseinfo['base']
          if isinstance(result, tuple):
            result = result[0] if kind == 'base' else result[1]
          elif kind == 'base':
            pass
          else:
            result = None
        elif kind == 'default':
          result = baseinfo['default']
        else:
          raise metax.c.Error('Invalid kind %s' % kind)
      return result
    tests:
      testx cc ::
        test.tcc()
        test.iseq('int32_t', test.baselang.metabase('int'))
        test.iseq('int64_t', test.baselang.metabase('int', param='42'))
        test.iseq('metax::str', test.baselang.metabase('str'))
      testx js ::
        test.tjs()
        test.iseq('number', test.baselang.metabase('int'))
        test.iseq('number', test.baselang.metabase('int', param='42'))
        test.iseq('string', test.baselang.metabase('str'))
      testx py ::
        test.tpy()
        test.iseq('int', test.baselang.metabase('int'))
        test.iseq('int', test.baselang.metabase('int', param='42'))
        test.iseq('str', test.baselang.metabase('str'))
    end method metabase;

    method metabaseValue : str #:
      Obtain the baselang representation of a meta-level value (for example,
      the attr value of a 'default' attribute of 'var', etc.)
    params:
      var value : any #:
        TODO(wmh): The value should probably always be an Expr, but currently
        the type of 'default' in 'var', 'field' and 'flag' is 'word' instead
        of 'expr'.
    scope:
      if isinstance(value, str):
        /# This is old-school ... should be removed in favor of Expr.
        /#  - support converting 'true', 'false', 'null', etc. to baselang
        /#    representations, but does not properly handle string literals,
        /#    list literals, hash literals, method invocations, or any of the
        /#    other things that Expr handles.
        result = self.pseudovars().get(value, value)
      elif isinstance(value, metax.c.Expr):
        raise metax.c.Error(
          'Not yet handling Expr ... may need to define a behavior')
      else:
        raise metax.c.Error(
          'Unknown type %s of value in metabaseValue' % type(value))
      return result
    test:
      ooplpy = test.cachedInfo(basel='python')[0]
      oopljs = test.cachedInfo(basel='javascript')[0]
      ooplcc = test.cachedInfo(basel='cpp')[0]

      for metaval, py, js, cc in (
        ('true', 'True', 'true', 'true'),
        ('false', 'False', 'false', 'false'),
        ('null', 'None', 'null', 'nullptr'),
        ('out', 'sys.stdout', 'null', 'std::cout'),
        ('err', 'sys.stderr', 'null', 'std::cerr'),
        ('in', 'sys.stdin', 'null', 'std::cin'),
        ('sout', 'metax.io.Sink.Out()', 'metax.io.Sink.Out()', 'metax::io::Sink::Out()'),
      ):
        test.iseq(py, ooplpy.metabaseValue(metaval))
        test.iseq(js, oopljs.metabaseValue(metaval))
        test.iseq(cc, ooplcc.metabaseValue(metaval))
    end method metabaseValue;

    method typeToBase : str #:
      Convert a metatype to a string representation of its base-language
      equivalent.
    params:
      var metatype : *metax.oopl.Type #:
        The metatype to convert.
      var class_construct : metax.oopl.ClassConstruct = null #:
        If specified, the class within which the type is being defined.
        Some baselangs cannot support fully-qualified references to the
        class currently being defined, and this allows such fully-qualified
        types to be localized.
      var value : any = null #:
        If present, the value being assigned to the variable of type 'metatype'.
        Used, for example, if metatype is 'str' (rather than '&str' or '*str')
        to heuristically decide between '&str' or '*str'.
      var defqn : bool = false #:
        If true, convert fully-qualified class-based types to class-name only.
        Used to support situations where the fully-qualified name poses
        problems in the baselang.
      var debug : bool = false #:
        If true, enable debugging.
    scope:
      defqn = False

      cls = self.__class__
      if debug:
        print(
          'In BaseLanguageOopl.typeToBase with metatype=%s' %
          (metatype.raw() if metatype else None))

      if metatype is None:
        result = 'METATYPE is NONE'

      elif not metatype.isValid():
        result = metatype.raw()
        if result.startswith('{#') and result.endswith('#}'):
          result = result[2:-2].replace('_', ' ')
        if debug:
          print('  type is invalid')

      else:
        params = metatype.params()

        /# Obtain the core metatype
        metabase = metatype.base() or '?'
        if metabase == 'str':
          /# The 'str' type is unusual in that *str and &str exist in
          /# METATYPES as separate entities, so we add those annotations in.
          if metatype.isPtr():
            metabase = '*' + metabase
          elif metatype.isRef():
            metabase = '&' + metabase
          elif metatype.isValue():
            metabase = '@' + metabase

        /# Check if the metabase type is a known metatype (e.g. in METATYPES).
        numeric = metatype.numericParam() or None
        basetype = self.metabase(metabase, param=numeric if params else None)
        scope_sep = metax.c.Context.Tokens()['scope_sep']

        if debug:
          print(
            '  metabase=%s basetype=%s numeric=%s isptr=%s isref=%s' %
            (metabase, basetype, numeric, metatype.isPtr(), metatype.isRef()))

        if basetype:
          /# We've found a mapping from meta-level to base-level.

          if numeric:
            /# We've obtained a primitive type
            result = basetype
          else:
            /# We set up a default mapping from parameter name to type, in case
            /# we have a metatype that does not specify all of the types.
            param_map = {}
            param_pairs = cls.Templates().get(metabase, [])

            if False:
              print('-' * 70)
              print(metatype)
              print(basetype)
              print(param_pairs)
              print(params)

            np = len(params) if params else 0

            if param_pairs:
              /# This type has a certain number of parameters that can be
              /# provided (defaults are supported for parameters not given).
              /# TODO(wmh): Add support for empty pairs meaning arbitrary numbers of params
              if len(param_pairs) == 0:
                raise metax.c.Error('Not yet supporting arbitrary template params')
              else:
                for i in range(0, len(param_pairs)):
                  pkey, defmtype = param_pairs[i]
                  if i < np:
                    mtype = params[i]
                  else:
                    mtype = defmtype
                  param_map[pkey] = self.typeToBase(
                    /# TODO(wmh): Should some variant of 'value' be passed down?
                    mtype, class_construct=class_construct, defqn=defqn)
                /# print('PARAM PAIRS for %s: %s = %s [%s]' % (metabase, param_pairs, param_map, basetype))
            result = basetype % param_map
        else:
          /# The metatype is not native/primitive, so it must be a class.
          if defqn:
            if metabase == 'metax.root.ObjectMetaRoot':
              /# TODO(wmh): Fix this hackery!
              result = metabase
            else:
              result = metabase.split(scope_sep)[-1]
          else:
            result = metabase

          /# The base part may be prefixed by EXTERNAL_CLASS_INDICATOR to
          /# indicate a non-meta class.
          if result[0] == metax.c.Type.EXTERNAL_CLASS_INDICATOR:
            result = result[1:]

        /# In javascript, we cannot (for some reason I really want to address)
        /# refer to the fully-qualified name of the class from within the
        /# class itself. Instead, we must use the non-qualified class name.
        if class_construct:
          nmspfqn = class_construct.namespace().fqn()
          /#print('HERE with %-30s and %s' % (nmspfqn, result))
          if result == class_construct.fqn():
            result = result.split('.')[-1]
          elif False and result.startswith(nmspfqn):
            result = result.split('.')[-1]

        result = self._annotateBaseType(metatype, result)

      if debug:
        print('  result is "%s" for "%s"' % (result, metatype.raw()))

      return result
    test:
      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      oopljs, _, _, _ = test.cachedInfo(basel='javascript')
      ooplcc, _, _, _ = test.cachedInfo(basel='cpp')

      cc_any = metax.oopl.OoplCpp.CC_ANY
      cc_str = metax.oopl.OoplCpp.CC_STR
      cc_strview = metax.oopl.OoplCpp.CC_STRVIEW
      cc_str_value = metax.oopl.OoplCpp.CC_STR_VALUE

      oomap = {
        'py': ooplpy.typeToBase,
        'js': oopljs.typeToBase,
        'cc': ooplcc.typeToBase,
      }

      for item in (
        {'type': 'int', 'py': 'int', 'js': '!number', 'cc': 'int32_t'},
        {'type': '*demo.cards2.Card',
         'py': 'demo.cards2.Card',
         'js': '?demo.cards2.Card',
         'cc': 'demo::cards2::Card*',
        },
        {'type': 'any', 'py': 'any', 'js': '?*', 'cc': cc_any + '*'},
        {'type': '*any', 'py': 'any', 'js': '?*', 'cc': cc_any + '*'},
        {'type': '&any', 'py': 'any', 'js': '!*', 'cc': cc_any + '&'},
        {'type': '@any', 'py': 'any', 'js': '!*', 'cc': cc_any},
        {'type': 'str', 'py': 'str', 'js': '?string', 'cc': cc_strview},
        {'type': '*str', 'py': 'str', 'js': '?string', 'cc': cc_strview},
        {'type': '&str', 'py': 'str', 'js': '!string', 'cc': cc_strview},
        {'type': '@str', 'py': 'str', 'js': '!string', 'cc': cc_strview},
        {'type': '&*str', 'py': 'str', 'js': '?string', 'cc': cc_strview},
        {'type': '@vec',
         'py': 'list',
         'js': '!Array.<?*>',
         'cc': 'std::vector<%s*>' % cc_any,
        },
        {'type': '@map',
         'py': 'dict',
         'js': '!Object.<!string,?*>',
         'cc': 'std::map<%s,%s*>' % (cc_strview, cc_any),
        },
        {'type': 'ostream',
         'py': 'file', 'js': '?Object', 'cc': 'std::ostream*',
        },
        {'type': '*#nm.sp.A',
         'py': 'nm.sp.A', 'js': '?nm.sp.A', 'cc': 'const nm::sp::A*',
        },
        {'type': '#*nm.sp.A',
         'py': 'nm.sp.A', 'js': '?nm.sp.A', 'cc': 'nm::sp::A*const',
        },
        {'type': '&nm.sp.A',
         'py': 'nm.sp.A', 'js': '!nm.sp.A', 'cc': 'nm::sp::A&',
        },
        {'type': '&#nm.sp.A',
         'py': 'nm.sp.A', 'js': '!nm.sp.A', 'cc': 'const nm::sp::A&',
        },
        {'type': '@vec<@str>',
         'py': 'list',
         'js': '!Array.<!string>',
         'cc': 'std::vector<%s>' % cc_strview,
        },
        {'type': 'vec<@str>',
         'py': 'list',
         'js': '?Array.<!string>',
         'cc': 'std::vector<%s>*' % cc_strview,
         'debug': False,
        },
        {'type': '#vec<@str>',
         'py': 'list',
         'js': '?Array.<!string>',
         'cc': 'const std::vector<%s>*' % cc_strview,
         'debug': False,
        },
        {'type': '@pair<int,int>',
         'py': 'tuple',
         'js': '!Array.<?*>',
         'cc': 'std::pair<int32_t,int32_t>',
        },
        {'type': '@pair<@map,@str>',
         'py': 'tuple',
         'js': '!Array.<?*>',
         'cc': 'std::pair<std::map<%s,%s*>,%s>' % (cc_strview, cc_any, cc_strview),
        },
      ):
        metastr = item['type']
        try:
          metatype = metax.c.Type.Instance(metastr)
        except metax.c.Error as e:
          self.fail('Type "%s" raises exception: %s' % (metastr, e))
        else:
          debug = item.get('debug', False)
          for bl in sorted(oomap):
            base = oomap[bl](metatype, debug=debug)
            expected = item[bl]
            test.iseq(
              item[bl], base,
              'baselang %s for %s\n  expected: %s\n  computed: %s' %
              (bl, metastr, expected, base))

      test.iseq(
        '?nm.sp.A',
        oopljs.typeToBase(metax.c.Type.Instance('nm.sp.A'), defqn=True))
      test.iseq(
        '?Array.<?nm.sp.A>',
        oopljs.typeToBase(metax.c.Type.Instance('vec<nm.sp.A>'), defqn=True))
    end method typeToBase;

    method compileExpr : tuple<str,Type> #:
      Compile an Expr instance into a baselang.

      Returns:
       0. the baselang code representing the expression
       1. the meta type of the expression.
    params:
      var expr : metax.c.Expr #:
        The expr to compile. If null, mtype is used to establish a default.
      var metafile : *metax.oopl.MetaFile #:
        The meta file being parsed/compiled.
      var executable : metax.oopl.ExecutableConstruct = null #:
        The context within which this expr is being compiled.  Used in order
        to establish type of result from type analysis and to resolve native
        methods.
        TODO(wmh): This should probably be renamed to symcons of type
        SymbolConstruct ... for var-related exprs it will be a MethodConstruct,
        but for fields it will be a ClassConstruct. And for experessions found
        within CaseConstructs, etc. it can be numerous things (SwitchConstruct,
        LoopConstruct, etc.)
      var metatype : metax.c.Type = null #:
        The expected type of the expression. Used if expr is null, to establish
        a default value. Note that this method returns the metatype when expr is
        non-null, so this is only needed when expr is null.
      var typecheck : bool = true #:
        If False, do not typecheck, even if executable is provided.
        Useful for disabling certain warnings.
      var indent : str = '' #:
        What to insert before each line (except first??)
    scope:
      lines = ['']
      if expr is None:
        /# Provide a default value based on expression type.
        if metatype is None:
          raise metax.c.InternalError(
            'Invoked compileExpr on null expr without providing mtype')
        lines[-1] += self.defaultValue(metatype)
      else:
        metatype = self._compileExpr(
          expr, metafile, lines,
          indent=indent, executable=executable, typecheck=typecheck)
      code = '\n'.join(lines)
      /# TODO(wmh): Should we be doing the following?
      /#  code = self.pseudovars().get(code, code)
      code2 = self.pseudovars().get(code, code)
      if code2 != code:
        /# print('*** HERE with "%s" vs "%s"' % (code, code2))
        code = code2

      return code, metatype
    tests:

      testx cc ::
        test.tcc()
        baselang = test.baselang
        compiler = test.compiler

        metafile = metax.c.MetaFile('/faux/path', compiler, '\n')

        for estr, expected_code, expected_type, attribute in (
          ('true', 'true', 'bool', None),
          ('null', 'nullptr', 'meta.Null', None),
          ('1', '1', 'uint', None),
          ('apple', 'apple', None, None),
          ('""', '""', '&str', None),
          ('"hello"', '"hello"', '&str', None),
          ("''", '""', '&str', None),
          ("'world'", '"world"', '&str', None),
          ('(a, b=1)', '(a, b=1)', [None, None],
           metax.oopl.ClassConstruct.DummySuperAttribute),
          ('(a)', 'a', 'bool',
           metax.oopl.ClassConstruct.DummyNonSuperAttribute),
          ('( ! a )', '(!a)', 'bool',
           metax.oopl.ClassConstruct.DummyNonSuperAttribute),
          ( '(3 < a < 7)', '(3 < a) and (a < 7)', 'bool',
           metax.oopl.ClassConstruct.DummyNonSuperAttribute),
          ('[false, true, null, 1, a]',
           '[\n  false,\n  true,\n  nullptr,\n  1,\n  a,\n]',
           'vec', None),
          ("{'a': false, 'b': true, 'c': a}",
           '{\n  "a" : false,\n  "b" : true,\n  "c" : a,\n}',
           'map', None),
        ):
          expr = metax.c.Expr.FromStr(estr, attribute=attribute)
          code, mtype = baselang.compileExpr(expr, metafile)
          test.iseq(expected_code, code)
          if expected_type is None:
            test.isnull(mtype)
          elif isinstance(expected_type, list):
            test.isinst(mtype, list)
            for i, etype in enumerate(expected_type):
              mt = mtype[i]
              if mt is None:
                test.isnull(mt)
              else:
                test.iseq(etype, mt.raw())
          else:
            test.iseq(expected_type, mtype.raw())

      testx py ::
        test.tpy()
        baselang = test.baselang
        compiler = test.compiler

        metafile = metax.c.MetaFile('/faux/path', compiler, '\n')

        for estr, expected_code, expected_type, attribute in (
          ('true', 'True', 'bool', None),
          ('null', 'None', 'meta.Null', None),
          ('1', '1', 'uint', None),
          ('apple', 'apple', None, None),
          ('""', '""', '&str', None),
          ('"hello"', '"hello"', '&str', None),
          ("''", "''", '&str', None),
          ("'world'", "'world'", '&str', None),
          ('(a, b=1)', '(a, b=1)', [None, None],
           metax.oopl.ClassConstruct.DummySuperAttribute),
          ('(a)', 'a', 'bool',
           metax.oopl.ClassConstruct.DummyNonSuperAttribute),
          ('( ! a )', '(!a)', 'bool',
           metax.oopl.ClassConstruct.DummyNonSuperAttribute),
          ( '(3 < a < 7)', '(3 < a) and (a < 7)', 'bool',
           metax.oopl.ClassConstruct.DummyNonSuperAttribute),
          ('[false, true, null, 1, a]',
           '[\n  False,\n  True,\n  None,\n  1,\n  a,\n]',
           'vec', None),
          ("{'a': false, 'b': true, 'c': a}",
           "{\n  'a' : False,\n  'b' : True,\n  'c' : a,\n}",
           'map', None),
        ):
          expr = metax.c.Expr.FromStr(estr, attribute=attribute)
          code, mtype = baselang.compileExpr(expr, metafile)
          test.iseq(expected_code, code)
          if expected_type is None:
            test.isnull(mtype)
          elif isinstance(expected_type, list):
            test.isinst(mtype, list)
            for i, etype in enumerate(expected_type):
              mt = mtype[i]
              if mt is None:
                test.isnull(mt)
              else:
                test.iseq(etype, mt.raw())
          else:
            test.iseq(expected_type, mtype.raw())

    end method compileExpr;

    method _compileExpr : metax.oopl.Type #:
      Compile an Expr instance into a baselang.

      Returns: Type
        The meta type of the expression.  None if no type could be established.
    params:
      var expr : &metax.c.Expr #:
        The expr to compile. Should never be null.
      var metafile : *metax.oopl.MetaFile #:
        The meta file being parsed/compiled.
      var lines : vec<str>;
      var indent : str = '';
      var executable : metax.oopl.ExecutableConstruct = null #:
        The context within which this expr is being compiled.  Used in order
        to establish type of result from type analysis.
      var typecheck : bool = true #:
        If False, do not typecheck, even if executable is provided.
        Useful for disabling certain warnings.
    scope:
      assert expr is not None

      /# caller should set lineno before invoking _compileExpr!
      lnum = metafile.lnum()
      numerrs = metafile.numErrors()
      metatype = None
      basel = self.id()
      kind = expr.kind()

      if kind == 'num':
        /# The representation of numbers is pretty consistent across languages.
        /# In Meta, the legal syntax for a number matches that in json, which
        /# should be valid in all baselangs.
        /# TODO(wmh): Support Perl's 100_000 syntax (rather than C++17's use of
        /# single quotes. Unfortunately cannot support commas, as they will
        /# mess up arg parsing (unless we require a space after commas in
        /# param lists?)
        /#
        /# For now, meta literal numbers are valid in all baselangs.
        /# We use the verbatim str value provided by the user (data['str'])
        /# rather than the int/float available in data['expr'] to maintain
        /# scientific notation.
        numval = expr.value()
        lines[-1] += str(numval)

        /# The metatype is int<?>, uint<?>, or real<?>, depending on exact value.
        /# TODO(wmh): We can do a better job of establishing an exact parameter
        /# value. For now, we just return int, uint or double.
        if isinstance(numval, int):
          tstr = 'int' if numval < 0 else 'uint'
        else:
          tstr = 'double'
        if typecheck:
          metatype = metax.c.Type.Instance(tstr)

      elif kind == 'str':
        /# A string literal is always quoted in the Meta source
        result = self.literalString(expr)
        lines[-1] += result
        if typecheck:
          metatype = metax.c.Type.Instance('&str')

      elif kind == 'var':
        /# This is just an identifier.
        /# TODO(wmh): Rename 'var' to 'id'.
        /#
        /# There are some special values that look like identifiers that are to
        /# be treated differently (e.g. self, true, false, null, ...). Any key
        /# in BaseLanguageOopl.PseudoVars() is mapped to an associated value.
        /#
        /# Also, if data contains a 'default' key (another full expr), this
        /# overall expression is presumably part of a parameter list with a
        /# default value, and the compiled version of the default value is added
        /# to the result.
        /#
        /# For a var Expr
        /#   kind: 'var'
        /#   expr: the meta-level variable (an identifier)
        /#   str: the meta-level variable (an identifier)
        varname = expr.value()
        result, metatype = self.analyzeVariable(varname, executable=executable)
        if not metatype and typecheck:
          /# metafile.info('Failed to type var %s' % varname, line=lnum)
          pass

        /# Handle the special 'default' key, which exists for 'var' expressions
        /# with default values.
        default = expr.default()
        if default is not None:
          defcode, deftype = self.compileExpr(
            default, metafile, executable=executable)
          result += '=' + defcode

        lines[-1] += result

      elif kind == 'bool':
        /# Compile a boolean expression.
        /#  - syntax is similar across most base languages, except some diffs
        /#    in operators (python uses 'and' and 'or' vs '&&' and '||', etc)
        metatype = metax.c.Type.Instance('bool')
        emeta = expr.value()
        edata = emeta['data']
        n = len(edata)

        /# print('BOOL: n=%d edata=%s' % (n, edata))
        if n == 1:
          /# Must be an expression
          if not isinstance(edata[0], metax.c.Expr):
            metafile.error('Found 1 element in expr but not Expr: %s' % str(edata))
            /# FIX ME
            lines.append('bool error ?')
          else:
            code, btype = self.compileExpr(
              edata[0], metafile, executable=executable)
            if btype and btype is not metatype:
              metafile.error('expression returned non bool %s' % str(btype))
            else:
              /# We do not need to wrap code in (), as code will be properly
              /# wrapped per the baselang.
              lines[-1] += code
              /# print('LINES: %s' % str(lines))
        elif n == 2:
          /# Must be unary operator followed by expression, and only unary
          /# operator is '!'
          if edata[0] != '!':
            metafile.error(
              'Found 2 elements in expr but 1st is not !: %s' % str(edata))
          elif not isinstance(edata[1], metax.c.Expr):
            metafile.error(
              'Found 2 elements in expr but 2nd is not Expr: %s' % str(edata))
          else:
            code, btype = self.compileExpr(
              edata[1], metafile, executable=executable)
            if btype and btype is not metatype:
              metafile.error('expression returned non bool %s' % str(btype))
            else:
              lines[-1] += '(!%s)' % code
        else:
          /# Must be expr op [expr op]...
          parts = []
          i = 1
          code1, btype1 = self.compileExpr(
            edata[0], metafile, executable=executable)
          while i < n:
            op = edata[i]
            if not isinstance(op, str):
              metafile.error('Expecting arg %d of %s to be op' % (i, edata))
              break
            e2 = edata[i+1]
            if not isinstance(e2, metax.c.Expr):
              metafile.error('Expecting arg %d of %s to be expr' % (i+1, edata))
              break
            code2, btype2 = self.compileExpr(
              e2, metafile, executable=executable)
            parts.append('(%s %s %s)' % (code1, op, code2))
            i += 2
            code1 = code2
          if parts:
            /# TODO(wmh): If adding all of the parts to last line would exceed
            /# maximum line width, wrap to subsequent lines with proper
            /# indentation.
            lines[-1] += '%s' % ' and '.join(parts)
      elif kind == 'op':
        /# TODO(wmh): Currently blindly dumping verbatim operators, but we
        /# need to do type analysis on lhs, establish the operators defined on
        /# that type, and map the operator to the baselang specific syntax
        /# (which may or may not be an actual operator).
        metatype = None
        expr = data['expr']

        lhs_code, lhs_type = self.compileExpr(
          expr['lhs'], metafile, executable=executable, typecheck=typecheck)
        rhs_code, rhs_type = self.compileExpr(
          expr['rhs'], metafile, executable=executable, typecheck=typecheck)

        opname = expr['op']
        baselang_syntax = '%(lhs)s %(op)s %(rhs)s'
        lines[-1] += baselang_syntax % (
          {'lhs': lhs_code, 'op': opname, 'rhs': rhs_code})

      elif kind == 'call':
        metatype = self._compileCall(
          expr, metafile, lines,
          indent=indent, executable=executable, typecheck=typecheck)

      elif kind == 'hash':
        metatype = self._compileHash(
          expr, metafile, lines,
          indent=indent, executable=executable, typecheck=typecheck)

      elif kind == 'list':
        metatype = self._compileList(
          expr, metafile, lines,
          indent=indent, executable=executable, typecheck=typecheck)

      elif kind == 'plist':
        /# An parenthesized list.
        /# The value is a list of Expr.
        parts = []
        metatype = []
        for argexpr in expr.value():
          argcode, argtype = self.compileExpr(
            argexpr, metafile, executable=executable)
          parts.append(argcode)
          metatype.append(argtype)
        lines[-1] += '(' + ', '.join(parts) + ')'

      else:
        raise metax.c.Error('Invalid expr kind "%s"' % kind)

      if metafile.numErrors() > numerrs:
        metafile.hasErrors(show=True)
        print('WARNING: Ignoring _compileExpr result due to errors')
        result = None

      return metatype
    test:
      /# Tested in compileExpr().  Do we need more tests?
      pass
    end method _compileExpr;

    method _compileCall : metax.c.Type #:
      Produce baselang syntax for a callsite.

      Returns:
        The meta-level type of the value returned by the call.
    params:
      var expr : *metax.oopl.Expr #:
        An Expr of kind 'call'
      var metafile : *metax.oopl.MetaFile;
      var lines : vec<str> #:
        Where to write the output.
      var indent : str = '';
      var executable : metax.oopl.ExecutableConstruct = null;
      var typecheck : bool = true;
    scope:
      /# A call site. The value() dict is:
      /#   rec: receiver of call
      /#   subcalls: list of dict
      /#     name: str
      /#       name of method or field to invoke on current receiver.
      /#     field: bool
      /#       true means field access (if not present, method call)
      /#     args: list of dict
      /#       same structure as 'data' itself
      val = expr.value()
      rec = val['rec']
      subcalls = val['subcalls']
      subcall_index = 0
      basel = self.id()

      /# Establish the baselang receiver and its type.
      recstr, metatype = self.analyzeVariable(rec, executable=executable)

      if False:
        print(
          'HERE with recstr=%s executable=%s metatype=%s' %
          (recstr, executable.kindfqn(), metatype))
        print('#' * 70)
        print(metafile.path())
        print(expr)
        print(executable.kindfqn())
        print(executable.primary().line())
        print('#' * 70)

      if metatype:
        rec = recstr

      else:
        /# It is possible that 'rec' is the name of a top-level namespace,
        /# and that we are attempting to access some method or field within
        /# a non-local namespace or class.
        filecons = metafile.construct()
        namespace = filecons.symbol(rec)
        if namespace:
          /# TODO(wmh): Define meta!namespace as shorthand for
          /# meta.lang.Namespace, and implement that class. Each namespace
          /# results in an auto-generated singleton class being defined within
          /# the namespace, with a single instance that provides first-class
          /# object status to namespaces. It will also be where namespace-level
          /# variables will be implemented in languages that do not support them
          /# directly.
          construct = namespace
          for i in range(0, len(subcalls)):
            subcall = subcalls[i]
            subvar = subcall['name']
            /# print('Looking for %s (%s)' % (subvar, subcall))
            /#construct.showSymbols()
            child = construct.symbol(subvar)
            if not child:
              break
            elif child.isnamespace():
              /# we continue iterating thru subcalls.
              construct = child
              subcall_index = i + 1
              rec += '.' + subvar
              pass
            elif child.isclass():
              /# We've reached a point where subsequent subcalls should be
              /# processed as method invocations or field accesses, using
              /# child as the executable.
              subcall_index = i + 1
              executable = child
              rec += '.' + subvar
              /#print('HERE with %s' % child.kindfqn())
              /#child.showSymbols()
              metatype = child.implicitType()
              /#print(subcalls[subcall_index:])
              /#print(metatype)
              break
            else:
              raise metax.c.Error('Unexpected %s' % child.kindfqn())

        if not metatype and typecheck:
          metafile.warning(
            'Failed to establish a type for receiver "%s"' % recstr, line=lnum)
          global DC
          DC += 1
          if DC > 10:
            raise metax.c.Error('here')
          /# print(
          /#   'Here with %s and %s' %
          /#   (executable.kindfqn() if executable else executable, rec))
          if executable:
            print('DEBUG: Dumping symbols due to missing metatype')
            executable.showSymbols()

      /#print('Here with receiver %s : %s' % (rec, metatype))

      /# Now process the cascading call-sites.
      /#  - update what the receiver looks like, in 'rec'
      /#  - maintain the metatype of the receiver
      /#  - typecheck arguments
      for subcall in subcalls[subcall_index:]:
        is_field = subcall.get('field', False)
        argsdata = subcall.get('args', None)

        /# First, we establish the separator that appears between the receiver
        /# and the method/field.
        /#  - almost always '.'
        /#  - in C++ and Perl, is '->' if the receiver is a ptr type
        sep = '.'
        if basel in ('python', 'cpp'):
          /# If metatype is pointer type.
          if False:
            sep = '->'

        /# Establish the field/method name
        /#  - note that for field access, it is the raw field name, which is
        /#    highly discouraged in Meta except for public raw fields.
        /#  - this name may be changed (later, when we do type analysis), if
        /#    the receiver is a native type.
        name = subcall['name']

        /# Now process the args.
        /#  - Each element of argsdata is a dict suitable for passing into a
        /#    recursive call to _compileExpr.
        if is_field:
          /# For a field, there are two possibilities:
          /#  - an arglist with exactly one arg, representing a request to set
          /#    the field to a given value.
          /#  - no arglist, which is a request to get the value of a field.
          /#     - the return value of a getter is the type of the field being
          /#       gotten.
          /#  - note that if the receiver is a native type, no field access
          /#    is allowed (the native interface is method-only).
          if argsdata:
            if len(argsdata) != 1:
              raise metax.c.Error('bad!')
            /# We have a field assignment request.
            /#  - there can be no further subcalls, since we need to return
            /#    a single baselang statement (TODO(wmh): maybe in some
            /#    baselangs we can assign and proceed in the same statement?
            /#    Also, are we sure that we have to return a single statement?
            /#    Maybe that is too limiting (oh ... but this will often be the
            /#    rhs or an arg to a method invocation, so yeah, almost
            /#    certainly needs to be a single statement).
            valcode, valtype = self.compileExpr(
              argsdata[0], metafile, executable=executable)
            callcode = name + ' = ' + valcode

            /# NOTE: Do NOT need to update the current receiver type 'metatype'
            /#  - the return value of a setter (at least one generated by
            /#    Meta) is the receiver, so the return type after is the same
            /#    as the return type before.
            /#  - No updates needed normally, but what if a person overrides a
            /#    getter/setter with an explicit method? (note that if they
            /#    override via the field 'scope' block they have no ability to
            /#    change the return type and self is implicitly returned if they
            /#    don't do it themselves.
            /#  - Overriding of getters via explicit method is disallowed by
            /#    the unique-id-per-scope rule, but one could override fieldIs()
            /#    or fieldRef()
            /#  - TODO(wmh): explicitly disallow overriding of field accessors
            /#    via 'method' constructs!

            /# TODO(wmh): enforce no subcalls after field set elsewhere!

          else:
            /# We have a field access request. No args.
            callcode = name
            if typecheck:
              metatype = self.typecheckField(metafile, metatype, name)

          rec += sep + callcode

        else:
          /# For a method, we process each arg.
          /#  - args will contain a list of two-tuples (argcode, argtype).
          args = []
          if argsdata:
            for argdata in argsdata:
              /# compileExpr returns a two-tuple (argcode, argtype)
              args.append(
                self.compileExpr(
                  argdata, metafile, executable=executable))

          /# Establish the method name/type.
          /#  - note that for field access, it is the raw field name, which is
          /#    highly discouraged in Meta except for public raw fields.
          /#  - we perform type analysis to establish the legality of the given
          /#    name (and to convert native-type names to baselang equivalents)
          name = subcall['name']
          if typecheck and metatype:
            /# We have enough info to do type analysis on the requested
            /# method invocation ... maybe.
            rec, metatype = self.compileMethodInvocation(
              metafile, rec, metatype, name, args)
            /# print(
            /#   'FOUND return type "%s" [%s]' %
            /#   (str(metatype), metatype.raw() if metatype else None))
          else:
            /# Without typechecking (or without a receiver type), we cannot
            /# handle native-type method renaming, so the following code is
            /# very likely to be incorrect.
            metatype = None
            callcode = name + '(' + ', '.join([p[0] for p in args]) + ')'
            rec += sep + callcode

      lines[-1] += rec

      return metatype
    tests:
      testx py ::
        test.tpy(
          /# needed so that classes are registered in compiler.classes().
          expand=True)
        baselang = test.baselang
        compiler = test.compiler
        metafile = test.metafile

        def Chk(method, code, expected_base, expected_type):
          expr = metax.c.Expr.FromStr(code, attribute=None)
          lines = ['']
          mtype = baselang._compileCall(
            expr, metafile, lines, executable=method)
          test.iseq(expected_type, mtype.asStr() if mtype else 'None')
          test.iseq(expected_base, '\n'.join(lines))
          test.isfalse(metafile.hasErrors(show=True))

        bmi = test.method
        Chk(bmi, '@self.weight;\n', 'self.weight()', 'float')
        Chk(bmi, '@self.weight();\n', 'self.weight()', 'float')
    end method _compileCall;

    method _compileHash : metax.c.Type #:
      Compile a literal hash into python syntax.

      Returns:
        The baselang syntax representing this expr.
    params:
      var expr : *metax.oopl.Expr #:
        An Expr of kind 'hash'
      var metafile : *metax.oopl.MetaFile;
      var lines : vec<str> #:
        Where to write the output.
      var indent : str = '';
      var executable : metax.oopl.ExecutableConstruct = null;
      var typecheck : bool = true;
    scope:
      /# The 'indent' variable represents the amount of indentation to put
      /# before the closing '}' and should match the amount of indentation
      /# present on lines[-1] at the beginning of this method.  Each
      /# key/value pair is placed on a separate line indented by subindent.
      assert expr.kind() == 'hash'
      data = expr.value()
      keytypes = []
      valtypes = []
      subindent = indent + '  '
      lines[-1] += '{'
      lines.append(indent)
      for keyexpr, valexpr in data:
        lines[-1] += '  '
        keytype = self._compileExpr(
          keyexpr, metafile, lines,
          indent=subindent, executable=executable, typecheck=typecheck)
        keytypes.append(keytype)
        lines[-1] += ' : '
        valtype = self._compileExpr(
          valexpr, metafile, lines,
          indent=subindent, executable=executable, typecheck=typecheck)
        valtypes.append(valtype)
        lines[-1] += ','
        lines.append(indent)
      lines[-1] += '}'
      /# TODO(wmh): Analyze keytypes and valtypes to determine if there
      /# is consistency amongst them. If the keys are all the same type K,
      /# and the values are all the same type V, we can return type
      /# map<K,V>. If either keytypes or valtypes is multi-typed, we can
      /# use 'any' or a disjunctive type.
      metatype = metax.c.Type.Instance('map')
      return metatype
    test:
      /# Tested in compileExpr().  Do we need more tests?
      pass
    end method _compileHash;

    method _compileList : metax.c.Type #:
      Compile a literal list into python syntax.

      Returns: str
        The baselang syntax representing this expr.
    params:
      var expr : *metax.oopl.Expr #:
        An Expr of kind 'list'.
      var metafile : *metax.oopl.MetaFile;
      var lines : vec<str> #:
        Where to write the output.
      var indent : str = '';
      var executable : metax.oopl.ExecutableConstruct = null;
      var typecheck : bool = true;
    scope:
      /# The 'indent' variable represents the amount of indentation to put
      /# before the closing ']' and should match the amount of indentation
      /# present on lines[-1] at the beginning of this method.  Each
      /# value is placed on a separate line indented by subindent.
      assert expr.kind() == 'list'
      data = expr.value()
      valtypes = []
      subindent = indent + '  '
      lines[-1] += '['
      lines.append(indent)
      for valexpr in data:
        lines[-1] += '  '
        valtype = self._compileExpr(
          valexpr, metafile, lines,
          indent=subindent, executable=executable, typecheck=typecheck)
        valtypes.append(valtype)
        lines[-1] += ','
        lines.append(indent)
      lines[-1] += ']'
      /# TODO(wmh): Analyze valtypes to determine if there is consistency
      /# amongst them.  If they are all the same type T, we can return a
      /# metatype of type 'vec<T>', else 'vec<any>' aka 'vec'
      metatype = metax.c.Type.Instance('vec')
      return metatype
    test:
      /# Tested in compileExpr().  Do we need more tests?
      pass
    end method _compileList;

    method compileMethodInvocation : tuple<str,metax.c.Type> #:
      Generate baselang syntax of an invocation of method 'name' on rectype.

      Returns:
       0. the baselang method invocation syntax (including receiver, method
          and args)
       1. the meta Type the callsite returns.
    params:
      var metafile : MetaFile #:
        Where to report errors
      var receiver : str #:
        The baselang code representing the receiver of the current method
        invocation.
      var rectype : metax.c.Type #:
        The receiver type
      var name : str #:
        The name of the method being invoked on the receiver type.
        This is the meta-level name, which may change in the resulting
        baselang code (e.g. if rectype is a native type).
      var args : vec<tuple<str,metax.c.Type>> #:
        The baselang syntax for the args passed in the meta-level invocation,
        along with the meta-level type of each arg.
      var line : int = 0 #:
        The line number in meta source code where the method invocation resides.
    scope:
      metatype = None

      if rectype is None:
        /#  The receiver type is unknown ... this code is likely to be
        /#  incorrect.
        code = receiver + '.' + name + '(' + ', '.join(args) + ')'

      elif rectype.isNative():
        /#  We have a native type ... obtain the method invocation code and
        /#  return type from nativeMethodToBase().
        code, metatype = self.nativeMethodToBase(
          metafile, receiver, rectype, name, args)

      elif rectype.isPrimitive():
        /#  We have a primitive type. In Meta, all primiitve types benefit from
        /#  the same meta-level-to-base-level mapping of syntax, so we obtain
        /#  the baeslang syntax from nativeMethodToBase().
        code, metatype = self.nativeMethodToBase(
          metafile, receiver, rectype, name, args)

      else:
        /#  We have a class type.  No renaming of the method, and args are
        /#  just comma-separated (at least in all baselangs implemented so far).
        sep = '->' if self.id() == 'cc' and rectype.isPtr() else '.'
        code = receiver + sep + name + (
          '(' + ', '.join([p[0] for p in args]) + ')')

        /#  We establish the return type by finding the method named 'name'
        /#  within the class identified by rectype.
        fqcn = rectype.base()
        classy = metafile.compiler().getClass(fqcn, default=None)
        if classy:
          executable = classy.symbols().find(name)
          if isinstance(executable, FieldConstruct):
            /# The field and the getter for the field have the same meta-level
            /# name, so we've suffixed the getter with ':get'
            executable = classy.symbols().find(name + ':get')
          if executable:
           /#  Have found the executable being invoked.
            metatype = executable.attrval('returns')
          else:
            classy.symbols().show()
            metafile.warning('Class %s has no executable "%s"' % (fqcn, name))
        else:
          code = 'failed to find class for %s' % fqcn
          metatype = None

      return code, metatype
    test:
      /# expand needed so that method/class link exists.
      test.tpy(expand=True)
      rectype = metax.c.Type.Instance('demo.tmp.Person')
      code, mtype = test.baselang.compileMethodInvocation(
        test.metafile, 'self', rectype, 'bmi', '', line=17)
      test.iseq('self.bmi()', code)
      test.issame(metax.c.Type.Instance('float'), mtype)
    end method compileMethodInvocation;

    method nativeMethodToBase : tuple<str,Type> #:
      Type check the method with name $name applied to receiver $receiver.

      Returns:
        0. the baselang code corresponding to an invocation of a native
           meta-method (a native meta-method is a conceptual method defined
           on some receiver, but which may be implemented by arbitrary baselang
           code).
        1. the meta Type the method returns.

      TODO(wmh): Since this method may return multiple lines of baselang code,
      we should instead pass in a 'lines' param rather than returning a string.
      Actually, it is best to provide both an 'expr' string that can be used in
      an expr context, as well as a 'prelines' list of lines that would need to
      be inserted into the baselang code stream as statements sometime before
      the baselang statement containing the expr being compiled.
    params:
      var metafile : MetaFile #:
        Where to report errors
      var receiver : str #:
        The baselang code representing the receiver of the current method
        invocation.
      var rectype : metax.c.Type #:
        The receiver type
      var name : str #:
        The name of a method being invoked on the native receiver type.
      var args : vec<tuple<str,metax.c.Type>> #:
        The baselang syntax for the args passed in the meta-level invocation,
        along with the meta-level type of each arg.
    scope:
      code = None
      metatype = None
      iscc = self.id() == 'cpp'
      sep = '->' if iscc and rectype.isPtr() else '.'

      /#  print(
      /#    'Here with receiver=%s rectype=%s name=%s args=%s' %
      /#    (receiver, rectype, name, args))

      /#  Verify that 'name' is defined on the native type in question.
      native_type = rectype.base()
      metalang = metafile.compiler().metalang()
      interface = metalang.__class__.NATIVE.get(native_type, None)

      if interface:
        fullname = native_type + '.' + name

        /#  We've found an interface for the native type
        typeparams = interface.get('template', [])
        methinfo = interface['scope'].get(name, None)
        if methinfo:
          /#  We've confirmed that the specified method name is understood
          argsinfo = methinfo['args'] or []
          codeinfo = methinfo['code']
          retspec = methinfo['returns'] or 'void'
          recparams = rectype.params() or []
          codetmpl = codeinfo.get(self.suffix(), None)
          if codetmpl:
            /#  We have a baselang code template for the method.

            /#  We typecheck the args against argsinfo.
            /#   - it is ok for there to be fewer elements in args than in
            /#     argsinfo if some args are optional.
            /#   - If argsinfo[i]['default'] exists, that arg is optional.
            if len(args) > len(argsinfo):
              metafile.error(
                'native %s expects %d args but received %d' %
                (fullname, len(argsinfo), len(args)))
            elif len(recparams) > len(typeparams):
              metafile.error(
                'native %s has only %d template params but given %d' %
                (fullname, len(typeparams), len(recparams)))
            else:
              data = {'rec': receiver}
              if iscc:
                data['recsep'] = receiver + sep

              /# Establish argument key/values.
              arg_index = 0
              for argcode, argtype in args:
                arginfo = argsinfo[arg_index]
                /# TODO(wmh): Type-validate argtype against argexptype
                /# (argtype must be equal or a subtype of argexptype).
                argexptype = arginfo['type']
                /#  Record the mapping for this arg.
                data['A%d' % (arg_index + 1)] = argcode
                arg_index += 1

              /# Establish template param key/values.
              /#  - Suppose typeparams = ['str', 'any'] and recparams = [].
              /#     - we want to populate recparams with [T('str'), T('any')]
              /#  - Suppose typeparams = ['str', 'any'] and
              /#    recparams = [T('int')].
              /#      - the default way to intpret this is that we want to
              /#        fill out recparams to be [T('int'), T('any')]
              /#      - however, at least for the 'map' type, it is better
              /#        if we fill out recparams to [T('str'), T('int')]
              /#        (by filling on the left, not the right).
              np = len(recparams)
              if True:
                /# Fill in missing params on the right
                for param_index in range(0, len(typeparams)):
                  param = (
                    recparams[param_index] if param_index < np
                    else typeparams[param_index])
                  data['T%d' % (param_index+1)] = param
              else:
                /# Fill in missing params on the left
                pass

              code = codetmpl % data

            metatype = metax.c.Type.Instance(retspec % data)
          else:
            metafile.error(
              'Native "%s" not implemented for %s' % (full, name, self.id()))
        else:
          metafile.error(
            'Native type "%s" does not understand method "%s"' %
            (native_type, name))
      else:
        metafile.error('Unrecognized native type "%s"' % native_type)

      return code, metatype
    test:
      T = metax.c.Type.Instance
      bls = {}
      mfs = {}
      for basel in ('cc', 'javascript', 'python'):
        metac = metax.c.Compiler(
          metal='oopl', basel=basel, metalangs=metax.c_test.METALANGS)
        baselang = metac.baselang()
        suffix = baselang.suffix().replace('.', '')
        bls[suffix] = baselang
        mfs[suffix] = metax.c.MetaFile(None, metac, '')

      def Chk(rectype, rec, meth, args, etypestr, codemap):
        /# rectype : metax.c.Type
        /#   type of receiver (crucial to determining which native methods)
        /# rec : str
        /#   the base-lang code representing the receiver (can be an
        /#   arbitrarily complex baselang expr as long as it produces an
        /#   object of type rectype).
        /# meth : str
        /#   name of meta-level native method being invoked on receiver
        /# args : vec<tuple<str,metax.c.Type>>
        /#   describes args of the native method, as a two-tuple containing
        /#   baselang code for the passed-in arg value, and the required
        /#   meta-level type of the arg.
        /# etypestr : str
        /#   The expected meta-level type of native method invocation, as a
        /#   string.
        /# codemap : map
        /#   maps baselang suffixes to strings representing the baselang
        /#   code correponding to the native method invocation.
        for suffix in codemap:
          baselang = bls[suffix]
          expected_code = codemap[suffix]
          code, mtype = baselang.nativeMethodToBase(
            mfs[suffix], rec, rectype, meth, args)
          mtypestr = mtype.raw() if mtype else None
          if etypestr is None:
            print('%s: etype: %s' % (suffix, mtypestr))
          else:
            test.iseq(etypestr, mtypestr)
          if expected_code is None:
            print("%s: code: '%s'" % (suffix, code))
          else:
            test.iseq(code, expected_code)

      /# Methods on type 'str'
      strtype = T('str')
      Chk(
        strtype, 'name', 'size', [],
        'int', {
          'cc': 'name->size()',
          'js': 'name.length',
          'py': 'len(name)',
        })
      Chk(
        strtype, 'name', 'len', [],
        'int', {
          'cc': 'name->size()',
          'js': 'name.length',
          'py': 'len(name)',
        })
      Chk(
        strtype, 'name', 'length', [],
        'int', {
          'cc': 'name->size()',
          'js': 'name.length',
          'py': 'len(name)',
        })

      /# Methods on type 'vec<int>'
      vectype = T('vec<int>')
      Chk(
        vectype, 'alist', 'size', [],
        'int', {
          'cc': 'alist->size()',
          'js': 'alist.length',
          'py': 'len(alist)',
        })
      vectype = T('vec<int>')
      Chk(
        vectype, 'alist', 'push', [('3', T('int'))],
        'void', {
          'cc': 'alist.push_back(3)',
          'js': 'alist.push(3)',
          'py': 'alist.append(3)',
        })
      Chk(
        vectype, 'alist', 'pop', [],
        'int', {
          'cc': 'alist.pop_back()',
          'js': 'alist.pop()',
          'py': 'alist.pop()',
        })
      Chk(
        vectype, 'alist', 'push_front', [('3', T('int'))],
        'void', {
          'cc': 'alist.insert(alist.begin(), 3)',
          'js': 'alist.unshift(3)',
          'py': 'alist.insert(0, 3)',
        })
      Chk(
        vectype, 'alist', 'pop_front', [],
        'int', {
          'cc': '(G_scratch = v[0], v.erase(v.begin()), std::any_cast<int>(G_scratch))',
          'js': 'alist.shift()',
          'py': 'alist.pop(0)',
        })
      Chk(
        vectype, 'alist', 'insert', [('1', T('int')), ('3', T('int'))],
        'void', {
          'cc': 'alist.insert(alist.begin() + 1, 3)',
          'js': 'alist.splice(1, 0, 3)',
          'py': 'alist.insert(1, 3)',
        })
      Chk(
        vectype, 'alist', 'remove', [('1', T('int'))],
        'int', {
          'cc': '(G_scratch = v[1], v.erase(v.begin()+1), std::any_cast<int>(G_scratch))',
          'js': 'alist.splice(1, 1)[0]',
          'py': 'alist.pop(1)',
        })

      /# Methods on type 'map<str,int>'
      maptype = T('map<str,int>')
      Chk(
        maptype, 'amap', 'size', [],
        'int', {
          'cc': 'amap->size()',
          'js': 'amap.size',
          'py': 'len(amap)',
        })
      Chk(
        maptype, 'amap', 'has', [('"apple"', T('str'))],
        'bool', {
          'cc': 'amap.find("apple") != amap.end()',
          'js': 'amap.has("apple")',
          'py': '"apple" in amap',
        })
      Chk(
        maptype, 'amap', 'get', [('"apple"', T('str'))],
        'int', {
          'cc': 'amap["apple"]',
          'js': 'amap.get("apple")',
          'py': 'amap["apple"]',
        })
      Chk(
        maptype, 'amap', 'set', [('"apple"', T('str')), ('3', T('int'))],
        'void', {
          'cc': 'amap["apple"] = 3',
          'js': 'amap.set("apple", 3)',
          'py': 'amap["apple"] = 3',
        })
      Chk(
        maptype, 'amap', 'keys', [],
        'iter<vec<str>>', {
          'cc': 'meta::lang::Dictionary::Keys(amap)',
          'js': 'amap.keys()',
          'py': 'amap.keys()',
        })
      Chk(
        maptype, 'amap', 'values', [],
        'iter<vec<int>>', {
          'cc': 'meta::lang::Dictionary::Values(amap)',
          'js': 'amap.values()',
          'py': 'amap.values()',
        })
      Chk(
        maptype, 'amap', 'pairs', [],
        'iter<vec<tuple<str,int>>>', {
          'cc': 'amap.begin()',
          'js': 'amap.entries()',
          'py': 'amap.items()',
        })

      /# Tests on ostream
      otype = T('&ostream')

      return

      /# STUB for new tests
      /#  - if etype is None, it is a request to print out result
      /#  - last arg is map ... only baselangs with a key suffix in that
      /#    arg are tested. If the value is null, the resulting code is
      /#    tested, otherwise it is compared.
      Chk(
        fixme, 'name', 'size', [],
        None, {
          'cc': None,
          'js': None,
          'py': None,
        })
    end method nativeMethodToBase;

    method analyzeVariable : tuple<str,Type> #:
      Identify the baselang representation for a varname (and its metatype).

      Also handles pseudo vars like 'true', 'self', 'out', etc.

      Returns: tuple<str,Type>
       0. the baselang representation of the variable
       1. the meta-level Type instance of the variable. None means unable to
          type.
    params:
      var varname : str;
      var executable : metax.oopl.ExecutableConstruct = null;
    scope:
      /# We first establish if varname is a pseudovar.

      cls = self.__class__
      pseudo_metatype = cls.PseudoVars().get(varname, None)

      if pseudo_metatype is not None:
        /# We have a pseudovar.
        pseudo_base = self.pseudovars().get(varname, None)
        if pseudo_base is None:
          /# TODO(wmh): Decide on the proper way to report implementation-level
          /# errors (something stronger than metafile.error(), but maybe not
          /# so stong as an exception ... or maybe that is exactly what we
          /# want).  Do we return null for both result and metatype instead?
          raise metax.c.Error(
            'Pseudovar %s does not have a value in baselang %s' %
            (varname, self.id()))
        else:
          result = pseudo_base
          metatype = pseudo_metatype
          if metatype is metax.c.SELF:
            /# Special indicator that the type matches that of the receiver.
            if executable:
              myclass = executable.myclass()
              metatype = myclass.typeOfSelf(dothis=(varname=='this'))
            else:
              metatype = None
              /# TODO(wmh): Error is too strong ... how to handle this?
              raise metx.c.Error(
                'Warning: no executable - cannot identify type of self')
      else:
        /# We do NOT have a pseudovar, so 'varname' must represent a symbol
        /# within the executable's symbol table to be valid.
        result = varname
        metatype = executable.establishType(varname) if executable else None

      return result, metatype
    test:
      def Chk(expected_varname, expected_type, pair):
        varname, mtype = pair
        test.iseq(expected_varname, varname)
        test.iseq(expected_type, mtype.raw())

      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      filec = metax.meta.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.oopl.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.oopl.ClassConstruct.NewFromData(
        'Card', context, parent=namespace.attr('scope:'),
        secondaries=[('scope:', [])])
      method = metax.oopl.MethodConstruct.NewFromData(
        'f', context, parent=klass.attr('scope:'))
      method.myclassIs(klass)

      Chk('True', 'bool', ooplpy.analyzeVariable('true', executable=method))
      Chk('False', 'bool', ooplpy.analyzeVariable('false', executable=method))
      Chk(
        'None', 'meta.Null',
        ooplpy.analyzeVariable('null', executable=method))
      Chk(
        'self', '&nm.sp.Card',
        ooplpy.analyzeVariable('self', executable=method))
    end method analyzeVariable;

    method initCode #:
      Write baselang code to initialize all uninitialized fields in preamble
    params:
      var method : metax.oopl.ExecutableConstruct #:
        The method for which super code is desired.
      var output : vec<str> #:
        Where to append lines of baselang code representing the super-call.
    scope:
      metafile = method.metafile()
      stmtend = self.config('stmtend')
      recsepstr = self.receiverStr(method, style='base', sep=True)[0]

      myclass = method.myclass()
      initmap = self.analyzeExecutableForFields(method)
      scope_attr = method.attr('scope:', default=None)
      attrkind = method.attrval('kind')
      basel = self.baselang().id()
      params = method.parsedParams()
      fieldmap = params.get('fields', {})

      for field in myclass.fields():
        fid = field.id()
        metatype = field.attrval('type')
        fkind = field.attrval('kind')

        /# We first see if the field exists in fieldmap
        /#  - if in fieldmap, we have a syntactic request to initialize a field
        /#    from a parameter.
        defval = fieldmap.get(fid, None)
        if defval is None:
          /# TODO(wmh): Should we do LOOKUP on 'default' to get '<special>', or
          /# set it to null here?
          default = field.attrval('default', default=None)
          if default:
            defval, resmtype = self.compileExpr(
              default, metafile, method, indent='    ')
          else:
            defval = self.defaultValue(metatype)
        if fkind == 'static':
          /# Static fields are not initialized in initializers. They are handled
          /# on a per-baselang basis in FieldConstruct.translateMeta(),
          /# *Oopl.formatFieldDefintiion(), etc.
          pass
        elif fid in initmap:
          /# There is an explicit initialization of this field in the
          /# user-provided code, so we do NOT provide a default initialization.
          fval = initmap[fid]
          if fval == defval:
            metafile.warning(
              'Explicit initalization of %s to %s not necessary (is default)' %
              (fid, defval), attr=scope_attr)
        elif (basel == 'cpp' and
              metatype.isValue() and not metatype.isPrimitive()):
          /# There is no need to initialize the field, because C++ has already
          /# invoked a constructor on the field class to initialize the field
          /# before this method was entered.
          /# print('Skipping %s = %s' % (field.rawfield(), defval))
          pass
        else:
          code = '%s%s = %s%s' % (recsepstr, field.rawfield(), defval, stmtend)
          output.append(code)

      /# If this class has any packed fields, the underlying packs are
      /# initialized to value 0. Furthermore, a method that efficiently
      /# extracts all values within each pack is auto-generated.
      packed = myclass.packed()
      if packed:
        for pack in packed:
          rawpack = '_' + pack
          code = '%s%s = 0%s' % (recsepstr, rawpack, stmtend)
          output.append(code)
    test:
      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      metafile = test.metafileFor(text='', metal='oopl', basel='python')
      filec = metax.meta.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.oopl.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.oopl.ClassConstruct.NewFromData(
        'Card', context, parent=namespace.attr('scope:'),
        secondaries=[('scope:', [])])
      method = metax.oopl.MethodConstruct.NewFromData(
        '__init__', context, parent=klass.attr('scope:'),
        secondaries=[('scope:', [])])
    end method initCode;

    method analyzeExecutableForFields : map #:
      Analyze an executable (simple) block looking for explicit field
      references.

      Returns:
        Mapping from fieldname to value.
        Will be empty if the scope: of the executable is complex.
    params:
      var executable : metax.oopl.ExecutableConstruct #:
        The executable for which a receiver is desired.
    scope:
      initmap = {}
      stmtend = self.config('stmtend')

      location = executable.attrval('location')
      scope, lines = executable.attrpair('scope:', default=None)
      initmap = {}

      /# Look for field assignments in the source code.
      /#  - The user is always allowed to refer to receiver by baselang
      /#    syntax ('self.' in python, 'this->' in C++, etc.)
      /#  - The user may also refer to the receiver by a special meta-level
      /#    name, dictated by the 'location' of the method (user, test, meta)
      /#    and which always uses '.' to access methods/state.
      /#     - for location user the variable is self
      /#     - for location test the variable is test
      /#     - for location meta the variable is meta
      if scope and scope.isSimpleBlock():
        recs = set()
        baserec = self.receiverStr(
          executable, style='base', location=location, sep=True)[0]
        recs.add(baserec)
        if baserec == 'this->':
          recs.add('(*this).')
        metarec = self.receiverStr(
          executable, style='meta', location=location, sep=True)[0]
        recs.add(metarec)
        recstr = '|'.join([re.escape(rec) for rec in recs])

        fre = re.compile(
          /# Note that we only consider assignments that are NOT indented,
          /# as they are the only ones guaranteed to always be executed.
          /# For example, if we have the code:
          /#   if some_expr:
          /#     self._debug = True
          /# we cannot assume self._debug is always initialized, so we must
          /# provide a default initialization in the preamble.
          r'^'
          r'(?P<rec_op>' + recstr + ')'
          r'(?:'
          /# Intentionally not looking for statement terminator in case the
          /# value continues on next line (in which case <rawval> won't be
          /# fully correct but will at least detect the field initialization).
          r'(?P<rawfield>[a-zA-Z0-9_]+)\s*=\s*(?P<rawval>.*)'
          r'|'
          /# Intentionally not closing parenthesis in case it continues on
          /# next line (in which case <value> won't be fully correct but will
          /# at least detect the field initialization.
          r'(?P<field>[a-zA-Z0-9_]+)Is\s*\((?P<value>.*)'
          r')')

        for line in lines:
          m = fre.search(line)
          if m:
            /# print(m.groupdict())
            rawfield = m.group('rawfield')
            if rawfield:
              /# CODETANGLE(fieldinit): See FieldConstruct.expandMeta(), which
              /# specifies how rawfields are formed from field names.
              /# TODO(wmh): Generalize this code to use the 'field_prefix' and
              /# 'field_suffix' keys of Context.Tokens(). Make sure to handle
              /# public fields that do not make a difference between rawfield
              /# and field.
              fname = rawfield
              if fname[0] == '_':
                fname = fname[1:]
              fval = m.group('rawval').rstrip(stmtend).rstrip()
            else:
              fname = m.group('field')
              fval = re.sub(r's*\);?\s*$', '', m.group('value'))
            /# print('LINE: %s [fname=%s fval=%s]' % (line, fname, fval))
            initmap[fname] = fval
      return initmap
    test:
      init_lines = [
        'self._py_js_cc = 1',
        'bob.c = 2',
        'self.pyjsccIs(21)',
        'this->_cc = 7;',
        'this->cc2Is(8);',
        'meta._height = 183',
        'meta.weightIs(50);',
      ]

      def Chk(basel, location, expected, debug=False):
        test.defineClassAndMethods(basel, context=None, init_lines=init_lines)
        baselang = test.baselang
        test.iseq(baselang.suffix(), '.' + basel)
        init = test.initializer
        location_attr = init.attr('location')
        assert location_attr.value() == 'user'
        try:
          location_attr.valueIs(location)
          test.iseq(expected, baselang.analyzeExecutableForFields(init))
        finally:
          location_attr.valueIs('user')

      Chk('py', 'user', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk('js', 'user', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk(
        'cc', 'user', {'cc': '7', 'cc2': '8', 'pyjscc': '21', 'py_js_cc': '1'})

      Chk('py', 'meta', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk('js', 'meta', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk(
        'cc', 'meta', {'cc': '7', 'cc2': '8', 'pyjscc': '21', 'py_js_cc': '1'})

    end method analyzeExecutableForFields;

    final
    method _receiverStr : tuple<str,str> #:
      Service method used by subclasses in their implementation of receiverStr.
    params:
      var method : metax.oopl.ExecutableConstruct #:
        The executable for which a receiver is desired.
      var location : str #:
        The location feature value of the method. If null, obtained from
        method.
      var style : str #:
        One of 'base', 'meta' or 'auto'
          base:
            This is the only style NOT handled by this method (instead, it
            is handled by subclasses in 'receiverStr').
          meta:
            Use the meta-defined receiver variable ('self' for instance,
            'meta' for metaclass, 'test' for testclass)
          auto:
            Establish the meta-level receiver, then look for that variable
            in the user-provided body of the method.  If found, use that
            variable, else use the 'base' variable.
      var myclass : metax.oopl.ClassConstruct #:
        The class of the method.  If null, uses method.myclass().
    scope:
      result = None
      if myclass is None:
        myclass = method.myclass()
        if myclass is None:
          raise metax.c.Error(
            'Construct %s has not initialized myclass' % method.kindfqn())
      kind = method.attrval('kind')
      if location is None:
        location = method.attrval('location')

      if style == 'meta':
        /# A meta-level receiver is desired.
        /#  - meta-methods and static methods use 'meta'
        /#  - test methods use 'test'
        /#  - instance methods use 'self'
        if myclass.isTest():
          result = 'test'
        elif myclass.isMeta():
          result = 'meta'
        else:
          result = 'meta' if (kind == 'static' or kind == 'cls') else 'self'

      elif style == 'auto':
        /# We are to establish the meta-level var, see if it exists in the
        /# scope, and return it or the base var dependning on whether it does.
        metavar = self._receiverStr(method, location, 'meta', myclass)[0]
        scope = method.attrval('scope:')
        /# TODO(wmh): Consider using BaseLanguageOopl.analzyeExecutableForFields
        /# (but it would need generalizing, since we are looking here for only
        /# metavar references).
        /# Note that meta-level vars ('self, 'test', and 'meta') always refer
        /# to reference types (never pointers), so we do not need to loo
        /# syntax like '(*this).f'
        mre = re.compile(r'%s(\.|->)' % metavar)
        found = False
        for line in scope:
          /# Check if metavar is used
          if mre.search(line):
            found = True
            break
        if found:
          /# We found a reference to the metavar, so that is what we return.
          result = metavar
        else:
          /# We did not find reference to the metavar, so we use the basevar.
          result = self.receiverStr(
            method, location=location, style='base', myclass=myclass)[0]

      elif style != 'base':
        /# This method does not handle style 'base', but does handle all others.
        raise metax.c.Error('Invalid style "%s"' % style)

      return (result, myclass, kind, location)
    test:
      /# This is called from each of the receiverStr() behavior implementations,
      /# and comprehensive testing is done therein.
      pass
    end method _receiverStr;

    method defaultValue : str #:
      The default value for a given metatype.
    params:
      var metatype : metax.oopl.Type;
    scope:
      if metatype.isPtr():
        default = self.pseudovars()['null']
      elif metatype.isStr():
        /# Special handling.
        default = self.metabase(metatype.raw(), kind='default')
      elif metatype.isRef():
        raise metax.c.Error('No defaults for ref type %s' % metatype.raw())
      else:
        default = self.metabase(metatype.base(), kind='default')
      return default
    test:
      py, _, _, _ = test.cachedInfo(basel='python')
      MetaType = metax.c.Type.Instance
      test.iseq('0', py.defaultValue(MetaType('@int')))
      test.iseq('None', py.defaultValue(MetaType('*int')))
      test.iseq('0.0', py.defaultValue(MetaType('@double')))
      test.iseq('None', py.defaultValue(MetaType('*str')))
      test.iseq('None', py.defaultValue(MetaType('str')))
      test.iseq("''", py.defaultValue(MetaType('&str')))
      test.iseq("''", py.defaultValue(MetaType('@str')))
    end method defaultValue;

    method simpleToBase : vec<str> #:
      Given a SimpleBlock, return the contents converted to
      this baselang.
    params:
      var simple : metax.attr.SimpleBlock #:
        The block to convert. If null, method is a noop.
      var output : vec<str> = null #:
        Where to write output.  If not given, new list is returned.
      var comment : bool = false #:
        If true, each line added to output is preceeded by the baselang
        comment character (and meta comments are not escaped).
      var strip_comments : bool = false #:
        If true, any meta-level comment prefixes are simply removed, rather
        than being replaced with the base-lang comment prefix. Useful when
        obtaining the lines in a 'comment:' attribute in which lines have
        been explicitly (and unnecessarily) quoted.
      var strip_empty : bool = false #:
        If true, empty lines at the beginning and end of the block are
        removed.
      var replace_receiver : bool = false #:
        If true, replace meta-level receiver variables with baselang version.
      var cdent : str = '' #:
        Indentation to insert after comment before code (after an initial ' ').
    scope:
      if output is None:
        output = []
      rem = '' if strip_comments else self.config('rem')
      remsp = rem + ' ' + cdent if rem else ''
      if simple is None:
        pass
      elif comment:
        /# We are to add the content of simple preceeded by baselang comments.
        for line in simple.value():
          if line:
            output.append(remsp + line)
          else:
            output.append(rem)
      else:
        parent = simple.parent()
        metafile = parent.metafile()
        metapath = metafile.path()
        metafile_str = "'" + metapath + "'"
        didx = metapath.rfind('/')
        metadir = metapath[:didx] if didx > -1 else '.'
        metadir_str = "'" + metadir + "'"
        comre = BaseLanguageOopl.CommentRE()
        lines = simple.value()

        /# Strip empty lines if requested.
        s = 0
        e = len(lines)
        if strip_empty:
          while s < e and not lines[s].strip():
            s += 1
          while e > 0 and not lines[e-1].strip():
            e -= 1

        /# Perform a small set of rewrites on the user-provided data.
        /#  - '^ */# ' is replaced with baselang comment one-line comment
        /#  - replace __meta file__ with the absolute path of the .meta file
        /#    that the __meta file__ is found within.
        /#  - replace __meta dir__ with the absolute path of the directory
        /#    within which the .meta file that the __meta dir__ is found within.
        /#  - do NOT replace replace '^ *>|' with '' (occurs in ...)
        /#  - do NOT perform pseudovar rewriting (e.g. 'meta' to 'self',
        /#    'test' to 'self', etc.). Instead, in methodInfo() we add a
        /#    local variable called 'test' or 'meta' (assigned to 'self').
        /#    The rewrites produced a difference between user expectations and
        /#    error messages, causing confusion.
        /#  - TODO(wmh): Compare this implementation against one that uses
        /#    a single regexp capturing all things we want to substitute,
        /#    with a function replacer (that will require a single scan of
        /#    the string, albeit a more expensive scan).
        for i in range(s, e):
          line = lines[i]
          line = line.replace('__meta' + 'file__', metafile_str)
          line = line.replace('__meta' + 'dir__', metadir_str)
          m = comre.match(line)
          if m:
            infix = '' if strip_comments else m.group(2)
            line = m.group(1) + rem + infix + m.group(3)
          output.append(line)
      return output
    tests:
      testx cc ::
        test.tcc()
        method = test.method
        block = metax.attr.SimpleBlock(
          method, 'scope:', [
            '/# Some C++',
            'int a = 1;',
          ])
        test.iseq(
          ['// Some C++', 'int a = 1;'],
          test.baselang.simpleToBase(block))

        block2 = metax.attr.SimpleBlock(
          method, 'comment:', [
            'This is a comment.',
            '',
            'Some additional text.',
          ])
        test.iseq(
          ['// This is a comment.', '//', '// Some additional text.'],
          test.baselang.simpleToBase(block2, comment=True))

      testx js ::
        test.tjs()
        method = test.method
        block = metax.attr.SimpleBlock(
          method, 'scope:', [
            '/# Some Javascript',
            'let a = 1;',
          ])
        test.iseq(
          ['// Some Javascript', 'let a = 1;'],
          test.baselang.simpleToBase(block))
      testx py ::
        test.tpy()
        method = test.method
        block = metax.attr.SimpleBlock(
          method, 'scope:', [
            '/# Some Python',
            'a = 1',
          ])
        test.iseq(
          ['# Some Python', 'a = 1'],
          test.baselang.simpleToBase(block))
    end method simpleToBase;

    method segmentForBlockAndComment : BaseSegment #:
      Return a BaseSegment instance for a simple block and associated comment.
    params:
      var block : metax.attr.SimpleBlock #:
        The block to make a segment for.
      var comment : metax.attr.SimpleBlock = null #:
        The comment associated with the block, to be inserted before the block
        in baselang code.
      var cdent : str = '' #:
        Indentation to insert after comment before code (after an initial ' ').
    scope:
      lines = []
      if comment is not None:
        lines.append('')
      self.simpleToBase(comment, output=lines, comment=True, cdent=cdent)
      xlines = len(lines)
      self.simpleToBase(block, output=lines)
      /# Note that block.line() is the default start for the segment,
      /# but we inserted xlines before it so we need to adjust.
      segment = metax.c.BaseSegment(
        block, chunks=lines, metaline=block.line() - xlines)
      return segment
    test:
      test.tpy()
      method = test.method
      comment = method.attr('comment:')
      scope = method.attr('scope:')
      segment = test.baselang.segmentForBlockAndComment(
        /# TODO(wmh): Is cdent working properly?
        scope, comment, cdent='  ')
      test.iseq(
        [
          '',
          '#   Calculate body mass index of this person.',
          '#   Result is unitless, but relies on height in meters and',
          '#   weight in kilograms.',
        ],
        segment.chunks())
      test.iseq('', segment.indent())
    end method segmentForBlockAndComment;

    method formatBuildRule : str #:
      Form a BUILD rule from data.

      Returns:
        A multi-line string representing a BUILD target definition.
    params:
      var rule : str #:
        The name of the BUILD rule to generate.
        Example: cc_library, cc_test, java_test, etc.
      var data : map #:
        See, for example, http://www.bazel.io/docs/be/c-cpp.html.
    scope:
      /# TODO(wmh): This import should be at the top of the namespace file,
      /# but until we add a 'preport:' secondary attribute to MetaLanguage,
      /# that isn't possible here.
      from past.builtins import basestring

      lines = [rule + '(']
      k = set(data)
      keys = []
      for key in ('name', 'main', 'srcs', 'hdrs', 'data', 'deps', 'tests'):
        if key in data:
          k.remove(key)
          keys.append(key)
      keys.extend(sorted(k))
      for key in keys:
        value = data[key]
        if isinstance(value, basestring):
          lines.append('  %s = "%s",' % (key, value))
        elif isinstance(value, int):
          lines.append('  %s = %d,' % (key, value))
        elif isinstance(value, (list, set)):
          /# TODO(wmh): This is a hack to get meta2 code working while using
          /# root.meta from meta1. When we have root.meta2 implemented we can
          /# remove this hackery
          if key == 'deps' and self.id() == 'python':
            for i in range(0, len(value)):
              m = re.match(r'//meta/([^:]+):.*', value[i])
              if m:
                value[i] = '//meta:%s' % m.group(1)
          /# End hackery

          if len(value) == 0:
            pass
          elif len(value) < 2:
            lines.append(
              '  %s = [%s],' %
              (key, ', '.join(["'%s'" % elem for elem in value])))
          else:
            lines.append('  %s = [' % key)
            for elem in value:
              lines.append('    "%s",' % elem)
            lines.append('  ],')
        else:
          raise metax.c.Error('Invalid build rule data value: %s' % str(value))
      lines.append(')')
      return '\n'.join(lines)
    test:
      test.tpy()
      test.iseqtext("""\
        >|py_library(
        >|  name = "Person",
        >|  visibility = ['//visibility:public'],
        >|)""",
        test.baselang.formatBuildRule(
          'py_library',
          {'name': 'Person', 'visibility': ['//visibility:public']}))
    end method formatBuildRule;

    method nameToBuildTarget : str #:
      Convert a name to BUILD target.
    params:
      var fqn : str #:
        The fully qualified  name to convert to a target.
        If null or empty, returns null.
      var lib : bool = false #:
        If true, the fqn is a namespace, not a class.
    scope:
      if fqn:
        parts = fqn.split(metax.c.Context.Tokens()['scope_sep'])
        if lib:
          last = parts[-1]
        else:
          last = parts.pop()
        target = '//' + '/'.join(parts) + ':' + last
      else:
        target = None
      return target
    test:
      test.tpy()
      test.iseq(
        '//demo/tmp:Person',
        test.baselang.nameToBuildTarget('demo.tmp.Person'))
    end method nameToBuildTarget;

    method parseComment : tuple<metax.attr.SimpleBlock,map> #:
      Obtain and parse a comment.

      Almost every construct in Meta(Oopl) supports a simple-block 'comment:'
      secondary attribute. This method obtains the SimpleBlock and a parsed
      representation of the lines in it.

      Returns:
       0) The comment SimpleBlock
       1) A map containing:
         user: vec<str>
         returns: vec<str>
         actions: map
    params:
      var construct : *metax.oopl.Construct = null #:
        The construct whose comment is to be parsed. One of 'construct' or
        'attribute' must be provided.
      var attribute : metax.attr.SimpleBlock = null #:
        The SimpleBlock representing the comment. One of 'construct' or
        'attribute' must be provided.
      var parse_return : bool = false #:
        If true, look for a 'Returns:' section.
    scope:
      /# The comment simple block of an executable has the following structure:
      /#   <comment> ::-
      /#      <text> [<nl> 'Returns:' <return_text>]
      if not attribute:
        if not construct:
          raise metax.c.Error('Must provide either attribute or construct')
        attribute, lines = construct.attrpair('comment:', default=None)
      else:
        lines = attribute.value()

      userlines = []
      retlines = []
      specials = {}

      if lines:
        inret = False
        retstr = 'Returns:'
        prefix = metax.c.Context.Tokens()['remark'] + ' '
        spre = BaseLanguageOopl.SpecialRE()
        metafile = self.metafile()

        for i, line in enumerate(lines):
          if parse_return and line.startswith(retstr):
            t = line[len(retstr):]
            if t:
              /# We have found the 'Returns:' marker, so all subsequent lines
              /# go to retlines instead of userlines.
              metafile.error(
                'No text allowed after "Returns:"',
                line=attribute.line() + i)
              retlines.append(t)
            inret = True
          else:
            /# We remove meta-level comment prefixes from the comment.
            if line.startswith(prefix):
              line = line[len(prefix):]

            /# We check if the line matches a special control line.
            m = spre.match(line)
            if m:
              /# We found a special action line. It is consumed and the data
              /# stored in specials.
              action = m.group('action')
              if action in specials:
                metafile.error(
                  'Invalid repeat of special "%s"' % action,
                  line=attribute.line() + i)
              else:
                specials[action] = m.group('text')
            elif inret:
              retlines.append(line)
            else:
              userlines.append(line)

      data = {'user': userlines, 'special': specials}
      if parse_return:
        data['returns'] = retlines

      return (attribute, data)
    tests:
      testx cc ::
        test.tcc()
        /# TODO(wmh): Make the comment in samples 'oopl' richer so we can
        /# test this method more fully.
        test.iseq(
          {
            'user': [
              'Calculate body mass index of this person.',
              'Result is unitless, but relies on height in meters and',
              'weight in kilograms.',
            ],
            'special': {},
          },
          test.baselang.parseComment(test.method)[1])
    end method parseComment;

    remark  #:
      The following are template methods that subclass must define. Each
      is defined by a behavior.

      accessorType(ftype:Type,acc:str):Type
      accessorCode(kind:str,fytpe:Type):str
      augmentVarset(construct:Construct,varset:VarSet)
      autogenStr(construct:ClassConstruct)
      autogenPrint(construct:ClassConstruct)
      autogenWrite(construct:ClassConstruct)
      autogenSize(construct:ClassConstruct):int
      buildPreambleText():str
      classSubPath(klass:ClassConstruct):str
      createBuildFragment(
        construct:Construct,targets:vec<str>,
        test:bool=false,name:str=null,src:str=null)
      emptyBlockCode(method:ExecutableConstruct,message:str=null):vec<str>
      finalizerName(klass:ClassConstruct):str
      formatClassConstruct(
        attribute:SimpleBlock,width:int=80,suppress:map=null):vec<str>
      formatClassType(metafile:MetaFile,cstr:str):str
      formatComment(comment:vec<str>,width:int=80):vec<str>
      formatDependencies(
        class_construct:ClassConstruct,
        triples:vec<tuple<str,str,str>>):tuple<vec<str>,vec<str>>
      formatDependency(
        class_construct:ClassConstruct,
        triples:vec<tuple<str,str,str>>,index:int):tuple<str,str>
      formatFieldDefinition(field:FieldConstruct):vec<str>
      formatMethodComment(construct:ExecutableConstruct,width:int=80):vec<str>
      formatParams(
        executable:ExecutableConstruct,
        preamble:vec<str>,decl:bool=false):vec<str>
      formatParentSpec(
        class_construct:ClassConstruct):tuple<str,tuple<str,str,str>>
      fqnToTarget(fqn)
      initializerName(klass:ClassConstruct):str
      metaMethodBody(metainst:str,metaclass:ClassConstruct):vec<str>
      parseBazelLog(logdata:str,tdata:map,debug:bool=false):any
      processTestOutput(stdout:str,stderr:str,cwd:str,namespace:str,...)
      repl()
      superCode(method:ExecutableConstruct,output:vec<str>,width:int=80):void
      _annotateBaseType(metatype:Type,basetype:str):str
    end;

  end class BaseLanguageOopl;

  class OoplPython < BaseLanguageOopl #:
    Functionality for compiling Meta(Oopl) code into Python.
  assocs:
    std assoc code;
  scope:

    lifecycle  params:
      var id : str;
      var parent : metax.attr.ComplexBlock;
      var context : *metax.oopl.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('python')
      self.nameIs('Python')
      self.suffixesIs(['py'])

      strptr = {
        'base': 'str', 'default': 'None',
        'format': lambda var: 'self.%s()' % var,
      }
      strref = {
        'base': 'str', 'default': "''",
      }
      self.metatypesIs({
        'bool': {
          'base': 'bool', 'default': 'False',
          'format': lambda var: 'str(' + var + ').lower()',
        },
        'trilean': {
          'base': 'trilean', 'default': 'None',
          'format': lambda var: 'str(' + var + ').lower().replace("None", "null")',
        },
        'char': {
          'base': 'str', 'default': "''",
          'format': lambda var: var,
        },
        'int': {
          'base': 'int', 'default': '0',
          'format': lambda var: "'%d' % " + var,
        },
        'uint': {
          'base': 'int', 'default': '0',
          'format': lambda var: "'%d' % " + var,
        },
        'real': {
          'base': 'float', 'default': '0.0',
          'format': lambda var: "'%g' % self." + var + '()',
        },
        'double': {
          'base': 'float', 'default': '0.0',
          'format': lambda var: "'%g' % self." + var + '()',
        },
        'float': {
          'base': 'float', 'default': '0.0',
          'format': lambda var: "'%g' % self." + var + '()',
        },
        /# The 'str' type has some special handling.
        /#   *str and str should be the same
        /#   &str should be a version that cannot be null
        /#   @str may be disallowed or will be same as &str.
        /#   (see BaseLanguageOopl.{typeToBase,metabase}).
        'str': strptr,
        '*str': strptr,
        '&str': strref,
        '@str': {'base': 'str', 'default': "''"},
        'string': {'base': 'str', 'default': 'None'},
        'vec': {'base': 'list', 'default': '[]'},
        'map': {'base': 'dict', 'default': '{}'},
        'set': {'base': 'set', 'default': 'set()'},

        'ostream': {'base': 'file', 'default': 'sys.stdout'},
        'istream': {'base': 'file', 'default': 'sys.stdin'},
        'strstream': {'base': 'file', 'default': 'None'},

        'regexp': {'base': 're.Pattern', 'default': 'None'},

        'date': {'base': 'datetime.datetime', 'default': 'None'},
        'ymd': {'base': 'datetime.date', 'default': 'None'},
        'hms': {'base': 'datetime.time', 'default': 'None'},

        'rv': {
          'base': 'scipy.stats._distn_infrastructure.rv_generic',
          'default': 'None',
        },

        'nulltype': {'base': 'types.NoneType', 'default': 'None'},
        'class': {'base': 'type', 'default': 'None'},
        'method': {'base': 'types.MethodType', 'default': 'None'},
        'function': {'base': 'types.LambdaType', 'default': 'None'},

        /# How to handle 'void' is still being worked out.
        'void': {'base': 'void', 'default': None},

        'pair': {'base': 'tuple', 'default': 'tuple()'},
        'tuple': {'base': 'tuple', 'default': 'tuple()'},
      })

      /# https://docs.python.org/3/reference/lexical_analysis.html#keywords
      self.keywordsIs(
        /# import keyword; keyword.kwlist
        ['and', 'as', 'assert', 'break', 'class', 'continue',
         'def', 'del', 'elif', 'else', 'except', 'exec',
         'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is',
         'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try',
         'while', 'with', 'yield'])

      self.updateConfigs({
        'namespace_primary': True,
        'definition_separate': False,
        'rem': '#',
        'self': 'self',
        'cls': 'cls',
        'selfsep': '.',
        'staticsep': '.',
        'stmtend': '',

        /# https://docs.python.org/2/library/unittest.html#test-cases
        'setup': {'name': 'setUp'},
        'teardown': {'name': 'tearDown'},
        'clsetup': {'name': 'setUpClass', 'level': 'meta'},
        'clteardown': {'name': 'tearDownClass', 'level': 'meta'},

        'switch_level': 0,
      })

      /# CODETANGLE(pseudovars)
      self.pseudovarsIs({
        'self': 'self',
        /# TODO(wmh): Decide whether we are supporting 'this' as a meta-level
        /# pseudovar, and if so, what it means to map it to baselang syntax.
        /# For now I'm assuming the baselang syntax is the receiver in the
        /# baselang that 'this' would be assigned to.
        'this': 'self',
        /# TODO(wmh): Decide whether we are supporting 'test' as a meta-level
        /# pseudovar, and if so, what it means to map it to baselang syntax.
        /# For now I'm assuming the baselang syntax is the receiver in the
        /# baselang that 'test' would be assigned to.
        'test': 'self',

        'true': 'True',
        'false': 'False',
        'null': 'None',
        'nan': 'metax.root.NaN',
        /# TODO(wmh): Accumulate the values used across various baselangs and
        /# decide what should be used for stdin, stdout and stderr. Using
        /# 'in' and 'out', 'err' may be too ambiguous ... might be more
        /# readable to prefix with 'std' or something else.
        'out': 'sys.stdout',
        'in': 'sys.stdin',
        'err': 'sys.stderr',
        'sout': 'metax.io.Sink.Out()',
        'serr': 'metax.io.Sink.Err()',
        'snull': 'metax.io.Sink.Null()',
      })
    setup:
      baselang, _, context, _ = self.cachedInfo(basel='python')
      self.baselang = baselang
      self.context = context
    end;

  end class OoplPython;

  class OoplJavascript < BaseLanguageOopl #:
    Functionality for compiling Meta(Oopl) code into Javascript

    References:
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\
        Global_Objects
      https://www.nczonline.net/blog/2014/01/21/\
        private-instance-members-with-weakmaps-in-javascript/
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/\
        Introduction_to_Object-Oriented_JavaScript
      http://javascriptissexy.com/oop-in-javascript-what-you-need-to-know/
      http://davidbcalhoun.com/2011/\
        different-ways-of-defining-functions-in-javascript-this-is-madness/
      https://philipwalton.com/articles/\
        implementing-private-and-protected-members-in-javascript/
      https://javascriptweblog.wordpress.com/2011/02/07/\
        truth-equality-and-javascript/

    Important:
      - When generating javascript code for method scope, keep the commentary
        from
          https://www.sitepoint.com/google-closure-how-not-to-write-javascript/
        in mind.
  assocs:
    std assoc subprocess;
  scope:

    lifecycle  params:
      var id : str;
      var parent : metax.attr.ComplexBlock;
      var context : *metax.oopl.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('javascript')
      self.nameIs('Javascript')
      self.suffixesIs(['js'])

      /# In javascript, which lacks static typing, this type mapping wouldn't
      /# usually be as important as in languages with static typing. However,
      /# because we are using Google Closure, which enforces static typing
      /# information more stringently than many statically typed languages,
      /# the mapping becomes quite important.
      /#
      /# See
      /#   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\
      /#     Global_Objects
      /#   https://github.com/google/closure-compiler/wiki/\
      /#     Types-in-the-Closure-Type-System
      /#   https://developers.google.com/closure/compiler/docs/js-for-compiler
      strptr = {'base': 'string',  'default': 'null' }
      self.metatypesIs({
        'bool':   {'base': 'boolean', 'default': 'false'},
        'char':   {'base': 'str',     'default': "''"   },
        'int':    {'base': 'number',  'default': '0'    },
        'uint':   {'base': 'number',  'default': '0'    },
        'real':   {'base': 'number',  'default': '0.0'  },
        'float':  {'base': 'number',  'default': '0.0'  },
        'double': {'base': 'number',  'default': '0.0'  },
        /# The 'str' type has some special handling.
        /#   *str and str should be the same
        /#   &str should be a version that cannot be null
        /#   @str may be disallowed or will be same as &str.
        /#   (see BaseLanguageOopl.{typeToBase,metabase}).
        'str':    strptr,
        '*str':   strptr,
        '&str':   {'base': 'string',  'default': "''"   },
        '@str':   {'base': 'string',  'default': "''"   },
        'string': {'base': 'String',  'default': 'null' },
        'vec':    {'base': 'Array.<%(TV)s>',   'default': '[]'   },
        /# TODO(wmh): Need to distinguish between map (keys can be anything) and
        /# smap (keys are always strings).  The builtin Map class should be
        /# used instead of Object (and literal {} needs to be handled somehow).
        'map':    {'base': 'Object.<%(TK)s,%(TV)s>',  'default': '{}'   },
        'any':    {'base': '*', 'default': None},

        /# IO in Javascript ... via phantomjs 'fs' module?
        /#   http://phantomjs.org/api/fs/
        'ostream': {'base': 'Object', 'default': 'null'},
        'istream': {'base': 'Object', 'default': 'null'},
        'strstream': {'base': 'Object', 'default': 'null'},

        'regexp': {},

        /# https://www.w3schools.com/js/js_datatypes.asp
        'nulltype': {'base': 'Object', 'default': 'null'},
        'class': {'base': 'Object', 'default': 'null'},
        'method': {'base': 'Function', 'default': 'null'},
        'function': {'base': '(Function|string)', 'default': 'null'},
        /# NOTE(wmh): TestCase.raises() accepts a function, and closure is
        /# insisting it be (Function|string). I can easily imagine other
        /# variations on this, so we may need to generalize or hack.

        /# How to handle 'void' is still being worked out.
        'void': {'base': 'void', 'default': None},

        'pair':    {'base': 'Array.<?*>', 'default': '[]'},
        'tuple':   {'base': 'Array.<?*>', 'default': '[]'},
      })

      /# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\
      /#   Reserved_Words
      self.keywordsIs(
        [
          'break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete',
          'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof',
          'new', 'return', 'switch', 'this', 'throw', 'try', 'typeof', 'var',
          'void', 'while', 'with',
          /# future
          'class', 'enum', 'export', 'extends', 'import', 'super',
          /# future if strict
          'implements', 'interface', 'let', 'package', 'private', 'protected',
          'public', 'static', 'yield',
        ])

      self.updateConfigs({
        'namespace_primary': False,
        'definition_separate': False,
        'rem': '//',
        'self': 'this',
        'cls': 'this',
        'selfsep': '.',
        'staticsep': '.',
        'stmtend': ';',

        /# $CLOSURE_ROOT/library/closure/goog-orig/testing/testcase.js
        'setup': {'name': 'setUp', 'level': 'instance'},
        'clsetup': {'name': 'setUpPage', 'level': 'instance'},
        'teardown': {'name': 'tearDown', 'level': 'instance'},
        'clteardown': {'name': 'tearDownPage', 'level': 'instance'},

        /# specific to this baselang.
        'use_es2015': True,

        /# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\
        /#   Statements/switch
        'switch_level': 2,
      })

      /# CODETANGLE(pseudovars)
      self.pseudovarsIs({
        /# See comments in OoplPython when initializing this same pseudovars
        /# field for details/questions about self, this, and test.
        'self': 'this',
        'this': 'this',
        'test': 'this',

        'true': 'true',
        'false': 'false',
        'null': 'null',
        /# TODO(wmh): Fix these! If we use Node.js we will have process.stdout, etc.
        'out': 'null',
        'in': 'null',
        'err': 'null',
        'sout': 'metax.io.Sink.Out()',
        'serr': 'metax.io.Sink.Err()',
        'snull': 'metax.io.Sink.Null()',
      })
    setup:
      baselang, _, context, _ = self.cachedInfo(basel='javascript')
      self.baselang = baselang
      self.context = context
    end;

    test
    method test_typeToBase scope:
      oopljs, _, context, _ = test.cachedInfo(basel='javascript')
      MetaType = metax.c.Type.Instance
      /# TODO(wmh): Decide how to deal with 'str'
      /#  - See notes in README.md in "Implementing interned string support".
      test.iseq('?string', oopljs.typeToBase(MetaType('str')))
      test.iseq('?string', oopljs.typeToBase(MetaType('*str')))
      test.iseq('!string', oopljs.typeToBase(MetaType('&str')))
      test.iseq('!string', oopljs.typeToBase(MetaType('@str')))
    end method;

  end class OoplJavascript;

  class OoplCpp < BaseLanguageOopl #:
    Functionality for compiling Meta(Oopl) code into C++

    Notes on Bazel:
     - For C++, Bazel uses a CROSSTOOL file to specify details about
       the C++ compiler and associated programs used to interact with
       the C++ code.
     - One can provide a custom toolchain, but it is currently non-trivial:
       - About the CROSSTOOL:
           https://github.com/bazelbuild/bazel/wiki/About-the-CROSSTOOL
       - Building with a custom toolchain:
           https://github.com/bazelbuild/bazel/wiki/\
             Building-with-a-custom-toolchain
       - Generating C++ crosstool with a Skylark Remote Repository:
           https://bazel.build/designs/2016/02/16/cpp-autoconf.html
       - Using Skylark remote repositories to auto-detect the C++ toolchain:
           https://blog.bazel.build/2016/03/31/autoconfiguration.html
       - Yet Another CROSSTOOL Writing Tutorial:
           https://github.com/bazelbuild/bazel/wiki/\
             Yet-Another-CROSSTOOL-Writing-Tutorial
    Documentation on CROSSTOOL:
  assocs:
    std usertest assoc collections;
    std usertest assoc pprint;
    std assoc subprocess;
  scope:

    lifecycle  params:
      var id : str;
      var parent : metax.attr.ComplexBlock;
      var context : *metax.oopl.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    clinit:
      /# cls.CC_ANY = 'long long'
      cls.CC_ANY = 'void'

      /# CODETANGLE(cc_str_defn): How we define 'CC_STR' and 'CC_STRVIEW' here
      /# must be compatible with how we define 'str' and 'strview' in
      /# $METAREP/src/templates/oopl/cpp/metastrap/__Meta__.h.
      /#
      /# TODO(wmh): Get abseil working, and start using absl::string_view. Note
      /# that we can represent a null 'str' using absl::string_view by setting
      /# sv.data() to null (and this differs from the empty string, so we don't
      /# have to special case things too much).

      /#cls.CC_STR = 'const std::string'
      /#cls.CC_STR_VALUE = 'std::string'
      cls.CC_STR = 'metax::str'
      cls.CC_STRVIEW = 'metax::strview'
      cls.CC_STR_VALUE = 'metax::str'
      cls.PTR_MAP = {
        'u': 'std::unique_ptr',
        's': 'std::shared_ptr',
        'w': 'std::weak_ptr',
      }
    scope:
      self.idIs('cpp')
      self.nameIs('C++')
      self.suffixesIs(['cc', 'h'])

      /# See
      /#  http://en.cppreference.com/w/cpp/language/types
      strptr = {'base': OoplCpp.CC_STR, 'default': 'nullptr'}
      strref = {'base': OoplCpp.CC_STR, 'default': 'metax::string()'}
      self.metatypesIs({
        'bool': {'base': 'bool', 'default': 'false'},
        'char': {'base': 'char', 'default': "''"},
        'int': {
           #  http://en.cppreference.com/w/cpp/types/integer
           0: True,
           8: {'base': 'int8_t',  'default': '0'},
          16: {'base': 'int16_t', 'default': '0'},
          32: {'base': 'int32_t', 'default': '0'},
          64: {'base': 'int64_t', 'default': '0'},
          None: {'base': 'int32_t', 'default': '0'},
        },
        'uint': {
          0: True,
          7: {'base': 'uint8_t', 'default': '0'},
          15: {'base': 'uint16_t', 'default': '0'},
          31: {'base': 'uint32_t', 'default': '0'},
          63: {'base': 'uint64_t', 'default': '0'},
          None: {'base': 'int', 'default': '0'},
        },
        'real': {
          0: True,
          32: {'base': 'float', 'default': '0.0'},
          64: {'base': 'double', 'default': '0.0'},
          80: {'base': 'long double', 'default': '0.0'},
          None: {'base': 'float', 'default': '0.0'},
        },
        'float': {'base': 'float', 'default': '0.0'},
        'double': {'base': 'double', 'default': '0.0'},
        /# The 'str' type has some special handling.
        /#   *str and str should be the same
        /#   &str should be a version that cannot be null
        /#   @str may be disallowed or will be same as &str.
        /#   (see BaseLanguageOopl.{typeToBase,metabase}).
        'str': strptr,
        '&str': strref,
        '*str': strptr,
        '@str': {
          'base': OoplCpp.CC_STR_VALUE, 'default': 'std::string("")'},
        'string': {'base': 'std::string', 'default': 'std::string("")'},
        'vec': {'base': 'std::vector<%(TV)s>', 'default': None},
        'map': {'base': 'std::map<%(TK)s,%(TV)s>', 'default': None},
        'void': {'base': 'void', 'default': None},
        'any': {'base': OoplCpp.CC_ANY, 'default': None},

        'ostream': {'base': 'std::ostream', 'default': 'std::cout'},
        'istream': {'base': 'std::istream', 'default': 'std::cin'},
        'strstream': {
          'base': 'std::stringstream', 'default': 'std::stringstream()'},

        'regexp': {},

        'nulltype': {'base': 'std::nullptr_t', 'default': 'nullptr'},
        /# TODO(wmh): Change to metax.root.ObjectMetaRoot when we have support
        /# for including required implicit targets implemented.
        /# TODO(wmh): Change 'long long' to 'std::any' when c++17 support
        /# available in bazel.
        'class': {'base': 'metax.root.ObjectMetaRoot', 'default': 'nullptr'},
        /# TODO(wmh): Can we use std::function? Sometimes (e.g.
        /# TestCase.raises()) we do not know the signature ... can std::function
        /# handle varargs?
        'method': {'base': 'void*', 'default': 'nullptr'},
        'function': {'base': 'void*', 'default': 'nullptr'},

        /# How to handle 'void' is still being worked out.
        'void': {'base': 'void', 'default': None},

        'pair': {
          'base': 'std::pair<%(T1)s,%(T2)s>',
          'default': 'std::pair<%(T1)s,%(T2)s>()',
        },
        'tuple': {'base': 'types.TupleType', 'default': 'tuple()'},
        'map': {'base': 'std::map<%(TK)s,%(TV)s>', 'default': None},
      })

      self.keywordsIs(
        /# http://en.cppreference.com/w/cpp/keyword
        ['alignas', 'alignof', 'and', 'and_eq', 'asm', 'auto', 'bitand',
         'bitor',
         'bool', 'break', 'case', 'catch', 'char', 'char16_t', 'char32_t',
         'class',
         'compl', 'const', 'constexpr', 'const_cast', 'continue', 'decltype',
         'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
         'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend',
         'goto', 'if', 'inline', 'int', 'long', 'mutable', 'namespace', 'new',
         'noexcept', 'not', 'not_eq', 'nullptr', 'operator', 'or', 'or_eq',
         'private', 'protected', 'public', 'register', 'reinterpret_cast',
         'return', 'short', 'signed', 'sizeof', 'static', 'static_assert',
         'static_cast', 'struct', 'switch', 'template', 'this', 'thread_local',
         'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union',
         'unsigned', 'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while',
         'xor', 'xor_eq'])

      self.updateConfigs({
        'namespace_primary': False,
        'definition_separate': True,
        'rem': '//',
        'self': 'this',
        'cls': 'this',
        'selfsep': '->',
        'staticsep': '::',
        'stmtend': ';',

        /# https://github.com/google/googletest/blob/master/googletest/docs/\
        /#   Primer.md
        'setup': {'name': 'SetUp', 'dispatch': 'virtual'},
        'clsetup': {'name': 'SetUpTestCase', 'level': 'static'},
        'teardown': {'name': 'TearDown', 'dispatch': 'virtual'},
        'clteardown': {'name': 'TearDownTestCase', 'level': 'static'},

        /# https://en.cppreference.com/w/cpp/language/switch
        'switch_level': 1,
      })

      /# TODO(wmh): Certain pseudovars may have metatype-specific baselang
      /# values. For example, 'null' is a common default for str-valued params,
      /# but if 'str' is std::string or absl::string_view or some other
      /# non-pointer class, it is invalid to assign nullptr to it.
      /# CODETANGLE(pseudovars)
      self.pseudovarsIs({
        /# See comments in OoplPython when initializing this same pseudovars
        /# field for details/questions about self, this, and test.
        'self': '(*this)',
        'this': 'this',
        'test': '(*this)',

        'true': 'true',
        'false': 'false',
        'null': 'nullptr',
        'out': 'std::cout',
        'in': 'std::cin',
        'err': 'std::cerr',
        'sout': 'metax::io::Sink::Out()',
        'serr': 'metax::io::Sink::Err()',
        'snull': 'metax::io::Sink::Null()',
      })
    setup:
      baselang, _, context, _ = self.cachedInfo(basel='cpp')
      self.baselang = baselang
      self.context = context
    end lifecycle;

    method typeToBase : str #:
      Convert a metatype to a string representation of its base-language
      equivalent.
    params:
      var metatype : *metax.oopl.Type #:
        The metatype to convert.
      var class_construct : metax.oopl.ClassConstruct = null #:
        If specified, the class within which the type is being defined.
        Some baselangs cannot support fully-qualified references to the
        class currently being defined, and this allows such fully-qualified
        types to be localized.
      var value : any = null #:
        If present, the value being assigned to the variable of type 'metatype'.
        Used, for example, if metatype is 'str' (rather than '&str' or '*str')
        to heuristically decide between '&str' or '*str'.
      var defqn : bool = false #:
        If true, convert fully-qualified class-based types to class-name only.
        Used to support situations where the fully-qualified name poses
        problems in the baselang.
      var debug : bool = false;
    scope:
      /# TODO(wmh): This should be a behavior.
      if metatype.isStr():
        result = OoplCpp.CC_STRVIEW
      else:
        result = super(OoplCpp, self).typeToBase(
          metatype, class_construct=class_construct, value=value, defqn=defqn,
          debug=debug)
      return result
    test:
      baselang, _, context, _ = test.cachedInfo(basel='cpp')
      MetaType = metax.c.Type.Instance
      cc_str = metax.oopl.OoplCpp.CC_STR
      cc_strview = metax.oopl.OoplCpp.CC_STRVIEW
      cc_str_value = metax.oopl.OoplCpp.CC_STR_VALUE

      test.iseq('%s' % cc_strview, baselang.typeToBase(MetaType('str')))
      test.iseq('%s' % cc_strview, baselang.typeToBase(MetaType('@str')))
      test.iseq('%s' % cc_strview, baselang.typeToBase(MetaType('&str')))
      test.iseq('%s' % cc_strview, baselang.typeToBase(MetaType('*str')))
    end method typeToBase;

  end class OoplCpp;

  behavior accessorCode : str #:
    Returns the baselang code for a specified kind of accessor of given type.
  params:
    var kind : str #:
      One of 'get', 'set', 'ref', etc.
    var ftype : metax.oopl.Type #:
      The type of the field for which accessor code is desired.
    var field_code : str #:
      The full baselang syntax for accessing the field. This will be things
      like 'self.age', 'this->age', 'A::age', etc.
    var packinfo : tuple<int,int,bool> = null #:
      Indicates that the field is packed.
  scope:
    abstract
    receiver BaseLanguageOopl;

    receiver OoplCpp ::
      /# In C++, we do not need to do anything special for packed fields, as
      /# bit-field support exists natively.
      if kind == 'get':
        if ftype.isUniquePtr():
          result = ['return ' + field_code + '.get();']
        else:
          result = ['return ' + field_code + ';']
      elif kind == 'ref':
        if ftype.isUniquePtr():
          result = ['throw "Cannot return unique ptr by reference";']
        else:
          result = ['return ' + field_code + ';']
      elif kind == 'set':
        /# See ../../README.md section 'Accessors' for discussion of setter
        /# return values. Currently having setters return void.
        if ftype.isUniquePtr():
          result = [field_code + ' = std::move(value);']
        else:
          result = [field_code + ' = value;']
      elif kind == 'format':
        result = []
      elif kind == 'write':
        result = []
      elif kind == 'size':
        result = []
      else:
        raise Error('Invalid kind "%s"' % kind)
      return result
    test:
      test.tcc()

      /# A simple ptr type.
      metatype = metax.c.Type.Instance('*demo.cards1.Card')
      test.iseq(
        ['return this->_card;'],
        test.baselang.accessorCode('get', metatype, 'this->_card'))
      test.iseq(
        ['this->_card = value;'],
        test.baselang.accessorCode('set', metatype, 'this->_card'))
      test.iseq(
        ['return this->_card;'],
        test.baselang.accessorCode('ref', metatype, 'this->_card'))
      test.iseq(
        [],
        test.baselang.accessorCode('format', metatype, 'this->_card'))
      test.iseq(
        [],
        test.baselang.accessorCode('write', metatype, 'this->_card'))
      test.iseq(
        [],
        test.baselang.accessorCode('size', metatype, 'this->_card'))

      /# Now a unique ptr.
      metatype = metax.c.Type.Instance('u*demo.cards1.Card')
      test.iseq(
        ['return this->_card.get();'],
        test.baselang.accessorCode('get', metatype, 'this->_card'))
      test.iseq(
        ['this->_card = std::move(value);'],
        test.baselang.accessorCode('set', metatype, 'this->_card'))
      test.iseq(
        ['throw "Cannot return unique ptr by reference";'],
        test.baselang.accessorCode('ref', metatype, 'this->_card'))

      /# Now a packed field
      metatype = metax.c.Type.Instance('int')
      packinfo = (3, 5, False)
      test.iseq(
        ['return this->_val;'],
        test.baselang.accessorCode(
          'get', metatype, 'this->_val', packinfo=packinfo))
      test.iseq(
        ['this->_val = value;'],
        test.baselang.accessorCode(
          'set', metatype, 'this->_val', packinfo=packinfo))
      test.iseq(
        ['return this->_val;'],
        test.baselang.accessorCode(
          'ref', metatype, 'this->_val', packinfo=packinfo))
    end receiver OoplCpp;

    receiver OoplJavascript ::
      /# NOTE: This is very similar to the OoplPython implementation, just
      /# with statement terminators. Will the code diverge over time, or
      /# should we reuse?

      if packinfo:
        /# Only meaningful for 'get' and 'set
        start_bit, bits, signed = packinfo
        maxval = (1 << bits) - 1
        mask = '0x%x' % maxval
        smask = '0x%x' % (maxval << start_bit)
        if signed:
          halfval = (1 << (bits-1))
          if kind == 'get':
            result = [
              'return ((%s >> %d) & %s) - %d;' %
              (field_code, start_bit, mask, halfval)
            ]
          elif kind == 'set':
            result = [
              '%s = (%s & ~%s) | ( (value + %d) << %d );' %
              (field_code, field_code, smask, halfval, start_bit)
            ]
          elif kind == 'ref':
            result = ['throw "cannot ref packed field";']
          else:
            raise Error('Invalid kind "%s" for packed field' % kind)
        else:
          if kind == 'get':
            result = [
              'return (%s >> %d) & %s;' %
              (field_code, start_bit, mask)
            ]
          elif kind == 'set':
            result = [
              '%s = (%s & ~%s) | ( value << %d );' %
              (field_code, field_code, smask, start_bit)
            ]
          elif kind == 'ref':
            result = ['throw "cannot ref packed field";']
          else:
            raise Error('Invalid kind "%s" for packed field' % kind)
      elif kind == 'get':
        result = ['return ' + field_code + ';']
      elif kind == 'ref':
        result = ['return ' + field_code + ';']
      elif kind == 'set':
        /# See ../../README.md section 'Accessors' for discussion of setter
        /# return values. Currently having setters return void.
        result = [field_code + ' = value;']
      elif kind == 'format':
        result = []
      elif kind == 'write':
        result = []
      elif kind == 'size':
        result = []
      else:
        raise Error('Invalid kind "%s"' % kind)
      return result
    test:
      test.tjs()

      /# A simple ptr type.
      metatype = metax.c.Type.Instance('*demo.cards1.Card')
      test.iseq(
        ['return this._card;'],
        test.baselang.accessorCode('get', metatype, 'this._card'))
      test.iseq(
        ['this._card = value;'],
        test.baselang.accessorCode('set', metatype, 'this._card'))
      test.iseq(
        ['return this._card;'],
        test.baselang.accessorCode('ref', metatype, 'this._card'))
      test.iseq(
        [],
        test.baselang.accessorCode('format', metatype, 'this._card'))
      test.iseq(
        [],
        test.baselang.accessorCode('write', metatype, 'this._card'))
      test.iseq(
        [],
        test.baselang.accessorCode('size', metatype, 'this._card'))

      /# Now a unique ptr.
      metatype = metax.c.Type.Instance('u*demo.cards1.Card')
      test.iseq(
        ['return this._card;'],
        test.baselang.accessorCode('get', metatype, 'this._card'))
      test.iseq(
        ['this._card = value;'],
        test.baselang.accessorCode('set', metatype, 'this._card'))
      test.iseq(
        ['return this._card;'],
        test.baselang.accessorCode('ref', metatype, 'this._card'))

      /# Now a packed field
      metatype = metax.c.Type.Instance('int')
      packinfo = (3, 5, False)
      test.iseq(
        ['return (this._val >> 3) & 0x1f;'],
        test.baselang.accessorCode(
          'get', metatype, 'this._val', packinfo=packinfo))
      test.iseq(
        ['this._val = (this._val & ~0xf8) | ( value << 3 );'],
        test.baselang.accessorCode(
          'set', metatype, 'this._val', packinfo=packinfo))
      test.iseq(
        ['throw "cannot ref packed field";'],
        test.baselang.accessorCode(
          'ref', metatype, 'this._val', packinfo=packinfo))
    end receiver OoplJavascript;

    receiver OoplPython ::
      if packinfo:
        /# Only meaningful for 'get' and 'set
        start_bit, bits, signed = packinfo
        maxval = (1 << bits) - 1
        mask = '0x%x' % maxval
        smask = '0x%x' % (maxval << start_bit)
        if signed:
          halfval = (1 << (bits-1))
          if kind == 'get':
            result = [
              'return ((%s >> %d) & %s) - %d' %
              (field_code, start_bit, mask, halfval)
            ]
          elif kind == 'set':
            result = [
              '%s = (%s & ~%s) | ( (value + %d) << %d )' %
              (field_code, field_code, smask, halfval, start_bit)
            ]
          elif kind == 'ref':
            result = ['raise Error("cannot ref packed field")']
          else:
            raise Error('Invalid kind "%s" for packed field' % kind)
        else:
          if kind == 'get':
            result = [
              'return (%s >> %d) & %s' %
              (field_code, start_bit, mask)
            ]
          elif kind == 'set':
            result = [
              '%s = (%s & ~%s) | ( value << %d )' %
              (field_code, field_code, smask, start_bit)
            ]
          elif kind == 'ref':
            result = ['raise Error("cannot ref packed field")']
          else:
            raise Error('Invalid kind "%s" for packed field' % kind)
      elif kind == 'get':
        result = ['return ' + field_code]
      elif kind == 'ref':
        result = ['return ' + field_code]
      elif kind == 'set':
        /# See ../../README.md section 'Accessors' for discussion of setter
        /# return values. Currently having setters return void.
        result = [field_code + ' = value']
      elif kind == 'format':
        result = []
      elif kind == 'write':
        result = []
      elif kind == 'size':
        result = []
      else:
        raise Error('Invalid kind "%s"' % kind)
      return result
    test:
      test.tpy()

      /# A simple ptr type.
      metatype = metax.c.Type.Instance('*demo.cards1.Card')
      test.iseq(
        ['return self._card'],
        test.baselang.accessorCode('get', metatype, 'self._card'))
      test.iseq(
        ['self._card = value'],
        test.baselang.accessorCode('set', metatype, 'self._card'))
      test.iseq(
        ['return self._card'],
        test.baselang.accessorCode('ref', metatype, 'self._card'))
      test.iseq(
        [],
        test.baselang.accessorCode('format', metatype, 'self._card'))
      test.iseq(
        [],
        test.baselang.accessorCode('write', metatype, 'self._card'))
      test.iseq(
        [],
        test.baselang.accessorCode('size', metatype, 'self._card'))

      /# Now a unique ptr.
      metatype = metax.c.Type.Instance('u*demo.cards1.Card')
      test.iseq(
        ['return self._card'],
        test.baselang.accessorCode('get', metatype, 'self._card'))
      test.iseq(
        ['self._card = value'],
        test.baselang.accessorCode('set', metatype, 'self._card'))
      test.iseq(
        ['return self._card'],
        test.baselang.accessorCode('ref', metatype, 'self._card'))

      /# Now a packed field
      metatype = metax.c.Type.Instance('int')
      packinfo = (3, 5, False)
      test.iseq(
        ['return (self._val >> 3) & 0x1f'],
        test.baselang.accessorCode(
          'get', metatype, 'self._val', packinfo=packinfo))
      test.iseq(
        ['self._val = (self._val & ~0xf8) | ( value << 3 )'],
        test.baselang.accessorCode(
          'set', metatype, 'self._val', packinfo=packinfo))
      test.iseq(
        ['raise Error("cannot ref packed field")'],
        test.baselang.accessorCode(
          'ref', metatype, 'self._val', packinfo=packinfo))
    end receiver OoplPython;

  end behavior accessorCode;

  behavior accessorType : *metax.oopl.Type #:
    The Type to use for a return value or arg of an accessor.

    Suppose a field has type T. What type should its getter, setter and
    reffer return? What is the type of the arg of the setter?
    This method answers those questions.
  params:
    var ftype : *metax.oopl.Type #:
      The type of the field for which a return type is desired.
    var acc : str #:
      One of 'get', 'set', 'setarg', or 'ref'.
    var namespace_function : function = null #:
      A function accepting no args that returns the namespace within which
      the Type appears.  Used to resolve relative class types.  If resolution
      is needed, it is an error not to provide such a function
  scope:

    abstract
    receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      base = ftype.base() + ftype.paramStr()
      prefix = ftype.prefix()
      strview = metax.c.Type.Instance(
        '@' + OoplCpp.CC_STRVIEW.replace('::', '.'))
      strref = metax.c.Type.Instance(
        '&' + OoplCpp.CC_STRVIEW.replace('::', '.'))
      result = None

      res = ''
      if acc == 'get':
        /# if T is primitive, getter is T
        /# If field is @T, getter is &#T
        /# If field is &T, getter is &#T
        /# If field is *T, getter is *#T
        /# If field is **T, getter is *#*#T
        if ftype.isPrimitive():
          result = ftype
        else:
          if ftype.isStr():
            /# We have the 'str' type. Note that 'str' is inherently const so
            /# we do NOT need to prefix the type with '#'.
            /#  get *str returns metax::str (there is a special metax::str
            /#    instance that represents null)
            /#  get &str returns metax::str (how do we ensure non-null not
            /#    allowed?)
            /#  get @str returns metax::str copy
            result = strview
          elif ftype.isValue():
            /# The only possible prefixes are '@' and '@#'.
            res = '&#'
          elif ftype.isRef():
            /# The prefix starts with '&', then zero or more '*' each
            /# optionally preceeded by '#', then an optional '#'.
            /# (regexp '^&(?:#?\*)*#?$').  In all cases, we return a reference,
            /# with all pointers being const, and the base value itself
            /# also const.
            numast = prefix.count('*')
            res = '&' + '#*' * numast + '#'
          elif ftype.isPtr():
            /# For '*T' the getter is '*#T'
            /# For '**T', the getter is '*#*#T;
            /# For 'u*T', the getter is '*#T'
            /#   (we do not pass unique_ptr ... ownership stays with receiver)
            /# For 's*T', the getter is '*#T' (is this correct?)
            /# For 'w*T', the getter is '*#T'
            /#   (is this correct, or do we pass the weakness?)
            numast = prefix.count('*')
            res = '*' + ('#*' * (numast-1)) + '#'
          else:
            raise metax.c.InternalError('Should never reach this')
          if result is None:
            result = metax.c.Type.Instance(
              res + base, namespace_function=namespace_function)

      elif acc == 'set':
        /# We used to have setters return 'this', but with the concept of
        /# the '..' operator that is no longer needed.
        result = None

      elif acc == 'setarg':
        /# The setter arg type.
        /#  - we very rarely want pass-by-value semantics here (only for
        /#    primitives and 'super-light' class types like 'std::string_view')
        /#  - whether the arg should be const or not depends on whether we
        /#    are copying or moving ... how do we allow the user to specify
        /#    this?
        if ftype.isStr():
          result = strview
        else:
          /# TODO(wmh): We need to add more special-casing here.
          result = ftype

          /# Special cases:
          /#  - a unique pointer (e.g. u*T)
          /#     - we are returning the type of the setter arg here, which
          /#       should the same type as the field because we want by-value
          /#       semantics as we are intending to take ownership of the
          /#       passed-in arg. See
          /#         https://stackoverflow.com/questions/8114276/\
          /#           how-do-i-pass-a-unique-ptr-argument-to-a-constructor-\
          /#             or-a-function/8114913#8114913
      elif acc == 'ref':
        /# If field is base const (#T, *#T, &#T, etc.), it is an error to
        /# generate a reffer for it.
        /# If field is @T, reffer is &T
        /# If field is &T, reffer is &T
        /# If field is *T, reffer is &*T
        result = None
        if ftype.isStr():
          result = strref
        elif ftype.isBaseConst():
          raise metax.c.Error(
            'Cannot generate reffer for type "%s"' % ftype.raw())
        elif ftype.isValue():
          /# The only possible prefix is '@' (since '@#' is not allowed).
          res = '&'
        elif ftype.isRef():
          /# The prefix starts with '&', then zero or more '*' each
          /# optionally preceeded by '#' (regexp '^&(?:#?\*)*$').
          res = prefix
        elif ftype.isPtr():
          /# The prefix starts with '*' or '#*', then zero or more '*' each
          /# optionally preceeded by '#'. Cannot contain '&' or '@' anywhere.
          res = '&' + prefix
        else:
          raise metax.c.InternalError('Should never reach this')

        if result is None:
          result = metax.c.Type.Instance(
            res + base, namespace_function=namespace_function)
      else:
        raise metax.c.Error('Unhandled acc "%s"' % acc)

      return result
    test:
      test.tcc()
      MetaType = metax.c.Type.Instance
      test.iseq(
        'int',
        test.baselang.accessorType(MetaType('int'), 'get').raw())
      test.iseq(
        '&#demo.cards2.Card',
        test.baselang.accessorType(MetaType('&demo.cards2.Card'), 'get').raw())

      test.iseq(
        '*#ostream',
        test.baselang.accessorType(MetaType('ostream'), 'get').raw())

      test.iseq(
        '*#nm.sp.T',
        test.baselang.accessorType(MetaType('u*nm.sp.T'), 'get').raw())

      test.iseq(
        'u*nm.sp.T',
        test.baselang.accessorType(MetaType('u*nm.sp.T'), 'setarg').raw())

      /# TODO(wmh): Add more.
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      if acc == 'get':
        result = ftype
      elif acc == 'set':
        result = None
      elif acc == 'setarg':
        result = ftype
      elif acc == 'ref':
        result = ftype
      else:
        raise metax.c.Error('Unhandled acc "%s"' % acc)
      return result
    test:
      test.tjs()
      metatype = metax.c.Type.Instance('demo.cards1.Card')
      test.iseq(
        metatype, test.baselang.accessorType(metatype, 'get'))
      test.iseq(
        /# TODO(wmh): Decide whether setters return self or not. If they do,
        /# the return type here should be the klass, not None
        None, test.baselang.accessorType(metatype, 'set'))
      test.iseq(
        metatype, test.baselang.accessorType(metatype, 'ref'))
    end receiver OoplJavascript;

    receiver OoplPython scope:
      if acc == 'get':
        result = ftype
      elif acc == 'set':
        result = None
      elif acc == 'setarg':
        result = ftype
      elif acc == 'ref':
        result = ftype
      else:
        raise metax.c.Error('Unhandled acc "%s"' % acc)
      return result
    test:
      test.tpy()
      metatype = metax.c.Type.Instance('*demo.cards1.Card')
      test.iseq(
        metatype, test.baselang.accessorType(metatype, 'get'))
      test.iseq(
        /# TODO(wmh): Decide whether setters return self or not. If they do,
        /# the return type here should be the klass, not None
        None, test.baselang.accessorType(metatype, 'set'))
      test.iseq(
        metatype, test.baselang.accessorType(metatype, 'ref'))
    end receiver OoplPython;

  end behavior accessorType;

  behavior _annotateBaseType : str #:
    Baselang specific metatype conversion to baselang.

    This is a template method invoked within typeToBase.
    Adds ptr/ref/const/etc annotations to a baselang basetype.

    Returns:
      The baselang version of the core part of metatype.
  params:
    var metatype : *metax.oopl.Type #:
      The meta-level type being converted.
    var basetype : str #:
      The baselang version of the core part of metatype.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      /# In Python:
      /#   @int is int
      /#   &int is not yet supportable
      /#   *int .... do we use meta.lang.Integer (java-like boxing?)
      /#
      /#   @vec is list
      /#   &vec is list
      /#   *vec is list
      /#
      /#   @map is dict
      /#   &map is dict
      /#   *map is dict
      /#
      /#   @str is not allowed (interned does not support copy semantics ...
      /#      but we could use move semantics?)
      /#   &str is str
      /#   *str is str (implicitly const)
      return basetype
    test:
      baselang = test.baselang
      MetaType = metax.c.Type.Instance

      def Chk(expected, metatype, basetype):
        res = baselang._annotateBaseType(metatype, basetype)
        self.iseq(expected, res)

      Chk('demo.cards1.Card',
          MetaType('*demo.cards1.Card'), 'demo.cards1.Card')
      Chk('demo.cards1.Card',
          MetaType('*demo.cards1.Card'), 'demo.cards1.Card')
      Chk('demo.cards1.Card',
          MetaType('*demo.cards1.Card'), 'demo.cards1.Card')

      Chk('file', MetaType('ostream'), 'file')
      Chk('file', MetaType('&ostream'), 'file')
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# https://developers.google.com/closure/compiler/docs/\
      /#   js-for-compiler#types
      base = metatype.base()
      if metatype.isTemplate():
        result = basetype[1:]
        prefix = None
      elif metatype.isPtr():
        prefix = '?'
      else:
        prefix = '!'

      /# Javascript supports union types like '(Function|string)' [see
      /# http://usejsdoc.org/tags-type.html]. When specifying optional or
      /# required status, use '(?Function|?string)' rather than
      /# '?(Function|string)'.
      if basetype[0] == '(' and basetype[-1] == ')':
        result = (
          '(' +
          '|'.join([prefix + bt for bt in basetype[1:-1].split('|')]) +
          ')')
      else:
        result = prefix + basetype
      return result
    test:
      oopljs, _, context, _ = test.cachedInfo(basel='javascript')

      test.iseq(
        '!number',
        oopljs._annotateBaseType(metax.c.Type.Instance('int'), 'number'))
      test.iseq(
        '?number',
        oopljs._annotateBaseType(metax.c.Type.Instance('*int'), 'number'))
      test.iseq(
        '?Function',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('function'), 'Function'))
      test.iseq(
        '!Function',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('&function'), 'Function'))
      test.iseq(
        '(?Function|?string)',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('function'), '(Function|string)'))
      test.iseq(
        '(!Function|!string)',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('&function'), '(Function|string)'))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      /# In C++
      /#       @int is int
      /#       &int is int&
      /#       *int is int*
      /#
      /#       @vec is std::vector<T>
      /#       &vec is std::vector<T>&
      /#       *vec is std::vector<T>*
      /#
      /#       @map is std::hashmap<K,V>
      /#       &map is std::hashmap<K,V>&
      /#       *map is std::hashmap<K,V>*
      /#
      /#       @str is not allowed (interned does not support copy semantics ...
      /#         but we could use move semantics?)
      /#       &str is const metax.lib.IStr&
      /#       *str is const metax.lib.IStr*
      /#
      /#         *T is T*
      /#        *#T is const T*
      /#        #*T is T*const
      /#       #*#T is const T*const
      /#        u*T is std::unique_ptr<T>
      /#       u*#T is std::unique_ptr<const T>
      /#       #u*T is const std::unique_ptr<T>
      /#      #u*#T is const std::unique_ptr<const T>
      /#
      /#       u**T is std::unique_ptr<T*>
      /#      u*s*T is std::unique_ptr<std::shared_ptr<T>>
      /#   #u*#s*#T is const std::unique_ptr<const std::shared_ptr<const T>>

      result = basetype.replace('.', '::')

      if metatype.isPtr():
        /# We handle any number of [#][usw]* specs.
        /#  - parts will contain (1 + 3K) elements, where
        /#     - K is the number of '*' chars
        /#     - parts[0] is either '' or '&'
        /#     - parts[1+k] is '#' if ptr const else ''
        /#     - parts[1+k+1] is 'u' or 's' or 'w' or ''
        /#     - parts[1+k+2] is empty except when 1+k+2==n-1 in which case it
        /#       is empty if the base type is not const and is '#' if the
        /#       base type is const.
        prefix = metatype.prefix()
        parts = metax.c.Type.METATYPE_SPLIT.split(prefix)
        /#print('%-30s = %s' % (metatype.raw(), str(parts)))

        n = len(parts)
        assert ((n-1)%3) == 0
        k = (n-1) / 3
        isconst = parts[-1] == '#'

        /# We process from the back.
        /#  - we start three back from the end
        i = n - 3
        first = True
        while i > 0:
          ptrconst = parts[i] == '#'
          special = parts[i+1]
          if special:
            /# We have something like u*T or #u*T or #u*#T
            if isconst:
              result = 'const ' + result
            result = OoplCpp.PTR_MAP[special] + '<' + result + '>'
            if ptrconst:
              result = 'const ' + result
          else:
            /# We have something like *T or #*T or #*#T
            result = result + '*'
            if ptrconst:
              result += 'const'
            if isconst and first:
              result = 'const ' + result
          i -= 3
          first = False
        if parts[0] == '&':
          result += '&'
      else:
        if metatype.isPtr():
          /# We have '&T' or '&#T' (anything else has a pointer and is handled
          /# above.
          /# TODO(wmh): Handle rvalue refs!
          result += '*'
        elif metatype.isRef():
          result += '&'
        if (metatype.isBaseConst() and
            not result.startswith('const ') and
            not metatype.isStr()):
          result = 'const ' + result
      return result
    test:
      baselang = test.baselang
      MetaType = metax.c.Type.Instance

      def Chk(expected, metatype, basetype):
        res = baselang._annotateBaseType(metatype, basetype)
        self.iseq(expected, res)

      Chk('nm::sp::A', MetaType('@nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A&', MetaType('&nm.sp.A'), 'nm.sp.A')

      Chk('nm::sp::A*', MetaType('*nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A', MetaType('@nm.sp.A'), 'nm.sp.A')

      Chk('const nm::sp::A*', MetaType('*#nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A*const', MetaType('#*nm.sp.A'), 'nm.sp.A')
      Chk('const nm::sp::A*const', MetaType('#*#nm.sp.A'), 'nm.sp.A')

      Chk('std::unique_ptr<nm::sp::A>',MetaType('u*nm.sp.A'), 'nm.sp.A')
      Chk('std::unique_ptr<const nm::sp::A>',MetaType('u*#nm.sp.A'), 'nm.sp.A')
      Chk('const std::unique_ptr<nm::sp::A>',MetaType('#u*nm.sp.A'), 'nm.sp.A')
      Chk('const std::unique_ptr<const nm::sp::A>',
          MetaType('#u*#nm.sp.A'), 'nm.sp.A')
      Chk('const std::unique_ptr<const nm::sp::A>',
          MetaType('#u*#nm.sp.A'), 'nm.sp.A')

      Chk('nm::sp::A**', MetaType('**nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A*const*', MetaType('*#*nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A*const*const', MetaType('#*#*nm.sp.A'), 'nm.sp.A')
      Chk('const nm::sp::A*const*', MetaType('*#*#nm.sp.A'), 'nm.sp.A')

      Chk('const std::weak_ptr<const const std::shared_ptr<'
          'const const std::unique_ptr<const nm::sp::A>>>',
          MetaType('#w*#s*#u*#nm.sp.A'), 'nm.sp.A')

      Chk('std::ostream*', MetaType('ostream'), 'std::ostream')
      Chk('std::ostream&', MetaType('&ostream'), 'std::ostream')

      Chk('const std::string&', MetaType('&str'), 'const std::string')
      Chk('std::string', MetaType('@str'), 'std::string')
    end receiver OoplCpp;

  end behavior _annotateBaseType;

  behavior augmentVarset #:
    Perform baselang-specific modifications of the varset.
  params:
    var construct : *metax.oopl.Construct;
    var varset : *metax.oopl.VarSet;
    var decl : bool = false #:
      If true, augmenting for declaration (default is definition).
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      kind = construct.kind()

      if kind == 'class':
        metaclass = construct.metaclass()
        underclass = construct.underclass()
        metafile = construct.metafile()

        namespace = construct.namespace()
        fqn = namespace.id()
        lines = []
        postlines = []

        /# Define the vars related to namespace start/end.
        varset.addVar('namespace_under', fqn.replace('.', '_'))
        for part in fqn.split('.'):
          lines.append('namespace %s {' % part)
          postlines.append('}  // %s' % part)
        varset.addVar('namespace_spec', '\n'.join(lines))
        varset.addVar('end_namespace', list(reversed(postlines)))

        /# The ${header} exists in the defn (.cc) template to include the
        /# header (.h) file.
        varset.addVar('header', construct.fqn().replace('.', '/') + '.h')

        /# Define preclass (before class) and postclass (after class)
        preclass = varset.getValue('preclass')
        postclass = varset.getValue('postclass')
        preamble = varset.getValue('preamble')

        if construct.isMeta():
          if underclass:
            /# Each metaclass FooMeta associated with userclass Foo should
            /# declare a namespace variable MetaFoo to contain the singleton
            /# instance of FooMeta.
            /#
            /# TODO(wmh): Should MetaFoo be of type *FooMeta or @FooMeta?.
            /# TODO(wmh): Should MetaFoo be a method returning the singleton
            /# instance, rather than a variable? Matches better with Meta's
            /# "everything should be a function" philosophy.
            metaclass_instname = metax.oopl.ClassConstruct.MetaInstifyName(
              underclass.id())

            if decl:
              /# Declare the meta-class singleton instance.
              postclass.append('// The singleton instance of the metaclass.')
              postclass.append(
                'extern %s* %s;' % (construct.id(), metaclass_instname))
              postclass.append('')
            else:
              /# Initialize the meta-class singleton instance.
              postclass.append('')
              postclass.append(
                '// Create the singleton instance of the metaclass.')
              postclass.append(
                'static std::vector<metax::root::ObjectMetaRoot*> _bases;')
              postclass.append(
                'static std::map<%s, %s*> _symbols;' %
                (OoplCpp.CC_STR_VALUE, OoplCpp.CC_ANY))
              postclass.append(
                '%s* %s = new %s("%s", _bases, _symbols);' %
                (construct.id(), metaclass_instname, construct.id(),
                construct.fqn()))

        /# If the class has no initializer, but has a parent class, we
        /# explicitly inherit the constructors of the parent.
        if not construct.initializer():
          parentclasses = construct.parentclasses()
          if parentclasses:
            parentclass = parentclasses[0]
            preamble.append(
              'using %s::%s;' % (parentclass['fqn'], parentclass['id']))

      elif kind == 'method':
        modifiers = varset.getValue('modifiers')
        assert not modifiers
        mods = []

        /# Visibility
        visibility = construct.attrval('visibility')
        vis = visibility
        mods.append('%s:' % vis)

        /# misc.
        attrkind = construct.attrval('kind')
        if attrkind == 'static':
          mods.append('static')
        elif attrkind == 'initializer':
          /# No return type for initializers.
          varset.setValue('returns', '')
        else:
          /# Virtual or non-virtual dispatch?
          /#  - only valid if not static and not initializer!
          attrkind = construct.attrval('kind')
          if attrkind != 'initializer':
            dispatch = construct.attrval('dispatch')
            if dispatch == 'virtual':
              mods.append('virtual')

        if mods:
          mods.append('')

        modifiers.extend(mods)

        /# Handle constructor initialization list
        /#  - the initlist is part of defn not decl, so instead of adding
        /#    it to $params we define $initlist
        kind = construct.attrval('kind')
        initlist_str = ''
        super_attr = None
        if kind == 'initializer':
          /# The initialization list of C++ constructors is considered, by Meta,
          /# to be part of the params.
          super_attr, super_args = construct.attrpair('super', default=None)
          if super_args:
            init_str, _ = self.compileExpr(
              super_args, construct.metafile(), executable=construct)
            /# TODO(wmh): Fix this. Because ${initlist} appears in the cpp_defn
            /# template on the same line as ${method}, there are two different
            /# variables on the same line with differing attributes, and
            /# BaseSegment.addChunk() only handles one attribute.
            super_attr = None
            myclass = construct.myclass()
            parentclasses = myclass.parentclasses()
            pinfo = parentclasses[0]
            /# TODO(wmh): If the parent class is in the same namespace as
            /# myclass, we should use pinfo['id'] instead of pinfo['fqn']
            initlist_str = ' : %s%s' % (pinfo['fqn'], init_str)
        varset.addVar('initlist', initlist_str, attribute=super_attr)
    test:
      test.tcc(expand=True)  # expand to get metaclasses

      /# Class
      klass = test.klass
      cscope = test.cscope
      varset = metax.c.VarSet()
      varset.addVar('preclass', [])
      varset.addVar('preamble', [])
      varset.addVar('postclass', [])
      test.baselang.augmentVarset(klass, varset)
      test.iseqmap(
        {
          'end_namespace': [['}  // tmp', '}  // demo'], None, None, -1],
          'namespace_spec': [
            'namespace demo {\nnamespace tmp {', None, None, -1],
          'namespace_under': ['demo_tmp', None, None, -1],
          'header': ['demo/tmp/Person.h', None, None, -1],
          'postclass': [[], None, None, -1],
          'preclass': [[], None, None, -1],
          'preamble': [[], None, None, -1],
        },
        varset.map())

      /# Instance Method
      varset = metax.c.VarSet()
      varset.addVar('modifiers', [])
      test.baselang.augmentVarset(cscope.cons('bmi'), varset)
      test.iseq(
        {'initlist': ['', None, None, -1],
         'modifiers': [['public:', 'virtual', ''], None, None, -1]},
        varset.map())

      /# Class Method
      varset = metax.c.VarSet()
      varset.addVar('modifiers', [])
      test.baselang.augmentVarset(cscope.cons('ClassMethod'), varset)
      test.iseq(
        {'initlist': ['', None, None, -1],
         'modifiers': [['public:', 'virtual', ''], None, None, -1]},
        varset.map())

      /# Static Method
      varset = metax.c.VarSet()
      varset.addVar('modifiers', [])
      test.baselang.augmentVarset(cscope.cons('StaticMethod'), varset)
      test.iseq(
        {'initlist': ['', None, None, -1],
         'modifiers': [['public:', 'static', ''], None, None, -1]},
        varset.map())

    end receiver OoplCpp;

    receiver OoplJavascript scope:
      kind = construct.kind()
      use_es2015_classes = self.config('use_es2015')

      if kind == 'class':
        namespace = construct.namespace()
        nmsp = namespace.id()
        clsname = construct.id()
        metaname = metax.oopl.ClassConstruct.MetaifyName(clsname)

        varset.addVar('fqcn', construct.fqn())

        /# In Javascript, an initial comment block with @fileoverview allows
        /# one to specify @suppress commands.
        local_list, _ = construct.suppressInfo()
        overview_lines = [' * @fileoverview']
        if local_list:
          overview_lines.append(' * @suppress {%s}' % ','.join(local_list))
        overview = '/**\n' + '\n'.join(overview_lines) + '\n */\n'
        varset.addVar('overview', overview)

        if construct.isTest() and not use_es2015_classes:
          varset.addVar('test_method_restr', '')
          /# We currently are not producing a 'goog.provide' statement in test
          /# classes (because this disables some implicit testing we currently
          /# rely on). However, goog.provide() is what ensures that the
          /# namespace is initialized. We ensure that the namespace is defined.
          /#  - TODO(wmh): There must be a cleaner way of doing this using
          /#    something in goog/base.js (e.g. goog.constructNamespace_) that
          /#    does not disable unittesting (which goog.provide apparently
          /#    does).
          /#  - TODO(wmh): If the top-level namespace is not defined by the
          /#    time this class is imported, closure will complain. I'm not
          /#    clear how to get around that, so the code has been organized
          /#    to ensure that a goog.require() of some class that does
          /#    define the toplevel namespace is present.
          imports = varset.getValue('imports')
          imports.append('')
          nparts = nmsp.split('.')
          for i in range(0, len(nparts)):
            npref = '.'.join(nparts[:i+1])
            if i == 0:
              imports.append('%s = %s || {};' % (npref, npref))
            else:
              imports.append(
                '/** @type {?Object} */ %s;  // find cleaner way' % npref)
              imports.append('%s = %s || {};' % (npref, npref))

        if use_es2015_classes:
          assert clsname == varset.getValue('class')
          underclass = construct.underclass()
          postclass = varset.getValue('postclass')

          /# We look for the (very special) situation where we are defining
          /# a class nm.sp.Foo whose parent is Foo, for some javascript
          /# builtin class (e.g. 'Object', 'Error', etc.). In such situations
          /# the code generated is:
          /#   class Foo extends Foo {...}
          /# which is obviously problematic. We fix this by change it to
          /#   class Foo_ extends Foo {...}
          /# and updating all relevant references to Foo_ instead of Foo.
          parentspec = varset.getValue('parentspec')
          if parentspec == ' extends ' + clsname:
            clsname += '_'
            varset.setValue('class', clsname)

          /# When defining javascript classes using ES2015 syntax (and the
          /# goog.module()), we need to add postamble to the class as follows:
          /#  - all variants (user, test, meta) need to specify the value of the
          /#    special 'exports' variable to the object (or objects) we want to
          /#    make visible to callers who goog.require() the module.
          /#     - for user and test, this is simply
          /#          exports = <classname>;
          /#       but for meta classes, this is:
          /#          exports = {<metainst>, <metaclass>};
          /#  - for meta classes, before setting exports, we need to create
          /#    the singleton Meta<classname> instance of <classname>Meta.
          /#  - for test classes, after setting exports, we need to invoke
          /#    the test-harness infrastructure.
          if construct.isMeta():
            if underclass:
              metaclass_instname = metax.oopl.ClassConstruct.MetaInstifyName(
                underclass.id())
              /# Create the singleton instance of the metaclass.
              postclass.append(
                "const %s = new %s('%s', [], {});" %
                (metaclass_instname, clsname, construct.id()))

              /# Define the two-valued export.
              postclass.append(
                'exports = {%s, %s};' % (metaclass_instname, clsname))
            else:
              postclass.append('exports = %s;' % clsname)
          else:
            /# For both user and test classes we add a simple one-value
            /# 'export'. TODO(wmh): Is it necessary to make a module for the
            /# test class? Only if we want to allow other test classes to import
            /# this test class, which may indeed be useful.
            postclass.append('exports = %s;' % clsname)

            /# For test classes, we invoke the test machinery.
            if construct.isTest() and underclass:
              postclass.append('')
              postclass.append(
                /# TODO(wmh): For now, passing in the fully-qualified name of
                /# the test class, as opposed to the underlying user class,
                /# but if we can figure out how to change class names in
                /# all baselangs, it might be better to use the userlevel fqn.
                "var tc = new %s('%s');" % (clsname, construct.fqn()))
              postclass.append('tc.runSelfTests();')

      elif kind == 'method':
        dot = metax.c.Context.Tokens()['scope_sep']
        myclass = construct.myclass()
        method_prefix = myclass.fqn()
        kind = construct.attrval('kind')
        modifiers = varset.getValue('modifiers')

        if kind == 'instance':
          method_prefix += dot + 'prototype'

        elif kind == 'static':
          modifiers.append('static')

        elif kind == 'cls':
          raise metax.c.Error("Fix this ... these should be in the metaclass, yes?'")

        elif kind == 'initializer':
          /# Javascript is a snowflake. In most languages, class nm.sp.Class has
          /# initializer nm.sp.Class.Class, but in javascript it is nm.sp.Class
          /# And while instance methods in Javascript are defined as
          /#   nm.sp.Class.prototype.methname = function ...
          /# the initializer is
          /#   nm.sp.Class = function ...
          method_prefix = dot.join(myclass.fqn().split(dot)[:-1])

          /# postmethod stores the invocation of the goog.inherits()
          if not use_es2015_classes:
            parentinfo = myclass.parentclasses()[0]
            varset.getValue('postmethod').append(
              'goog.inherits(%s, %s);' % (myclass.fqn(), parentinfo['fqn']))

          /# TODO(wmh): Use @name <class>#<method> per
          /#   https://stackoverflow.com/questions/10490713/\
          /#     how-to-document-the-properties-of-the-object-in-the-jsdoc-3-\
          /#       tag-this
          preamble = varset.getValue('preamble')
          baselang = construct.baselang()
          for field in myclass.fields():
            ftype = field.attrval('type', default=metax.c.LOOKUP)
            /# TODO(wmh): See the comment within the scope of
            /# OoplJavascript.formatMethodComment() discussing defqn. We need
            /# to do the same thing here.
            preamble.append(
              '/** @type {%s} */ this.%s;' %
              (baselang.typeToBase(ftype, class_construct=myclass, defqn=True),
              field.rawfield()))

        /# TODO(wmh): This is obviously not being used, as it is totally
        /# broken.  Look above in "kind == 'instance'", where dot is added
        /# to method_prefix, and again below. What is this for? method_prefix
        /# does not appear in the javascript varset for construct method.
        method_prefix += dot
        varset.addVar('method_prefix', method_prefix)
    test:
      test.tjs(expand=True)  # expand to get metaclasses

      /# Class
      klass = test.klass
      cscope = test.cscope
      varset = metax.c.VarSet()
      varset.addVar('class', klass.id(), attribute=klass.primary())
      varset.addVar('postclass', [])
      varset.addVar('parentspec', test.baselang.formatParentSpec(klass))
      test.baselang.augmentVarset(klass, varset)
      test.iseq(
        {'overview': ['/**\n * @fileoverview\n */\n', None, None, -1],
         'parentspec': [' extends Object', None, None, -1],
         'fqcn': ['demo.tmp.Person', None, None, -1],
         'class': ['Person', klass.primary(), None, -1],
         'postclass': [['exports = Person;'], None, None, -1]},
        varset.map())

      /# Instance Method
      varset = metax.c.VarSet()
      varset.addVar('modifiers', [])
      test.baselang.augmentVarset(cscope.cons('bmi'), varset)
      test.iseq(
        {'modifiers': [[], None, None, -1],
         'method_prefix': ['demo.tmp.Person.prototype.', None, None, -1]},
        varset.map())

      /# Class Method
      varset = metax.c.VarSet()
      varset.addVar('modifiers', [])
      test.baselang.augmentVarset(cscope.cons('ClassMethod'), varset)
      test.iseq(
        {'modifiers': [[], None, None, -1],
         'method_prefix': ['demo.tmp.Person.', None, None, -1]},
        varset.map())

      /# Static Method
      varset = metax.c.VarSet()
      varset.addVar('modifiers', [])
      test.baselang.augmentVarset(cscope.cons('StaticMethod'), varset)
      test.iseq(
        {'modifiers': [[], None, None, -1],
         'method_prefix': ['demo.tmp.Person.', None, None, -1]},
        varset.map())
    end receiver OoplJavascript;

    receiver OoplPython scope:
      kind = construct.kind()

      if kind == 'class':
        /# The __metaclass__ attribute of a class specifies the metaclass.
        metaclass = construct.metaclass()
        if metaclass:
          /# Remember that a class may not have a metaclass even if it is
          /# a user class (if autogen=nometa).
          variant = construct.variant()
          if variant in ('user', 'test'):
            /# Meta guarantees that for every user-level class nm.sp.Foo, there
            /# is a metaclass nm.sp.FooMeta and a singleton instance of that
            /# metaclass named nm.sp.MetaFoo. In python, since we've defined
            /# Foo.__metaclass__ to be FooMeta, MetaFoo is just Foo.
            postclass = varset.getValue('postclass')
            name = construct.id()
            postclass.append('')

            /# TODO(wmh): Look into the best way to handle this issue.
            /#  - When creating test classes, if we define:
            /#      MetaFooTest = FooTest
            /#    then the testcase infrastructure will invoke the tests on
            /#    the class twice (once via FooTest, once via MetaFootTest).
            /#  - For now, we do not define this variable for test classes,
            /#    and require users to use self.meta() to gain access to
            /#    the metaclass of a testclass.
            /#  - We should consider not defining the MetaFoo variable for
            /#    class Foo in any situation (require use of self.meta()).
            /#  - If Meta implemented its own xUnit infrastructure from
            /#    scratch (so baselangs do not use baselang-specific
            /#    implementations) we would have easy control over this kind
            /#    of issue.
            if variant == 'user':
              /# CODETANGLE(metainst_for_testclass)
              postclass.append(
                '%s = %s' %
                (metax.oopl.ClassConstruct.MetaInstifyName(name), name))

        /# If this class has a clinit method, invoke it after the class
        /# definition (note that this invocation is actually moved to the
        /# bottom of the namespace within namespace compilation code).
        clinit = construct.clinit()
        if clinit is not None:
          postclass = varset.getValue('postclass')
          postclass.append('%s.%s()' % (construct.id(), clinit.id()))

      elif kind == 'method':
        attrkind = construct.attrval('kind')
        modifiers = varset.getValue('modifiers')
        if attrkind == 'cls':
          modifiers.append('@classmethod')
        elif attrkind == 'static':
          modifiers.append('@staticmethod')
    test:
      test.tpy(expand=True)  # expand to get metaclasses

      /# Class
      klass = test.klass
      cscope = test.cscope
      varset = metax.c.VarSet()
      varset.addVar('postclass', [])
      test.baselang.augmentVarset(klass, varset)
      test.iseq(
        {'postclass': [['', 'MetaPerson = Person'], None, None, -1]},
        varset.map())

      /# Instance Method
      varset = metax.c.VarSet()
      varset.addVar('modifiers', [])
      test.baselang.augmentVarset(cscope.cons('bmi'), varset)
      test.iseq(
        {'modifiers': [[], None, None, -1]},
        varset.map())

      /# Class Method
      varset = metax.c.VarSet()
      varset.addVar('modifiers', [])
      test.baselang.augmentVarset(cscope.cons('ClassMethod'), varset)
      test.iseq(
        {'modifiers': [['@classmethod'], None, None, -1]},
        varset.map())

      /# Static Method
      varset = metax.c.VarSet()
      varset.addVar('modifiers', [])
      test.baselang.augmentVarset(cscope.cons('StaticMethod'), varset)
      test.iseq(
        {'modifiers': [['@staticmethod'], None, None, -1]},
        varset.map())
    end receiver OoplPython;

  end behavior augmentVarset;

  behavior autogenStr : MethodConstruct #:
    Auto-generate the human-readable printMeta() method.
      method metaxStr : str;
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:

    receiver BaseLanguageOopl scope:
      context = klass.context()
      scope = klass.attr('scope:', default=metax.c.REQUIRED)

      body = []

      method = metax.oopl.MethodConstruct.NewFromData(
        'strMeta',
        context,
        parent=scope,
        features=[('autogen', 'notest')],
        secondaries=[
          (':', metax.c.Type.Instance('str')),
          ('#:',['Auto-generated string representation of this object.']),
          ('scope:', body),
        ],
        precount=1,
      )
      assert method.myclass() is klass
      method.expandMeta()
      method.namespaceIs(klass.namespace())

      return method
    test:
      /# Tested in subclasses, which extend this method.
      pass
    end;

    receiver OoplCpp scope:
      method = super(OoplCpp, self).autogenStr(klass)
      body = method.attrval('scope:')
      /# TODO(wmh): Add body!
      return method
    test:
      test.tcc()
      method = test.baselang.autogenStr(self.klass)
      method.write(fp=test.fp())
      test.iseqtext("""
        >|notest method strMeta : str #:
        >|  Auto-generated string representation of this object.
        >|scope:
        >|end method strMeta;
        >|""",
        test.out())
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      method = super(OoplJavascript, self).autogenStr(klass)
      body = method.attrval('scope:')
      /# TODO(wmh): Add body!
      return method
    test:
      test.tcc()
      method = test.baselang.autogenStr(self.klass)
      method.write(fp=test.fp())
      test.iseqtext("""
        >|notest method strMeta : str #:
        >|  Auto-generated string representation of this object.
        >|scope:
        >|end method strMeta;
        >|""",
        test.out())
    end receiver OoplJavascript;

    receiver OoplPython scope:
      method = super(OoplPython, self).autogenStr(klass)
      body = method.attrval('scope:')
      /# TODO(wmh): Add body!
      return method
    test:
      test.tcc()
      method = test.baselang.autogenStr(self.klass)
      method.write(fp=test.fp())
      test.iseqtext("""
        >|notest method strMeta : str #:
        >|  Auto-generated string representation of this object.
        >|scope:
        >|end method strMeta;
        >|""",
        test.out())
    end receiver OoplPython;

  end behavior autogenStr;

  behavior autogenPrint : MethodConstruct #:
    Auto-generate the human-readable printMeta() method.

      method printMeta : void params:
        var fp : &ostream = out;
        var indent : str = '';
      end;
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:

    receiver BaseLanguageOopl scope:
      context = klass.context()
      scope = klass.attr('scope:', default=metax.c.REQUIRED)

      body = []

      method = metax.oopl.MethodConstruct.NewFromData(
        'printMeta',
        context,
        parent=scope,
        features=[('autogen', 'notest')],
        secondaries=[
          (':', metax.c.Type.Instance('void')),
          ('#:',['Auto-generated human-readable summary of this object.']),
          ('params:', [
            {'var': 'fp', 'secondaries': [
              (':', metax.c.Type.Instance('&ostream')),
              ('=', metax.c.Expr('var', 'out', 'out')),
            ]},
            {'var': 'indent', 'secondaries': [
              (':', metax.c.Type.Instance('str')),
              ('=', metax.c.Expr('str', "''", "''")),
            ]},
          ]),
          ('scope:', body),
        ],
        precount=1,
      )
      assert method.myclass() is klass
      method.expandMeta()
      method.namespaceIs(klass.namespace())

      return method
    test:
      pass
    end;

    receiver OoplCpp scope:
      method = super(OoplCpp, self).autogenPrint(klass)
      body = method.attrval('scope:')

      /# TODO(wmh): Since every class defines these methods, should we just
      /# include <iostream> in __Meta__.h?
      /# The params require module 'iostream'.
      klass.addDependency('iostream', 'std', 'needed by autogened printMeta')

      /# TODO(wmh): Add body!
      return method
    test:
      test.tcc()
      method = test.baselang.autogenPrint(self.klass)
      method.write(fp=test.fp())
      test.iseqtext("""
        >|notest method printMeta : void #:
        >|  Auto-generated human-readable summary of this object.
        >|params:
        >|  var fp : &ostream = out;
        >|  var indent : str = '';
        >|scope:
        >|end method printMeta;
        >|""",
        test.out())
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      method = super(OoplJavascript, self).autogenPrint(klass)
      body = method.attrval('scope:')
      /# TODO(wmh): Add body!
      return method
    test:
      test.tjs()
      method = test.baselang.autogenPrint(self.klass)
      method.write(fp=test.fp())
      test.iseqtext("""
        >|notest method printMeta : void #:
        >|  Auto-generated human-readable summary of this object.
        >|params:
        >|  var fp : &ostream = out;
        >|  var indent : str = '';
        >|scope:
        >|end method printMeta;
        >|""",
        test.out())
    end receiver OoplJavascript;

    receiver OoplPython scope:
      method = super(OoplPython, self).autogenPrint(klass)
      metatypes = self.metatypes()

      /# The params require module 'sys'.
      klass.addDependency('sys', 'std', 'needed by autogened printMeta')

      body = method.attrval('scope:')

      body.append('subindent = indent + "  "')
      body.extend([
        /# IMPORTANT: We do NOT add 'indent' to the beginning of the line
        /# describing the class type, because this code is invoked after a
        /# a field name has already been printed (this only prints the value,
        /# not the entire field).
        "fp.write('%s %%x:\\n' %% id(self))" % klass.id()
      ])

      fields = klass.fields()
      if fields:
        maxlen = max([len(field.id()) for field in fields])
        /# TODO(wmh): We need the complete set of fields as inherited from the
        /# ancestor chain!
        for field in klass.fields():
          mtype = field.attrval('type')
          accs = field.accessors()
          formatter = accs.get('format', None) if accs else None
          minfo = metatypes.get(mtype.raw(), None)
          fstr = field.id().ljust(maxlen)
          format_code = None
          more_code = None
          if formatter:
            /# The user has provided explicit code to use for formatting the
            /# field, so we invoke the format accessor
            format_code = 'fix me'  # invoke receiver.<field>Format()
          elif minfo and 'format' in minfo:
            /# There is an explicit format specified in the base language for
            /# this type.
            format_code = minfo.get('format', None)(field.id())
            body.append(
              "fp.write('%%s  %s = %%s\\n' %% (indent, %s))" %
              (fstr, format_code))
          else:
            /# The field is assumed to be of a class type, so it defines the
            /# printMeta() method. We invoke it.
            body.append("fp.write('%%s  %s = ' %% indent)" % fstr)
            body.append(
              "self.%s().printMeta(fp=fp, indent=subindent)\n" % field.id())

      return method
    test:
      test.tpy()
      method = test.baselang.autogenPrint(self.klass)
      method.write(fp=test.fp())
      test.iseqtext("""
        >|notest method printMeta : void #:
        >|  Auto-generated human-readable summary of this object.
        >|params:
        >|  var fp : &ostream = out;
        >|  var indent : str = '';
        >|scope:
        >|  subindent = indent + "  "
        >|  fp.write('Person %x:\\n' % id(self))
        >|end method printMeta;
        >|""",
        test.out())
    end receiver OoplPython;

  end behavior autogenPrint;

  behavior autogenWrite : MethodConstruct #:
      Auto-generate the machine-readable writeMeta() method.
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:

    receiver BaseLanguageOopl scope:
      context = klass.context()
      scope = klass.attr('scope:', default=metax.c.REQUIRED)
      metatypes = self.metatypes()

      /# TODO(wmh): subclasses should invoke this parent method, then
      /# populate the body.
      body = []

      fields = klass.fields()
      if fields:
        for field in klass.fields():
          mtype = field.attrval('type')
          accs = field.accessors()
          /# TODO(wmh): Serialize to protobuf!

      method = metax.oopl.MethodConstruct.NewFromData(
        'writeMeta',
        context,
        parent=scope,
        features=[('autogen', 'notest')],
        secondaries=[
          (':', metax.c.Type.Instance('void')),
          ('#:',['Auto-generated protobuf serializer of this object.']),
          ('params:', [
            {'var': 'fp', 'secondaries': [
              (':', metax.c.Type.Instance('&ostream')),
              ('=', metax.c.Expr('var', 'out', 'out')),
            ]},
          ]),
          ('scope:', body),
        ],
        precount=1,
      )
      assert method.myclass() is klass
      method.expandMeta()
      method.namespaceIs(klass.namespace())

      return method
    test:
      pass
    end receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      method = super(OoplCpp, self).autogenWrite(klass)
      /# TODO(wmh): Add body lines
      return method
    test:
      test.tcc()
      method = test.baselang.autogenWrite(test.klass)
      test.iseq([], method.attrval('scope:'))
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      method = super(OoplJavascript, self).autogenWrite(klass)
      /# TODO(wmh): Add body lines
      return method
    test:
      test.tjs()
      method = test.baselang.autogenWrite(test.klass)
      test.iseq([], method.attrval('scope:'))
    end receiver OoplJavascript;

    receiver OoplPython scope:
      method = super(OoplPython, self).autogenWrite(klass)

      /# The code above requires standard module 'sys'.
      klass.addDependency('sys', 'std', 'needed by autogened writeMeta')

      return method
    test:
      test.tpy()
      method = test.baselang.autogenWrite(test.klass)
      test.iseq([], method.attrval('scope:'))
    end receiver OoplPython;

  end behavior autogenWrite;

  behavior autogenSize : MethodConstruct #:
      Auto-generate the byte-size calculator.
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:

    receiver BaseLanguageOopl scope:
      context = klass.context()
      scope = klass.attr('scope:', default=metax.c.REQUIRED)
      metatypes = self.metatypes()

      body = []

      fields = klass.fields()
      if fields:
        for field in klass.fields():
          mtype = field.attrval('type')
          accs = field.accessors()
          /# TODO(wmh): Generate code to sum up the field sizes. This may need
          /# to happen in the subclass overrides.

      method = metax.oopl.MethodConstruct.NewFromData(
        'sizeMeta',
        context,
        parent=scope,
        features=[('autogen', 'notest')],
        secondaries=[
          (':', metax.c.Type.Instance('int')),
          ('#:',['Auto-generated sizeof method for this object.']),
          ('scope:', body),
        ],
        precount=1,
      )
      assert method.myclass() is klass
      method.expandMeta()
      method.namespaceIs(klass.namespace())

      return method
    test:
      pass
    end receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      method = super(OoplCpp, self).autogenSize(klass)
      method.attrval('scope:').extend(['int result = 0;', 'return result;'])
      return method
    test:
      test.tcc()
      method = test.baselang.autogenSize(self.klass)
      method.write(fp=test.fp())
      test.iseqtext("""
        >|notest method sizeMeta : int #:
        >|  Auto-generated sizeof method for this object.
        >|scope:
        >|  int result = 0;
        >|  return result;
        >|end method sizeMeta;
        >|""",
        test.out())
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      method = super(OoplJavascript, self).autogenSize(klass)
      method.attrval('scope:').extend(['let result = 0;', 'return result;'])
      return method
    test:
      test.tjs()
      method = test.baselang.autogenSize(self.klass)
      method.write(fp=test.fp())
      test.iseqtext("""
        >|notest method sizeMeta : int #:
        >|  Auto-generated sizeof method for this object.
        >|scope:
        >|  let result = 0;
        >|  return result;
        >|end method sizeMeta;
        >|""",
        test.out())
    end receiver OoplJavascript;

    receiver OoplPython scope:
      method = super(OoplPython, self).autogenSize(klass)
      method.attrval('scope:').extend(['result = 0', 'return result'])
      return method
    test:
      test.tpy()
      method = test.baselang.autogenSize(self.klass)
      method.write(fp=test.fp())
      test.iseqtext("""
        >|notest method sizeMeta : int #:
        >|  Auto-generated sizeof method for this object.
        >|scope:
        >|  result = 0
        >|  return result
        >|end method sizeMeta;
        >|""",
        test.out())
    end receiver OoplPython;

  end behavior autogenSize;

  behavior buildPreambleText : str #:
    The baselang-specific preamble at the top of a BUILD file.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      return ''
    test:
      test.iseq('', test.baselang.buildPreambleText())
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      return (
        >|"""load("@io_bazel_rules_closure//closure:defs.bzl", "closure_js_library")
        >|load("@io_bazel_rules_closure//closure:defs.bzl", "closure_js_binary")
        >|load("@io_bazel_rules_closure//closure:defs.bzl", "closure_js_test")
        >|""")
    test:
      test.contains('io_bazel_rules_closure', test.baselang.buildPreambleText())
    end receiver OoplJavascript;

    receiver OoplPython scope:
      return ''
    test:
      test.iseq('', test.baselang.buildPreambleText())
    end receiver OoplPython;

  end behavior buildPreambleText;

  behavior testLogDir : str #:
    Obtain the baselang specific directory into which tests are written. Unlike
    other methods, this returns an absolute path, not one relative to
    repositoryPath(). The directory is created if not present.
  params:
    var fqn : str #:
      A method fqn to convert to a test directory.
    var create : bool = false #:
      If true, create the directory if not present.
  scope:

    receiver BaseLanguageOopl scope:
      metac = self.context().compiler()
      fs = metac.fs()
      basepath = metac.basePath()
      parts = fqn.split('.')
      methname = parts.pop()
      clsname = parts.pop()
      result = fs.join(
        metac.repositoryPath(), basepath, *parts, '.' + clsname, methname)
      if create and not fs.isdir(result):
        fs.makedirs(result, mode=0o700)
      return result
    test:
      test.tpy()
      test.endswith(
        '/oopl/python/demo/tmp/.Person/bmi',
        test.baselang.testLogDir(test.method.fqn()))
    end receiver BaseLanguageOopl;

  end behavior testLogDir;

  behavior classPath : str #:
    Obtain the baselang specific path in which a class is stored.
  params:
    var fqn : str #:
      An fqn to convert to a subpath.
    var suffix : str = null #:
      Usually null, in which case the primary suffix for the baselang is used,
      but may be an alternative suffix.
  scope:

    receiver BaseLanguageOopl scope:
      if suffix is None:
        suffix = self.suffix()
      return self.context().compiler().basePath(fqn, prefix='', suffix=suffix)
    test:
      test.tcc()
      test.iseq(
        'oopl/cpp/demo/tmp/Person.cc',
        test.baselang.classPath(test.klass.fqn()))

      /# TODO(wmh): Make this a separate test!
      test.tjs()
      test.iseq(
        'oopl/javascript/demo/tmp/Person.js',
        test.baselang.classPath(test.klass.fqn()))
    end receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if suffix is None:
        suffix = self.suffix()
      return self.context().compiler().basePath(fqn, prefix='.', suffix=suffix)
    test:
      test.tpy()
      test.iseq(
        'oopl/python/demo/tmp/.Person.py',
        test.baselang.classPath(test.klass.fqn()))
    end receiver OoplPython;

  end behavior classPath;

  behavior classSubPath : str #:
    The path (relative to WORKSPACE dir) of the file that contains the
    definition of a given class.
  params:
    var klass : metax.oopl.ClassConstruct;
    var location : str = 'defn' #:
      One of 'defn' or 'decl'. Only meaningful for baselangs that
      distinguish between declaration and definition.
  scope:

    abstract
    receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      /# In C++, each class contains two files, a .h and a .cc file.
      /# We consider the .h file to be primary, and the .cc file is handled
      /# specially.
      metac = klass.compiler()
      suffix = self.suffix(location=location)
      return metac.basePath(klass.fqn(), suffix=suffix)
    test:
      test.tcc()
      test.iseq(
        'oopl/cpp/demo/tmp/Person.cc',
        test.baselang.classSubPath(test.klass))
    end receiver OoplCpp;

    receiver OoplPython scope:
      /# For class 'nm.sp.Class', the class-specific file is usually written to
      /# nm/sp/Class.<suff>, but for python we hide these files in
      /# nm/sp/.Class.py (i.e. initial '.' before class name).
      /#
      /# TODO(wmh): If we find a way to support per-class files publicly in
      /# python, we can make each class visible by removing this method
      /# and inheriting the parent definition of this method.
      metac = klass.compiler()
      return metac.basePath(klass.fqn(), prefix='.', suffix=self.suffix())
    test:
      test.tpy()
      test.iseq(
        'oopl/python/demo/tmp/.Person.py',
        test.baselang.classSubPath(test.klass))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# In Javascript, when using Google closure, test classes must end in
      /# '_test.js'.
      /#   - TODO(wmh): Test classes are named ClassTest. Do we want to have
      /#     the files be ClassTest_test.js or Class_test.js? For now, we are
      /#     going with the latter (Class_test.js). A better solution would be
      /#     to implement the javascript Unit infrastructure totally in
      /#     Meta without reliance on goog.testing, and remove the requirement
      /#     that test files end in _test.js (unless that is a Bazel requirement
      /#     rather than a goog.testing requirement?)
      metac = klass.compiler()
      if klass.isTest():
        fqn = klass.fqn()
        if fqn.endswith('Test'):
          /# TODO(wmh): By allowing classes with a 'Test' suffix and without
          /# a test suffix, we open ourselves up to a potential file conflict
          /# Suppose we have a user-provided test class 'Blah' and 'BlahTest'
          /# ... they would both write to 'Blah_test.js'. Solutions:
          /#  - do not remove the 'Test' suffix and use BlahTest_test.js
          /#  - do not allow users to define user-provided test classes that
          /#    end with 'Test'.
          fqn = fqn[:-4]
        return metac.basePath(fqn, suffix='_test' + self.suffix())
      else:
        metac = klass.compiler()
        suffix = self.suffix(location=location)
        result = metac.basePath(klass.fqn(), suffix=suffix)
      return result
    test:
      test.tjs()
      test.iseq(
        'oopl/javascript/demo/tmp/Person.js',
        test.baselang.classSubPath(test.klass))
    end receiver OoplJavascript;

  end behavior classSubPath;

  behavior createBuildFragment : tuple<str,map> #:
    Create a BUILD fragment for this construct.

    Returns:
     0) str (build rule)
     1) map (key/values in target)
  params:
    var construct : *metax.oopl.Construct #:
      A class construct.
    var targets : vec<str> #:
      The targets that this construct depends on.
    var test : bool = false #:
      If true, the targets are for the test class associated with the
      construct.
    var name : str = null #:
      The name of the target.  Usually null, in which case the name of
      the construct is used.
    var src : str = null #:
      The src file.  Usually null, in which case it is computed based on
      the construct name.
  scope:

    abstract
    receiver BaseLanguageOopl;

    receiver OoplPython scope:
      kind = construct.kind()

      if kind == 'namespace':
        if name is None:
          name = construct.id().split('.')[-1]
        if src is None:
          src = name + '.py'
        rule = 'py_test' if test else 'py_library'
        build = {
          'name': name,
          'srcs': [src],
          'deps': targets,
          'visibility': ['//visibility:public'],
        }

        /# NOTE: Although ClassConstruct.registerResource() does register
        /# a mapping from resource name to target, in Python we cannot rely
        /# on that mapping containing all per-class resources (if two
        /# different metafiles define different classes in the same namespace,
        /# something we almost certainly need to support, then if we only
        /# parse one of the .meta files, the class resources in the other
        /# .meta file will be missing).  The easy solution is to simply
        /# scan the namespace directory for any files looking like resource
        /# links.
        metac = construct.compiler()
        fs = metac.fs()
        resource_dir = fs.join(
          /# CODETANGLE(resource_dir)
          /# TODO(wmh): Rename to something else that won't conflict
          /# with a sub-namespace named 'resources'.
          metac.repositoryPath(),
          metac.basePath(construct.fqn()), metax.c.RESOURCES_SUBDIR)
        if fs.exists(resource_dir):
          build['data'] = [
            metax.c.RESOURCES_SUBDIR + '/' + f
            for f in fs.listdir(resource_dir)
          ]

        if kind == 'class':
          /# TODO(wmh): In Python, since we do not have per-class targets,
          /# we need to instead collect all class resources into the
          /# namespace build fragment.  This is problematic if we allow
          /# two different metafiles to define classes in the same namespace
          /# (something we almost certainly need to support) because we would
          /# need to parse all meta files defining a namespace whenever any
          /# .metafile for the namespace is referenced ... or, alternatively,
          /# record per-class resource data on disk so it can be aggregated.
          /#   - we could just scan for symlinks that look like resource links!
          resources = construct.resources()
          data = []
          for resname, respath in resources.items():
            data.append(respath)
          build['data'] = sorted(data)
        if test:
          build['size'] = 'small'

      elif kind == 'class':
        raise metax.c.InternalError(
          'Python should not be creating per-class build fragments (yet)')
      else:
        rule = None
        build = None

      return rule, build
    test:
      test.tpy(expand=True)  # must expand to obtain dependencies.

      /# Test namespace build fragment
      test.iseq(
        ('py_library',
         {'srcs': ['tmp.py'],
          'visibility': ['//visibility:public'],
          'name': 'tmp',
          'deps': ['//metax/root:root']}),
        test.baselang.createBuildFragment(
          test.namespace, ['//metax/root:root']))

      /# Test class build fragment (disabled in python).
      _, targets = test.baselang.formatDependencies(test.klass)
      test.iseq(
        set(['//demo/tmp:tmp', '//metax/root:root']),
        targets)
      test.raises(
        metax.c.InternalError,
        test.baselang.createBuildFragment, test.klass, targets)
    end receiver OoplPython;

    receiver OoplJavascript scope:
      kind = construct.kind()

      if kind == 'class':
        /# TODO(wmh): Need to add this to the BUILD file:
        /#   load("//closure:defs.bzl", "closure_js_library")
        metac = construct.compiler()
        cli = metac.cli()
        fs = metac.fs()
        baselang = construct.baselang()
        variant = construct.variant()

        _, suppress_list = construct.suppressInfo()
        suppress_set = set(suppress_list)

        if name is None:
          name = construct.id()
        if src is None:
          class_subpath = baselang.classSubPath(construct)
          src = fs.basename(class_subpath)
        if test:
          /# assert ClassConstruct.IsTestName(name)
          rule = 'closure_js_test'
          test_dep = '@io_bazel_rules_closure//closure/library:testing'
          if test_dep not in targets:
            targets.append(test_dep)
        else:
          rule = 'closure_js_library'
        build = {
          'name': name,
          'srcs': [src],
          'deps': targets,
          'visibility': ['//visibility:public'],
        }

        /# We always disable extra requires because ...
        suppress_set.add('JSC_EXTRA_REQUIRE_WARNING')
        /# We always disable nuulable returns ... just because the current
        /# program always uses a non-null value doesn't mean it won't change
        /# in the future.
        suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')

        if test:
          build['size'] = 'small'
          build['testonly'] = 1
          /# For user-provided class C, the auto-generated test class CTest
          /# implicitly includes class C (because tests for C must rely on C,
          /# and it is cumbersome for the user to specify something that is
          /# almost always the case). HOWEVER, if the initialization of
          /# instances of C occurs within a namespace-specific TestCase class
          /# that CTest inherits from, there is actually no need to include C in
          /# CTest. Closure produces the following error when a goog.require()
          /# is specified that is not actually used:
          /#    ERROR - extra require: 'wmh.games.catan.Hex'
          /#      goog.require('wmh.games.catan.Hex');
          /#      ^
          /#        ProTip: "JSC_EXTRA_REQUIRE_WARNING" or "extraRequire" or
          /#        "legacyGoogScopeRequire" can be added to the `suppress`
          /#        attribute of: //wmh/games/catan_test:HexTest_lib
          /#        Alternatively /** @suppress {legacyGoogScopeRequire} */
          /#        can be added to the source file.
          /#
          /# For now, we suppress JSC_EXTRA_REQUIRE_WARNING within test classes.
          /# TODO(wmh): Verify these are still needed
          /# suppress_set.add('JSC_EXTRA_REQUIRE_WARNING')
          /# suppress_set.add('JSC_MISSING_PROVIDE')

          optmap = {
            'off': 'WHITESPACE_ONLY',
            'low': 'SIMPLE,',
            'avg': 'SIMPLE',
            /# Tests actually run faster with less optimization. In fact, it
            /# might be best to use 'WHITESPACE_ONLY', but that is currently
            /# producing errors.
            'high': 'SIMPLE',
            'max': 'ADVANCED'}
          build['compilation_level'] = optmap[cli.optimize_level]
          build['entry_points'] = [construct.fqn()]

        elif name == 'TestCase':
          /# Special case ... we assume the TestCase class inherits from
          /# metax.test.TestCase, which is marked as testonly because it
          /# relies on
          /#   @io_bazel_rules_closure//closure/library:testing
          /# Any class that relies on a testonly target must also be testonly.
          build['testonly'] = 1
          suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')

        elif variant == 'meta':
          /# A auto-generated meta class.
          /#  - preferably, the definition of the class itself should appear
          /#    first in the goog.provide() list, but this is always
          /#    alphabetically after the instance-of-metaclass variable also
          /#    provided by this file, so we disable JSC_PROVIDES_NOT_SORTED.

          /# TODO(wmh): Verify these are still needed.
          /# suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')
          /# suppress_set.add('JSC_PROVIDES_NOT_SORTED')
          pass

        else:
          /# The code prefers to reference classes by long name (since some
          /# baselangs require it, and shortnames can be ambiguous if two
          /# different classes with the same name in different namespaces are
          /# required within the same class), so although closure would prefer
          /# we define
          /#    const Bar = goog.require('nm.sp2.Bar');
          /#    class Foo extends Bar { ... }
          /#                      ^^^
          /# we will often instead use:
          /#    const Bar = goog.require('nm.sp2.Bar');
          /#    class Foo extends nm.sp2.Bar { ... }
          /#                      ^^^^^^^^^^
          /# which generates the following error. Disabling this should never
          /# introduce any errors.
          if False:
            /# Disabled because it causes 'CR_SUPERFLUOUS_SUPPRESS' which
            /# cannot be disabled (see below).
            suppress_set.add(
              'JSC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME')

          /# The previous suppress, when inserted unilaterally, is sometimes
          /# superfluous if the class does not use the long form of a class
          /# name when specifying a parent (for example when the parent is
          /# javascript Object, etc.).
          if False:
            /# This does not work as advertised ... adding it to the target does
            /# not stop the error from occurring.
            suppress_set.add('CR_SUPERFLUOUS_SUPPRESS')
          /#suppress_set.add('superfluousSuppress')

          /# Normal user-provided class.
          /#  - Suppose a method has a meta return type of 'str' (aka interned
          /#    string). In Meta, there is a "null" interned string instance
          /#    (although exactly what this means differs from baselang to
          /#    baseland ... in C++ it is a special instance of IStr, in Python
          /#    it is None, etc.).
          /#  - For now, we are using javascript 'null' to represent the null
          /#    interned string. This means that the javascript return type of a
          /#    method returning a meta 'str' should be '?string' (string or
          /#    null). However, if a particular method returns a literal string,
          /#    the compiler can tell that it is never null, and by default
          /#    produces an error of the form:
          /#      ERROR - The return type of the function "<somefunc>" is
          /#      nullable, but it always returns a non-null value. Consider
          /#      making the return type non-nullable.
          /#  - We cannot, in general, make the return type '!string' because
          /#    some other method that returns a meta 'str' might return null.
          /#    For the time being, we suppress this error within all
          /#    closure_js_library class build targets.
          /#### suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')
          pass

          /# The following is required because in Javascript the <C>Class
          /# singleton instance of <C>MetaClass is defined in <C>MetaClass.js
          /# rather than <C>.js, and <C>.js has to goog.require <C>MetaClass.js
          /# to ensure that <C>Class is available, with no guarantees that the
          /# user will actually use it (and by default closure complains about
          /# extraneous requires).  It would be useful to NOT disable this
          /# warning, but this would require us to move the definition of
          /# <C>Class from <C>MetaClass.js to <C>Class.js (which would result
          /# in there always being a referecnce to <C>MetaClass within <C> to
          /# justify the goog.require.  The downside of this is if we want to
          /# at some point provide some optimizations whereby metaclass are
          /# not included in source code (if noop, not used, etc.), the current
          /# implementation is easy because all metaclass code is in a separate
          /# file, whereas the proposed implementation would scatter it across
          /# <C>.js and <C>MetaClass.js.
          /#### suppress_set.add('JSC_EXTRA_REQUIRE_WARNING')

          /# The following is needed for situations where a circularity exists
          /# between two classes where A needs B and B needs A.  This happens
          /# if in A there is a 'cls assoc B' and in B there is a 'cls assoc A'.
          /# To break this circularity, one must specify a target of "" in one
          /# of the assocs (e.g. 'cls assoc A target ""' in class B), but if
          /# this is done, bazel will complain with:
          /#   file.meta:1 (B.js:10) ERROR - Namespace not provided by any
          /#      srcs or direct deps of //nm/sp:B.
          /# This error is disabled by CR_NOT_PROVIDED.
          /#
          /# IMPORTANT: We should NOT be inserting this always ... we should
          /# insert only in the special case of a circularity between classes.
          /# TODO(wmh): Figure out how to pass circularity info into this method
          /# so we can conditionally add CR_NOT_PROVIDED.

          /# 20170802: Disabled all of these (for now)
          /# 'CR_NOT_PROVIDED',
          /# Needed because CR_NOT_PROVIDED (above) generates this error.
          /#'CR_SUPERFLUOUS_SUPPRESS',
          /#'superfluousSuppress',

        if suppress_set:
          build['suppress'] = sorted(suppress_set)

      else:
        rule = None
        build = None

      /# print('%s: %s' % (rule, build))
      return rule, build
    test:
      test.tjs(expand=True)  # must expand to obtain dependencies.

      /# Test class build fragment (disabled in python).
      _, targets = test.baselang.formatDependencies(test.klass)
      test.iseq(
        set([
            /# TODO(wmh): Fix MetaPerson (should be PersonMeta).
            '//demo/tmp:MetaPerson',
            '//metax/root:Object',
            '//metax/root:ObjectMeta',
            ]),
        targets)
      test.iseq(
        ('closure_js_library',
         {
           'srcs': ['Person.js'],
           'visibility': ['//visibility:public'],
           'name': 'Person',
           'deps': set(['//demo/tmp:MetaPerson', '//metax/root:Object',
                        '//metax/root:ObjectMeta']),
           'suppress': ['JSC_EXTRA_REQUIRE_WARNING',
                        'JSC_NULLABLE_RETURN_WITH_NAME'],
         }
       ),
       test.baselang.createBuildFragment(test.klass, targets))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if construct.kind() == 'class':
        /# TODO(wmh): Find a better way to handle header files external to Meta.
        /# For now, hacking Any to allow progress on C++ implementation.
        try:
          any_idx = targets.index('//:Any')
        except ValueError:
          pass
        else:
          targets[any_idx] = '//metastrap:Any'

        name = construct.id()
        data = {
          'name': name,
          'srcs': [name + '.cc'],
          'deps': targets,
          'visibility': ['//visibility:public'],
        }
        rule = 'cc_library'
        if test:
          rule = 'cc_test'
          data['size'] = 'small'
          data['srcs'].append(name + '.h')
        else:
          data['hdrs'] = [name + '.h']
        copts = data.setdefault('copts', [])
        /# The -Iexternal/gtest/include is needed to support gtest.
        copts.append('-Iexternal/gtest/include')
        /# The -Wnounused-variable is temporary until we get the code for
        /# inserting 'self'/'test'/'meta' properly conditionalized so that
        /# it isn't inserted of the variable isn't used.
        /# TODO(wmh): Consider using [[maybe_unused]]:
        /#   https://en.cppreference.com/w/cpp/language/attributes
        copts.append('-Wno-unused-variable')

      else:
        rule = None
        data = None
      return rule, data
    test:
      test.defineClassAndMethods('cc')
      test.iseq(
        ('cc_library',
         {
          /# 'copts': ['-Imetastrap', '-Iexternal/gtest/include'],
          'name': 'Card',
          'visibility': ['//visibility:public'],
          'srcs': ['Card.cc'],
          'deps': [],
          'copts': ['-Iexternal/gtest/include', '-Wno-unused-variable'],
          'hdrs': ['Card.h']}),
        test.baselang.createBuildFragment(test.klass, []))
    end receiver OoplCpp;

  end behavior createBuildFragment;

  behavior defineBaseVar : str #:
    Obtain the baselang syntax for defining/initializing a variable.
  params:
    var name : str #:
      Name of variable.
    var baseval : str = null #:
      The baselang-specific syntax for the value. One of 'baseval' or 'metaval'
      must be provided.
    var metaval : metax.c.Expr = null #:
      A meta-level expression to convert to baselang syntax.
    var mtype : metax.c.Type = null #:
      The type of the variable. If null, use auto if avaiable else any.
  scope:

    receiver BaseLanguageOopl ::
      metafile = self.metafile()
      if metaval:
        if baseval:
          raise metax.c.InternalError('Do not specify both baseval and metaval')
        /# TODO(wmh): Add code here!
        raise metax.c.InternalError('Not yet handling metaval in defineBaseVar')
      elif baseval:
        /# subclasses will add text before (typing) and after (termination).
        result = '%s = %s' % (name, baseval)
      else:
        raise metax.c.InternalError('Must specify one of baseval or metaval')
      return result
    test:
      /# tested in subclass overrides (no instance of this class).
      pass
    end receiver BaseLanguageOopl;

    receiver OoplCpp ::
      result = super(OoplCpp, self).defineBaseVar(
        name, baseval=baseval, metaval=metaval, mtype=mtype)
      /# https://stackoverflow.com/questions/29859796/c-auto-vs-auto
      prefix = 'auto&' if mtype is None else self.typeToBase(mtype)
      result = prefix + ' ' + result + ';'
      return result
    test:
      test.tcc()
      test.iseq(
        'auto& self = (*this);',
        test.baselang.defineBaseVar('self', baseval='(*this)', mtype=None))
      /# TODO(wmh): More testing!
    end receiver OoplCpp;

    receiver OoplJavascript ::
      result = super(OoplJavascript, self).defineBaseVar(
        name, baseval=baseval, metaval=metaval, mtype=mtype)
      /# TODO(wmh): Add jsdoc typing info here!
      result = 'let ' + result + ';'
      return result
    test:
      test.tjs()
      test.iseq(
        'let self = this;',
        test.baselang.defineBaseVar('self', baseval='this', mtype=None))
      /# TODO(wmh): More testing!
    end receiver OoplJavascript;

    receiver OoplPython ::
      result = super(OoplPython, self).defineBaseVar(
        name, baseval=baseval, metaval=metaval, mtype=mtype)
      /# No type and no prefix, so parent result is sufficient.
      return result
    test:
      test.tpy()
      test.iseq(
        'this = self',
        test.baselang.defineBaseVar('this', baseval='self', mtype=None))
      /# TODO(wmh): More testing!
    end receiver OoplPython;

  end behavior defineBaseVar;

  behavior emptyBlockCode : vec<str> #:
    Returns the lines of baselang code used to represent an empty block.

    In some languages this is an empty list, while others require a special
    syntax (e.g. Python's pass) while others may require some special
    value be returned to satisfy
  params:
    var executable : metax.oopl.ExecutableConstruct #:
      The executable for which empty block code is desired.  May be null,
      in which case the code should assume void return type.
    var message : str = null #:
      If present, the returned value should include code that will
      print out the message on stdout.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      /# TODO(wmh): The returned list should contain code within python for
      /# returning an appropriate dummy-value based on method return type!
      result = []
      if message:
        result.append('print("%s")' % message)

      if executable:
        /# We don't require 'returns' because we are currently calling this
        /# code in BehaviorConstruct.expandMeta() for ReceiverConstruct
        /# instances, which do not define a 'returns' but do define 'presence'.
        /# TODO(wmh): Consider cleaning this up.
        returns = (
          executable.attrval('returns', default=None) if executable
          else None)
        presence = executable.attrval('presence')

        if presence == 'abstract':
          /# No formal mechanism for marking a method abstract in Javascript,
          /# so we raise a runtime error.
          code = (
            'raise NotImplementedError'
            "('%s.%s.REPLACE' % (self.__class__.__module__, self.__class__.__name__))"
          )
          /# We replace 'REPLACE' with the name of the executable. However, if
          /# executable is a 'receiver', we instead want the name of the
          /# behavior it resides within.
          if executable.kind() == 'receiver':
            behavior = executable.parentConstruct()
            code = code.replace('REPLACE', behavior.id() + ' (behavior)') 
          else:
            code = code.replace('REPLACE', executable.id())
          result.append(code)
        if returns and not returns.isVoid():
          defval = self.defaultValue(returns)
          result.append('return %s' % defval)

      if not result:
        /# TODO(wmh): It is not sufficient to check if result is empty ... if
        /# it has 20 lines, but all of them are comments or empty, we will need
        /# a 'pass' statement.
        result.append('pass')

      return result
    test:
      test.tpy()
      test.iseqvec(['return 0.0'], test.baselang.emptyBlockCode(test.method))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      result = []
      if message:
        result.append("console.log('%s');" % message)
      if executable:
        returns = executable.attrval('returns', default=None)
        presence = executable.attrval('presence')
        if presence == 'abstract':
          /# No formal mechanism for marking a method abstract in Javascript,
          /# so we raise a runtime error.
          result.append(
            "throw new Error('NotImplemented: %s');" % executable.fqn())
        elif returns and not returns.isVoid():
          /# Closure will complain if we don't return something from methods
          /# with return types, so we return the default value associated with
          /# the return type.
          defval = self.defaultValue(returns)
          result.append('return %s;' % defval)
      return result
    test:
      test.tjs()
      test.iseqvec(
        ['return 0.0;'],
        test.baselang.emptyBlockCode(test.method))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      result = []
      if message:
        result.append('std::cout << "%s" << std::endl;' % message)
      if executable:
        returns = executable.attrval('returns')
        presence = executable.attrval('presence')
        if presence == 'abstract':
          /# In C++, abstract methods have no body whatsoever.
          result = None
        elif returns is None:
          pass
        elif returns.isPtr():
          result = ['return nullptr;']
        elif returns.isVoid():
          /# We do not return anything.
          pass
        elif returns.isStr():
          /# Applies only to @str and &str (*str and str are isPtr)
          result.append(
            'return %s;' % self.defaultValue(metax.c.Type.Instance('@str')))
        elif returns.isPrimitive() and not returns.isRef():
          result.append('return %s;' % self.defaultValue(returns))
        else:
          /# For ref and value types, we create a static faux instance of the
          /# (base) return type and return it.
          /# TODO(wmh): Need mechanism for supporting class-based return types
          /# that do not have a default constructor.  Could also be useful in
          /# unittests to have a mechanism for creating dummy instances of each
          /# class, so consider adding syntax for such instances and using it
          /# to generate code here.
          /# TODO(wmh): Some class types will need even more specialized
          /# handling. For example, metatype '&ostream' should return std::cout
          /# or std::cerr, rather than creating a new instance.
          metabase = metax.c.Type.Instance('@' + returns.base())
          result.append('static %s dummy;' % self.typeToBase(metabase))
          result.append('return dummy;')
      return result
    test:
      test.tcc()
      /# We make a copy of test.method so that we can change the return type.
      faux_parent = metax.attr.ComplexBlock(None, 'scope:', [])
      method = test.method.clone(faux_parent)
      return_attr = method.attr('returns')

      /# Now verify various return types.
      for metatype_str, expected in (
        ('int', ['return 0;']),
        ('str', ['return nullptr;']),
        ('*str', ['return nullptr;']),
        ('@str', ['return std::string("");']),
        ('&str', ['return std::string("");']),
        ('nm.sp.A', ['return nullptr;']),
        ('*nm.sp.A', ['return nullptr;']),
        ('@nm.sp.A', ['static nm::sp::A dummy;', 'return dummy;']),
        ('&nm.sp.A', ['static nm::sp::A dummy;', 'return dummy;']),
      ):
        metatype = metax.c.Type.Instance(metatype_str)
        return_attr.valueIs(metatype)
        res = test.baselang.emptyBlockCode(method)
        test.iseq(
          expected, res, 'For "%s" expecting emptyBlockCode\n  %s\nnot\n  %s'
          % (metatype_str, expected, res))
    end receiver OoplCpp;

  end behavior emptyBlockCode;

  behavior establishTemplateName : str #:
    Obtain the name of the template to use to instantiate a method.
  params:
    var executable : metax.oopl.ExecutableConstruct #:
      The executable for which a template is desired.
    var defn : bool = false #:
      If true, obtain the template for the definition, not declaration.
  scope:
    abstract
    receiver BaseLanguageOopl;

    receiver OoplPython scope:
      return self.id()
    test:
      test.defineClassAndMethods('py')
      test.iseq('python', test.baselang.establishTemplateName(test.method))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      result = self.id()
      if not self.config('user_es2015', False):
        /# TODO(wmh): Add support for using oldstyle template if we are not
        /# generating ES2015 classes
        pass
      return result
    test:
      test.defineClassAndMethods('js')
      test.iseq('javascript', test.baselang.establishTemplateName(test.method))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      /# C++ has a distinction between decl and defn, and the output for
      /# testcase methods is quite different than for a normal method.
      result = self.id()
      if defn:
        result += '_defn'
      else:
        result += '_decl'

      if executable.isTestCase():
        result += '_test'

      return result
    test:
      test.defineClassAndMethods('cc')
      method = test.method
      test.iseq(
        'cpp_defn', test.baselang.establishTemplateName(method, defn=True))
      test.iseq(
        'cpp_decl', test.baselang.establishTemplateName(method, defn=False))

      /# We fake up a test class and test method associated with 'method'.
      klass = method.myclass()
      testclass = klass.clone(None)
      testclass.idIs('CardTest')
      testclass.underclassIs(klass)
      testmethod = method.clone(testclass.attr('scope:'))
      testmethod.idIs('test_show')
      testmethod.myclassIs(testclass)
      test.istrue(testclass.isTestCase())
      test.istrue(testmethod.isTestCase())

      /# Verify that we get the test templates for test methods.
      test.iseq(
        'cpp_defn_test',
        test.baselang.establishTemplateName(testmethod, defn=True))
      test.iseq(
        'cpp_decl_test',
        test.baselang.establishTemplateName(testmethod, defn=False))

      /# TODO(wmh): Verify that we do NOT get the test methods for methods in
      /# testcase classes that aren't test methods, and for test methods in
      /# non-testcase classes.
    end receiver OoplCpp;

  end behavior establishTemplateName;

  behavior finalizerName : str #:
    The name of the finalizer for a given class.

    In most baselangs, this is the name of the class. Specific baselangs
    can override this default implementation (e.g. python).
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      return '~' + klass.id()
    test:
      test.tcc()
      test.iseq('~Person', test.baselang.finalizerName(test.klass))
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      /# According to
      /#   https://stackoverflow.com/questions/20266610/\
      /#     finalizers-for-javascript-objects
      /# There is no support for finalizers in Javascript.
      result = None
      return result
    test:
      test.tjs()
      test.isnull(test.baselang.finalizerName(test.klass))
    end receiver OoplJavascript;

    receiver OoplPython scope:
      return '__del__'
    test:
      test.tpy()
      test.iseq('__del__', test.baselang.finalizerName(test.klass))
    end receiver OoplPython;

  end behavior finalizerName;

  behavior formatClassComment : vec<str> #:
    Format the 'comment' of a class.  This differs from the generic
    formatComment() method in that class comments may provide important
    information like fields, etc.

    Returns:
      The list of lines representing legal baselang syntax for a class
      comment/docstr.
  params:
    var attribute : metax.attr.SimpleBlock #:
      The comment attribute. If null, returns result for no comment.
    var width : int = 80 #:
      Maximum width allowed.
    var suppress : map = null #:
      Where to write suppress commands (and reasons why).
    var default : vec<str> = null #:
      If present, and the comment is missing or empty, use this value
      as the comment.
  scope:

    abstract
    receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      if attribute:
        comment = self.simpleToBase(attribute, strip_comments=True)
        comment = self.formatComment(comment, width=width)
      else:
        comment = []
      return comment
    test:
      test.tcc()
      comment = test.klass.attr('comment:', default=None)
      test.iseqvec(
        [
          '// First line should be oneline summary.',
          '//',
          '// Subsequent lines are for more details and can be formatted in',
          '// Meta(Doc) syntax.',
        ],
        test.baselang.formatClassComment(comment))
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      if attribute:
        _, data = self.parseComment(attribute=attribute)
        construct = attribute.parent()
        visibility = construct.attrval('visibility')

        lines = self.simpleToBase(attribute, strip_comments=True)
        comment = []
        comment.append('/**')
        comment.append(' * %s' % construct.fqn())
        if False:
          comment.append(' * @fileoverview %s' % construct.kindfqn())
          comment.append(' *')
        for line in data['user']:
          if line:
            comment.append(' *   ' + line)
          else:
            comment.append(' *')
        comment.append(' * @%s' % visibility)

        specials = data['special']
        suppress_str = specials.get('suppress', None)
        if suppress_str:
          suppress_list = re.split(r'\s*,\s*', suppress_str.strip())
          if suppress is not None:
            for supvar in suppress_list:
              suppress[supvar] = (
                'Explicit suppression by user in %s' % construct.kindfqn())
          /# This is the wrong place to add @suppress ... must be in a
          /# @fileoverview at the top of the file.
          /# comment.append(
          /#   ' * @suppress {%s}' % ','.join(sorted(suppress_list)))

        comment.append(' */')
      else:
        comment = []
      return comment
    test:
      test.tjs()
      comment = test.klass.attr('comment:', default=None)
      test.iseqvec(
        ['/**',
         ' * demo.tmp.Person',
         ' *   First line should be oneline summary.',
         ' *',
         ' *   Subsequent lines are for more details and can be formatted in',
         ' *   Meta(Doc) syntax.',
         ' * @public',
         ' */'],
        test.baselang.formatClassComment(comment))
    end receiver OoplJavascript;

    receiver OoplPython scope:
      if attribute:
        comment = self.simpleToBase(attribute, strip_comments=True)
      else:
        comment = []
      if not comment and default:
        comment.extend(default)
      comment = self.formatComment(comment, width=width)
      return comment
    test:
      test.tpy()
      comment = test.klass.attr('comment:', default=None)
      test.iseqvec(
        ['"""First line should be oneline summary.',
         '',
         'Subsequent lines are for more details and can be formatted in',
         'Meta(Doc) syntax.', '"""'],
        test.baselang.formatClassComment(comment))
    end receiver OoplPython;

  end behavior formatClassComment;

  behavior formatClassType : tuple<str,str> #:
    Format a string representing a class name into a base fqn and meta fqn.

    Returns:
      0) the baselang fqn.
         The special value 'void' means 'no class'.
      1) the meta-level fqn.
  params:
    var metafile : *metax.oopl.MetaFile #:
      The metafile being processed (for reporting errors).
    var cstr : str #:
      The class string. Examples include the 'parent' value in class
      constructs and the primary value of 'assoc' constructs. May include
      an initial '^' character.
    var namespace : metax.oopl.NamespaceConstruct #:
      The namespace within which the class type resides.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      metafqn = metax.oopl.ClassConstruct.CanonicalizeClassName(
        cstr, namespace=namespace)
      if not metafqn:
        raise metax.c.Error('Should always have a class in python')
      basefqn = metafqn
      return basefqn, metafqn
    test:
      _, oopl, _, _ = test.cachedInfo()
      py = oopl.baselangNamed('python')
      construct = test.basics()
      metafile = test.metafile
      test.iseq(('object', 'object'), py.formatClassType(
        metafile, '^object', construct.namespace()))
      test.iseq(
        ('metax.c.MetaFile', 'metax.c.MetaFile'),
        py.formatClassType(metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('nm.sp.MetaFile', 'nm.sp.MetaFile'),
        py.formatClassType(metafile, 'MetaFile', construct.namespace()))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      metafqn = metax.oopl.ClassConstruct.CanonicalizeClassName(
        cstr, namespace=namespace)
      if not metafqn:
        raise metax.c.Error('Should always have a class in python')
      basefqn = metafqn
      return basefqn, metafqn
    test:
      baselang = test.baselang
      construct = test.basics()
      metafile = test.metafile
      test.iseq(('Object', 'Object'), baselang.formatClassType(
        metafile, '^Object', construct.namespace()))
      test.iseq(
        ('metax.c.MetaFile', 'metax.c.MetaFile'),
        baselang.formatClassType(
          metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('metax.c.MetaFile', 'metax.c.MetaFile'),
        baselang.formatClassType(
          metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('nm.sp.MetaFile', 'nm.sp.MetaFile'),
        baselang.formatClassType(
          metafile, 'MetaFile', construct.namespace()))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      metafqn = metax.oopl.ClassConstruct.CanonicalizeClassName(
        cstr, namespace=namespace)
      if metafqn:
        basefqn = metafqn.replace('.', '::')
      else:
        basefqn = None
      return basefqn, metafqn
    test:
      baselang = test.baselang
      construct = test.basics()
      metafile = test.metafile
      test.iseq(('std::string', 'std.string'), baselang.formatClassType(
        metafile, '^std.string', construct.namespace()))
      test.iseq(
        ('metax::c::MetaFile', 'metax.c.MetaFile'),
        baselang.formatClassType(
          metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('nm::sp::MetaFile', 'nm.sp.MetaFile'),
        baselang.formatClassType(
          metafile, 'MetaFile', construct.namespace()))
    end receiver OoplCpp;

  end behavior formatClassType;

  behavior formatComment : vec<str>
  #:
    Format a list of strings representing a comment into syntax valid
    in this baselang.

    Returns:
      A modified copy of the input comment.
  ##:
    TODO(wmh): The code here is similar (but not exactly the same) as code
    in BaseLanguageOopl.simpleToBase(). Can we remove the redundancy?
  params:
    var comment : vec<str> #:
      The list of lines to format. They can be modified in place.
    var width : int = 80 #:
      Maximum width allowed.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if comment is None:
        result = []
      else:
        result = comment[:]
      ncom = len(result)
      if ncom == 0:
        result = []
      elif ncom == 1:
        result[0] = '\"\"\"' + result[0] + '\"\"\"'
      else:
        result[0] = '\"\"\"' + result[0]
        result.append('\"\"\"')
      return result
    test:
      baselang = test.baselang
      comment = baselang.formatComment(['This is a test'])
      test.iseqvec(['\"\"\"This is a test\"\"\"'], comment)
      comment = baselang.formatComment(['This is a test', 'of two lines'])
      test.iseqvec(['\"\"\"This is a test', 'of two lines', '\"\"\"'], comment)
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if comment is None:
        result = []
      else:
        result = comment[:]
      rem = self.config('rem')
      remsp = rem + ' '
      for i in range(0, len(result)):
        if result[i]:
          result[i] = remsp + result[i]
        else:
          result[i] = rem
      return result
    test:
      _, oopl, _, _ = test.cachedInfo()
      js = oopl.baselangNamed('javascript')
      comment = js.formatComment(['This is a test'])
      test.iseqvec(['// This is a test'], comment)
      comment = js.formatComment(
        [
          'This is a test',
          'of multiple lines',
          '',
          'In multiple',
          'paragraphs.'
        ])
      test.iseqvec(
        [
          '// This is a test',
          '// of multiple lines',
          '//',
          '// In multiple',
          '// paragraphs.'
        ],
        comment)
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if comment is None:
        result = []
      else:
        result = comment[:]
      rem = self.config('rem')
      remsp = rem + ' '
      for i, line in enumerate(result):
        if line:
          result[i] = remsp + line
        else:
          result[i] = rem
      return result
    test:
      _, oopl, _, _ = test.cachedInfo()
      cc = oopl.baselangNamed('cpp')
      comment = cc.formatComment(['This is a test'])
      test.iseqvec(['// This is a test'], comment)
      comment = cc.formatComment(['This is a test', 'of two lines'])
      test.iseqvec(['// This is a test', '// of two lines'], comment)
    end receiver OoplCpp;

  end behavior formatComment;

  behavior formatDependencies : tuple<vec<str>,vec<str>> #:
    Analyze dependency data to produce imports and BUILD targets.

    NOTE: It is usually not necessary for subclasses to override this
    method. Instead, they can override formatDependency().  However, in
    some situations it may be easier to override this method entirely.

    Returns:
     0. The collection of baselang source lines importing dependencies
     1. The collection of BUILD targets needed to obtain dependencies.
  params:
    var class_construct : metax.oopl.ClassConstruct #:
      The class for which dependencies are being computed.
  scope:
    receiver BaseLanguageOopl scope:
      /# TODO(wmh): Although it is often possible to handle all dependencies by
      /# iterating over each dependency, there are some situations in some
      /# baselangs where dependencies interact. We may need to go back to a
      /# model where baselangs template formatDependencies() rather than
      /# formatDependency(). For example, javascript has some subtlties around
      /# this.
      deps = class_construct.deps()
      targets = set()
      imports = []
      for fqn in deps:
        import_str, target_str = self.formatDependency(
          class_construct, fqn)
        if import_str:
          imports.append(import_str)
        if target_str:
          targets.update(target_str.split(','))

      /# TODO(wmh): Sort std imports before non-std!
      imports = sorted(imports)

      return (imports, targets)
    test:
      test.tpy()
      test.iseq(
        ([], set([])),
        test.baselang.formatDependencies(test.klass))
    end receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      /# Every header file in C++ includes the special metastrap/__Meta__.h
      /# file, which defines all the core types like metax::str, etc.
      class_construct.addDependency(
        'metastrap.__Meta__', 'lib',
        'implicit import in OoplCpp.formatDependencies',
        target='//metastrap:__Meta__')

      /# Now call the parent implementation.
      imports, targets = super(OoplCpp, self).formatDependencies(
        class_construct)
      return imports, targets
    test:
      test.tcc()
      test.iseq(
        (['#include "metastrap/__Meta__.h"'], set(['//metastrap:__Meta__'])),
        test.baselang.formatDependencies(test.klass))
    end receiver OoplCpp;

  end behavior formatDependencies;

  behavior formatDependency : tuple<str,str> #:
    Obtain baselang import text and bazel target for a given dependency.

    Returns:
     0. The baselang import text to add for the dependency. May be null.
     1. The bazel target to add for the dependency.
  params:
    var class_construct : metax.oopl.ClassConstruct #:
      The class for which a dependency is being computed.
    var fqn : str #:
      The dependency to format.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      deps = class_construct.deps()

      info = deps[fqn]

      kind = info['kind']
      target = info['target']
      fqn_path = '/'.join(fqn.split('.'))

      if fqn_path == 'void':
        import_str = None

      elif kind == 'cls':
        import_str = '#include "%s.h"' % fqn_path

      elif kind == 'lib':
        /# TODO(wmh): In Python, this means "make all symbols within a namespace
        /# visible in the importing context, prefixed by the basename of the
        /# lib. What do we do in C++?
        import_str = '#include "%s.h"' % fqn_path

      elif kind == 'std':
        import_str = '#include <%s>' % fqn_path.replace('_h', '.h')
        target = None

      elif kind == 'decl':
        /# We are to forward declare the class only.
        raise metax.c.Error('Fix decl in C++')

      elif kind == 'def':
        /# We are to forward declare, *and* include the header file *after*
        /# the class definition.
        raise metax.c.Error('Fix def in C++')

      else:
        raise metax.c.Error('Unknown kind "%s"' % kind)

      return (import_str, target)
    test:
      test.defineClassAndMethods('cc')
      klass = test.klass
      klass.addDependency('metax.root.Object', 'cls', 'test1')
      klass.addDependency('demo.cards1.Card', 'lib', 'test2')
      klass.addDependency('ostream', 'std', 'test3')
      test.iseq(
        ('#include "metax/root/Object.h"', '//metax/root:Object'),
        test.baselang.formatDependency(test.klass, 'metax.root.Object'))
      test.iseq(
        ('#include "demo/cards1/Card.h"', '//demo/cards1/Card:Card'),
        test.baselang.formatDependency(test.klass, 'demo.cards1.Card'))
      test.iseq(
        ('#include <ostream>', None),
        test.baselang.formatDependency(test.klass, 'ostream'))
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      deps = class_construct.deps()
      info = deps[fqn]
      kind = info['kind']
      target = info['target']

      /# TODO(wmh): If the base name of the class occurs multiple times amongst
      /# all triples, we will need to use alternative names or not produce
      /# shorthand names at all.

      if kind == 'cls':
        /# There are two special-cases that we need to deal with:
        /#   1) nm.sp.FooMeta is a request for the metaclass
        /#   2) nm.sp.MetaFoo is a request for the metaclass instance.
        /# They both reside in module nm/sp/FooMeta.js.
        /#
        /# CODE TANGLE: meta-disallowed
        if metax.oopl.ClassConstruct.IsMetaName(fqn):
          /# A request to import nm.sp.FooMeta.
          /#   const {FooMeta} = goog.require('nm.sp.FooMeta')
          parts = fqn.split('.')
          import_str = "const {%s} = goog.require('%s');" % (parts[-1], fqn)
        elif metax.oopl.ClassConstruct.IsMetaInstName(fqn):
          /# A request to import nm.sp.MetaFoo
          /#   const {MetaFoo} = goog.require('nm.sp.FooMeta')
          parts = fqn.split('.')
          metainst = parts[-1]
          parts[-1] = metax.oopl.ClassConstruct.MetaifyName(
            metax.oopl.ClassConstruct.UnmetainstifyName(metainst))
          import_str = "const {%s} = goog.require('%s');" % (
            metainst, '.'.join(parts))
        else:
          /# We define the assoc basename locally.  Note that if there are any
          /# other assocs in triples with the same basename this will yield an
          /# error ... must fix.
          import_str = "const %s = goog.require('%s');" % (
            fqn.split('.')[-1], fqn)

      elif kind == 'lib':
        /# TODO(wmh): Is there a way to import all classes in a namespace
        /# in Javascript?  Or does Meta need to determine which classes
        /# exist and import them?
        import_str = "goog.require('%s');" % fqn

      elif kind == 'std':
        /# TODO(wmh): Are there any std assocs in Javascript? Maybe the
        /# various modules in phantomjs? http://phantomjs.org/api/
        /#   webpage: http://phantomjs.org/api/webpage/
        /#   child_process: http://phantomjs.org/api/child_process/
        /#   fs: http://phantomjs.org/api/fs/
        /#   system: http://phantomjs.org/api/system/
        /#   webserver: http://phantomjs.org/api/webserver/
        /#
        /# For now, we simply ignore std assocs in javascript.
        import_str = None
      else:
        raise metax.c.Error('Unknown kind "%s"' % kind)

      return (import_str, target)
    test:
      test.tjs(expand=True)
      klass = test.klass
      test.iseq(
        /# TODO(wmh): Fix 'demo.tmp.MetaPerson'
        /#  (should be 'demo.tmp.PersonMeta')
        ['demo.tmp.MetaPerson', 'metax.root.Object', 'metax.root.ObjectMeta',
         /# TODO(wmh): os should not be in the javascript list
         'os',
        ],
        sorted(klass.deps().keys()))
      test.iseq(
        ("const Object = goog.require('metax.root.Object');",
         '//metax/root:Object'),
        test.baselang.formatDependency(test.klass, 'metax.root.Object'))
      test.iseq(
        ("const {MetaPerson} = goog.require('demo.tmp.PersonMeta');",
         '//demo/tmp:MetaPerson'),
        test.baselang.formatDependency(test.klass, 'demo.tmp.MetaPerson'))

    end receiver OoplJavascript;

    receiver OoplPython scope:
      deps = class_construct.deps()
      info = deps[fqn]
      kind = info['kind']
      target = info['target']
      reason = info['reason']
      optional = info.get('optional', False)
      alias = info.get('alias', None)
      alias_str = ' as %s' % alias if alias else ''
      opt_str = (' optional=%s' % fqn) if optional else ''

      if kind == 'cls':
        /# Note that 'target' will be class-specific, but Python does not
        /# (currently) have class-specific targets, only namespace targets.
        /# So we convert the class target to a namespace target.
        m = re.match(r'^([^:]+)/([^:]+):(\S+)$', target)
        if not m:
          raise metax.c.Error(
            'Failed to parse target "%s" when looking for namespace' % target)
        target = '%s/%s:%s' % (m.group(1), m.group(2), m.group(2))

        idx = fqn.rfind('.')
        if idx == -1:
          metafile.error('Invalid class type "%s"' % fqn)
          import_str = None
        else:
          import_str = 'import %s%s  # target=%s reason=%s%s' % (
            fqn[:idx], alias_str, target, reason, opt_str)

      elif kind == 'lib':
        /# The target identifies a namespace, so we do not need to
        /# modify it.
        import_str = 'import %s%s  # target=%s reason=%s%s' % (
          fqn, alias_str, target, reason, opt_str)

      elif kind == 'std':
        import_str = 'import %s%s' % (fqn, alias_str)

      else:
        raise metax.c.Error('Unknown kind "%s"' % kind)

      return import_str, target
    test:
      test.tpy(expand=True)
      klass = test.klass
      test.iseq(
        ['demo.tmp.PersonMeta', 'metax.root.Object', 'metax.root.ObjectMeta',
         'os', 'sys'],
        sorted(klass.deps().keys()))
      test.iseq(
        ('import metax.root  # target=//metax/root:root reason=parent',
         '//metax/root:root'),
        test.baselang.formatDependency(test.klass, 'metax.root.Object'))
      test.iseq(
        ('import sys', None),
        test.baselang.formatDependency(test.klass, 'sys'))
      test.iseq(
        ('import demo.tmp  '
         '# target=//demo/tmp:tmp reason=implicit import in '
         'ClassConstruct.translateMeta()',
         '//demo/tmp:tmp'),
        test.baselang.formatDependency(test.klass, 'demo.tmp.PersonMeta'))
    end receiver OoplPython;

  end behavior formatDependency;

  behavior formatFieldDefinition : vec<str> #:
    Obtain the baselang code needed to define this field.
  params:
    var field : metax.oopl.FieldConstruct #:
      The field to format.
    var defn : bool = false #:
      For baselangs that do not distinguish between declaration and definition,
      this arg is ignored. For languages that do care, false (default) means
      generate field declaration code, true means generate field definition
      code.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      result = []
      rawfield = field.rawfield()
      myclass = field.myclass()
      type_attr, metatype = field.attrpair('type', default=metax.c.LOOKUP)
      if metatype.isStr():
        /# The 'str' type should be implementable using:
        /#   const std::string
        /#   std::string_view
        /#   any class that
        /#    - provides the read-only portion of std::string API
        /#    - can support '*str' means nullable
        /#    - can support '&str' means non-nullable
        /#    - does not need to implement '*str' as a pointer to a class
        /#    - does not need to implement '&str' as a ref to a class
        /#    - provides very fast string comparison (ala internment)
        /# Prefixes
        /#  - *str means the string value can be null (but does not necessarily
        /#    mean the instance of the class implementing the string has to
        /#    be null).
        /#  - &str means cannot be null
        /#  - @str means cannot be null and is pass-by-value
        /#  - str means *str (can be null)
        basetype = OoplCpp.CC_STR
      else:
        basetype = self.typeToBase(metatype, class_construct=myclass)
        /# print('****** %-20s %-30s = %s' % (rawfield, metatype, basetype))

      kind = field.attrval('kind')
      kindstr = 'static ' if kind == 'static' else ''
      value = ''
      if defn:
        if kind == 'static':
          if not value:
            value = self.defaultValue(metatype)
          result.append('')
          result.append(
            '// static field %s : %s' % (field.id(), metatype.raw()))
          if value is None:
            code = '%s %s::%s;' % (basetype, myclass.id(), rawfield)
          else:
            code = '%s %s::%s = %s;' % (basetype, myclass.id(), rawfield, value)
          result.append(code)
      else:
        code = 'private: %s%s %s%s;' % (kindstr, basetype, rawfield, value)
        result.append(code)
      return result
    test:
      test.tcc()
      test.iseq(
        ['private: metax::str None;'],
        test.baselang.formatFieldDefinition(test.field))
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      /# Fields are defined in initializers. No field-specific syntax.
      return []
    test:
      test.tjs()
      test.iseq([], test.baselang.formatFieldDefinition(test.field))
    end receiver OoplJavascript;

    receiver OoplPython scope:
      /# instance fields are defined in initializers, meta fields are
      /# defined in metaclass initializers, but static fields are defined
      /# here.
      kind = field.attrval('kind')
      if kind == 'static':
        default = field.attrval('default', default=None)
        mtype = field.attrval('type', default=metax.c.LOOKUP)
        basedef, mtype2 = self.compileExpr(
          default, self.metafile(), metatype=mtype)
        if mtype is not mtype2:
          if mtype.isNative():
            /# we check if there is an explicit type conversion from mtype2
            /# to mtype that we can apply to the default value.
            nativemap = MetaxOopl.NATIVE
            tmap = nativemap[mtype.base()]['scope']
            dmap = tmap.get('(%s)' % mtype2.base(), None)
            if dmap:
              /# TODO(wmh): Need a general method for instantiating
              /# template code (something lower-level than nativeMethodToBase).
              suffix = self.suffix()
              tmplcode = dmap['code'][suffix]
              /# If the default value is a string, we make it a raw string.
              litstr = 'r' + basedef if mtype2.base() == 'str' else basedef
              basedef = tmplcode % {'A1': litstr}

          /# Sanity check.
          print(
            'NOTE: In formatFieldDefinition, default type %s vs %s' %
            (mtype, mtype2))
        result = ['%s = %s' % (field.rawfield(), basedef)]
      else:
        result = []
      return result
    test:
      test.tpy()
      test.iseq([], test.baselang.formatFieldDefinition(test.field))
      /# TODO(wmh): Add a test for static fields
    end receiver OoplPython;

  end behavior formatFieldDefinition;

  behavior formatMethodComment : vec<str> #:
    Format the 'comment' of an executable.  This differs from the generic
    formatComment() method in that method comments often describe parameters,
    return types, etc. (in baselangs that don't have static typing).

    Returns:
      The list of lines representing legal baselang syntax for a method
      comment/docstr.
  params:
    var construct : metax.oopl.ExecutableConstruct #:
      The construct to format the comment of.
    var width : int = 80 #:
      Maximum width allowed.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      kind = construct.attrval('kind', default=metax.c.LOOKUP)
      params = construct.parsedParams()
      visibility = construct.attrval('visibility', default=metax.c.LOOKUP)
      returns = construct.attrval('returns', default=metax.c.LOOKUP)

      comment_attr, comdata = self.parseComment(
        construct=construct, parse_return=True)
      clines = comdata['user']

      pdata = params['data']
      if pdata:
        if not clines:
          clines.append('No comment provided.')
        if clines[-1]:
          clines.append('')
        clines.append('Args:')
        for param in pdata:
          clines.append('  %s: %s' % (param['name'], str(param['type'])))
          if 'comment' in param:
            for ln in param['comment']:
              if ln:
                clines.append('    ' + ln)
              else:
                clines.append('')

      if comdata['returns']:
        clines.append('')
        clines.append('Returns:')
        clines.extend(comdata['returns'])

      if clines is None:
        clines = []
      lines = self.formatComment(clines, width=width)
      return lines
    test:
      test.tpy()
      test.iseqvec(
        ['"""Calculate body mass index of this person.',
         'Result is unitless, but relies on height in meters and',
         'weight in kilograms.', '"""'],
        test.baselang.formatMethodComment(test.method))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      suppress = set()
      lines = []
      lines.append('/**')

      attrkind = construct.attrval('kind')
      is_init = attrkind == 'initializer'
      myclass = construct.myclass()
      comment_attr, comdata = self.parseComment(
        construct=construct, parse_return=True)
      clines = comdata['user']
      if 'suppress' in comdata['special']:
        suppress.update(re.split(r'\s*,\s*', comdata['special']['suppress']))

      /# Add the user-provided documentation for this executable.
      lines.append(' * %s' % ('initializer' if is_init else construct.fqn()))
      if clines:
        for line in clines:
          if line:
            lines.append(' *   ' + line)
          else:
            lines.append(' *')

      /# Add annotations for all parameters.
      params = construct.parsedParams()
      for param in params['data']:
        default = param.get('default', None)
        /# TODO(wmh): As of 2017-12-22, when providing the fully-qualified
        /# name of a type, closure produces the error:
        /#    metax/test/TestCase.js:445: ERROR - Reference to fully qualified
        /#      import name 'goog.testing.PropertyReplacer' in JSDoc.
        /#      Please use the short name 'PropertyReplacer' instead.
        /#       * @return {?goog.testing.PropertyReplacer}
        /#                   ^
        /#      ProTip: "JSC_JSDOC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME" or "lintChecks" or "strictModuleChecks" can be added to the `suppress` attribute of:
        /#      //metax/test:TestCase
        /# Adding JSC_JSDOC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME
        /# to the BUILD rule results in a
        /#    ERROR - Build rule (//metax/root:ObjectMetaRoot) contains superfluous suppress codes: CR_SUPERFLUOUS_SUPPRESS, JSC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME
        /#      ProTip: "CR_SUPERFLUOUS_SUPPRESS" or "superfluousSuppress" can be added to the `suppress` attribute of:
        /#      //metax/root:ObjectMetaRoot
        /# And adding "CR_SUPERFLUOUS_SUPPRESS" to the appropriate build target
        /# does NOT work as advertised ... the superfluous error persists.
        /#
        /# I would very much prefer to keep using fqns (not least of which
        /# because using only class names will not work in situations where
        /# a class needs nm.sp1.A and nm.sp2.A), but until
        /# "CR_SUPERFLUOUS_SUPPRESS" is working properly, we set defqn=True
        /# in the call to typeToBase().

        /#basetype2 = self.typeToBase(
        /#  param['type'], class_construct=myclass, defqn=False)
        basetype = self.typeToBase(
          param['type'], class_construct=myclass, defqn=True)

        if default is None:
          lines.append(' * @param {%s} %s' % (basetype, param['name']))
        else:
          defval = default
          lines.append(' * @param {%s} [%s=%s]' % (
            basetype, param['name'], defval))
        pcom = param.get('comment', [])
        for line in pcom:
          if line:
            lines.append(' *   ' + line)
          else:
            lines.append(' *')
      if 'varvec' in params or 'varmap' in params:
        lines.append(' * @param {*} varargs')

      /# Annotate the return type
      returns = construct.attrval('returns', default=metax.c.LOOKUP)
      if not returns.isVoid():
        /# See comment above about defqn - we need to do the same thing here.
        baseret = self.typeToBase(returns, class_construct=myclass, defqn=True)
        lines.append(' * @return {%s}' % baseret)
        if 'returns' in comdata:
          for rline in comdata['returns']:
            if rline:
              lines.append(' *   ' + rline)
            else:
              lines.append(' *')

      /# Record the visibility
      if is_init:
        /# jsdoc does not want us to annotate the visibility of the constructor.
        /# instead, we annotate the visibility of the class itself (done
        /# in OoplJavascript.formatClassConstruct()).
        pass
      else:
        visibility = construct.attrval('visibility', default=metax.c.LOOKUP)
        lines.append(' * @%s' % visibility)

      /# Handle initializer-specific annotations.
      kind = construct.attrval('kind', default=metax.c.LOOKUP)
      if kind == 'initializer':
        myclass = construct.myclass()
        pspec = myclass.parentclasses()[0]
        if False:
          lines.append(' * @constructor')
          /# TODO(wmh): How to declare the fields of a class properly?
          /# Using @property does not appear to work properly.
          /# TODO(wmh): Add an '@extends {class}' line for the parent.
          lines.append(' * @extends {%s}' % pspec['fqn'])

        if myclass.isTestCase():
          /# Meta<Javascript> generates javascript tests within subclasses of
          /# goog.testing.TestCase. However, the test-harness running code
          /# currently relies on some implicit behavior provided by
          /# goog.requiring goog.testing.jsunit. This implicit behavior breaks
          /# if we add a
          /#   goog.provide('<the_test_class>')
          /# but google closure complains about
          /#   "JSC_MISSING_PROVIDE" or "missingProvide"
          /# if such a provide is not given. For now, we suppress the warning in
          /# this situation, but finding a way to allow test classes to be
          /# defined normally would be best.
          /#
          /# TODO(wmh): Determine if this is still necessary
          /# suppress.add('missingProvide')
          pass

      /# Handle 'new' vs 'override' semantics.
      inheritance = construct.attrval('inheritance', default=metax.c.LOOKUP)
      if inheritance != 'new':
        lines.append(' * @override')

      /# Suppress requested warnings.
      if suppress:
        lines.append(' * @suppress {%s}' % (','.join(sorted(suppress))))
      lines.append(' */')

      return lines
    test:
      test.tjs()
      test.iseqvec(
        ['/**',
         ' * demo.tmp.Person.bmi',
         ' *   Calculate body mass index of this person.',
         ' *   Result is unitless, but relies on height in meters and',
         ' *   weight in kilograms.',
         ' * @return {!number}',
         ' * @public', ' */',
        ],
        test.baselang.formatMethodComment(test.method)
      )
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      comment_attr, clines = construct.attrpair('comment:', default=None)
      kind = construct.attrval('kind', default=metax.c.LOOKUP)
      params = construct.parsedParams()
      visibility = construct.attrval('visibility', default=metax.c.LOOKUP)
      returns = construct.attrval('returns', default=metax.c.LOOKUP)

      /# TODO(wmh): Fix this ... using formatComment() temporarily.
      if clines is None:
        clines = []
      lines = self.formatComment(clines, width=width)
      return lines
    test:
      test.defineClassAndMethods('cc')
      test.iseqvec(
        [
          '// This is a test.',
          '//',
          '// Multiline comment with blank line.',
        ],
        test.baselang.formatMethodComment(test.method))
    end receiver OoplCpp;

  end behavior formatMethodComment;

  behavior formatParams : vec<str> #:
    Format the params into baselang code.

    Returns:
      A list of baselang syntax, one element per parameter.
  params:
    var executable : metax.oopl.ExecutableConstruct #:
      The executable containing the params.
    var preamble : vec<str> #:
      Where to write any parameter-related preamble code.
    var decl : bool = false #:
      If true, format for declaration not definition.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      result = []
      kind = executable.attrval('kind')
      if kind == 'static':
        /# No receiver.
        /#  - define the local variable 'cls'.
        /#    TODO(wmh): Only insert the definition if there isn't already a
        /#    definition of 'cls' at left margin!
        preamble.append('cls = %s' % executable.myclass().id())
        pass
      else:
        rec = self.receiverStr(executable)[0]
        assert rec is not None
        result.append(rec)

      params = executable.parsedParams()
      pdata = params['data']
      if pdata:
        metafile = self.metafile()
        nulltype = metax.c.Type.Instance('meta.Null')
        for param in pdata:
          part = param['name']
          if 'default' in param:
            defexpr = param['default']
            metatype = param['type']
            defval, metatype2 = self.compileExpr(
              defexpr, metafile, executable=executable, metatype=metatype)
            if (
              False and
              metatype is not metatype2 and
              metatype2 is not nulltype
            ):
              /# TODO(wmh): The discrepancies reported by this when not disabled
              /# are a bit concerning. Things like:
              /#   str vs &str
              /#   &ostream vs meta.ostream
              /#   int vs uint
              /#   bool vs None
              /# are all potential errors. On the other hand, diffs like
              /#   vec<metax.c.Construct> vs meta.Null
              /#   metax.oopl.ClassConstruct vs meta.Null
              /#   metax.oopl.ExecutableConstruct vs meta.Null
              /#   map vs meta.Null
              /# are valid.
              print(
                'NOTE: In formatParams, metatype %s vs %s' %
                (metatype, metatype2))

            /# TODO(wmh): Need to implement a generic mechanism for providing
            /# type-specific interpretations of default values. The following is
            /# an example of how we can provide specialized support for the 'rv'
            /# native type (allow default to be set to a float, implying a
            /# constant rv), but we need something more general that is still
            /# efficient (e.g. something where we can look up in a dict for the
            /# native type and perform actions based on that lookup).
            metatype = param['type']
            rawtype = metatype.raw() if metatype else None
            if rawtype == 'rv':
              /# The default value for a random variable can be:
              /#  - a call of the form 'rv.uniform(loc,scale)' or
              /#    'rv.norm(loc,scale)', etc.
              /#  - a number, which is interpreted as a constant RV.
              ekind = defexpr.kind()
              if ekind == 'num':
                /# TODO(wmh): Ensure that we import scipy.stats!
                myclass = executable.myclass()
                myclass.addDependency(
                  /# TODO(wmh): We should be looking in self.metatypes()['rv']
                  /# or self.metatypes()['rv.uniform'] for the namespace to
                  /# import.
                  'scipy.stats', 'std', 'implicit import for type rv',
                  target=None)
                defval = 'scipy.stats.uniform(%s, 0.0)' % defval
              elif ekind == 'call':
                /# TODO(wmh): Fix this!  Allow expressions of the form
                /#   @rv.uniform(10,2), @rv.norm(5,2), etc.
                /# The code is currently failing to properly parse the expr
                /# representations of the above ... clean that up!
                raise metax.c.Error(
                  'Not yet supporting explicit call exprs in rvs')
              else:
                raise metax.c.Error(
                  'Not supporting %s expr for type %s' % (ekind, rawtype))
            part += '=' + defval
          result.append(part)
      if 'varvec' in params:
        result.append('*%s' % params['varvec']['name'])
      if 'varmap' in params:
        result.append('**%s' % params['varmap']['name'])

      return '(%s)' % ', '.join(result)
    test:
      test.tpy(expand=True)
      preamble = []
      test.iseq(
        "(self, fp=sys.stdout, indent='')",
        test.baselang.formatParams(test.method2, preamble))
      test.iseq([], preamble)
    end receiver OoplPython;

    receiver OoplJavascript scope:
      result = []
      rec = self.receiverStr(executable)[0]

      variadics = []
      params = executable.parsedParams()
      pdata = params['data']
      if pdata:
        metafile = self.metafile()
        for param in pdata:
          part = param['name']
          if 'default' in param:
            metatype = param['type']
            defval, metatype2 = self.compileExpr(
              param['default'], metafile,
              executable=executable, metatype=metatype)
            /# As of ES2015, default parameters exist in javascript.
            /#   https://developer.mozilla.org/en-US/docs/Web/JavaScript/\
            /#     Reference/Functions/Default_parameters
            part += '=' + defval
          result.append(part)
      if 'varvec' in params:
        variadics.append(params['varvec'])
      if 'varmap' in params:
        variadics.append(params['varmap'])
      if variadics:
        result.append('varargs')
        /# http://usejsdoc.org/\
        /#   tags-param.html#multiple-types-and-repeatable-parameters
      return '(%s)' % ', '.join(result)
    test:
      test.tjs(expand=True)
      preamble = []
      test.iseq(
        "(fp=null, indent='')",
        test.baselang.formatParams(test.method2, preamble))
      test.iseq([], preamble)
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      result = []
      rec = self.receiverStr(executable)[0]
      myclass = executable.myclass()

      mutability = executable.attrval('mutability')
      presence = executable.attrval('presence')
      kind = executable.attrval('kind')

      variadics = []
      params = executable.parsedParams()
      pdata = params['data']
      if pdata:
        metafile = self.metafile()
        for param in pdata:
          basetype = self.typeToBase(param['type'], class_construct=myclass)
          part = basetype + ' ' + param['name']
          if 'default' in param:
            if decl:
              /# In C++, default args can be added to declaration or definition
              /# but not both. Since the default args are part of the public
              /# interface, we assign them in decl not defn.
              metatype = param['type']
              defexpr = param['default']
              if metatype is metax.c.Type.Str and defexpr.value() == 'null':
                defval = 'metax::NullStr()'
                metatype2 = metatype
              else:
                defval, metatype2 = self.compileExpr(
                  defexpr, metafile,
                  executable=executable, metatype=metatype)
              part += ' = ' + defval
          result.append(part)
      if 'varvec' in params:
        variadics.append(params['varvec'])
      if 'varmap' in params:
        variadics.append(params['varmap'])
      if variadics:
        /# http://en.cppreference.com/w/cpp/language/variadic_arguments
        result.append('...')

      result = '(%s)' % ', '.join(result)
      if mutability == 'const' and kind != 'static':
        result += ' const'
      if presence == 'abstract':
        result += ' = 0'

      return result
    test:
      test.defineClassAndMethods('cc')
      method = test.method2
      method.myclass().namespaceIs(test.namespace)
      preamble = []
      test.iseq(
        '(metax::strview a, int32_t b = 1, bool c = false)',
        test.baselang.formatParams(method, preamble, decl=True))
      test.iseq(
        '(metax::strview a, int32_t b, bool c)',
        test.baselang.formatParams(method, preamble))
      test.iseqvec([], preamble)
    end receiver OoplCpp;

  end behavior formatParams;

  behavior formatParentSpec : str #:
    Obtain baselang syntax for how to define parents of a class.

    SideEffect:
      May register additional dependencies in class_construct via
      addDependency().

    Returns:
     0) the baselang syntax for defining the parents
     1) a list of triples containing 0 or more imports to include.
        Each element specifies (metafqn, kind, target) where kind is one of
        'cls' or 'std' or 'lib'.
  params:
    var class_construct : metax.oopl.ClassConstruct;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      parentclasses = class_construct.parentclasses()
      parentdata = parentclasses[0]
      metafqn = parentdata['metafqn']
      basefqn = parentdata['fqn']
      parentspec = basefqn or metafqn

      metaclass = class_construct.metaclass()
      if metaclass:
        /# CODETANGLE(metaclass_support)
        parentspec = 'with_metaclass(%s, %s)' % (metaclass.id(), parentspec)
      return parentspec
    test:
      test.tpy(expand=True)
      test.iseq(
        'with_metaclass(PersonMeta, metax.root.Object)',
        test.baselang.formatParentSpec(test.klass))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      parentclasses = class_construct.parentclasses()
      parentdata = parentclasses[0]
      metafqn = parentdata['metafqn']
      basefqn = parentdata['fqn']
      parentspec = basefqn or metafqn

      /# TODO(wmh): If two different classes with the same name but differing
      /# namespaces are required within a class, we will not be able to
      /# produce the same shortname for both and the following assumption will
      /# be invalidated.  I'd prefer to use the long names always, but that
      /# is posing closure errors (missing require 'metax.root.ObjectMetaRoot',
      /# even though the require is not missing).
      parent_name = parentspec.split('.')[-1]

      /# Closure prefers that if we have introduced a short name for a class via
      /# 'goog.require', that we use the short name over the fully-qualified
      /# name. However, Meta often prefers to do the opposite because:
      /#  - some baselangs require fully qualified names (e.g. Perl)
      /#  - shortnames can be ambiguous if two different classes with the
      /#    same basename but differing namespaces are required within
      /#    the same class
      /#
      /# For example, closure prefers:
      /#    const Bar = goog.require('nm.sp2.Bar');
      /#    class Foo extends Bar { ... }
      /#                      ^^^
      /# But Meta often produces:
      /#    const Bar = goog.require('nm.sp2.Bar');
      /#    class Foo extends nm.sp2.Bar { ... }
      /#                      ^^^^^^^^^^
      /# This can generate a closure error of the form:
      /#   metax/root/ObjectMeta.js:10: ERROR - Reference to fully qualified
      /#   import name 'metax.root.ObjectMetaRoot'. Please use the short name
      /#   'ObjectMetaRoot' instead.
      /#
      /# Disabling this should never introduce any errors ... not sure why
      /# closure is even making a fuss about it.
      if '.' in parent_name:
        raise metax.c.Error('Should never get here')
        /# class_construct.suppress()['JSC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME'] = (
        /#   'Using fqn parent %s' % parent_name)

      /# Form the javascript syntax needed to declare class_construct to be
      /# a child of parent_name.
      parent_spec = ' extends ' + parent_name

      return parent_spec
    test:
      test.tjs(expand=True)
      test.iseq(
        ' extends Object',
        test.baselang.formatParentSpec(test.klass))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      parent_classes = class_construct.parentclasses()
      if parent_classes:
        parent_data = parent_classes[0]
        metafqn = parent_data['metafqn']
        basefqn = parent_data['fqn']

        /# Form the C++ syntax needed to declare class_construct to be
        /# a child of parent_name.
        if not basefqn:
          parent_spec = ''
        else:
          /# TODO(wmh): Generalize ... not always public inheritance.
          parent_spec = ' : public ' + basefqn

      else:
        parent_spec = ''
      return parent_spec
    test:
      test.tcc(expand=True)
      test.iseq(
        ' : public metax::root::Object',
        test.baselang.formatParentSpec(test.klass))
    end receiver OoplCpp;

  end behavior formatParentSpec;

  behavior fqnToTarget : map #:
    Convert a fully-qualified name into a Bazel BUILD target and --test_args.

    Returns:
      namespace: str
        The namespace portion of the fqn
      class: str
        The class within the namepace. Not present if fqn is just a namespace.
      method: str
        The method within the namepace. Not present if fqn has no method.
      target: str
        The full BUILD target for the specified fqn.
      test_target: str
        The full BUILD target for the test target associated with specified fqn.
      test_arg: str
        The --test_arg value to pass to the target (not present if not needed)
      kind: str
        The kind of fqn ('namespace', 'class', or 'method'). Not present if
        error exists.
      path: str
        The path to a baselang file containing the fqn.
      test_path: str
        The path to a baselang file containing the test variant of fqn.
      error: str
        If present, the fqn is not valid, and this value explains why.
        Callers must test for present of this to establish success.
  params:
    var fqn : str #:
      The fully qualified namespace[.class[.method]] for which a target is
      desired.
    var verbose : bool = false #:
      If true, print out details of verification process.
  scope:
    receiver BaseLanguageOopl #:
      This implementation is applicable to baselanguages that have per-class
      BUILD targets and 'first-class' class files.
    scope:
      result = {}
      /# The smallest granularity of target is a class. For methods we use
      /# --test_arg.
      metac = self.compiler()
      metarep = metac.repositoryPath()
      fs = metac.fs()
      parts = fqn.split('.')
      k = len(parts)
      ispy = self.id() == 'python'

      /# Establish the namespace portion of the fqn.
      nmsps = []
      rootdir = fs.join(metarep, metac.basePath())
      ndir = rootdir
      i = 0
      while i < k:
        tdir = fs.join(ndir, parts[i])
        if not fs.isdir(tdir): break
        nmsps.append(parts[i])
        ndir = tdir
        i += 1

      if i == 0:
        /# Failed to find any namespaces.
        result['error'] = '%s does not represent a valid target' % fqn
      else:
        result['namespace'] = '.'.join(nmsps)
        testbase = metax.oopl.NamespaceConstruct.TestifyName(nmsps[-1])
        if verbose:
          print('  namespace is %s' % result['namespace'])

        /# NOTE: We can determine whether the namespace is terminal (has
        /# classes) based on whether the _test version of the namespace exists.
        namespace_path = ndir
        namespace_test_path = metax.oopl.NamespaceConstruct.TestifyName(ndir)

        namespace_terminal = False
        if fs.isdir(namespace_test_path):
          namespace_terminal = True
        namespace_target = '//%s:%s' % ('/'.join(nmsps), nmsps[-1])
        namespace_test_target = (
          '//%s/%s:%s' % ('/'.join(nmsps[:-1]), testbase, testbase)
          if len(nmsps) > 1 else '//%s:%s' % (testbase, testbase))

        if i < k:
          /# Per-class map files are in .<name>.<suffix>.map (even in python)
          class_candidate = parts[i]

          /# In C++, self.suffix() is .cc, but we need to use .h because the
          /# .h.map file is guaranteed to have all symbols whereas .cc.map will
          /# not have header-inlined symbols.
          suffix = self.suffix()
          map_suffix = '.h' if self.id() == 'cpp' else suffix
          mapbase = '.%s%s.map' % (class_candidate, map_suffix)
          clsbase = '__init__.py' if ispy else class_candidate + suffix
          tstbase = (
            '__init__.py' if ispy
            else metax.oopl.ClassConstruct.TestifyName(class_candidate)+suffix)
          tbase = nmsps[-1] if ispy else class_candidate
          tfile = fs.join(ndir, mapbase)
          if fs.exists(tfile):
            /# We've verified a class name.
            result['target'] = (
              namespace_target if ispy else '//%s:%s' %
              ('/'.join(nmsps), tbase))
            result['test_target'] = (
              namespace_test_target if ispy
              else '//%s:%s' % (
                metax.oopl.NamespaceConstruct.TestifyName('/'.join(nmsps)),
                metax.oopl.ClassConstruct.TestifyName(class_candidate)))
            result['class'] = class_candidate
            result['path'] = fs.relpath(
              fs.join(namespace_path, clsbase), rootdir)
            if namespace_terminal:
              result['test_path'] = fs.relpath(
                fs.join(namespace_test_path, tstbase), rootdir)
            if verbose:
              print('  class is %s' % class_candidate)

            i += 1
            if i < k:
              /# The fqn is a method.

              /# We can verify the specified method is valid by parse the
              /# class map file (tfile). However, the specified fqn may also
              /# include a testx suffix, so it is better to search in the
              /# testclass mapfile for the test method instead.
              method_name = parts[i]
              test_namespace = NamespaceConstruct.TestifyName(
                result['namespace'])
              test_ndir = NamespaceConstruct.TestifyName(ndir)
              test_class = ClassConstruct.TestifyName(class_candidate)
              test_method = ExecutableConstruct.TestifyName(method_name)
              ttfile = '%s/.%s%s.map' % (test_ndir, test_class, map_suffix)
              verified = False
              test_fqn = '%s.%s.%s' % (test_namespace, test_class, test_method)
              with fs.open(ttfile, 'r') as mfp:
                for line in mfp:
                  if test_fqn in line:
                    verified = True
                    break

              if verified:
                result['kind'] = 'method'
                result['method'] = method_name
                if ispy:
                  result['test_arg'] = '%s.%s' % (
                    metax.oopl.ClassConstruct.TestifyName(class_candidate),
                    metax.oopl.ExecutableConstruct.TestifyName(method_name))
                else:
                  result['test_arg'] = (
                    metax.oopl.ExecutableConstruct.TestifyName(method_name))
              else:
                if verbose:
                  print('  failed to find %s in %s' % (test_fqn, ttfile))
                result['error'] = '%s is not a method within %s.%s' % (
                  method_name, result['namespace'], class_candidate)
            else:
              /# The fqn is a class.
              result['kind'] = 'class'
              if ispy:
                result['test_arg'] = metax.oopl.ClassConstruct.TestifyName(
                  class_candidate)
          else:
            /# Invalid class name.
            result['error'] = (
              '%s is not a namespace or class in %s' %
              (class_candidate, fqn.rsplit('.', 1)[0]))
        else:
          /# The fqn contains only namespaces.
          result['kind'] = 'namespace'
          result['target'] = namespace_target
          if namespace_terminal:
            result['test_target'] = namespace_test_target
          if ispy:
            result['path'] = fs.relpath(
              fs.join(namespace_path, '__init__.py'), rootdir)
            if namespace_terminal:
              result['test_path'] = fs.relpath(
                fs.join(namespace_test_path, '__init__.py'), rootdir)

      return result
    test:
      /# TODO(wmh): Add in additional class-based baselangs as they are
      /# supported.
      for bl in ('cc',):
        test.defineClassAndMethods('cc')

        print(test.baselang.fqnToTarget('metax'))
        print('FIX this for C++')
        break

        test.iseqmap(
          {
            'namespace': 'metax',
            'target': '//metax:metax',
            'kind': 'namespace',
          },
          test.baselang.fqnToTarget('metax'))
        test.iseqmap(
          {
            'error': 'bad does not represent a valid target',
          },
          test.baselang.fqnToTarget('bad'))
        test.iseqmap(
          {
            'namespace': 'metax.root',
            'target': '//metax/root:root',
            'test_target': '//metax/root_test:root_test',
            'kind': 'namespace',
         },
          test.baselang.fqnToTarget('metax.root'))
        test.iseqmap(
          {
            'namespace': 'metax',
            'error': 'bad is not a namespace or class in metax',
          },
          test.baselang.fqnToTarget('metax.bad'))
        test.iseqmap(
          {
            'namespace': 'metax.root',
            'class': 'Object',
            'target': '//metax/root:Object',
            'test_target': '//metax/root_test:ObjectTest',
            'path': 'metax/root/Object.cc',
            'test_path': 'metax/root_test/ObjectTest.cc',
            'kind': 'class',
          },
          test.baselang.fqnToTarget('metax.root.Object'))
        test.iseqmap(
          {
            'namespace': 'metax.root',
            'class': 'Object',
            'method': 'Init',
            'target': '//metax/root:Object',
            'test_target': '//metax/root_test:ObjectTest',
            'path': 'metax/root/Object.cc',
            'test_path': 'metax/root_test/ObjectTest.cc',
            'test_arg': 'test_Init',
            'kind': 'method',
          },
          test.baselang.fqnToTarget('metax.root.Object.Init'))
        test.iseqmap(
          {
            'namespace': 'metax.root',
            'class': 'Object',
            'target': '//metax/root:Object',
            'test_target': '//metax/root_test:ObjectTest',
            'path': 'metax/root/Object.cc',
            'test_path': 'metax/root_test/ObjectTest.cc',
            'error': 'bad is not a method within metax.root.Object',
          },
          test.baselang.fqnToTarget('metax.root.Object.bad'))

      /# Python is a special case.
      test.defineClassAndMethods('py')
      test.iseqmap(
        {
          'namespace': 'metax',
          'target': '//metax:metax',
          'path': 'metax/__init__.py',
          'kind': 'namespace',
        },
        test.baselang.fqnToTarget('metax'))
      test.iseqmap(
        {
          'error': 'bad does not represent a valid target',
        },
        test.baselang.fqnToTarget('bad'))
      test.iseqmap(
        {
          'namespace': 'metax.root',
          'target': '//metax/root:root',
          'test_target': '//metax/root_test:root_test',
          'kind': 'namespace',
          'path': 'metax/root/__init__.py',
          'test_path': 'metax/root_test/__init__.py',
       },
        test.baselang.fqnToTarget('metax.root'))
      test.iseqmap(
        {
          'namespace': 'metax',
          'error': 'bad is not a namespace or class in metax',
        },
        test.baselang.fqnToTarget('metax.bad'))
      test.iseqmap(
        {
          'namespace': 'metax.root',
          'class': 'Object',
          'target': '//metax/root:root',
          'test_target': '//metax/root_test:root_test',
          'test_arg': 'ObjectTest',
          'kind': 'class',
          'path': 'metax/root/__init__.py',
          'test_path': 'metax/root_test/__init__.py',
        },
        test.baselang.fqnToTarget('metax.root.Object'))
      test.iseqmap(
        {
          'namespace': 'metax.root',
          'class': 'Object',
          'method': 'Init',
          'target': '//metax/root:root',
          'test_target': '//metax/root_test:root_test',
          'test_arg': 'ObjectTest.test_Init',
          'kind': 'method',
          'path': 'metax/root/__init__.py',
          'test_path': 'metax/root_test/__init__.py',
        },
        test.baselang.fqnToTarget('metax.root.Object.Init'))
      test.iseqmap(
        {
          'namespace': 'metax.root',
          'class': 'Object',
          'target': '//metax/root:root',
          'test_target': '//metax/root_test:root_test',
          'error': 'bad is not a method within metax.root.Object',
          'path': 'metax/root/__init__.py',
          'test_path': 'metax/root_test/__init__.py',
        },
        test.baselang.fqnToTarget('metax.root.Object.bad'))
    end;

  end behavior fqnToTarget;

  behavior initializerName : str #:
    The name of the initializer for a given class.

    In most baselangs, this is the name of the class. Specific baselangs
    can override this default implementation (e.g. python).
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      return '__init__'
    test:
      test.tpy()
      test.iseq('__init__', test.baselang.initializerName(test.klass))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if self.config('use_es2015'):
        /# In javascript using ES2015 class definitions, the initializer is
        /# always 'constructor.  See
        /# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\
        /#   Classes
        result = 'constructor'
      else:
        /# Old-style javascript is different than most other languages, in that
        /# the class is defined (not just initialized) by a function with the
        /# same name as the class. The new class syntax of ES2015 is much
        /# cleaner, but this code path is supported in case we want to use
        /# non-class syntax.
        result = klass.id()
      return result
    test:
      test.tjs()
      test.iseq('constructor', test.baselang.initializerName(test.klass))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      return klass.id()
    test:
      test.tcc()
      test.iseq('Person', test.baselang.initializerName(test.klass))
    end receiver OoplCpp;

  end behavior initializerName;

  behavior interpolateString #:
    Given a meta-level string literal, interpolate references.
  params:
    var strlit : str #:
      The string literal containing interpolation requests.
    var output : vec<str> #:
      Where to write output. Must be provided and must have at least one
      string element, to which the first line of output is appended, with
      zero or more additional lines appended by this method.
    var method : ExecutableConstruct = null #:
      If present, perform validation on the symbols references in the
      interpolation string. If not present, blindly assume the symbols exist.
      TODO(wmh): Should this be SymbolConstruct to support interpolation
      requests within field attributes (use symboltable of class)?
    var indent : int = 0 #:
      How many spaces to insert before each line (other than first).
      This is usually 0 because indentation is handled during template
      instantiation instead.
    var width : int = 80 #:
      Maximum width of lines produced. If we are interpolation a template that
      is indented 10 spaces, we'll want this to be 70 for a full width of 80.
      Note that we do not know at the time interpolateString() is called what
      the template-instantiated width is, so we'll have to be conservative.
  scope:

    receiver OoplCpp ::
      pass
    test:
      test.tjs()
      output = []
      test.baselang.interpolateString(
        '${name} is ${.weight}kg and ${!height}m\n'
          '${=name~20s!} ${=.weight<5.1f} ${=!height>2d}',
          output, method=test.method, width=70)
      test.iseqvec([], output)
    end receiver OoplCpp;

    receiver OoplJavascript ::
      pass
    test:
      test.tjs()
      output = []
      test.baselang.interpolateString(
        '${name} is ${.weight}kg and ${!height}m\n'
          '${=name~20s!} ${=.weight<5.1f} ${=!height>2d}',
          output, method=test.method, width=70)
      test.iseqvec([], output)
    end receiver OoplJavascript;

    receiver OoplPython ::
      /# For now we are using python2 '%' syntax, but we may want to move
      /# to python3's 'format' OR perform string concatenation if that turns
      /# out to be more efficient.
      if output is None:
        output = []
      cls = self.__class__

      def Lit(val):
        /# Convert to a string literal in baselang
        /# TODO(wmh): BaseLanguageOopl.literalString could be used, but expects
        /# an Expr arg.
        /# TODO(wmh): Needs to be baselang-generic if we want this method to
        /# be baselang-independent.
        return repr(val)

      /# method.symbols().show()

      parts = []

      start = 0
      for m in cls.InterpolateRE().finditer(strlit):
        s = m.start(0)
        pre = strlit[start:s]
        if pre:
          parts.append(Lit(pre))
        data = m.groupdict()

        /# Establish the variable being references
        /#  - a local variable if no sep
        /#  - a field if sep == '!'
        /#  - a method if sep == '.'
        name = data['id']
        sep = data['sep']
        if not sep:
          /# mostly generic but needs modification in perl.
          namecode = name
        else:
          /# baselang-specific
          rec = data['receiver'] or 'self'
          if sep == '.':
            /# References a method.
            namecode = rec + '.' + name + '()'
          else:
            /# References a field.
            /# TODO(wmh): Generalize how rawfields are produced from fields.
            /# TODO(wmh): Decide whether 'name' encodes rawness or not.
            namecode = rec + '.' + '_' + name

        prefix = data['prefix']
        if prefix == '=':
          parts.append(Lit(name + '='))

        strict = data['strict']
        align = data['align']
        if align:
          /# We need to produce python code to left-align/right-align/center
          /# the text.
          /#  - based on the timing experiments in tests/py/interpolate.py,
          /#    it appears that per-var %-style formatting is fastest.
          if align == '~':
            /# Center alignment.
            thecode = 'metax.root.Object.Center(%s, %s, strict=%s)' % (
              namecode, data['width'], str(strict == '!'))
          else:
            /# We have a left or right alignment with explicit width.
            /#  - we use % notation to do the formatting
            /#  - if strict is present, we need to truncate if too large.
            form = (
              '%' +
              ('-' if align == '<' else '') +
              data['width'] +
              (data['fraction'] or '') +
              (data['type'] or 's')
            )
            thecode = "('" + form + "' % " + namecode + ')'
            if strict:
              thecode = 'metax.root.Object.Trunc(' + thecode + ')'
        else:
          /# No alignment means we format as a string.
          thecode = 'str(' + namecode + ')'
        parts.append(thecode)

        /# Advance to next match.
        start = m.end(0)
      post = strlit[start:]
      if post:
        parts.append(post)

      lastlen = len(output[-1])
      oneline = ' + '.join(parts)
      if len(oneline) + lastlen < width:
        /# We can fit the entire interpolated string on the same line.
        output[-1] += oneline
      else:
        /# We use multiple lines, so we start/end with '(' and ')'.
        indent += 2
        output[-1] += '('
        np = len(parts)
        dent = ' ' * indent
        output.append(dent + parts[0])
        w = indent + len(parts[0])
        for i in range(1, np):
          part = parts[i]
          n = len(part)
          if w + n + 3 < width:
            /# We can fit this part on same line.
            output[-1] += ' + ' + part
            w += n + 3
          else:
            /# We cannot fit this part on same line
            output.append(dent + ' + ' + part)
            w = indent + 3 + n
        output[-1] += ')'

      return output
    test:
      test.newbasic('python')
      code = """
        >|namespace demo.tmp scope:
        >|  class Person scope:
        >|    field name : str;
        >|    field height : float;
        >|    field weight : float;
        >|
        >|    lifecycle Person params:
        >|      var name -> name;
        >|      var height -> height;
        >|      var weight -> weight;
        >|    scope:
        >|    end;
        >|
        >|    method func : float params:
        >|      var arg1 : int;
        >|      var arg2 : str = '';
        >|    scope<*>:
        >|      var local1 : int = 1;
        >|    end;
        >|  end class;
        >|end namespace;
        >|"""
      test.prepMeta(
        /# expand needed to populate params in symbol tables, translate needed
        /# to populate local vars.  TODO(wmh): Should we populate vars in
        /# expandMeta()?
        text=code, basel='python', expand=True, imports=False, translate=True)
      test.method = test.file.child('/demo.tmp/Person/func')
      test.klass = test.method.parentConstruct()
      test.namespace = test.klass.parentConstruct()

      output = ['a = ']
      test.baselang.interpolateString(
        '${name} is ${.weight}kg and ${!height}m\n'
          '${=name~20s!} ${=.weight<5.1f} ${=!height>2d}',
          output, method=test.method, width=70)
      res = '\n'.join(output)
      test.iseqtext("""\
       >|a = (
       >|  str(name) + ' is ' + str(self.weight()) + 'kg and '
       >|   + str(self._height) + 'm\\n' + 'name='
       >|   + metax.root.Object.Center(name, 20, strict=True) + ' '
       >|   + 'weight=' + ('%-5.1f' % self.weight()) + ' ' + 'height='
       >|   + ('%2d' % self._height))""",
       res)
    end receiver OoplPython;

  end behavior interpolateString;

  behavior lazyLines : vec<str> #:
    Define the code to implement a lazy accessor getter.
  params:
    var metafile : metax.c.MetaFile #:
      The metafile being parsed.
    var getter : MethodConstruct #:
      The getter containing the lazy attribute.
    var lazy : metax.attr.Attribute #:
      The lazy attribute.
    var mtype : metax.c.Type #:
      The type of the field.
    var rawfield : str #:
      The baselang rawfield name.
  scope:

    abstract
    receiver BaseLanguageOopl;

    receiver OoplCpp ::
      newlines = []
      resvar = '__meta_result'
      recstr, specstr = self.receiverStr(getter, sep=True)
      if recstr is None:
        recstr = specstr
      rawvar = '%s%s' % (recstr, rawfield)

      if mtype.isPtr():
        /# We can make an efficient copy, so we do not use auto&. That allows
        /# us to assign the ->result to both resvar and recstr.
        newlines.append('auto %s = %s;' % (resvar, rawvar))
      else:
        /# Non-ref assignment will invoke the copy constructor, which we want
        /# to avoid, so we assign by reference. This however means that we
        /# do not need to copy ->result to recstr, as the lazy block will be
        /# directly modifying the desired variable.
        newlines.append('auto& %s = %s;' % (resvar, rawvar))

      if mtype.isValue():
        /# TODO(wmh): We need to decide how 'lazy' applies to value types.
        /#  - if it is an 'int', do we assign if 0, or if it is the special
        /#    value -2^(size)?
        /#  - if it is a 'float', the default value is 0.0, so unless we want
        /#    to change the default to NaN, we must assume that lazy semantics
        /#    is desired for value 0.0, not for NaN.
        newlines.append('if (!%s) {' % resvar)
      else:
        /# TODO(wmh): If mtype is a 'str', and we are implementing 'str' as
        /# absl::string_view, we need to instead check var.data() == nullptr.
        newlines.append('if (%s == nullptr) {' % resvar)

      /# TODO(wmh): Handle complex block! This portion can be a submethod
      /# as it is common to all baselangs.
      lazylines = lazy.value()
      for i in range(0, len(lazylines)-1):
        newlines.append('  ' + lazylines[i])
      lazyend = lazylines[-1][:3]
      if lazyend != '-> ':
        metafile.error(
          'Expecting lazy: block of accessor to end with line '
          'starting "-> " not "%s"' % (lazyend), line=lazy.line())

      resval = lazylines[-1][3:]
      if mtype.isPtr():
        newlines.append('  %s = %s;' % (resvar, resval))
        newlines.append('  %s = %s;' % (rawvar, resvar))
      newlines.append('}')  # ends 'if' above.
      newlines.append('return %s;' % resvar)

      return newlines
    test:
      /# Setup the args needed to invoke lazylines.
      test.tcc()
      baselang = test.baselang
      primary_line = 17
      ftype = metax.c.Type.Instance(
        '*A', namespace_function=lambda: test.namespace)
      lazy = metax.attr.ComplexBlock(None, 'scope:', ['a = new A();', '-> a'])
      getter = metax.oopl.MethodConstruct.NewFromData(
        'somegetter', test.context,
        secondaries=[
          (':', ftype),
          ('scope:', ['return self._somegetter;'], primary_line),
        ],
        primary_line=primary_line)
      getter.myclassIs(test.klass)

      /# Invoke lazylines and confirm output
      lines = baselang.lazyLines(
        test.metafile, getter, lazy, ftype, '_somegetter')
      test.isfalse(test.metafile.hasErrors(show=True))
      test.iseqvec(
        [
          'auto __meta_result = this->_somegetter;',
          'if (__meta_result == nullptr) {',
          '  a = new A();',
          '  __meta_result = a;',
          '  this->_somegetter = __meta_result;',
          '}',
          'return __meta_result;',
        ],
        lines)
    end receiver OoplCpp;

    abstract
    receiver OoplJavascript #:
      Fix me (only abstract to avoid generating test method).

    receiver OoplPython ::
      newlines = []
      resvar = '__meta_result'
      recstr, specstr = self.receiverStr(getter, sep=True)
      if recstr is None:
        recstr = specstr
      rawvar = '%s%s' % (recstr, rawfield)
      newlines.append('%s = %s' % (resvar, rawvar))

      if mtype.isValue():
        newlines.append('if not %s:' % resvar)
      else:
        newlines.append('if %s is None:' % resvar)

      /# TODO(wmh): Handle complex block! This portion can be a submethod
      /# as it is common to all baselangs.
      lazylines = lazy.value()
      for i in range(0, len(lazylines)-1):
        newlines.append('  ' + lazylines[i])
      lazyend = lazylines[-1][:3]
      if lazyend != '-> ':
        metafile.error(
          'Expecting lazy: block of accessor to end with line '
          'starting "-> " not "%s"' % (lazyend), line=lazy.line())

      resval = lazylines[-1][3:]
      newlines.append('  %s = %s' % (resvar, resval))
      newlines.append('  %s = %s' % (rawvar, resvar))
      newlines.append('return ' + resvar)

      return newlines
    test:
      /# Setup the args needed to invoke lazylines.
      test.tpy()
      baselang = test.baselang
      primary_line = 17
      ftype = metax.c.Type.Instance('int')
      lazy = metax.attr.ComplexBlock(None, 'scope:', ['a = 77', '-> a'])
      getter = metax.oopl.MethodConstruct.NewFromData(
        'somegetter', test.context,
        secondaries=[
          (':', ftype),
          ('scope:', ['return self._somegetter'], primary_line),
        ],
        primary_line=primary_line)
      getter.myclassIs(test.klass)

      /# Invoke lazylines and confirm output
      lines = baselang.lazyLines(
        test.metafile, getter, lazy, ftype, '_somegetter')
      test.isfalse(test.metafile.hasErrors(show=True))
      test.iseqvec(
        [
          '__meta_result = self._somegetter',
          'if not __meta_result:',
          '  a = 77',
          '  __meta_result = a',
          '  self._somegetter = __meta_result',
          'return __meta_result',
        ],
        lines)
    end receiver OoplPython;

  end behavior lazyLines;

  behavior literalString : str #:
    Provides a baselang-specific representation of a literal string.
  params:
    var expr : Expr #:
      An expr of kind 'str'.
  scope:

    receiver OoplCpp ::
      /# Strings must be quoted using ".
      assert expr.kind() == 'str'
      value = expr.value()
      delim = "\""
      if not value:
        raise metax.c.Error('Not supporting empty literal strings')
      if value[0] == "'":
        value = value[1:-1]
        /# TODO(wmh): Properly escape unescaped double quotes in value
        result = delim + value + delim
      elif value[0] != delim:
        /# TODO(wmh): Properly escape unescaped double quotes in value
        result = delim + value + delim
      else:
        result = value
      return result
    test:
      test.tcc()
      test.iseq('""', test.baselang.literalString(metax.c.Expr.FromStr("''")))
      test.iseq('""', test.baselang.literalString(metax.c.Expr.FromStr('""')))
      test.iseq(
        '"Hello World!"',
        test.baselang.literalString(metax.c.Expr.FromStr('"Hello World!"')))
      test.iseq(
        '"Hello World!"',
        test.baselang.literalString(metax.c.Expr.FromStr("'Hello World!'")))
    end receiver OoplCpp;

    receiver OoplJavascript ::
      /# Strings must be quoted, but can use either ' or ". We use whatever the
      /# user used when specifying it in meta syntax.
      assert expr.kind() == 'str'
      return expr.asStr(quote=True)
    test:
      test.tjs()
      test.iseq("''", test.baselang.literalString(metax.c.Expr.FromStr("''")))
      test.iseq('""', test.baselang.literalString(metax.c.Expr.FromStr('""')))
      test.iseq(
        '"Hello World!"',
        test.baselang.literalString(metax.c.Expr.FromStr('"Hello World!"')))
    end receiver OoplJavascript;

    receiver OoplPython ::
      /# Strings must be quoted, but can use either ' or ". We use whatever the
      /# user used when specifying it in meta syntax. However, in order to be
      /# both python2 and python3 compliant, we preface all literal strings with
      /# a unicode indicator.
      assert expr.kind() == 'str'
      return expr.asStr(quote=True)
    test:
      test.tpy()
      test.iseq("''", test.baselang.literalString(metax.c.Expr.FromStr("''")))
      test.iseq('""', test.baselang.literalString(metax.c.Expr.FromStr('""')))
      test.iseq(
        '"Hello World!"',
        test.baselang.literalString(metax.c.Expr.FromStr('"Hello World!"')))
    end receiver OoplPython;

  end behavior literalString;

  behavior metaMethodBody : vec<str> #:
    Returns the list of lines in baselang syntax used to implement the
    special 'meta' method in every user-level class to return the
    singleton instance of the metaclass.
  params:
    var metainst : str #:
      The name of the baselang variable containing the metaclass instance.
    var metaclass : metax.oopl.ClassConstruct #:
      The metaclass construct. May be null, in which case there is no
      metaclass ... appropriate code should be returned for that situation.
  scope:

    abstract
    receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      if metaclass:
        meta_body = ['return %s;' % metainst]
      else:
        meta_body = ['return nullptr;']
      return meta_body
    test:
      test.tcc(expand=True)
      test.iseqvec(
        ['return MetaPerson;'],
        test.baselang.metaMethodBody('MetaPerson', test.klass.metaclass()))
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      if metaclass:
        meta_body = ['return %s;' % metainst]
      else:
        meta_body = ['return null;']
      return meta_body
    test:
      test.tjs(expand=True)
      test.iseqvec(
        ['return MetaPerson;'],
        test.baselang.metaMethodBody('MetaPerson', test.klass.metaclass()))
    end receiver OoplJavascript;

    receiver OoplPython scope:
      if metaclass:
        meta_body = []
        meta_body.append('result = self.__class__')
        /# TODO(wmh): The following code use to do the following:
        /#   assert result is <class>
        /#   assert result is Meta<class>
        /# However, this breaks in situations where a class does not generate
        /# an implicit 'meta' method (e.g. classes that do not generate a
        /# meta class).  So we have changed the code to:
        /#   assert issubclass(result, <class>)
        /#   assert issubclass(result, Meta<class>)
        /# Look into whether this needs further cleanup/removal/reversion.

        meta_body.append(
          'assert issubclass(result, %s)' % metaclass.underclass().id())
        underclass = metaclass.underclass()
        if not underclass.isTestCase():
          /# CODETANGLE(metainst_for_testclass): We do not currently generate
          /#   MetaFooTest = FooTest
          /# for testcase classes because it causes every method defined on
          /# the test class to be executed twice.
          meta_body.append('assert issubclass(result, %s)' % metainst)
        meta_body.append('return result')
      else:
        meta_body = ['return None']
      return meta_body
    test:
      test.tpy(expand=True)
      test.iseqvec(
        ['result = self.__class__',
         'assert issubclass(result, Person)',
         'assert issubclass(result, MetaPerson)',
         'return result'],
        test.baselang.metaMethodBody('MetaPerson', test.klass.metaclass()))
    end receiver OoplPython;

  end behavior metaMethodBody;

  behavior parseBazelLog : any #:
    Perform baselang-specific parsing of a bazel test log file.

    Writes addiitonal keys into 'tdata'
  params:
    var logdata : str #:
      The entire content of the logfile.
    var tdata : map #:
      Where to write info.  The following keys must be provided:
        status2: str
          One of 'FATAL' or ...
        count: int
          Number of tests ran
        time2: str
          Amount of time taken to run all tests (num plus time unit)
        methods: dict
          maps class.method to map:
            stdout: str
              the stdout of the test method
            stderr: str
              the stderr of the test method
            us: int
              microseconds taken for this method test
            ok: bool
              True if test passed, false if it failed.
    var debug : bool = false #:
      If true, enable debugging output.
  scope:

    abstract
    receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      if debug:
        dsep('OoplCpp.parseBazelLog Input', delim='@')
        print(logdata)
        print(tdata)
        dsep('OoplCpp.parseBazelLog Input', delim='@', end=True)
      methods = tdata['methods']

      /# Parse the test.log file. You can see the output interactively with:
      /#   % cd ./tests/cc/gtest/src
      /#   % blaze test --test_output=all :PersonTest
      /#
      /# Contains following structure
      /#   exec ${PAGER:-/usr/bin/less} "$0" || exit 1
      /#   ---------------------------------------------------------------
      /#   <env_initializer_output>
      /#   [==========] Running <M> tests from <N> test case.
      /#   [----------] Global test environment set-up.
      /#   <env_setup_output>
      /#   [----------] <M> tests from FrenchDeckTest
      /#   <clsetup_output>
      /#   [ RUN      ] <class>Test.test_<method>
      /#   <initializer_output>
      /#   <setup_output>
      /#   <output>
      /#   <teardown_output>
      /#   <finalizer_output>
      /#   [       OK ] <class>Test.test_<method> (<ms> ms)
      /#   [ RUN      ] <class>Test.test_<method2>
      /#   <*_output2>
      /#   ...
      /#   [  FAILED  ] <class>Test.test_<method2> (<ms2> ms)
      /#   [ RUN      ] <class>Test.test_<method3>
      /#   <*_output3>
      /#   ...
      /#   [       OK ] <class>Test.test_<method3> (<ms3> ms)
      /#   ...
      /#   <clteardown_output>
      /#   [----------] <M> tests from <class>Test (<class_ms> ms total)
      /#
      /#   [----------] Global test environment tear-down
      /#   <env_teardown_output>
      /#   [==========] 3 tests from 1 test case ran. (1 ms total)
      /#   [  PASSED  ] 2 tests.
      /#   [  FAILED  ] 1 test, listed below:
      /#   [  FAILED  ] FrenchDeckTest.test_asStr
      /#
      /#    1 FAILED TEST
      /#   <env_finalizer_output>
      /#
      /# where
      /#   <env_initializer_output>
      /#     output in the initializer of the global Environment subclass
      /#     (usually not provided unless we make it a namespace-wide option).
      /#   <env_setup_output>
      /#     output from Environment::SetUp()
      /#   <clsetup_output>
      /#     output from <class>Test::SetUpTestCase()
      /#   <initializer_output>
      /#     output from <class>Test::<class>Test
      /#   <setup_output>
      /#     output from <class>Test::SetUp()
      /#   <output>
      /#     output from <class>Test::test_<method>
      /#   <teardown_output>
      /#     output from <class>Test::TearDown()
      /#   <finalizer_output>
      /#     output from <class>Test::~<class>Test
      /#   <clteardown_output>
      /#     output from <class>Test::TearDownTestCase()
      /#   <env_teardown_output>
      /#     output from Environment::TearDown()
      /#   <env_finalizer_output>
      /#     output from Environment::~Environment()

      def StrToMicroSeconds(tstr):
        assert tstr.endswith(' ms')
        return int(tstr[:-3]) * 1000

      /# The following is a collection of regexps that should match lines in
      /# logdata. Any line not matching one of these is output associated with
      /# the section identified by the current index.
      /#
      /# Index 7 is special in that we can transition either to index 8 or
      /# index 5 (this cycle allows us to parse multiple test methods).
      regexps = [
        re.compile(r'^exec.*PAGER.*exit'),
        re.compile(r'^---{50,}$'),
        re.compile(
          r'\[==========\] Running (?P<count>\d+) tests from 1 test case\.$'),
        re.compile(
          r'\[----------\] Global test environment set-up\.$'),
        re.compile(
          r'\[----------\] (?P<count>\d+) tests from (?P<class>\S+)Test$'),

        /# This starts the parsing of a test method
        re.compile(
          r'\[ RUN      \] (?P<class>\S+)Test\.test_(?P<method>\S+)$'),

        /# This ends the parsing of a test method.
        re.compile(
          r'\[\s*(?P<mstatus>OK|FAILED)\s*\] '
          r'(?P<class>\S+)Test\.test_(?P<method>\S+) \((?P<mtime>\d+\s*\S+)\)'),

        /# This is the special regexp ... if we are looking for this one,
        /# we need to also check for index 5 (if index 5 matches, we loop
        /# back, processing another test).
        re.compile(
          r'\[----------\] (?P<count>\d+) tests from (?P<class>\S+)Test '
          r'\((?P<time2>\d+ \S+) total\)$'),

        re.compile(
          r'\[----------\] Global test environment tear-down'),
        re.compile(
          r'\[==========\] (?P<count>\d+) tests from 1 test case ran.*'),
        re.compile(r'\[  PASSED  \] (?P<passed>\d+) tests\.'),
        re.compile(r'\[  FAILED  \] (?P<failed>\d+) test, listed below:'),
      ]

      outputs = {5: ['']}
      matches = {}
      order = []
      index = 0

      if debug:
        print('@' * 70)
        print(logdata)
        print('@' * 70)

      for line in logdata.split('\n'):
        if debug:
          print('### %s' % line)
        if index >= len(regexps):
          outputs.setdefault(index, []).append(line)
        else:
          m = regexps[index].match(line)
          if m:
            /# We have found a new regexp. We advance the regexp index. Any
            /# line that doesn't match against the next regexp is added to
            /# outputs[index-1] (with index 7 being special).
            if debug:
              print(
                'Found index %d: %s for %s' %
                (index, str(m.groupdict()), line))
            matches[index] = m.groupdict()
            index += 1
          else:
            /# For every index except 7, the only transition is to index+1.
            /# However, at index 7, we can transition to either 8 or 5, so
            /# the code below checks for the transition to 5.  This means
            /# we are finished parsing one test method and are parsing
            /# another (instead of finishing the parsing of methods).
            if index == 7:
              m = regexps[5].match(line)
              if m:
                /# We are current on the line after the line matching index 6.
                /# There are only two possible matches:
                /#  1) it matches index 7, which ends the method-specific part
                /#     of parsing
                /#  2) it matches index 5, the start of another unittest.
                /#
                /# We are in situation #2 ... it matches index 5. This means
                /# we've just finished processing a test method, with the
                /# (merged) stdout and stderr available in outputs[5] and
                /# some additional info available in matches[5] and matches[6]
                order.append((matches[5], matches[6], outputs[5]))
                matches[5] = m.groupdict()
                outputs[5] = []
                index = 6
              else:
                outputs.setdefault(index - 1, []).append(line)
            else:
              /# The current line did not match next (or prev) regexp, so
              /# it belongs to the output for index-1.
              outputs.setdefault(index - 1, []).append(line)
              if index == 8:
                /# We've matched index 7, so we've parsed the final test method.
                order.append((matches[5], matches[6], outputs[5]))

      /# Now we parse 'order' into 'methods'
      for start_dict, end_dict, outlines in order:
        assert start_dict['class'] == end_dict['class']
        assert start_dict['method'] == end_dict['method']
        cmname = '%s.%s' % (start_dict['class'], start_dict['method'])
        ok = end_dict['mstatus'] == 'OK'
        mdata = {
          'us': StrToMicroSeconds(end_dict['mtime']),
          'ok': ok
        }
        stdout = []
        stderr = []
        tlines = stdout
        tre = re.compile(r': Failure$')
        if outlines:
          if outlines[0] == '':
            outlines.pop(0)
          /# We assume everything in outlines is stdout until we find a line
          /# matching tre, after which we assume everything is stderr.
          for line in outlines:
            m = tre.search(line)
            if m:
              tlines = stderr
            tlines.append(line)
        if stdout:
          mdata['stdout'] = '\n'.join(stdout)
        if stderr:
          mdata['stderr'] = '\n'.join(stderr)
        methods[cmname] = mdata

      /# Establish overall status2
      if 11 in matches:
        print('HERE with %s' % matches[11])
        assert matches[11]['failed'] != '0'
        status = 'FAILED'
      else:
        status = 'OK'
      tdata['status2'] = status

      /# Establish count of number of tests.
      count = matches[7]['count']
      assert count == matches[4]['count']
      tdata['count2'] = int(count)

      /# Establish time taken for all tests.
      tdata['time2'] = matches[7]['time2']

      if debug:
        for i in sorted(outputs):
          print(i)
          for line in outputs[i]:
            print('  ' + line)
        pprint.pprint(matches)
        pprint.pprint(order)
        for key in methods:
          print('%-20s: %s' % (key, methods[key]))

    test:
      logdata = (
        >|"""exec ${PAGER:-/usr/bin/less} "$0" || exit 1
        >|-------------------------------------------------------------------
        >|[==========] Running 3 tests from 1 test case.
        >|[----------] Global test environment set-up.
        >|[----------] 3 tests from FrenchDeckTest
        >|[ RUN      ] FrenchDeckTest.test_FrenchDeck
        >|Fix C++ teardown
        >|[       OK ] FrenchDeckTest.test_FrenchDeck (0 ms)
        >|[ RUN      ] FrenchDeckTest.test_asStr
        >|unknown file: Failure
        >|C++ exception with description "TestCase.iseq() not yet implemented" thrown in the test body.
        >|Fix C++ teardown
        >|[  FAILED  ] FrenchDeckTest.test_asStr (1 ms)
        >|[ RUN      ] FrenchDeckTest.test_meta
        >|Fix C++ teardown
        >|[       OK ] FrenchDeckTest.test_meta (0 ms)
        >|[----------] 3 tests from FrenchDeckTest (1 ms total)
        >|
        >|[----------] Global test environment tear-down
        >|[==========] 3 tests from 1 test case ran. (1 ms total)
        >|[  PASSED  ] 2 tests.
        >|[  FAILED  ] 1 test, listed below:
        >|[  FAILED  ] FrenchDeckTest.test_asStr
        >|
        >| 1 FAILED TEST
        >|""")
      tdata = {
        'methods': {},
      }
      baselang, _, _, _ = test.cachedInfo('cc')
      baselang.parseBazelLog(logdata, tdata, debug=False)

      test.iseq(
        {'count2': 3,
         'status2': 'FAILED',
         'time2': '1 ms',
         'methods': {
           'FrenchDeck.FrenchDeck': {
             'ok': True,
             'stdout': 'Fix C++ teardown',
             'us': 0,
           },
           'FrenchDeck.asStr': {
             'ok': False,
             'stderr': (
               'unknown file: Failure\nC++ exception with description '
               '"TestCase.iseq() not yet implemented" thrown in the test '
               'body.\nFix C++ teardown'
             ),
             'us': 1000,
           },
           'FrenchDeck.meta': {
             'ok': True,
             'stdout': 'Fix C++ teardown',
             'us': 0,
           },
         },
        }, tdata, pprint.pformat(tdata))
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      methods = tdata['methods']

      if debug:
        dsep('OoplJavascript.parseBazelLog Input', delim='@')
        print(logdata)
        print(tdata)
        dsep('OoplJavascript.parseBazelLog Input', delim='@', end=True)

      msre = re.compile(r'^(\d{2}):(\d{2}):(\d{2})\.(\d{3})$')

      def StrToMs(val):
        /# Convert a string in form HH:MM:SS.mmm into milliseconds.
        m = msre.match(val)
        if not m: raise metax.c.Error('Invalid ms "%s"' % val)
        seconds = (
          int(m.group(1)) * 3600 + int(m.group(2)) * 60 + int(m.group(3)))
        ms = seconds * 1000 + int(m.group(4))
        return ms

      class_start_re = re.compile(
        r'\n-> (?P<time>\S+) : Starting tests: (?P<fqn>\S+)\n')
      class_end_re = re.compile(
        r'\n-> (?P<time>\S+) : (?P<runcount>\d+) of (?P<count>\d+) tests run in '
        r'(?P<duration>\S+)\.\n')
      method_start_re = re.compile(
        r'^-> (?P<time>\S+) : Running test: (?P<method>\S+)')

      tdata['status2'] = '???'

      ms = class_start_re.search(logdata)
      me = class_end_re.search(logdata)
      if ms and me:
        fqn = ms.group('fqn')
        parts = fqn.split('.')
        class_name = metax.oopl.ClassConstruct.UntestifyName(parts[-1])
        namespace_name = '.'.join(parts[:-1])

        tdata['subcount'] = int(me.group('runcount'))
        tdata['count'] = int(me.group('count'))
        tdata['time2'] = me.group('duration')

        methdata = logdata[ms.end(0):me.start(0)]
        if methdata.strip():
          end_re = None
          method = None
          stdout = None

          if debug:
            print(methdata)
            print('=' * 70)

          for line in methdata.split('\n'):
            m = method_start_re.match(line)
            if m:
              test_method_name = m.group('method')
              method_name = metax.oopl.ExecutableConstruct.UntestifyName(test_method_name)
              end_re = re.compile(
                r'^-> (?P<time>\S+) : %s : (?P<status>\S+)' % test_method_name)
              cmname = class_name + '.' + method_name
              stdout = []

              if debug:
                print('Found test method: %s' % str(m.groupdict()))

              mdata = methods.setdefault(cmname, {})
              mdata['start'] = m.group('time')
            elif end_re is None:
              print('**** IGNORING %s' % line)
            else:
              /# We should always find a method_start before we need end_re.
              m = end_re.match(line)
              if m:
                /# Found end of method.
                mdata['stdout'] = '\n'.join(stdout)
                /# TODO(wmh): Where is stderr written??? Remember that this
                /# isn't necessarily actually stderr, but rather any error
                /# output produced while running the test.
                /# NOTE(wmh): Only add 'stderr' if there are actual errors.
                mdata['end'] = m.group('time')
                mdata['us'] = (StrToMs(mdata['end']) - StrToMs(mdata['start'])) * 1000
                if debug:
                  print('Found end of method: %s' % str(mdata))
                end_re = None
                stdout = None
              else:
                assert line.startswith('-> ')
                stdout.append(line[3:])

          if stdout:
            print('***** ERROR! Have left-over stdout')
            print('\n'.join(stdout))

          if debug:
            print('@' * 70)

      else:
        print('ERROR: Failed to find class tests!')

      /#import pprint; pprint.pprint(tdata)
    test:
      /# TODO(wmh): Fix this!
      if False:
        print('Awaiting data on what arg content should look like.')
    end receiver OoplJavascript;

    receiver OoplPython scope:
      if debug:
        dsep('OoplPython.parseBazelLog Input', delim='@')
        print(logdata)
        print(tdata)
        dsep('OoplPython.parseBazelLog Input', delim='@', end=True)
      methods = tdata['methods']

      /# Parse the test.log file.  Contains following structure
      /#   exec ${PAGER:-/usr/bin/less} "$0" || exit 1
      /#   -----------------------------------------------------------------------------
      /#   <one_char_per_test>
      /#   <errors>
      /#   ----------------------------------------------------------------------
      /#   <summary>
      /#
      /#   <status>
      /#   <stdout>
      /#
      /# where
      /#   <one_char_per_test> is '.' or 'E' or ?
      /#   <errors> starts with a line of '======'
      /#   <summary> is of form "Ran 2 tests in 0.001s"
      /#   <status> is of form "FAILED (errors=1)" or "OK"
      /#   <stdout> is the stdout from the test
      /#     - when using Meta infrastructure, setUp() prints out the name
      /#       of the class and method followed by '...'
      /#     - the code executed by the test may add arbitrary output
      /#     - the Meta infrastructure, in tearDown(), prints out the
      /#       time taken in microseconds and ERROR or FAIL if error occurred.
      summary_re = re.compile(
        r'\nRan (?P<count>\d+) tests? in (?P<time>\S+)')
      status_re = re.compile(
        r'\n(?P<status>FAILED|OK)(?: \((?P<counts>\S+)\))?\s*')
      sum = summary_re.search(logdata)
      stat = status_re.search(logdata)
      if not sum or not stat:
        print()
        print('summary: %s' % sum)
        print('status : %s' % stat)
        print(logdata)
        print('ERROR: Failed to find expected match(es)')
        tdata['status2'] = 'FATAL'
        return

      statdata = stat.groupdict()
      sumdata = sum.groupdict()
      /# print('#' * 70; print target; print statdata; print sumdata)

      tdata['count'] = int(sumdata['count'])
      tdata['time2'] = sumdata['time']
      tdata['status2'] = statdata['status']

      /# Obtain error text
      /#  - everything before the start of the sum match if ============ exists
      eqidx = logdata.find('\n=======================')
      if eqidx == -1:
        errors = ''
      else:
        errors = logdata[eqidx:sum.start(0)]
      /#print(errors)

      /# Now parse the error text
      /#  - after splitting, edata will contain 3K+1 elements where K is the
      /#    number of errors
      /#  - index 0 is text before the first error
      /#     - stdout from code outside test method invocations (useful for
      /#       debugging).
      /#  - within the 3-tuple:
      /#     - index 0 is the name of the method
      /#     - index 1 is the name of the class
      /#     - index 2 is the error text
      ere = re.compile(r'\nERROR: test_(\S+)\s+\(\S+\.(\S+)\)\n')
      edata = ere.split(errors)
      n = len(edata)
      assert (n-1) % 3 == 0
      preout = edata[0].strip()
      if False and preout:
        print('-' * 70)
        print(preout)
        print('-' * 70)
        pprint.pprint(edata)

      i = 1
      while i < n:
        method_name = edata[i]
        class_name = edata[i+1]
        assert class_name.endswith('Test')
        class_name = class_name[:-4]
        cmname = class_name + '.' + method_name
        stderr = edata[i+2]
        methods.setdefault(cmname, {})['stderr'] = stderr
        i += 3

      /# Parse the stdout
      /#  - everything after the end of the stat match.
      /#  - consists of
      /#     <class>.<method>     ...<stdout> <time> <status>
      /#    where
      /#      <class> is the name of the class being tested (not test class)
      /#      <method> is the name of the method being tested (not test method)
      /#      <stdout> is whatever was written to stdout when test was run.
      /#               (may contain newlines)
      /#      <time> is how long the test took (<num> ' us')
      /#      <status> is optional and is either ERROR or FAILED
      stdout = logdata[stat.end(0)-1:]  # -1 so we start on a newline (ore below relies on it)
      if stdout[0] != '\n':
        print('#' * 70)
        print(logdata)
        print('-' * 70)
        print(stdout)
        print('#' * 70)
        return

      ore = re.compile(
        r'\n(?P<cmname>[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+)\s+\.\.\.')
      tre = re.compile(r' *(?P<us>\d+) us\s+')
      olines = ore.split(stdout)
      n = len(olines)
      assert (n-1) % 2 == 0
      /# There are 2K+1 elements in olines (first element is text before
      /# first method (ignored)). Within each pair of elements thereafter,
      /# first is class.method, second is output (including time at end)
      i = 1
      while i < n:
        cmname = olines[i]
        stdout = olines[i+1]
        tm = tre.search(stdout)
        mdata = methods.setdefault(cmname, {})
        if not tm:
          raise metax.c.Error('Failed to parse microseconds from "%s"' % stdout)
        mdata['us'] = int(tm.group('us'))
        /# We remove the time data from stdout
        stdout = stdout[:tm.start(0)]
        mdata['stdout'] = stdout
        i += 2
    test:
      test.tpy()

      /# tdata has both input keys (must exist when invoked) and output keys
      /# (written into tdata by invocation).
      tdata = {
        'methods': collections.OrderedDict(),
        /# 'status': 'FAILED',
        /# 'time': '0.2s',
        /# 'target': '//demo/cards2_test:FrenchPackTest',
        /# 'cached': None,
        /# 'logpath': '/Users/wmh/src/meta/src/kernel/testdata/sample_logs/demo/cards2_test/FrenchPackTest/test.log',
        /# 'namespace': 'demo.cards2',
        /# 'class': 'FrenchPack',
        /# 'dir': '/Users/wmh/src/meta/src/kernel/testdata/sample_logs/demo/cards2_test/FrenchPackTest',
        /# 'log': 'exec ${PAGER:-/usr/bin/less} "$0" || exit 1\n-----------------------------------------------------------------------------\n.E\n======================================================================\nERROR: test_asStr (__main__.FrenchPackTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File "/private/var/tmp/_bazel_wmh/8a547b9529defa4d451cf083bf4156d1/bazel-sandbox/e96aaaed-7873-4fb6-a866-0c97391c7dd1-0/execroot/python/bazel-out/local-fastbuild/bin/demo/cards2_test/FrenchPackTest.runfiles/__main__/demo/cards2_test/FrenchPackTest.py", line 13, in test_asStr\n    card = demo.cards2.Card(1, 2)\nAttributeError: \'module\' object has no attribute \'Card\'\n\n----------------------------------------------------------------------\nRan 2 tests in 0.001s\n\nFAILED (errors=1)\nFrenchPack.__init__                      ...demo.cards2.FrenchPack.__init__ missing unittest\n      14 us  \nFrenchPack.asStr                         ...     163 us  ERROR\n',
      }

      test.baselang.parseBazelLog(
        >|"""\
        >|exec ${PAGER:-/usr/bin/less} "$0" || exit 1
        >|-----------------------------------------------------------------------------
        >|.E
        >|======================================================================
        >|ERROR: test_asStr (__main__.FrenchPackTest)
        >|----------------------------------------------------------------------
        >|Traceback (most recent call last):
        >|  File "/private/var/tmp/_bazel_wmh/8a547b9529defa4d451cf083bf4156d1/bazel-sandbox/e96aaaed-7873-4fb6-a866-0c97391c7dd1-0/execroot/python/bazel-out/local-fastbuild/bin/demo/cards2_test/FrenchPackTest.runfiles/__main__/demo/cards2_test/FrenchPackTest.py", line 13, in test_asStr
        >|    card = demo.cards2.Card(1, 2)
        >|AttributeError: 'module' object has no attribute 'Card'
        >|----------------------------------------------------------------------
        >|Ran 2 tests in 0.001s
        >|FAILED (errors=1)
        >|""",
        tdata)
      test.iseq(
        ['count', 'methods', 'status2', 'time2'],
        sorted(tdata))
      test.iseq(['FrenchPack.asStr'], sorted(tdata['methods']))
    end receiver OoplPython;

  end behavior parseBazelLog;

  behavior processTestOutput #:
    Process the output of non-bazel execution of the baselang test harness.
    Note that various baselangs rely on bazel to provide a testing harness,
    cannot be invoked without bazel (and thus don't have a definition here).
  params:
    var stdout : str #:
      The stdout produced by invoking the non-bazel test harness.
    var stderr : str #:
      The stderr produced by invoking the non-bazel test harness.
    var cwd : str #:
      The directory from which to process.
    var namespace : str #:
      The namespace under test.
    var nofilt : bool = false #:
      If true, do not filter the stdout/stderr, just print verbatim
    var timestamp : float = 0.0 #:
      Unix timestamp of when the test run was invoked.
    var verbosity : int = 0 #:
      0 = Show only errors
      1 = Show one line for each method, and full errors
    var fp : ostream = out #:
      Where to write the output.
  scope:

    receiver OoplPython scope:
      if nofilt:
        filterr = stderr
        if stdout:
          dsep(title='stdout')
          fp.write(u'' + stdout + '\n')
        if stderr:
          dsep(title='stderr')
          /#print(stderr)
          fp.write(u'' + filterr + '\n')
        if stdout or stderr:
          dsep(end=True)
        return

      import io
      vv = metax.root.SafeStr(stderr or '')
      /# print('*** HERE with %s' % repr(vv))
      ifp = io.StringIO(vv)
      efp = io.StringIO()
      metac = self.compiler()
      metac.filterMetaOutput(cwd=cwd, ifp=ifp, ofp=efp, debug=False)
      fs = metac.fs()
      filterr = efp.getvalue()

      /# Perform base-to-meta line mapping on stderr
      outlines = metax.root.SafeStr(stdout).split('\n')
      errlines = metax.root.SafeStr(filterr).split('\n')

      /# Establish some vars.
      outre = re.compile(
        /# CODE TANGLE(methstart)
        r'^(?P<fqn>\S+)\s+\.\.\. (?P<rest>.*)')
      timere = re.compile(
        r'^(?P<head>.*?)\s+(?P<us>\d+) us  (?:(?P<status>.*))?$')
      failre = re.compile(
        r'^(?P<status>FAIL|ERROR): test_(?P<method>\S+) \(\S+\.(?P<class>\S+)Test\)')
      sepre = re.compile('^(?P<c>[=-])(?P=c){60,}')
      ranre = re.compile(r'^Ran (?P<numtests>\d+) tests? in (?P<seconds>\S+)s')

      def PrintStripped(data, prefix):
        """Strip leading/trailing lines of whitespace from data list."""
        i = 0
        n = len(data)
        if False:
          /# We should NOT be stripping blank leading/trailing lines if they
          /# represent actual output produced by the code ... if spurious
          /# blank lines are being introduced, fix that issue rather than
          /# stripping potentially valuable empty lines from actual output.
          while i < n and not data[i].strip():
            i += 1
          while n > 0 and not data[n-1].strip():
            n -= 1
        for j in range(i, n):
          dstr = metax.root.SafeStr(data[j])
          fp.write(u'' + prefix + dstr + '\n')

      /# We'll add one dict per test to data, merging stdout and stderr.
      /#   name: str
      /#     fqn of test.
      /#   time: int
      /#     number of microseconds
      /#   stdout: vec<str>
      /#   stderr: vec<str>
      data = []
      /# datamap maps fqn name to the same dict stored in data for that fqn.
      datamap = {}

      /# Parse stdout
      /#  - we are expecting lines of the form:
      /#      <class>.<method>                   ...    <time> us  [<status>]
      /#    optionally followed by output from a test method.
      current_fqn = None
      for line in outlines:
        m = outre.match(line)
        if m:
          fqn = m.group('fqn')
          item = {
            'fqn': fqn, 'stdout': [], 'stderr': [], 'status': None,
            'time': None}
          rest = m.group('rest')
          tm = timere.match(rest)
          if tm:
            /# We have a time for this test ... no output expected.
            item['time'] = int(tm.group('us'))
            item['status'] = tm.group('status')
            current_fqn = None
          else:
            /# We did not find a time for this test, which means the test
            /# produced some output on stdout. We consume it in subsequent
            /# iterations through the loop, until we find a line ending in
            /# a timespec.
            current_fqn = fqn
            item['stdout'].append(rest)
          data.append(item)
          datamap[fqn] = item
        else:
          if current_fqn is None:
            /# We are not currently expecting output
            if line.strip():
              fp.write(u'UNKNOWN STDOUT: %s\n' % line)
          else:
            /# This is stdout for current_fqn
            item = datamap[current_fqn]
            tm = timere.match(line)
            if tm:
              /# We've found the end of expected stdout
              current_fqn = None
              item['time'] = int(tm.group('us'))
              item['status'] = tm.group('status')
              head = tm.group('head')
              if head:
                item['stdout'].append(head)
            else:
              item['stdout'].append(line)

      /# Parse stderr
      /#  - we are expecting records of the form:
      /#
      /#      =================================================================
      /#      ERROR: test_attrinfo (__main__.ContextTest)
      /#      -----------------------------------------------------------------
      /#      Traceback (most recent call last):
      /#        File "metax/c_test/__init__.py", line 1610, in setUp
      /#          _, _, _, compiler = self.cachedInfo(metal='meta')
      /#      AttributeError: 'ContextTest' object has no attribute 'cachedInfo'
      /#
      /# - It is possible that we will encounter a class/method pair in stderr
      /#   that is NOT present in stdout (not sure how, but it happens).
      i = 0
      N = len(errlines)
      current_fqn = None
      postamble = None
      summary_data = {}
      while i < N:
        line = errlines[i]
        i += 1
        /# We ignore separator lines, as the line after seplines uniquely
        /# identifies which section we are in (at least in output I've seen).
        if sepre.match(line): continue
        failm = failre.match(line)
        ranm = ranre.match(line)

        if failm:
          d = failm.groupdict()
          fqn = '%s.%s' % (d['class'], d['method'])

          /# TODO(wmh): Apparently if a test method has a docstring, the
          /# output of the test includes the docstring before the separator.
          /# The code below assumes the separator is in errlines[i] (only
          /# tru if test method has no docstring (which is true for all
          /# test methods defined via 'test:' or 'tests:', but not explicit
          /# test methods). Need to fix this ... scan forward until sepre
          /# matches.

          if not sepre.match(errlines[i]):
            print('#' * 80)
            print('\n'.join(errlines))
            print('#' * 80)
            raise metax.c.Error('Should have found separator line after "%s"' % line)
          if fqn not in datamap:
            item = {
              'fqn': fqn, 'stderr': [], 'stdout': [], 'status': None,
              'time': None
            }
            data.append(item)
            datamap[fqn] = item
          current_fqn = fqn
        elif ranm:
          /# End of tests ... grab all remaining output.
          summary_data.update(ranm.groupdict())
          assert not errlines[i].strip()
          summary_data['status'] = errlines[i+1]
          j = i+2
          while j < len(errlines) and not errlines[j].strip():
            j += 1
          postamble = errlines[j:]
          break
        elif current_fqn is None:
          fp.write(u'UNKNOWN STDERR: %s\n' % line)
        else:
          /# A line of stderr for current fqn, if one exists.
          item = datamap[current_fqn]
          item['stderr'].append(line)

      /# Merge the stdout and stderr into a single stream, in the same
      /# format as used in the bazel-generated output.
      sep = '-' * 70 + '\n'
      show_nums = False
      /# print(stdout)
      last_printed_sep = False
      for i, item in enumerate(data):
        out = item['stdout']
        err = item['stderr']
        special = out or err

        if special and not last_printed_sep: fp.write(sep)

        /# Print out details
        /#  - if verbosity is 0, only print methods that have out/err.
        /#  - if verbosity is 1, print every method (and out/err if present)
        if special or verbosity:
          prefix = '%3d) ' % i if show_nums else ''
          fp.write(
            '%s%-40s ... %7d us   %s\n' %
            (prefix, item['fqn'], item['time'] or -1, item['status']))
          PrintStripped(out, ' |')
          PrintStripped(err, 'E|')

        /# Log this test result.
        if timestamp > 0:
          fullfqn = namespace + '.' + item['fqn']
          testlogdir = self.testLogDir(fullfqn, create=True)
          testidxpath = fs.join(testlogdir, 'LOG')
          with open(testidxpath, 'a') as ofp:
            ofp.write(
              '%13.3f %7dus %s\n' %
              (timestamp, item['time'] or -1, item['status']))
          if out or err:
            testlogpath = fs.join(testlogdir, 't%d.log' % timestamp)
            with open(testlogpath, 'w') as ofp:
              ofp.write('\n'.join(out) + '\n')
              ofp.write('##--##--##--##\n')
              ofp.write('\n'.join(err) + '\n')

        if special:
          fp.write(sep)
          last_printed_sep = True
        elif verbosity:
          last_printed_sep = False

      if summary_data:
        fp.write(
          '%-20s: %3d tests in %s seconds: %s\n' %
          (namespace, int(summary_data['numtests']), summary_data['seconds'],
          summary_data['status']))
      if postamble:
        for line in postamble:
          fp.write(line + '\n')
    test:
      test.tpy()
      test.baselang.processTestOutput(
        /# stdout
        """\
         >|OoplPython.OoplPython                    ...   73735 us
         >|OoplPython.augmentVarset                 ...behavior metax.oopl.augmentVarset (for OoplPython) does not yet have a unittest
         >|    1211 us
         >|OoplPython.autogenPrint                  ...   32229 us
         >|OoplPython.autogenSize                   ...behavior metax.oopl.autogenSize (for OoplPython) does not yet have a unittest
         >|    1362 us
         >|OoplPython.repl                          ...    1299 us
         >|OoplPython.superCode                     ...    2055 us
         >|""",
        /# stderr
        """\
         >|----------------------------------------------------------------------
         >|Ran 6 tests in 0.336s
         >|
         >|OK
         >|""",
        /# cwd
        '/Users/wmh/src/wmh/lib/meta/oopl/python',
        /# namespace
        'metax.oopl',
        nofilt=False, fp=test.fp())
      /# TODO(wmh): Use cleaner output than the above, that showcases everything
      /# that is parsed.
      /# print(test.out())
    end receiver OoplPython;

  end behavior processTestOutput;

  behavior receiverStr : tuple<str,str> #:
    Obtain the baselang-specific receiver variable associated with a method.

    IMPORTANT: There are two related values that are useful here:
     1. The syntax to use to access state within a given method. This is
        always a variable (or null if there is no variable by which state
        can be accessed).  This variable may be augmented by dereference and
        seperator syntax, but the core is a variable.
     2. The syntax to use to access state, without requiring that it be a
        variable.
  params:
    var method : metax.oopl.ExecutableConstruct #:
      The executable for which a receiver is desired.
    var location : str = null #:
      The location feature value of the method. If null, obtained from
      method.
    var style : str = 'base' #:
      One of 'base', 'meta' or 'auto'
        base:
          Use the baselang-defined receiver variable. Note that python and
          perl do not have a lang-defined variable name, but by convention
          the receiver is 'self' in both languages (and 'cls' for class
          methods).
        meta:
          Use the meta-defined receiver variable ('self' for instance,
          'meta' for metaclass, 'test' for testclass)
        auto:
          Establish the meta-level receiver, then look for that variable
          in the user-provided body of the method.  If found, use that
          variable, else use the 'base' variable.
    var myclass : metax.oopl.ClassConstruct = null #:
      The class of the method.  If null, uses method.myclass().
    var sep : bool = false #:
      If true, append the separator character. For style 'base', this
      is baselang-dependent, but for style 'meta' it is always '.'.
    var deref : bool = false #:
      Only considered if style is base. Dereferences pointer types.
      For example, for C++, returns '(*this)' so that one can use
      '(*this).func()'.
  scope:

    abstract
    receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      result, myclass, kind, location = self._receiverStr(
        method, location, style, myclass)
      special = result

      if style == 'base':
        /# This will either be 'this' or the metaclass instance.
        if kind == 'static':
          /# There is no receiver for static methods, but one prefaces the
          /# static method with '<class>::'.
          result = None
          special = myclass.id()
        elif location == 'meta':
          /# We want access to the singleton metaclass instance.
          result = 'this'
          special = ClassConstruct.MetaInstifyName(myclass.id())
        else:
          /# TODO(wmh): Consider deleting the 'this', 'self', and 'cls' entries
          /# from the baselang configs in favor of always using this method.
          result = 'this'
          special = 'this'

        /# deref only considered for style base.
        if deref:
          if kind != 'static':
            /# The receiver for static methods is not a real receiver, so it
            /# cannot be dereferenced.
            result = '(*' + result + ')' if result else None
            special = '(*' + special + ')'

      if sep:
        /# TODO(wmh): Can remove 'selfsep' from configs if we always use this
        /# method.
        if style == 'base':
          if result:
            result += '::' if kind == 'static' else ('.' if deref else '->')
          special += '::' if kind == 'static' else ('.' if deref else '->')
        else:
          /# The meta-level 'self', 'test' and 'meta' vars are always
          /# by-reference (never ptr).
          if result:
            result += '::' if kind == 'static' else '.'
          special += '::' if kind == 'static' else '.'

      return result, special
    test:
      basel = 'cpp'

      /# instance method
      baselang, instance_method = test.generateMethodVariant(basel, 'instance')
      test.iseq(
        ('this', 'this'),
        baselang.receiverStr(instance_method, location='user'))
      test.iseq(
        ('this', 'this'),
        baselang.receiverStr(instance_method))
      test.iseq(
        ('this->', 'this->'),
        baselang.receiverStr(instance_method, sep=True))
      test.iseq(
        ('(*this)', '(*this)'),
        baselang.receiverStr(instance_method, deref=True))
      test.iseq(
        ('(*this).', '(*this).'),
        baselang.receiverStr(instance_method, deref=True, sep=True))
      test.iseq(
        ('self', 'self'),
        baselang.receiverStr(instance_method, style='meta'))
      test.iseq(
        ('self.', 'self.'),
        baselang.receiverStr(instance_method, style='meta', sep=True))

      /# static method
      baselang, static_method = test.generateMethodVariant(basel, 'static')
      test.iseq(
        (None, 'Card'),
        baselang.receiverStr(static_method, location='user'))
      test.iseq(
        (None, 'Card'),
        baselang.receiverStr(static_method))
      test.iseq(
        (None, 'Card::'),
        baselang.receiverStr(static_method, sep=True))
      test.iseq(
        (None, 'Card'),
        baselang.receiverStr(static_method, deref=True))
      test.iseq(
        (None, 'Card::'),
        baselang.receiverStr(static_method, deref=True, sep=True))
      /# TODO(wmh): Decide how to handle the meta-level version of static
      /# receiver. In Python, we treat static and meta methods similarly
      /# (possible because the syntax for invoking a static method is the same
      /# as for a class method). In C++, the syntax is different (meta->f() vs
      /# <class>::f()). In order to be able to introduce a 'meta' variable and
      /# treat static and class method invocations the same in C++, we would
      /# need to perform a special replacement of 'meta.' with '<class>::'.
      test.iseq(
        ('meta', 'meta'),
        baselang.receiverStr(static_method, style='meta'))

      /# meta method
      baselang, meta_method = test.generateMethodVariant(basel, 'meta')
      test.iseq(
        ('this', 'MetaCard'),
        baselang.receiverStr(meta_method, location='meta'))
      test.iseq(
        ('this', 'MetaCard'),
        baselang.receiverStr(meta_method))
      test.iseq(
        ('(*this)', '(*MetaCard)'),
        baselang.receiverStr(meta_method, deref=True))
      test.iseq(
        ('this->', 'MetaCard->'),
        baselang.receiverStr(meta_method, sep=True))
      test.iseq(
        ('(*this).', '(*MetaCard).'),
        baselang.receiverStr(meta_method, sep=True, deref=True))
      test.iseq(
        ('meta', 'meta'),
        baselang.receiverStr(meta_method, style='meta'))
      test.iseq(
        ('meta.', 'meta.'),
        baselang.receiverStr(meta_method, style='meta', sep=True))

      /# test method
      baselang, test_method = test.generateMethodVariant(basel, 'test')
      test.iseq(
        ('this', 'this'),
        baselang.receiverStr(test_method, location='test'))
      test.iseq(
        ('this', 'this'),
        baselang.receiverStr(test_method))
      test.iseq(
        ('this->', 'this->'),
        baselang.receiverStr(test_method, sep=True))
      test.iseq(
        ('(*this)', '(*this)'),
        baselang.receiverStr(test_method, deref=True))
      test.iseq(
        ('(*this).', '(*this).'),
        baselang.receiverStr(test_method, deref=True, sep=True))
      test.iseq(
        ('test', 'test'),
        baselang.receiverStr(test_method, style='meta'))
      test.iseq(
        ('test.', 'test.'),
        baselang.receiverStr(test_method, style='meta', sep=True))

    end receiver OoplCpp;

    receiver OoplJavascript scope:
      result, myclass, kind, location = self._receiverStr(
        method, location, style, myclass)
      special = result

      if style == 'base':
        /# This will either be 'this' or the metaclass instance.
        if kind == 'static':
          /# In javascript, the syntax for accessing static methods is the same
          /# as for meta methods (similar to Python).
          /# static method with '<class>::'.
          result = 'meta'
          special = myclass.id()
        elif location == 'meta':
          /# We want access to the singleton metaclass instance.
          result = 'this'
          special = ClassConstruct.MetaInstifyName(myclass.id())
        else:
          /# TODO(wmh): Consider deleting the 'this', 'self', and 'cls' entries
          /# from the baselang configs in favor of always using this method.
          result = 'this'
          special = 'this'

        /# In javascript, there is no difference between deref and non-deref
        /# syntax, so the deref arg is ignored.

      if sep:
        /# In Javascript, the seperator is always '.'.
        result += '.'
        special += '.'

      return result, special
    test:
      basel = 'javascript'

      /# instance method
      baselang, instance_method = test.generateMethodVariant(basel, 'instance')
      test.iseq(
        ('this', 'this'),
        baselang.receiverStr(instance_method, location='user'))
      test.iseq(
        ('this', 'this'),
        baselang.receiverStr(instance_method))
      test.iseq(
        ('this.', 'this.'),
        baselang.receiverStr(instance_method, sep=True))
      test.iseq(
        ('this', 'this'),
        baselang.receiverStr(instance_method, deref=True))
      test.iseq(
        ('this.', 'this.'),
        baselang.receiverStr(instance_method, deref=True, sep=True))
      test.iseq(
        ('self', 'self'),
        baselang.receiverStr(instance_method, style='meta'))
      test.iseq(
        ('self.', 'self.'),
        baselang.receiverStr(instance_method, style='meta', sep=True))

      /# static method
      baselang, static_method = test.generateMethodVariant(basel, 'static')
      test.iseq(
        ('meta', 'Card'),
        baselang.receiverStr(static_method, location='user'))
      test.iseq(
        ('meta', 'Card'),
        baselang.receiverStr(static_method))
      test.iseq(
        ('meta.', 'Card.'),
        baselang.receiverStr(static_method, sep=True))
      test.iseq(
        ('meta', 'Card'),
        baselang.receiverStr(static_method, deref=True))
      test.iseq(
        ('meta.', 'Card.'),
        baselang.receiverStr(static_method, deref=True, sep=True))
      test.iseq(
        ('meta', 'meta'),
        baselang.receiverStr(static_method, style='meta'))

      /# meta method
      baselang, meta_method = test.generateMethodVariant(basel, 'meta')
      test.iseq(
        ('this', 'MetaCard'),
        baselang.receiverStr(meta_method, location='meta'))
      test.iseq(
        ('this', 'MetaCard'),
        baselang.receiverStr(meta_method))
      test.iseq(
        ('this', 'MetaCard'),
        baselang.receiverStr(meta_method, deref=True))
      test.iseq(
        ('this.', 'MetaCard.'),
        baselang.receiverStr(meta_method, sep=True))
      test.iseq(
        ('this.', 'MetaCard.'),
        baselang.receiverStr(meta_method, sep=True, deref=True))
      test.iseq(
        ('meta', 'meta'),
        baselang.receiverStr(meta_method, style='meta'))
      test.iseq(
        ('meta.', 'meta.'),
        baselang.receiverStr(meta_method, style='meta', sep=True))

      /# test method
      baselang, test_method = test.generateMethodVariant(basel, 'test')
      test.iseq(
        ('this', 'this'),
        baselang.receiverStr(test_method, location='test'))
      test.iseq(
        ('this', 'this'),
        baselang.receiverStr(test_method))
      test.iseq(
        ('this.', 'this.'),
        baselang.receiverStr(test_method, sep=True))
      test.iseq(
        ('this', 'this'),
        baselang.receiverStr(test_method, deref=True))
      test.iseq(
        ('this.', 'this.'),
        baselang.receiverStr(test_method, deref=True, sep=True))
      test.iseq(
        ('test', 'test'),
        baselang.receiverStr(test_method, style='meta'))
      test.iseq(
        ('test.', 'test.'),
        baselang.receiverStr(test_method, style='meta', sep=True))

    end receiver OoplJavascript;

    receiver OoplPython scope:
      result, myclass, kind, location = self._receiverStr(
        method, location, style, myclass)
      special = result

      if style == 'base':
        /# This will either be 'this' or the metaclass instance.
        if kind == 'static':
          /# TODO(wmh): We can use either <class> or Meta<class>, since they
          /# are the same object in Python.
          result = 'cls'     # make this 'meta'
          special = myclass.id()
        elif kind == 'cls' or myclass.isMeta():
          /# TODO(wmh): In Python, we are using receiverStr(style='base') for
          /# two different purposes:
          /#  1. obtain the name of the variable to use in method definitions
          /#  2. obtain the actual receiver in a given method.
          /# The two can probably be treated the same, but it might be useful
          /# to pass in another param to distinguish the two use-cases.
          result = 'cls'     # make this 'meta'
          special = ClassConstruct.MetaInstifyName(myclass.id())
        elif location == 'meta':
          /# We want access to the singleton metaclass instance.
          /#
          /# TODO(wmh): This is rarely reached because of the test above for
          /# myclass.isMeta(). However, it *is* accessed from
          /# baselang.analyzeExecutableForFields().
          result = 'cls'    # make this 'meta'
          special = ClassConstruct.MetaInstifyName(myclass.id())
        else:
          /# TODO(wmh): Consider deleting the 'this', 'self', and 'cls' entries
          /# from the baselang configs in favor of always using this method.
          result = 'self'
          special = 'self'

        /# In python, there is no difference between deref and non-deref syntax,
        /# so the deref arg is ignored.

      if sep:
        /# In Python, the seperator is always '.'.
        result += '.'
        special += '.'

      return result, special
    test:
      basel = 'python'

      /# instance method
      baselang, instance_method = test.generateMethodVariant(basel, 'instance')
      test.iseq(
        ('self', 'self'),
        baselang.receiverStr(instance_method, location='user'))
      test.iseq(
        ('self', 'self'),
        baselang.receiverStr(instance_method))
      test.iseq(
        ('self.', 'self.'),
        baselang.receiverStr(instance_method, sep=True))
      test.iseq(
        ('self', 'self'),
        baselang.receiverStr(instance_method, deref=True))
      test.iseq(
        ('self.', 'self.'),
        baselang.receiverStr(instance_method, deref=True, sep=True))
      test.iseq(
        ('self', 'self'),
        baselang.receiverStr(instance_method, style='meta'))
      test.iseq(
        ('self.', 'self.'),
        baselang.receiverStr(instance_method, style='meta', sep=True))

      /# static method
      baselang, static_method = test.generateMethodVariant(basel, 'static')
      test.iseq(
        ('cls', 'Card'),
        baselang.receiverStr(static_method, location='user'))
      test.iseq(
        ('cls', 'Card'),
        baselang.receiverStr(static_method))
      test.iseq(
        ('cls.', 'Card.'),
        baselang.receiverStr(static_method, sep=True))
      test.iseq(
        ('cls', 'Card'),
        baselang.receiverStr(static_method, deref=True))
      test.iseq(
        ('cls.', 'Card.'),
        baselang.receiverStr(static_method, deref=True, sep=True))
      /# TODO(wmh): Decide how to handle the meta-level version of static
      /# receiver. In Python, we treat static and meta methods similarly
      /# (possible because the syntax for invoking a static method is the same
      /# as for a class method). In C++, the syntax is different (meta->f() vs
      /# <class>::f()). In order to be able to introduce a 'meta' variable and
      /# treat static and class method invocations the same in C++, we would
      /# need to perform a special replacement of 'meta.' with '<class>::'.
      test.iseq(
        ('meta', 'meta'),
        baselang.receiverStr(static_method, style='meta'))

      /# meta method
      baselang, meta_method = test.generateMethodVariant(basel, 'meta')
      test.iseq(
        ('cls', 'MetaCard'),
        baselang.receiverStr(meta_method, location='meta'))
      test.iseq(
        ('cls', 'MetaCard'),
        baselang.receiverStr(meta_method))
      test.iseq(
        ('cls', 'MetaCard'),
        baselang.receiverStr(meta_method, deref=True))
      test.iseq(
        ('cls.', 'MetaCard.'),
        baselang.receiverStr(meta_method, sep=True))
      test.iseq(
        ('cls.', 'MetaCard.'),
        baselang.receiverStr(meta_method, sep=True, deref=True))
      test.iseq(
        ('meta', 'meta'),
        baselang.receiverStr(meta_method, style='meta'))
      test.iseq(
        ('meta.', 'meta.'),
        baselang.receiverStr(meta_method, style='meta', sep=True))

      /# test method
      baselang, test_method = test.generateMethodVariant(basel, 'test')
      test.iseq(
        ('self', 'self'),
        baselang.receiverStr(test_method, location='test'))
      test.iseq(
        ('self', 'self'),
        baselang.receiverStr(test_method))
      test.iseq(
        ('self.', 'self.'),
        baselang.receiverStr(test_method, sep=True))
      test.iseq(
        ('self', 'self'),
        baselang.receiverStr(test_method, deref=True))
      test.iseq(
        ('self.', 'self.'),
        baselang.receiverStr(test_method, deref=True, sep=True))
      test.iseq(
        ('test', 'test'),
        baselang.receiverStr(test_method, style='meta'))
      test.iseq(
        ('test.', 'test.'),
        baselang.receiverStr(test_method, style='meta', sep=True))
    end receiver OoplPython;

  end behavior receiverStr;

  behavior repl #:
    Perform a read-execute-print loop for this baselang.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      template = """
       >|%(includes)s
       >|using namespace std;
       >|int main() {
       >|%(body)s
       >|}
       >|"""

      chunks = []
      prompt = '>>> '
      execfile = './tmp'
      tmpfile = 'tmp.cc'

      includes = [
        '#include <iostream>'
      ]

      def GenCode(lines):
        text = '\n'.join(lines)
        if lines:
          chunks.append(text)

        /# Obtain the C++ code to compile.
        code = template % {
          'body': '\n'.join(chunks),
          'includes': '\n'.join(includes),
        }
        fs = self.compiler().fs()
        with fs.open(tmpfile, 'w') as tfp:
          tfp.write(code)
        return code, text

      import os
      while True:
        /# Obtain a new chunk of C++ code to add to the previous chunks.
        /#  - if line is empty or ends with ';' or '}', terminate
        /#  - otherwise keep reading input
        lines = []
        skip = False
        while True:
          /# Read one line
          line = raw_input(prompt)

          /# Check for exit request.
          if line in ('exit', 'quit'):
            return

          /# Check for special commands
          m = re.match(r'^\s*/(\S+)\s*(.*)', line)
          if m:
            command, args = m.groups()
            if command in ('p', 'print'):
              line = 'cout << %s << endl;' % args
            elif command == 'show':
              skip = True
              code, _ = GenCode(lines)
              print(code)
              break
            elif command == 'pop':
              skip = True
              chunks.pop()
              break
            elif command == 'include':
              skip = True
              for arg in args.split():
                if arg[0] == '<': pass
                elif arg[0] == '\"': pass
                else:
                  if arg.endswith('.h'):
                    arg = '"%s"' % arg
                  else:
                    arg = '<%s>' % arg
                includes.append('#include %s' % arg)
              break

          /# Register line
          lines.append(line)

          /# Determine if we need to ask for another line or end reading.
          if not line or line[-1] in (';', '}'):
            break

        if skip:
          continue

        code, text = GenCode(lines)

        /# Compile code, and if no compilation errors, run code.
        rc = subprocess.call(['g++', '-o', execfile, tmpfile])
        if rc == 0:
          rc = subprocess.call([execfile])

        if rc == 0:
          /# The code did not produce any compile-time or run-time error, so
          /# we leave it in place.  However, we modify the new chunk so that
          /# any code that prints to cout is commented out.
          /#  - this correctly handles 'p a'
          /#  - this correctly handles 'if (a) { cout << "blah" << endl; }'
          /#  - this incorrectly comments out the cout in
          /#      class A { public: A() { cout << "hello!" << endl; } };
          /#    but we provide an escape-hatch by not commenting out std::cout
          /#      class A { public: A() { std::cout << "hello!" << endl; } };
          chunks.pop()
          qtext = re.sub(r'(^[:])(cout[ <][^;]+;)', r'\1/* \2 */', text)
          chunks.append(qtext)

        else:
          /# The new chunk of C++ code produced a compile or run-time error,
          /# so we remove it from the list of chunks.
          chunks.pop()
    test:
      /# This is interactive, so we don't test it.
      pass
    end receiver OoplCpp;

    receiver OoplJavascript scope:
      /# TODO(wmh): Generalize location of phantomjs
      /# TODO(wmh): Need to set things up so that phantomjs loads up the
      /# Meta environment, including any meta files specified.
      subprocess.call(['pjs'])
    test:
      /# This is interactive, so we don't test it.
      pass
    end receiver OoplJavascript;

    receiver OoplPython scope:
      banner = 'Welcome to Meta'
      locals = {'a': 1}
      code.interact(banner=banner, local=locals)
    test:
      /# This is interactive, so we don't test it.
      pass
    end receiver OoplPython;

  end behavior repl;

  behavior superCode : void #:
    Write baselang code to invoke a superclass method.
  params:
    var method : metax.oopl.ExecutableConstruct #:
      The method for which super code is desired.
    var output : vec<str> #:
      Where to append lines of baselang code representing the super-call.
    var width : int = 80 #:
      Maximum width that lines can take on.
    var return_var : str = null #:
      If present, assign the result of the super call to the given var.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      recstr = self.receiverStr(method)[0]
      myclass = method.myclass()
      class_name = myclass.id()
      method_name = method.id()
      super_method = ''
      if return_var:
        super_method += '%s = ' % return_var
      super_method += 'super(%s, %s).%s' % (class_name, recstr, method_name)
      metafile = method.metafile()

      /# TODO(wmh): Should we do LOOKUP here? If we don't always do it
      /# (except for block-valued attributes) how will the user know when an
      /# attribute is inherited and when it isn't?  On the other hand, if
      /# super doesn't exist explicitly, we could assume the parent is invoked
      /# with the same args as method, providing a convenient short-hand that
      /# is common.
      super_attr, super_args = method.attrpair('super', default=None)
      if super_args:
        param_str, _ = self.compileExpr(
          super_args, metafile, executable=method)
        /# TODO(wmh): This logic should be implemented in compileExpr. Note
        /# that it already has the method in 'executable', so it can obtain
        /# the params and check for multi vars.
        params = method.parsedParams()
        varvec = params.get('varvec', None)
        varmap = params.get('varmap', None)
        if varvec or varmap:
          arglist = re.split(r'\s*,\s*', param_str[1:-1])
          if varvec:
            for i, arg in enumerate(arglist):
              if arg == varvec['name']:
                arglist[i] = '*' + arg
                break
          if varmap:
            for i, arg in enumerate(arglist):
              if arg == varmap['name']:
                arglist[i] = '**' + arg
                break
          param_str = '(%s)' % (', '.join(arglist))
      else:
        param_str = '()'

      if len(super_method) + len(param_str) < width:
        output.append(super_method + param_str)
      else:
        output.append(super_method + '(')
        output.append('    ' + param_str[1:])
    test:
      test.defineClassAndMethods('py')

      /# An initializer
      out = []
      test.baselang.superCode(test.initializer, out)
      test.iseqvec(['super(Card, self).__init__(a, b=1, c=False)'], out)

      /# A non-iniitalizer method
      out = []
      test.baselang.superCode(test.method2, out)
      test.iseqvec(['super(Card, self).f(a, b=1, c=False)'], out)
    end receiver OoplPython;

    receiver OoplJavascript scope:
      kind = method.attrval('kind', default=metax.c.LOOKUP)
      recstr = self.receiverStr(method)[0]
      myclass = method.myclass()
      class_name = myclass.id()
      method_name = method.id()

      use_es2015_classes = self.config('use_es2015')

      args = []

      if use_es2015_classes:
        super_method = 'super'
      else:
        super_method = '%s.base' % myclass.fqn()
        args.append(recstr)

      if kind == 'initializer':
        if not use_es2015_classes:
          args.append("'constructor'")
      else:
        if use_es2015_classes:
          super_method += '.' + method.id()
        else:
          args.append("'%s'" % method.id())

      /# TODO(wmh): Should we do LOOKUP here? If we don't always do it
      /# (except for block-valued attributes) how will the user know when an
      /# attribute is inherited and when it isn't?  On the other hand, if
      /# super doesn't exist explicitly, we could assume the parent is invoked
      /# with the same args as method, providing a convenient short-hand that
      /# is common.
      metafile = method.metafile()
      super_attr, super_args = method.attrpair('super', default=None)
      if super_args:
        for sarg in super_args.value():
          sstr, _ = self.compileExpr(sarg, metafile, executable=method)
          args.append(sstr)
      output.append(super_method + '(' + ', '.join(args) + ');')

    test:
      oopljs, _, context, _ = test.cachedInfo(basel='javascript')

      filec = metax.meta.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.oopl.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.oopl.ClassConstruct.NewFromData(
        'Card', context, namespace.attr('scope:'), secondaries=[('scope:', [])])
      kscope = klass.attr('scope:')
      expr = metax.c.Expr.FromStr(
        '(a, b=1, c=false)',
        attribute=metax.oopl.ClassConstruct.DummySuperAttribute)

      /# An initializer
      initializer = metax.oopl.MethodConstruct.NewFromData(
        '__init__', context, parent=kscope,
        features=[('kind', 'initializer')],
        secondaries=[('super', expr)])
      initializer.myclassIs(klass)
      out = []
      oopljs.superCode(initializer, out)
      test.iseqvec(["super(a, b=1, c=false);"], out)

      /# A non-iniitalizer method
      method = metax.oopl.MethodConstruct.NewFromData(
        'f', context, parent=kscope, secondaries=[('super', expr)])
      method.myclassIs(klass)
      out = []
      oopljs.superCode(method, out)
      test.iseqvec(["super.f(a, b=1, c=false);"], out)
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      kind = method.attrval('kind')

      if kind == 'initializer':
        /# The superCode() method is for generating code WITHIN a code block
        /# for invoking a superclass method. Invoking a parent constructor
        /# in C++ happens in the initlist, NOT within the code block, so we
        /# write nothing to output for initializers here ... handled in
        /# OoplCpp.augmentVarset().
        pass
      else:
        myclass = method.myclass()
        parent_classes = myclass.parentclasses()
        parent = parent_classes[0]
        pfqn = parent['fqn']
        pparts = pfqn.split('.')

        method_name = method.id()
        metafile = method.metafile()
        super_method = 'this->%s::%s' % (pparts[-1], method_name)

        /# TODO(wmh): Should we do LOOKUP here? If we don't always do it
        /# (except for block-valued attributes) how will the user know when an
        /# attribute is inherited and when it isn't?  On the other hand, if
        /# super doesn't exist explicitly, we could assume the parent is invoked
        /# with the same args as method, providing a convenient short-hand that
        /# is common.
        super_attr, super_args = method.attrpair('super', default=None)

        if super_args:
          param_str, _ = self.compileExpr(
            super_args, metafile, executable=method)
        else:
          param_str = '()'

        if len(super_method) + len(param_str) + 1 < width:
          output.append('%s%s;' % (super_method, param_str))
        else:
          output.append("%s(" % super_method)
          output.append('    ' + param_str[1:] + ';')
    test:
      test.defineClassAndMethods('cc')
      /# An initializer
      out = []
      test.baselang.superCode(test.initializer, out)
      test.iseqvec([], out)

      /# A non-iniitalizer method
      out = []
      test.baselang.superCode(test.method2, out)
      test.iseqvec(['this->metax::root::Object::f(a, b=1, c=false);'], out)
    end receiver OoplCpp;

  end behavior superCode;

  test
  class TestCase < metax.c_test.TestCase scope:

    method checkStatement : OoplConstruct #:
      Compile a meta program, find a statement construct within it, invoke
      translateMeta on that statement, and verify resulting output.

      Note that the return type is OoplConstruct rather than StatementConstruct
      because some constructs that can appear within method scope can also
      appear elsewhere and are thus not subclases of StatementConstruct
      (e.g. BlockConstruct). TODO(wmh): Can we remove this inconsistency?

      TODO(wmh): Generalize to be useful for expandMeta, importMeta and
      compileMeta as well. Or do they not produce output we can easily test?
    params:
      var code : str #:
        The meta-syntax code to be parsed.
      var mxpath : str #:
        A path identifying a statement construct within the parsed meta code.
      var expected : map = null #:
        Maps baselang suffix (py, cc, js, jv) to expected baselang output. If
        a key exists with a null value, it is a request to print the output
        rather than check against it (and also print out the construct
        identified by mxpath). If expected itself is null, it is shorthand
        for {'py': None, 'js': None}, so the output in python and javascript
        are printed out.
      var verbose : bool = false #:
        If true, print out the identified statement construct and the output
        produced by invoking translateMeta().
      var debuglevel : int = 0 #:
        How much debugging info to print out.
    scope:
      if expected is None:
        expected = {'py': None, 'js': None}

      result = {}
      for bl in sorted(expected):
        basel = metax.c.Compiler.SUFFIX_HACK['oopl'][bl]
        expected_text = expected[bl]

        /# Parse namespace/class/method/loop constructs and find the loop by
        /# xpath.
        statement = test.constructInCode(
          mxpath, text=code, metal='oopl', basel=basel, debuglevel=debuglevel)
        if not statement:
          print('#' * 80)
          print(code)
          print('#' * 80)
          /# test.metafile.hasErrors(show=True)
          test.fail('Failed to parse code')

        /# Conditionally print out the statement.
        if verbose or expected_text is None:
          print('=' * 80)
          print('construct at %s:' % mxpath)
          statement.write(indent='  ')

        /# Setup the stream expected by translateMeta().
        metafile = statement.metafile()
        new_statement = self._checkStatement(
          metafile, statement, expected=expected_text, verbose=verbose)
        result[bl] = new_statement

      return result
    test:
    end method checkStatement;

    method _checkStatement : any #:
      Given a statement construct, invoke expandMeta() and translateMeta() on
      it, obtain the resulting base language code produced for the statement,
      and compare it against expected text.
    params:
      var metafile : MetaFile #:
        The metafile containing the statement.
      var construct : Construct #:
        The statement or method to generate code for.
      var expected : str = null #:
        The expected baselang output. If null, print out the output rather
        than check against it (and also print out the construct identified by
        mxpath).
      var verbose : bool = false #:
        If true, print out the identified statement construct and the output
        produced by invoking translateMeta().
    scope:
      if metafile.hasErrors(show=True):
        return None

      if construct.isMethod():
        method = construct
        statement = None
      else:
        /# TODO(wmh): Why is this only necessary for SetConstruct and none of the
        /# other statement subclasses?
        statement = construct
        method = statement.ancestor('method')
        assert method
        statement.myexecIs(method)

      baselang = construct.baselang()
      myclass = method.myclass()
      if myclass is None:
        /# TODO(wmh): Use a stream within the method instead (and have statements
        /# cache their method??)
        myclass = method.ancestor('class')
        method.myclassIs(myclass)

      namespace = myclass.namespace()
      if namespace is None:
        namespace = myclass.ancestor('namespace')
        myclass.namespaceIs(namespace)

      /# Obtain the stream.
      segments = myclass.streamNamed('current-body')
      if not segments or not isinstance(segments[-1], metax.c.BaseSegment):
        segment = metax.c.BaseSegment(None)
        segments.append(segment)

      /# Invoke translateMeta on the statement
      construct.expandMeta()
      construct.translateMeta()

      /# Obtain last segment of current-body stream in class.
      segments = myclass.streamNamed('current-body')
      segment = segments[-1]

      /# Validate output.
      output = segment.flattenStr()
      if verbose or expected is None:
        print('=' * 80)
        print('Output produced by translateMeta for %s:' % baselang.id())
        print(output)
        print('=' * 80)
      if expected is not None:
        test.iseqtext(expected, output)

      /# Return statement to allow further testing.
      return statement
    test:
    end method _checkStatement;

    method generateMethodVariant : any #:
      A service method for use in unittests for receiverStr() and other
      methods that require instance, static, meta and test methods.
    params:
      var basel : str #:
        The desired baselang.
      var kind : str #:
        One of 'instance', 'static', 'meta' or 'test'
    scope:
      baselang, _, context, _ = test.cachedInfo(basel=basel)

      filec = metax.meta.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.oopl.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.oopl.ClassConstruct.NewFromData(
        'Card', context, parent=namespace.attr('scope:'),
        secondaries=[('scope:', [])])

      test.baselang = baselang
      test.context = context
      test.file = filec
      test.namespace = namespace
      test.klass = klass

      if kind == 'instance':
        method = metax.oopl.MethodConstruct.NewFromData(
          'f', context, parent=klass.attr('scope:'))
        method.myclassIs(klass)

      elif kind == 'static':
        method = metax.oopl.MethodConstruct.NewFromData(
          'SF', context, parent=klass.attr('scope:'),
          features=[('kind', 'static')])
        method.myclassIs(klass)

      elif kind == 'meta':
        method =  metax.oopl.MethodConstruct.NewFromData(
          'F', context, parent=klass.attr('scope:'),
          features=[('location', 'meta')])
        method.myclassIs(klass)
        klass.variantIs('meta')

      elif kind == 'test':
        method = metax.oopl.MethodConstruct.NewFromData(
          'test_f', context, parent=klass.attr('scope:'),
          features=[('location', 'test')])
        method.myclassIs(klass)
        klass.variantIs('test')

      else:
        raise metax.c.Error('Invalid kind %s' % kind)

      return baselang, method
    test:
    end method generateMethodVariant;


  end;

end namespace metax.oopl;
