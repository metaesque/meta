namespace metax.c #:
  /# The implementation of Meta in Meta.
  /#  - This file is implemented itself
  /#  - The meta2 compiler does for .meta2 code what metac does for .meta code,
  /#    but writes to <<repository_path>>/<metalang>/<baselang> instead of
  /#     - by convention, the notation <<var>> means something obtained from
  /#       ~/.config/metameta, and the notation <var> means something obtained
  /#       from flags.
  /#  - To avoid confusion, until the old meta1 code has been fully removed:
  /#     - meta2 code should not define namespace 'meta' anywhere. It should
  /#       use 'metax' instead.
  /#  - If .meta2 needs to rely on bootstrapping, it should use metameta2, not
  /#    metameta.  TODO(wmh): How to enforce this?
  /#
  /#  Life Of A MetaFile
  /#  - Create an instance of metax.c.Compiler, specifying metal and basel
  /#     - this results in Meta(Meta) and Meta(X) being parsed, for X==metal,
  /#       via Compiler.metalangNamed(), and involving bootstrapping because
  /#       they involve parsing a MetaFile.
  /#  - Invoke Compiler.parseMeta(), which
  /#     - creates a MetaFile
  /#     - invokes MetaFile.parseMeta() with a metalang-specific Context instance.
  /#  - MetaFile.parseMeta()
  /#     - creates a copy of the passed-in Context (every MetaFile has its own
  /#       Context instance so that the Context can store the metafile and
  /#       compiler instances).
  /#     - creates a FileConstruct and associated scope:, then invokes
  /#       MetaFile.parseComplexBlock to populate that scope with the top-level
  /#       constructs in the metafile.
  /#  - MetaFile.parseComplexBlock()
  /#     - creates a ConsGroup instance representing all legal tokens within
  /#       the complex block based on the set of legal constructs within the
  /#       block.
  /#     - repeatedly parses constructs via MetaFile.parseConstruct until
  /#       an explicit or implicit end-of-block is encountered.
  /#  - MetaFile.parseConstruct()
  /#     - skips empty lines and updates precount (or postcount of parent if last)
  /#     - consumes feature tokens until a primary key token is found
  /#     - obtains the primary attribute value handling optional values and
  /#       replacer semantics
  /#     - creates an Attribute to represent the primary attribute (do not
  /#       register)
  /#     - creates an instance of some subclass of Construct (as recording in
  /#       the ConsInfo associated with the primary key token), registering into
  /#       parent scope.
  /#     - validate legality of all previously parsed feature tokens now that
  /#       we've identified the construct, create FeatureAttribute instances and
  /#       register them in the newly created construct.
  /#     - register the primary attribute created above
  /#     - iterate until an explicit or implicit end of construct is found,
  /#       invoking MetaFile.parseSecondaryAttribute() to create and register
  /#       secondary attributes with the construct.
  /#  - MetaFile.parseSecondaryAttribute()
  /#     - Obtain the secondary key (handling autokey semantics) by invoking
  /#       MetaFile.peekSecondaryToken()
  /#     - Detect end-of-construct terminator and return special values
  /#     - Create an instance of a subclass of Attribute based on the value type
  /#       of the attribute BEFORE we have parsed the value (all Attribute
  /#       subclasses must handle a null value)
  /#     - Perform type-specific parsing of the secondary attribute value.
  /#     - Set the value of the Attribute instance created above.
  /#     - The termcode of the passed-in construct instance is changed from
  /#       TERM_UNINIT to 0<=<16 if a terminator (implicit or explicit) is
  /#       found.
  /#
  /#   - More notes:
  /#    - Every time ${file}.meta file is compiled:
  /#      - the file .${file}.${suffix}.files is created, containing all of the
  /#        files generated during compilation.  Used to detect old files that
  /#        should be deleted because of changes in the .meta file.
  /#      - if ./.meta2 does not exist, it is made a symlink to <<repository_path>>
  /#      - for every namespace nm.sp defined within ${file}.meta
  /#         - for every class C defined within nm.sp
  /#            - ./.meta2/oopl/${baselang}/nm/sp/${C}.${suff} is created
  /#              (except when ${suff} is 'py', in which case
  /#               ./.meta2/oopl/${baselang}/nm/sp/.${C}.py is created,
  /#               and ./.meta2/oopl/${baselang}/nm/sp/__init__.py merges all
  /#               classes into a python module aka meta namespace).
  /#
  /#  VARIABLE CONVENTIONS:
  /#  - basel = the id of a base language
  /#  - metal = the id of a meta language
  /#  - baselang = a BaseLanguageConstruct instance
  /#  - metalang = a MetaLanguageConstruct instance
  /#  - cons = the id of a construct
  /#  - kind = the kind of a construct
  /#  - construct = a Construct instance
  /#  - attribute = an Attribute instance
  /#  - metafile = a MetaFile instance
  /#  - metac = a Compiler instance
  /#
  /#  IMPORTANT:
  /#
  /#   - This code should have ZERO direct dependence on any baselang I/O
  /#     functionality (e.g. in python, no dependence on 'os', 'glob', 'shutil',
  /#     'tempfile', etc. All such funtionality is wrapped in
  /#     metax.fs.Filesystem, and one should always use compiler.fs().* to
  /#     perform I/O.
  /#
  /#  NEW IDEAS:
  /#
  /#   - No tests: block on namespace or class. Instead, a class can be marked
  /#     as 'test' or 'user' within namespaces, and a method/field can be marked
  /#     as 'meta', 'test' or 'user' within a class.
  /#
  /#   - The same token can be both a feature value and secondary key (but same
  /#    token cannot be both a feature value and feature key, and all feature
  /#    values across all feature keys in a construct must be unique).
  /#
  /#   - The same token can be both a construct kind (aka primary key) and a
  /#    secondary key (for a different construct), but no feature key or feature
  /#    value can be the same as a construct kind.
  /#
  /#   - Support for non-indenting scope blocks;
  /#
  /#           namespace nm.sp scope >>
  /#           class Person scope >>
  /#           method f : int >>
  /#             ...
  /#           end method f;
  /#           end class Person;
  /#           end namespace nm.sp;
  /#
  /#     All complex blocks besides scope still require indenting, which
  /#     suggests we should minimize the occurrence of such blocks. The 'config'
  /#     and 'comment' blocks stay, but maybe we should favor constructs within
  /#     scope: over other complex-valued secondary attributes? e.g. Should we
  /#     move the 'run' attribute to a 'run' construct?
  /#
  /#     An alternative to the above approach would be to support constructs
  /#     at higher levels and implicitly insert them. Better approach!
  /#
  /#           namespace nm.sp scope;
  /#           class Person;
  /#
  /#           method f : int scope:
  /#             ...
  /#           end method f;
  /#
  /#     In the above
  /#       - 'class' is allowed to appear at File level, and is implicitly
  /#         added to the preceding 'namespace'.
  /#       - 'method' is allowed to appear at class level, and is implicitly
  /#         added to the preceding 'class'.
  /#       - In Meta(Doc):
  /#           h1 title "Part1";
  /#           h2 title "Sub1";
  /#           h2 title "Sub2";
  /#           h1 title "Part2";
  /#         we can determine whether a section is to be inserted into the
  /#         preceeding one or added as a sibling based on level.
  /#          - Sub1 is added in Part1
  /#          - Sub2 is NOT added inside Sub1, but rather Part1
  /#          - Part2 is NOT added inside Part1, but rather the parent File.
testpreports:
  # This is a test
scope:

  class Error < metax.root.Error;

  nometanotest
  class InternalError < Error;

  nometanotest
  class InvalidType < Error;

  nometanotest
  class MissingConstruct < Error;

  nometanotest
  class MissingAttribute < Error;

  nometanotest
  class UnusedException < Error;

  nometanotest
  class InvariantViolated < Error;

  nometanotest
  class InvalidAttributeType < Error;

  nometanotest
  class ConflictingFeatureValues < Error;

  native #:
    These are currently required because Meta is not properly parsing
      params:
        var default : any = metax.c.REQUIRED;
    Only the 'Meta' is being parsed, and the '.REQUIRED' is being silently
    ignored.
  scope:
    ERROR = 1
    REQUIRED = 2
    LOOKUP = 3
    SPECIAL = 4
    EMPTY = 5
    SELF = 6

    /# What to store in termcode when the terminator has not yet been
    /# initialized.
    /#  - this is different from '0', which means "verified that terminator is
    /#    implicit"
    /#  - this used to be -1, but we want to pack termcode and termline together
    /#    so we avoid negative numbers at least until field packing exists and
    /#    supports negative numbers (if we decide to allow them in packed
    /#    fields).
    TERM_UNINIT = 16
    NEWSUFFIX = '2'
    SUFFIX = '.meta' + NEWSUFFIX
    SPECIAL_PREFIX_RE = re.compile(r'^\s*>\|')

    /# Provide a means of debugging control flow.
    D = metax.logs.SimpleLogs({
      'parse': 0,
      /# expand tracks expandMeta:
      /#  - set to 1 to see the overall flow of expandMeta() calls.
      /#  - set to 2 to see more details
      'expand': 0,
      'imports': 0,
      'translate': 0,
      'compile': 0,
    })

    def HtmlSafe(val):
      return val.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    /# TODO(wmh): Move this someplace cleaner. For example, metax.logs.
    def dsep(
      title='', end=False, prefix=False, width=80, delim='#', subtitle=None,
      fp=sys.stdout
    ):
      """Print a named start/end separator

      Args:
        title: str
          The title/name of the separator
        end: bool
          If true, this is the end separator (else start).
        prefix: bool
          If true, add a 'Start' or 'End' prefix to title based on 'end'
        width: int
          How many chars total in the separator
        delim: str
          The char to use in the separator.
        subtitle: str
          What to print on a separate line below the separator.
        fp: file
          Where to write the separator.

      Returns: str
      """
      if title:
        if prefix:
          p = 'End  ' if end else 'Start'
          inside = ' ' + prefix + ' ' + title + ' '
        else:
          inside = ' ' + title + ' '
      else:
        inside = ''
      dsize = width - len(inside)
      if dsize < 0:
        fp.write(inside + '\n')
      else:
        left = dsize / 2
        fp.write('%s%s%s\n' % (delim * left, inside, delim * (dsize - left)))
      if subtitle:
        fp.write(subtitle + '\n')
  end native;

  class Line #:
    A single line of a Meta file.

    This is a (start,end) pair within the entire file contents.
  assocs:
    cls assoc metax.logs.SimpleLogs;
  scope:

    field text : str #:
      The string representing entire file.
    field start : int #:
      Index within contents of start of line
      Invariant: start == 0 or contents[start-1] == '\n'
    field end : int #:
      Index within contents of end of line.
      Invariant: contents[end] == '\n'
    field num : int #:
      The line number of this line (starting from 1)
    field indent : int #:
      How many spaces between start and first non-space character on line.
      If end == start+1, indent is 0.

    lifecycle params:
      var text -> text;
      var start -> start;
      var end -> end;
      var num -> num;
      var indent -> indent;
    scope:
      assert text[end] == '\n'
      if start > 0:
        assert text[start-1] == '\n'
    test:
      test.iseq(0, test.line.indent())
      test.iseq(2, test.line2.indent())
      test.iseq(0, test.line3.indent())
      test.iseq(0, test.line4.indent())
    end;

    method line : str #:
      The full line (including indent, excluding newline) unless start
      is provided as an offset.
    params:
      var start : int = -1 #:
        First position to return. If negative, uses self._start. Note that this
        is absolute (i.e. relative to text, not the current line).
    scope:
      if start < 0:
        start = self._start
      return self._text[start:self._end]
    test:
      test.iseq('class Person scope:', test.line.line())
      test.iseq('  field name : str;', test.line2.line())
      test.iseq('name : str;', test.line2.line(start=28))
    end method line;

    method empty : bool #:
      Returns true if line contains only whitespace.
    scope:
      return self._start + self._indent == self._end
    test:
      test.isfalse(test.line.empty())
      test.isfalse(test.line2.empty())
      test.istrue(test.line3.empty())
    end method empty;

    method inblock : bool #:
      Returns true if this line is in the block with a given indent.
    params:
      var indent : int #:
        Only a line whose indent is greater-equal this value, or that is
        empty, is considered in block.
    scope:
      return self._indent >= indent or self.empty()
    test:
      test.isfalse(test.line.inblock(2))
      test.istrue(test.line2.inblock(2))
      test.istrue(test.line3.inblock(2))
      test.isfalse(test.line4.inblock(2))
    end method inblock;

    method asStr : str #:
      String representation of this instance.
    scope:
      return '%4d:%2d:%s' % (
        self.num(), self.indent(), self.text()[self.start():self.end()])
    test:
      test.iseq('   1: 0:class Person scope:', test.line.asStr())
      test.iseq('   2: 2:  field name : str;', test.line2.asStr())
      test.iseq('   3: 0:', test.line3.asStr())
    end method asStr;

    meta
    method FromText : vec<Line> #:
      Obtain a list of Line instances given text of a metafile.
    params:
      var text : str;
    scope:
      result = []
      n = len(text)
      start = 0
      num = 0
      while True:
        /# Parse a single line of text.

        /# Establish amount of intentation in this line.
        indent = 0
        while text[start + indent] == ' ':
          indent += 1

        /# Scan to end of line.
        i = start + indent
        while text[i] != '\n':
          i += 1

        /# Create a Line instance.
        num += 1
        line = cls(text, start, i, num, indent)
        result.append(line)

        /# Prepare for parsing next line.
        i += 1
        if i >= n: break
        start = i

      return result
    test:
      /# TODO(wmh): This is an example of where having tests for meta methods
      /# be defined in a separate (meta) class is problematic ... the TestCase
      /# class and all of its initialized state is not available to this
      /# method.
      text = 'class Person scope:\n  field name : str;\n'
      lines = metax.c.Line.FromText(text)
      test.iseq(2, len(lines))
      test.iseq('   2: 2:  field name : str;', lines[1].asStr())
    end method FromText;

    test
    lifecycle setup:
      text = (
        'class Person scope:\n'
        '  field name : str;\n'
        '\n'
        'end class;\n'
      )
      self.text = text
      lines = metax.c.Line.FromText(text)
      self.line = lines[0]
      self.line2 = lines[1]
      self.line3 = lines[2]
      self.line4 = lines[3]
    end;

  end class Line;

  class Type #:
    An abstraction of a Meta type.

    Primitive Types
     - bool
     - char (nightmare of unicode)
     - int<1> to int<128>, with what 'int' refers to be customizable.
        - implemented with masking, shifting, etc.
     - real<32>, real<64>, real<128> with 'real' being customizable.
     - complex

    Interned String Type
     - See discussion in <<src_root>/README.md

    Native Types
    - These are types that are mapped to baselanguage-level types where
      possible.
    - A meta class exists to define the interface, but the same interface
      is mapped onto base language functionality.
    - All primitive types provide a similar 'virtual' interface, so methods
      can be sent to numbers: 5.2.round, 7.floor, etc.
    - Native types are those that:
       - exist in Type.NATIVE, or
       - start with 'meta!' or '!'

    To be supported:
     - unique, shared, weak pointers
        - http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
     - http://clang.llvm.org/docs/ThreadSafetyAnalysis.html
     - literals for units of measurement
        - Ex: 95kg, 1.2m, 37oC, etc.
        - https://en.wikipedia.org/wiki/Units_of_measurement
        - kinds of units
           - length (metre, foot, yard, etc)
           - mass (kilogram, pound, stone, etc.)
           - time (second, minute, hour, day, week)
           - electric current (ampere, ???)
           - temperature (kelvin, celsius, fahrenheit)
           - luminous intensity (candela, ...)
           - amount of substance (mole, ...)
           - ... how to deal with derived units?

    Notes on combining the pass-by indicator ('@', '*' and '&') with
    constness indicator ('#'):
      pass-by-pointer
         *T   -> pointer to T
         *#T  -> pointer to const T (cannot modify what var points to)
         #*T  -> const pointer to T (can change var to a different value)
         #*#T -> const pointer to const T (cannot modify var or what it points to)

         &T   -> reference to T
         &#T  -> reference to constant T (cannot modify T, cannot modify ref)
     no! #&T  -> const reference to T, but references are always const so
                 this is the same as &T (and is disallowed to avoid clutter).

         @T   -> by-value T (copy if arg, guartanteed to be non-null if field)
         @#T  -> copy of const T (no different than just @T in most cases, but may be useful for local vars where one wants to remind oneself not to modify something ... const int val)
     no! #@T  -> const copy of T (same as @#T which is more canonical so this is disallowed)

    Notes about unique_ptr, shared_ptr and weak_ptr.
          u*T -> std::unique_ptr<T>
         u*#T -> std::unique_ptr<const T>
         #u*T -> const std::unique_ptr<T>
        #u*#T -> const std::unique_ptr<const T>

          s*T -> std::shared_ptr<T>
         s*#T -> std::shared_ptr<const T>
         #s*T -> const std::shared_ptr<T>
        #s*#T -> const std::shared_ptr<const T>

          w*T -> std::weak_ptr<T>
         w*#T -> std::weak_ptr<const T>
         #w*T -> const std::weak_ptr<T>
        #w*#T -> const std::weak_ptr<const T>

    Other rules about types:
     no! &&T  -> cannot take reference to a reference
         &*T  -> a reference to a pointer (so the pointer itself can be modified)
     no! *&T  -> a pointer to a reference is not allowed
     no! #&   -> use &#
     no! #@   -> use @#
     no! ##   -> redundant
     no! @*   -> use *
     no! @&   -> use &
     no! u#*T -> use #u*T
     no! s#*T -> use #s*T
     no! w#*T -> use #w*T

    Legal type prefixes are:
      @#?
      &?(#?[usw]?\*)*#?

    How to type a variable V.
     - Establish the base type T
     - Is T modifiable?
         If not, prefix with '#'
     - Can the variable be null?
        - if not
          - for a field or local var, prefix with '@'
          - for an arg, prefix with '&' (pass-by-ref) or '@' (pass-by-value)
     - Is T a class type and can variable can be null?
        - prefix with '*' or leave off (default is to prefix with '*')
     - If the variable is a primitive type and one wants pass-by-refence semantics,
        - prefix with '&' or '*' (boxed class will be used if lang does not support)
     - Any '*' in the prefix can be prefixed with 'u' (unique ptr), 's'
       (shared ptr) or 'w' (weak ptr) to obtain implicit memory management,
       and can be further prefixed by '#' to indicate the pointer itself is
       const (cannot be changed).  Note that in languages that provide
       garbage collection [usw] is ignored, but '#' can still be semantically
       useful.

    Does it make sense to claim that Meta has any primitive types?  Maybe
    these are just numeric examples of native types supported by Meta?

    On the other hand, it is useful to be able to ask if the type is primitve
    in situations where none of @, * or & are specified ... primitive types
    default to @, others to * (see details in Type.Instance())

    ----------------------------------------------------------------------
    Type Analysis and Inference In Meta

    Meta has the following data-structures useful for type analysis and inference
     - ClassConstruct maintains
        - the collection of all 'field' instances
        - the collection of all 'method' instances
       and they are initialized in ...?

     - ExecutableConstruct maintains:
        - the collection of all ...?

  scope:

    meta
    lifecycle MetaType #:
      meta public raw field PRIMITIVE : map<str,map> #:
        A mapping from Meta primitive type name to map containing:
          args: tuple
        Note that aliases for Meta primitive types must also be specified
        explicitly (e.g. 'float' and 'double', etc.
      meta public raw field NATIVE : map<str,map> #:
        Keys are Meta native types, values are maps containing:
          defparam: str
          args: tuple
      meta public raw field EXTERNAL_CLASS_INDICATOR : str = '^' #:
        Any type that starts with this value indicates that the core type
        is one defined outside of Meta. For example, the 'object' class from
        python is denoted '^object', and the 'Object' class from javascript
        is denoted '^Object'. Without such a prefix, 'object' would be
        interpreted as a relative type name, and the namespace would be
        appended to it to obtain the actual type.
      meta public raw field RE : regexp #:
        The regexp identifying a legal Meta type and all of its constituent parts.
      meta public raw field Repository : map #:
        The repository of interned Type instances.  Keys are 'raw' representations,
        and values are Type instances.  A first invocation of Type.Instance()
        with a particular raw type string will create a new Type instance, cache
        it, and return it.  Subsequent invocations of Type.Instance() for the
        same raw type string will return the previously created instance.
    scope:
      cls.EXTERNAL_CLASS_INDICATOR = '^';
      cls.PRIMITIVE = {
        /# bool, boolean
        'bool': {},
        /# char
        'char': {},  # <1>, <2>, <4> ???
        /# byte, short, int, long, longlong
        'int': {'args': ('int',)},   # <1> ... <128>
        /# unsigned byte, short, int, long, longlong
        'uint': {'args': ('int',)},   # <1> ... <128>
        /# float, double
        'real': {'args': ('int',)},  # <32> or <64> or <128>
        'float': {},
        'double': {},
        /# complex
        'complex': {},
      }
      cls.NATIVE = {
        'any': {},
        'void': {'defparam': ''},
        /# interned (const) string
        'str': {},
        /# mutable string
        'string': {},
        /# map, dict, hashtable, associative array
        'map': {'args': ('*', '*')},
        /# immutable ordered container: tuple
        /#  - a k-tuple can be specified with either no parameters or with k params.
        /#     - tuple
        /#     - tuple<int,str,Person>
        'tuple': {},
        /# mutable ordered container: vector, list, growable array
        'vec': {'args': ('*')},
        /# mutable unordered container: set, frozenset
        'set': {'args': ('*')},

        'ostream': {},
        'istream': {},
        'strstream': {},

        /# TODO(wmh): Establish what the names for time-related native types
        /# will be:
        /#  - to represent a date and time
        /#    - if year, month, day, hour, minute, second explicitly
        /#      - datetime
        /#      - time
        /#      - ymdhms
        /#    - if only store number of seconds relative to start
        /#      - timestamp
        /#    - if we want support for relative dates
        /#      - ??
        /#  - to represent a date (year, month, day)
        /#    - if year, month, day explicitly
        /#      - date
        /#      - ymd
        /#    - if only store number of days relative to start
        /#      - ??
        /#  - to represent a time within a day without the date
        /#    - if hour, minute, second stored explicitly
        /#      - ?
        /#    - if only store number of seconds relative to 00:00:00
        /#      - should this be related to the concept of Duration?
        /#
        /# Would be preferable to find high-level names that don't assume a
        /# particular implementation (and provide implementation-specific
        /# variants similar to how we'll do for map and vec).
        /#
        /# Desired features
        /#  - very space efficient
        /#  - very time efficient
        /#  - can perform relative date manipulation

        'regexp': {},

        'nulltype': {},
        'class': {},
        'method': {},
        'function': {},

        'void': {},
      }

      cls.RE = None
      cls.Repository = None

      /# TODO(wmh): Added the $? on 2016-06-30 to support "generic types" ala
      /# templates and generics (hash<$K,$V>, etc.).  Need to add support for
      /# this throughout the codebase.
      cls.LEGAL_METATYPE_RE = re.compile(
        r'^(?P<prefix>&?(?:#?[usw]?\*)*#?|@#?|&#?|\$)?'
        r'(?P<base>\%s?[a-zA-Z0-9_.!:]+)'
        r'(?:<(?P<params>\S+)>)?$'
        % cls.EXTERNAL_CLASS_INDICATOR)
      cls.METATYPE_SPLIT = re.compile(r'([#])?([usw])?\*')
    end lifecycle MetaType;

    meta
    method Initialize #:
      Initialize the repository with some fundamental types.

      This method is intentionally NOT placed within the metaclass initializer
      because it is useful to be able to reset the repository during unit tests.
    scope:
      /# We create Type instances for various ubiquitous types and aliases
      /# of those types.
      /#
      /# See ../../README.md section 'Implementing interned string support'
      /# for details on *str, &str, @str, #str and str. Below, we are
      /# implementing 'str' = '*str'.
      assert cls.Repository is None
      cls.Repository = {}
      strreftype = cls.Instance('&str')
      strptrtype = cls.Instance('*str')
      /# Because 'str' means '*str' it really isn't necessary to pass in
      /# default_prefix, but it is left in case we decide to swtich back to
      /# 'str' meaning '&'.
      strtype = cls.Instance('str', default_prefix='*')
      assert sorted(cls.Repository.keys()) == ['&str', '*str', 'str']

      /# TODO(wmh): Are there other types we should intern?
    test:
      metax.c.Type.Repository = None
      metax.c.Type.Initialize()
      test.iseqvec(
        ['&str', '*str', 'str'],
        sorted(metax.c.Type.Repository.keys()))
    end method Initialize;

    meta
    method Instance #:
      Return the interned instance of a Type given a representation.
    params:
      var raw : str #:
        The raw type
      var allow_invalid : bool = false #:
        If True, invalid types do not raise an Error.
      var cons : str = null #:
        The construct kind.  Used to determine what the default prefix
        should be when one is not specified.
      var default_prefix : str = null #:
        This is almost never given, but can be provided for special snowflake
        types whose default prefix differs from the normal rules ('@' for
        primitives, '*' for anything else). See Type.Initialize() for an
        example.
      var namespace_function : function = null #:
        A function accepting no args that returns the namespace within which
        the Type appears.  Used to resolve relative class types.  If resolution
        is needed, it is an error not to provide such a function
    scope:
      wrapper = None
      result = cls.Repository.get(raw, None)
      if not result:
        match = cls.LEGAL_METATYPE_RE.match(raw)
        if match:
          prefix, base, params_str = match.groups()
          params = cls.ParseTypes(
            params_str, allow_invalid=allow_invalid,
            namespace_function=namespace_function)
          native = (base in cls.NATIVE) or base.startswith('meta!') or base[0] == '!'
          primitive = base in cls.PRIMITIVE
          if not prefix:
            /# The rationale for what prefix to use when one is not explicit
            /# provided is discussed in detail in <<src_root>>/README.md. The
            /# summary is:
            /#   - Use '@' for primitive types
            /#   - Use '&' for 'str' (because &str is interpreted specially)
            /#   - Use '*' for all other types.
            if base == 'void' or primitive:
              prefix = '@'
            elif default_prefix is not None:
              prefix = default_prefix
            else:
              prefix = '*'

          use_native = native or primitive
          if (
            not use_native
            and Context.TOKENS['scope_sep'] not in base
            and base[0] != Context.TOKENS['explicit_class_indicator']
          ):
            /# This type refers to a relative class name (as opposed to a fully
            /# qualified one).  We need to establish both a Type instance that
            /# uses the fully qualified class name, and a TypeWrapper instance
            /# that captures this particular relative type.
            if namespace_function is None:
              raise Error('Must provide a namespace')
            namespace = namespace_function()
            if not isinstance(namespace, NamespaceConstruct):
              print 'ERROR: %s() = %s (%s) when resolving type "%s"' % (
                namespace_function,
                namespace, namespace.kindid() if namespace else None, base)
              raise Error(
                'Failed to establish namespace ... cannot qualify %s' % raw)

            wrapper = namespace.getType(raw)
            if wrapper:
              /# We have previously seen the same relative type, and can use it.
              result = wrapper.type()
            else:
              /# We need to create Type and TypeWrapper instances.
              nmsp = namespace.id()
              fqcn = nmsp + '.' + base
              fqraw = prefix + fqcn + (params_str or '')
              result = cls(
                fqraw, prefix, fqcn, params=params, native=False)
              wrapper = TypeWrapper(result, raw)
              namespace.registerType(wrapper)
          else:
            result = cls(raw, prefix, base, params=params, native=use_native)
        else:
          if allow_invalid:
            /# We are to return a Type instance even though it is invalid.
            result = cls(raw, prefix=None, base=None, native=False)
          else:
            result = None
        if result:
          cls.Repository[result.raw()] = result
      if not allow_invalid:
        if not result or not result.isValid():
          raise metax.root.Error('Invalid type %s (%s)' % (raw, result))
      return wrapper or result
    test:
      /# Create a namespace for use when a type needs to resolve a relative
      /# class.
      _, _, context, _ = self.cachedInfo()
      namespace = metax.c.NamespaceConstruct.NewFromData('nm.sp', context)
      nmspfunc = lambda: namespace

      /# The following types should all be valid and verbatim
      for mtstr in (
        '*str',
        '@void',
        '*map<*str,@int>',
        '*tuple<&#int,*#int,#*int,@#int>',
        '*nm.sp.Person',
      ):
        typ = metax.c.Type.Instance(mtstr, namespace_function=nmspfunc)
        self.assertTrue(typ.isValid())
        test.iseq(mtstr, typ.asStr(mode=1))

      /# The following types are valid but involve a rewrite.
      for mtstr, canonical in (
        ('int', '@int'),
        ('void', '@void'),
        /# TODO(wmh): Should '*^Object' be cleaned up or left as is?
        /# Note that '^' is not legal in types, only in 'parent', 'metaparent',
        /# and 'testparent' attributes of 'class' constructs, which have type
        /# 'word', not 'type'.  So having '^Object' in this list is kinda
        /# wrong to begin with.
        ('^Object', '*^Object'),
        ('str', '*str'),
        ('a.b.Person', '*a.b.Person'),
        ('map<int,*str,*a.b.Person>', '*map<@int,*str,*a.b.Person>'),
        ('A', '*nm.sp.A'),
        ('*A', '*nm.sp.A'),
        ('u*A', 'u*nm.sp.A'),
        ('s*A', 's*nm.sp.A'),
        ('w*A', 'w*nm.sp.A'),
        ('#u*A', '#u*nm.sp.A'),
        ('#s*A', '#s*nm.sp.A'),
        ('#w*A', '#w*nm.sp.A'),
        /# TODO(wmh): support this!
        /#('map<int,str,Person>', '&map<@int,*str,*Person>')
      ):
        typ = metax.c.Type.Instance(mtstr, namespace_function=nmspfunc)
        self.assertTrue(typ.isValid())
        test.iseq(canonical, typ.asStr(mode=1))

      /# The following types are invalid
      for mtstr in (
        'int@',
        'u#*A',
        's#*A',
        'w#*A',
      ):
        typ = metax.c.Type.Instance(
          mtstr, allow_invalid=True, namespace_function=nmspfunc)
        test.iseq(False, typ.isValid())
    end method Instance;

    meta
    method ParseTypes : vec<Type> #:
      Parse a comma-separated list of types into a list of Types.

      This parses the parameterized types associated with container classes.
      For example, a Map is of the form '*map<str,@int>', and a
      vector of vector of maps is: vec<vec<map<str,*int>>>'.  This
      method does not parse the entire type, just the portion inside the <...>,
      so for our two examples, params_str would be 'str,@int' and
      'vec<map<str,*int>>' respectively.
    params:
      var params_str : str #:
        The comma-separated list of within-parameter types to parse.
      var allow_invalid : bool = false #:
        If True, allow invalid types, otherwise raise Error.
      var namespace_function : function = null #:
        A function accepting no args that returns the namespace within which
        the Type appears.  Used to resolve relative class types.  If resolution
        is needed, it is an error not to provide such a function
    scope:
      if not params_str:
        return None
      result = []
      angles = 0
      start = 0
      i = 0
      N = len(params_str)
      sep = ','
      while True:
        if i > N:
          break
        if i == N or (params_str[i] == sep and angles == 0):
          raw = params_str[start:i]
          try:
            /# We first check if 'raw' is an integer.
            type_ = int(raw)
          except ValueError:
            type_ = cls.Instance(
              raw, allow_invalid=allow_invalid,
              namespace_function=namespace_function)
          result.append(type_)
          i += 1
          start = i
        else:
          c = params_str[i]
          if c == '<':
            angles += 1
          elif c == '>':
            angles -= 1
            if angles < 0:
              /# TODO(wmh): What to do when allow_invalid is true?
              raise metax.root.Error(
                'Invalid params (too many <): %s' % params_str)
          i += 1
      return result
    test:
      metax.c.Type.Repository = None
      metax.c.Type.Initialize()
      res = metax.c.Type.ParseTypes('*str,@int')
      test.iseq(['*str', '@int'], [t.raw() for t in res])
      test.iseq(
        ['&str', '*str', '@int', 'str'], sorted(metax.c.Type.Repository.keys()))
      res2 = metax.c.Type.ParseTypes('*map<*str,@int>')
      test.iseq(1, len(res2))
      params = res2[0].params()
      test.iseq(['*str', '@int'], [t.raw() for t in params])
      self.assertTrue(params[0] is metax.c.Type.Repository['*str'])
      self.assertTrue(params[1] is metax.c.Type.Repository['@int'])
      res3 = metax.c.Type.ParseTypes('3')
      test.iseq([3], res3)
    end method ParseTypes;

    meta
    method ShowRepository #:
      Print out the repository (useful during debugging).
    params:
      var fp : ostream = out;
    scope:
      rep = cls.Repository
      for tstr in sorted(rep):
        metatype = rep[tstr]
        fp.write('%-30s : %s\n' % (tstr, metatype))
    test:
      metax.c.Type.Repository = None
      metax.c.Type.Initialize()
      fp = test.newStr()
      metax.c.Type.ShowRepository(fp=fp)
      test.iseqtext(
        '&str                           : &str\n'
        '*str                           : *str\n'
        'str                            : str\n',
        fp.getvalue())
    end method ShowRepository;

    field prefix : str #:
      The pass-by and const semantics indicators.
    field base : str #:
      The base type
    field native : bool #:
      True if we are to use the base-language native type associated with
      this type when generating base-language code.  This is true
      for both native types and primitive types.
    field params : vec<any> #:
      The parameters of this type. Each element can be either a Type or an int.
    field raw : str #:
      The raw representation of the type.

    lifecycle params:
      var raw -> raw;
      var prefix -> prefix;
      var base -> base;
      var params -> params = null;
      var native -> native = false;
    scope:
    test:
      test.iseq('@int<32>', test.type.raw())
    end lifecycle;

    method clone : Type #:
      Make a copy of myself.
      TODO(wmh): Move to 'copy' attribute of 'lifecycle' when support available.
    scope:
      cls = self.__class__
      if self._params is None:
        params = None
      else:
        params = []
        for param in self._params:
          if isinstance(param, Type):
            params.append(param.clone())
          else:
            params.append(param)
      return cls(
        self._raw, self._prefix, self._base, params=params, native=self._native)
    test:
      type = test.type
      type2 = type.clone()
      test.notsame(type, type2)
      test.iseq(type.asStr(), type2.asStr())
    end method clone;

    method dump : void #:
      Print out details about this Type instance.

      TODO(wmh): This should be an automatically generated method.
    params:
      var fp : ostream = out;
    scope:
      fp.write('Type: %s\n' % self._raw)
      fp.write('  prefix = %s\n' % self._prefix)
      fp.write('  base   = %s\n' % self._base)
      fp.write('  native = %s\n' % self._native)
      fp.write('  params = %s\n' % self._params)
    test:
      fp = test.newStr()
      test.type.dump(fp=fp)
      test.iseqtext(
        'Type: @int<32>\n'
        '  prefix = @\n'
        '  base   = int\n'
        '  native = False\n'
        "  params = ['32']\n",
        fp.getvalue())
    end method dump;

    method numericParam : int #:
      Returns an integer if the params has size 1 and is an int, else 0.
    scope:
      params = self._params
      if params and len(params) == 1 and isinstance(params[0], int):
        result = params[0]
      elif self._raw == 'bool':
        result = 1
      else:
        result = 0
      return result
    test:
      test.iseq(0, test.type.numericParam())
      typ = metax.c.Type.Instance('uint<14>')
      test.iseq(14, typ.numericParam())
      typ2 = metax.c.Type.Instance('map<14,str>')
      test.iseq(0, typ2.numericParam())
      typ3 = metax.c.Type.Instance('bool')
      test.iseq(1, typ3.numericParam())
    end method numericParam;

    method fqcn : str #:
      Obtain the fully qualified class name.

      Returns:
        Returns None if the type is primitive or native.
    scope:
      if self.isPrimitive() or self.isNative():
        result = None
      else:
        result = self.base()
      return result
    test:
      types = metax.c.Type.ParseTypes('int,str,nmsp.sub.A,&a.b.C')
      test.iseq(
        [None, None, 'nmsp.sub.A', 'a.b.C'],
        [t.fqcn() for t in types])
    end method fqcn;

    method paramStr : str #:
      The parameters of the type as a string.
    scope:
      raw = self.raw()
      index = raw.find('<')
      if index == -1:
        result = ''
      else:
        result = raw[index:]
      return result
    test:
      test.iseq('', metax.c.Type.Instance('int').paramStr())
      test.iseq('<17>', metax.c.Type.Instance('int<17>').paramStr())
      test.iseq('<str,a.A>', metax.c.Type.Instance('map<str,a.A>').paramStr())
    end method paramStr;

    method isPrimitive : bool #:
      Determine if the base type is primitive.  Note that a pointer to a pointer
      to a primitive is considered primitive.
    scope:
      return self.__class__.PRIMITIVE.get(self.base(), None) is not None
    test:
      typ1 = metax.c.Type.Instance('uint<8>')
      test.iseq(True, typ1.isPrimitive())
      typ2 = metax.c.Type.Instance('*a.b.Person')
      test.iseq(False, typ2.isPrimitive())
    end method isPrimitive;

    method isNative : bool #:
      Determine if the base type is a native type.
    scope:
      return self.__class__.NATIVE.get(self.base(), None) is not None
    test:
      test.isfalse(test.type.isNative())
    end method isNative;

    method isValid : bool #:
      Determine if this is a valid (legal) type.
    scope:
      base = self.base()
      return self._native or bool(self.prefix() and base)
    test:
      t1 = metax.c.Type.Instance('*str')
      test.iseq(True, t1.isValid())
      t2 = metax.c.Type.Instance('@@blah', allow_invalid=True)
      test.iseq(False, t2.isValid())
    end method isValid;

    method isBaseConst : bool #:
      Determine if the base type is const or not.
      TODO(wmh): isPrimitive and isNative are about base types too, but
      are not named isBasePrimitive or isBaseNative. Why is this not named
      isConst() instead?
    scope:
      /# TODO(wmh): Conceptually, 'str' (and '@str' and '&str' and '*str')
      /# should return true for isBaseConst. But currently isBaseConst() is
      /# used in FieldConstruct.translateMeta() to determine whether to
      /# generate setters/reffers (no for const types) ... but we DO want
      /# to generate setters for fields of type 'str' (distinction between
      /# changing the string and changing the variable storing the string).

      return self.prefix().endswith('#')
    test:
      test.iseq(
        [False, False, True, True, False],
        [t.isBaseConst() for t in
         metax.c.Type.ParseTypes(
           'str,int,#a.Person,#int,#*a.Person')])
    end method isBaseConst;

    method isTemplate : bool #:
      Determine if this is a template type or not.
    scope:
      prefix = self.prefix()
      return prefix and prefix == '$'
    test:
      test.isfalse(test.type.isTemplate())
    end method isTemplate;

    method isPtr : bool #:
      Determine if this is a pointer type or not.
    scope:
      prefix = self.prefix()
      if not prefix:
        raise metax.root.Error('All types should have a prefix: %s' % self.raw())
      /# If there is a '*' anywhere in prefix, this is a pointer type.
      return '*' in prefix
    test:
      test.iseq(
        [True, False, True, True, True, False, True, True, False],
        [t.isPtr() for t in
         metax.c.Type.ParseTypes(
           'str,int,*a.Person,*int,a.Person,&a.Person,*#a.A,**a.A,&#a.A')])
    end method isPtr;

    method isRef : bool #:
      Determine if this is a reference type or not.
    scope:
      prefix = self.prefix()
      if not prefix:
        raise metax.root.Error('All types should have a prefix: %s' % self.raw())
      return prefix[0] == '&' and '*' not in prefix
    test:
      test.iseq(
        [False, False, False, False, False, True, False],
        [t.isRef() for t in
         metax.c.Type.ParseTypes(
           'str,int,*a.Person,*int,a.Person,&a.Person,&*a.A')])
    end method isRef;

    method isRefPtr : bool #:
      Determine if this is areference to a pointer.
    scope:
      prefix = self.prefix()
      if not prefix:
        raise metax.root.Error('All types should have a prefix: %s' % self.raw())
      return prefix[0] == '&' and '*' in prefix
    test:
      test.iseq(
        [False, False, False, False, False, False, False, False, False, True],
        [t.isRefPtr() for t in
         metax.c.Type.ParseTypes(
           'str,int,*a.Person,*int,a.Person,&a.Person,*#a.A,**a.A,&#a.A,&*a.A')])
    end method isRefPtr;

    method isValue : bool #:
      Determine if this is a value type or not.
    scope:
      prefix = self.prefix()
      if not prefix:
        raise metax.root.Error('All types should have a prefix: %s' % self.raw())
      return prefix[0] == '@'
    test:
      test.istrue(test.type.isValue())
    end method isValue;

    method isStr : bool #:
      True if the type is 'str' (or '@str' or '&str' or '*str')
    scope:
      return self.base() == 'str'
    test:
      test.isfalse(test.type.isStr())
      test.istrue(metax.c.Type.Instance('str').isStr())
    end method isStr;

    method isVoid : bool #:
      Determine if this is the void type or not.
      TODO(wmh): We will almost certainly need to make a distinction between
      '*void' and 'void'. Currently this method returns True for both, but
      we should maybe have isVoid() and isBaseVoid() to distinguish.
    scope:
      return self.base() == 'void'
    test:
      test.isfalse(test.type.isVoid())
      test.istrue(metax.c.Type.Instance('void').isVoid())
    end method isVoid;

    method isAny : bool #:
      Determine if this is the 'any' type or not.
      TODO(wmh): We will almost certainly need to make a distinction between
      '*any' and 'any'. Currently this method returns True for both, but
      we should maybe have isAny() and isBaseAny() to distinguish.
    scope:
      return self.base() == 'any'
    test:
      test.isfalse(test.type.isVoid())
    end method isAny;

    method asStr : str #:
      Convert to a string according to mode.
    params:
      var mode : int = 0 #:
        If 0, print the verbatim type seen.
        Otherwise print the type formed by composing parsed data.
    scope:
      raw = self.raw()
      if mode == 0 or raw.startswith('{#') and raw.endswith('#}'):
        result = raw
      else:
        params_str = ''
        params = self.params()
        if params:
          params_list = []
          for type_ in params:
            params_list.append(type_.asStr(mode=mode))
          params_str = '<' + ','.join(params_list) + '>'
        result = '%s%s%s' % (
          self.prefix(), self.base(), params_str)
        /#if result != self.raw():
        /#  result += ' [%s]' % self.raw()
      return result
    test:
      test.iseq('@int<32>', test.type.asStr())
    end method asStr;

    method __str__ : str #:
      TODO(wmh): Meta should auto-generate baselang-specific to-string
      methods based on asStr() or some more formal method.
    scope:
      return self.asStr()
    test:
      t1 = metax.c.Type.Instance('*str')
      test.iseq('*str', str(t1))
    end method __str__;

    test
    lifecycle setup:
      metax.c.Type.Repository = None
      metax.c.Type.Initialize()
      self.type = metax.c.Type('@int<32>', '@', 'int', ['32'])
    end lifecycle;
  end class Type;

  native #:
    TODO(wmh): How to cleanly handle this situation? The following
    code cannot be invoked within the metaclass initializer because it
    attempts to create an instance of Type, which does not yet exist within
    the metaclass initializer.
  scope:
    Type.Initialize()
  end;

  class TypeWrapper #:
    A wrapper for the Type class.

    The Type class has interned instances for each type in the system.
    Internment provides efficiency but is at odds with wanting a distinction
    between the canonical type and display type (where display type can differ
    depending on context).

    In particular, suppose we have
       namespace ex.code ::
         class A ::
           method meth : B ...
    The return type of 'meth' is not fully qualified, but under the hood Meta
    needs to know the fully qualified type in order to be able to find the
    associated class during type analysis. But if we create an interned Type
    instance with value ex.code.B, then when we canonicalize the code, the type
    will no longer be local, it will appear as 'ex.code.B', when the local
    version is arguably more readable (less clutter).

    To address this issue, the following strategy is used:
     - All interned Type instances specify fully qualified class names
       (for non-native, non-primitive types)
     - In the code, a type specification that is not fully qualified is
       made an instance of TypeWrapper, which contains the internted Type
       instance and a display representation.  This class otherwise responds
       to exactly the same interface as Type, with the sole difference being
       how the type responds to __str__ ... Type instances print the fully
       qualified class name, TypeWrapper instances print their cached display
       string instead.  There can be many TypeWrapper instances for the
       same local type, but only a single Type instance.

  scope:

    field type : metax.c.Type #:
      The type being wrapped.

    field display : str #:
      The local type name found in the source code, and to be displayed during
      (some) canonicalizations.

    lifecycle params:
      var type -> type;
      var display -> display;
    scope:
    end;

    method wrappedRaw : str #:
      The local type name found in the source code.
    scope:
      return self._display
    test:
      test.iseq('Person', test.wrap.wrappedRaw())
    end method wrappedRaw;

    method __str__ : str #:
      The printable representation of this WrappedType instance.
    scope:
      return self._display
    test:
      test.iseq('a.b.Person', str(test.type))
      test.iseq('Person', str(test.wrap))
    end method __str__;

    method __getattr__ : any #:
      This method delegates all non-locally defined methods to the contained
      self.type().
      TODO(wmh): This is a python-specific method, and a more general mechanism
      for delegating all non-local methods to a contained object is needed.
    params:
      var name;
    scope:
      return getattr(self._type, name)
    test:
      /# noop. See test_isPtr, test_isRef, test_fqcn below.
      pass
    end method __getattr__;

    test
    lifecycle #:
      TODO(wmh): Remember that in Meta2, we won't have a tests: block
      in classes, and instead will define methods as test methods like we
      currently define meta methods.
    setup:
      metax.c.Type.Repository = None
      metax.c.Type.Initialize()
      self.type = metax.c.Type.Instance('a.b.Person')
      self.wrap = metax.c.TypeWrapper(self.type, 'Person')
    end lifecycle;

    test
    method test_isPtr scope:
      test.iseq(True, test.type.isPtr())
      test.iseq(True, test.wrap.isPtr())
    end method test_isPtr;

    test
    method test_isRef scope:
      test.iseq(False, test.type.isRef())
      test.iseq(False, test.wrap.isRef())
    end method test_isRef;

    test
    method test_fqcn scope:
      test.iseq('a.b.Person', test.type.fqcn())
      test.iseq('a.b.Person', test.wrap.fqcn())
    end method test_fqcn;

  end class TypeWrapper;

  class SymbolTable #:
    Maintain a collection of symbol/construct mappings, supporting inheritance.
  scope:

    field construct : Construct #:
      The construct that owns this symboltable.
      TODO(wmh): This should be a weak reference.

    field parent : SymbolTable #:
      The parent symboltable. NamespaceConstructs have a null parent in their
      symbol table, but ClassConstruct symbol tables reference the symbol table
      of their namespace, and MethodConstruct symbol tables reference the
      symbol table of their class.

    field symbols : @map<str,map> #:
      Maps symbol name to symbol data. The data is a map with keys:
        construct: Construct
          May be a VarConstruct, a MethodConstruct, a ClassConstruct, or a
          a NamespaceConstruct.
        source: Construct
          Where the symbol was obtained from
        note: str (optional)
          Human-readable notes about the symbol

    lifecycle params:
      var construct -> construct;
      var parent -> parent;
    scope:
    end;

    method allSymbols : map<str,Construct> #:
      All symbols transitively visible within this table.
    scope:
      result = {}
      table = self
      while table is not None:
        symbols = table.symbols()
        for symbol, data in symbols.iteritems():
          if symbol not in result:
            result[symbol] = data
        table = table.parent()
      return result
    test:
      test.iseqvec(
        ['Card'],
        sorted(test.ntable.allSymbols().keys()))
      test.iseqvec(
        ['Card', '__init__', 'f', 'show'],
        sorted(test.ctable.allSymbols().keys()))
      test.iseqvec(
        ['height', 'name', 'self'],
        sorted(test.mtable.allSymbols().keys()))
    end method allSymbols;

    method findInfo : map #:
      Resolve a symbol into its associated map. See field symbols for details.
    params:
      var symbol : str #:
        The symbol to resolve.
    scope:
      result = None
      table = self
      while result is None and table:
        result = table.symbols().get(symbol, None)
        table = table.parent()
      return result
    test:
      test.iseq('height', test.mtable.findInfo('height')['construct'].id())
      test.iseq('f', test.ctable.findInfo('f')['construct'].id())
      test.iseq('Card', test.ctable.findInfo('Card')['construct'].id())
      test.isnull(test.ctable.findInfo('not-a-symbol'))
    end method findInfo;

    method find : Construct #:
      Resolve a symbol into its associated construct.
    params:
      var symbol : str #:
        The symbol to resolve.
    scope:
      result = None
      table = self
      while result is None and table:
        result = table.symbols().get(symbol, None)
        table = table.parent()
      return result['construct'] if result else None
    test:
      test.iseq('height', test.mtable.find('height').id())
      test.iseq('f', test.ctable.find('f').id())
      test.iseq('Card', test.ctable.find('Card').id())
      test.isnull(test.ctable.find('not-a-symbol'))
    end method find;

    method register #:
      Register a symbol with this table.
    params:
      var symbol : str #:
        The symbol name.
      var construct : Construct #:
        The construct associated with the symbol.
      var source : Construct = null #:
        Where this symbol is defined.  This param is almost always null,
        because self.construct() is almost always the value to use.
      var note : str = null #:
        Any human-readable notes associated with the symbol.
    scope:
      symbols = self.symbols()
      if symbol in symbols:
        raise Error(
          'Attempt to re-register %s within %s' %
          (symbol, self.construct().kindfqn()))
      if source is None:
        source = self.construct()
      data = {'construct': construct, 'source': source}
      if note:
        data['note'] = note
      symbols[symbol] = data
    test:
      /# register was called in setup.
      test.iseq(3, len(test.mtable.symbols()))
    end method register;

    method show #:
      Print out a symbol table
    params:
      var fp : ostream = out #:
        Where to write output
      var indent : str = '' #:
        Indentation before each line of output.
      var full : bool = false #:
        If true, show inherited symbols too.
      var width : int = -1 #:
        The amount of space reserved for symbol names in output.
        If negative, width of longest symbol is used.
    scope:
      construct = self.construct()
      symbols = self.allSymbols() if full else self.symbols()
      subindent = indent + '  '
      fp.write('%sSymbolTable for %s:\n' % (indent, construct.kindfqn()))
      if symbols:
        if width < 0:
          width = max([len(s) for s in symbols])
        for symbol in sorted(symbols):
          data = symbols[symbol]
          construct = data['construct']
          location = ' (%s)' % data['source'].kind() if full else ''
          notestr = data.get('note', None)
          note = ' [%s]' % notestr if notestr else ''
          fp.write(
            '%s%s = %s%s%s\n' %
            (subindent, symbol.ljust(width), construct.kindfqn(), location,
             note))
      else:
        fp.write('%s  empty\n' % indent)
    test:
      fp = test.fp()
      test.mtable.show(fp=fp, width=20)
      test.mtable.show(fp=fp, full=True, width=20)
      test.ctable.show(fp=fp)
      test.ctable.show(fp=fp, full=True)

      test.iseqtext(
        >|"""SymbolTable for method nm.sp.Card.show:
        >|  height               = var height
        >|  name                 = var name
        >|  self                 = var self
        >|SymbolTable for method nm.sp.Card.show:
        >|  height               = var height (method)
        >|  name                 = var name (method)
        >|  self                 = var self (method)
        >|SymbolTable for class nm.sp.Card:
        >|  __init__ = method nm.sp.Card.__init__
        >|  f        = method nm.sp.Card.f
        >|  show     = method nm.sp.Card.show
        >|SymbolTable for class nm.sp.Card:
        >|  Card     = class nm.sp.Card (namespace)
        >|  __init__ = method nm.sp.Card.__init__ (class)
        >|  f        = method nm.sp.Card.f (class)
        >|  show     = method nm.sp.Card.show (class)
        >|""",
        test.out())
    end method show;

    test
    lifecycle setup:
      test.defineClassAndMethods('py')
      TypeInst = metax.c.Type.Instance

      context = test.context

      /# Namespace symbol tables contain:
      /#  - symbols for each class defined within the namespace.
      /#  - symbols of dependent namespaces.
      test.ntable = metax.c.SymbolTable(test.namespace, None)
      test.ntable.register(test.klass.id(), test.klass)

      /# Class symbol tables contain:
      /#  - methods defined on them (user classes have user methods,
      /#    meta classes have meta methods)
      /#  - fields defined on them (user classes have user fields,
      /#    meta classes have meta fields). The raw field name is stored.
      /#
      /# This symbol table is used when establishing what symbols are legal
      /# at a call-site whose receiver is of class type C ... only symbols
      /# in the symbol table of C are legal.
      test.ctable = metax.c.SymbolTable(test.klass, test.ntable)
      test.ctable.register(test.method.id(), test.method)
      test.ctable.register(test.method2.id(), test.method2)
      test.ctable.register(test.initializer.id(), test.initializer)

      /# Method symbol tables contain:
      /#  - all parameters
      /#  - all local variables not within lexically scoped blocks.
      /#  - the special receiver pseudovar ('self' or 'test' or 'meta')
      /#  - (not?) meta-level fields/methods within user-level class method.
      /#  - DOES NOT inherit from class symboltable directly (indirectly
      /#    via the special receiver pseudovar).
      /#
      /# This symbol table is used when resolving variable references within
      /# method scope (e.g. default values of params, super args, local vars,
      /# etc.). If we have:
      /#     method f params:
      /#       var a : int = b;
      /#     super (a, C)
      /#     scope:
      /#       var f : int = g;
      /#     end;
      /# we need to be able to "see" variables 'b', 'C' and 'g' from the method
      /# symbol table in order for the syntax to be legal.
      test.mtable = metax.c.SymbolTable(test.method, None)
      test.mtable.register(
        'height',
        metax.c.VarConstruct.NewFromData(
          'height', context, termcode=1,
          secondaries=[(':', TypeInst('real'))]))
      test.mtable.register(
        'name',
        metax.c.VarConstruct.NewFromData(
          'name', context, termcode=1,
          secondaries=[(':', TypeInst('str'))]))
      test.mtable.register(
        'self',
        metax.c.VarConstruct.NewFromData(
          'self', context, termcode=1,
          secondaries=[(':', TypeInst(test.klass.fqn()))]))
    end lifecycle;

  end class SymbolTable;

  class ExprParser #:
    Parses expressions of the following forms:
     - num        : [-+0-9]
     - id         : [a-zA-Z_]
     - plist      : '('
     - str        : ' or \"
     - list       : '['
     - hash       : '{'
     - call       : '@'
  assocs:
    std assoc re;
    std test assoc pprint;
  scope:

    meta
    lifecycle scope:
      /# Map chars to functions for parsing exprs identified by the char.
      cmap = {}
      cls.CharMap = cmap
      cmap['@'] = cls._parseCall
      cmap['('] = cls._parsePList
      cmap['{'] = cls._parseHash
      cmap['['] = cls._parseList
      cmap['\"'] = cls._parseStr
      cmap["'"] = cls._parseStr
      cmap['-'] = cls._parseNum
      cmap['+'] = cls._parseNum
      for i in range(ord('0'), ord('9')+1):
        cmap[chr(i)] = cls._parseNum
      cmap['_'] = cls._parseVar
      for i in range(ord('a'), ord('z')+1):
        cmap[chr(i)] = cls._parseVar
      for i in range(ord('A'), ord('Z')+1):
        cmap[chr(i)] = cls._parseVar

      cls.TERMCHARS = list(',;)]}')

      cls.LEGAL_OP_CHARS = frozenset(list('+-*/%=!<>|&^~'))

      /# NOTE: ExprParser._parseNum() relies on NUM_RE not being fixed at the
      /# end (e.g. do not add a '$').
      cls.NUM_RE = re.compile(
        r'^([+-]?(?:0|[1-9]\d*))((?:\.\d*)?)(?:[eE]([-+]?\d+))?')

      cls.ENUM_RE = re.compile(r'^(?P<sep>[^<>]?)<(?P<spec>.*)>$')

      cls.ID_PREFIX_RE = re.compile(
        r'(?P<meta>meta!|!)?(?P<id>[a-zA-Z_][a-zA-Z0-9_]*)')

      cls.ID_RE = re.compile(
        /# TODO(wmh): Remove the 'meta!' and '!' clauses ... not needed in v2?
        r'^(?P<meta>meta!|!)?'
        r'(?P<id>[a-zA-Z_][a-zA-Z0-9_]*)'
        /# The :get notation is a hack to allow method ids to end with :get.
        /# A workaround for the fact that field constructs generate a
        /# getter with the same name, but Meta does not allow the same id
        /# to appear in the same scope.  We distinguish with :get and strip
        /# off the :get when we go to generate code. In the interests of
        /# consistency, we suffix setters and reffers similarly although they
        /# do not have the same name conflict as getters. It may, however,
        /# be useful to distinguish between fooIs (a user-provided method)
        /# and fooIs:set (a auto-generated setter for a user-provided field).
        r'(?:[:](?P<spec>get|set|ref))?$')

      cls.XID_RE = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_.]*$')

      /# This will be used in StrExpr()
      cls.DummyMetaFile = None
    test:
      /# pprint.pprint(metax.c.ExprParser.CharMap)
      test.iseq(71, len(metax.c.ExprParser.CharMap))
    end lifecycle;

    meta
    method StrExpr : Expr #:
      Given a string representation of an expression, obtain its Expr.
    params:
      var src : str #:
        The input string reprsentation.
    scope:
      /# Since ExprParser assumes a MetaFile containing all lines to be
      /# parsed, we need to wrap our src string.  Rather than creating a new
      /# MetaFile each time, we use a cached one. TODO(wmh): Lock this, or
      /# make thread-local, etc.
      metafile = cls.DummyMetaFile
      if metafile is None:
        metafile = MetaFile('/fake/path.meta', None, text='\n')
        cls.DummyMetaFile = metafile

      text = src + '\n'
      metafile.linesIs(Line.FromText(text))
      metafile.textIs(text)
      expr = cls(metafile).parse()
      return expr
    end method StrExpr;

    field source : MetaFile #:
      The MetaFile within which the expr resides.
    field row : int #:
      The line with source of the current position within the expr (from 0).
    field col : int #:
      The index within current row of the current position in the expr (from 0).
    field start : tuple<int,int> #:
      The row/col of the start of the expr.
    field errors : @vec<str> #:
      The collection of errors encountered during parsing.
    field line : str #:
      This is source[row].  If null, it means EOF has been reached.
    field terms : @vec<str> #:
      Maintains the list of terminators during recursive parsing of nested
      expressions like list, plist and hash.

    lifecycle params:
      var source -> source;
      var row -> row = 0;
      var col -> col = 0;
    scope<py>:
      assert isinstance(source, MetaFile)

      self.startIs((row, col))
      self.terms().append(';')
      self.set(row=row, col=col)
    end;

    method numrows : int #:
      Number of rows in source.
    scope:
      return len(self.source().lines())
    test:
      metafile = test.metafileFor('a \nb\ncd\n')
      eprs = metax.c.ExprParser(metafile)
      test.iseq(3, eprs.numrows())
    end method numrows;

    method pos : tuple<int,int,char> #:
      Returns current row, col and char
    scope:
      return (self.row(), self.col(), self.peek())
    test:
      eprs = metax.c.ExprParser(test.metafileFor('a \nb\ncd\n'))
      test.iseq((0, 0, 'a'), eprs.pos())
      eprs.set(row=2, col=1)
      test.iseq((2, 1, 'd'), eprs.pos())
    end method pos;

    method current : tuple<str,int> #:
      The current row text and index within that row. Same semantics as is
      returned by skipws().
    scope:
      return (self.line(), self.col())
    test:
      eprs = metax.c.ExprParser(test.metafileFor('a \nb\ncd\n'))
      test.iseq(('a \n', 0), eprs.current())
      eprs.set(row=2, col=1)
      test.iseq(('cd\n', 1), eprs.current())
    end method current;

    method peek : char #:
      Return the current character without advancing.
    scope:
      return self.line()[self.col()]
    test:
      eprs = metax.c.ExprParser(test.metafileFor('a \nb\ncd\n'))
      test.iseq('a', eprs.peek())
      eprs.set(row=2, col=1)
      test.iseq('d', eprs.peek())
    end method peek;

    method getc : char #:
      Obtain current char and advance to next.
    scope:
      line, col = self.current()
      result = line[col]
      if result == '\n':
        /# Advance to next line
        row = self.row()
        row += 1
        numrows = self.numrows()
        if row >= numrows:
          /# EOF
          self.rowIs(-1)
          self.lineIs(None)
        else:
          self.set(row=row, col=0)
      else:
        self.colIs(col + 1)
      return result
    test:
      eprs = metax.c.ExprParser(test.metafileFor('a \nb\ncd\n'))
      test.iseq('a', eprs.getc())
      test.iseq(' ', eprs.getc())
      test.iseq('\n', eprs.getc())
      test.iseq('b', eprs.getc())
      test.iseq('\n', eprs.getc())
      test.iseq('c', eprs.getc())
      test.iseq('d', eprs.getc())
      test.iseq('\n', eprs.getc())
      test.iseq(None, eprs.line())
    end method getc;

    method set #:
      Set row and/or col.  If row is specified by col is not, col is set to 0
      (start of new row).

      Any attempt to map source()[row] to a string of text should go thru
      this method, so that we have a single place to abstract away the
      exact implementation of source(). In old code, it is a list of Line,
      although the new test code assumes a list of str. We will need to decide
      how to represent the lines as we migrate to Meta.
    params:
      var row : int = -1;
      var col : int = -1;
    scope:
      if row >= 0:
        self.rowIs(row)
        newline = self.source().lines()[row].line() + '\n'
        /# print '***** HERE with %s and %s (%s)' % (self.source().__class__, newline, newline.__class__)
        self.lineIs(newline)
        if col < 0:
          col = 0
      if col >= 0:
        self.colIs(col)
    test:
      eprs = metax.c.ExprParser(test.metafileFor('a \nb\ncd\n'))
      test.iseq((0, 0, 'a'), eprs.pos())
      eprs.set(row=2, col=1)
      test.iseq((2, 1, 'd'), eprs.pos())
    end method set;

    method reset #:
      Return this eprs to its state upon first being created. e.g. not parsed,
      row and col at start row/col.
    scope:
      srow, scol = self.start()
      self.rowIs(srow)
      self.colIs(scol)
    test:
      eprs = metax.c.ExprParser(test.metafileFor('a \nb\ncd\n'), row=2, col=1)
      eprs.set(row=0, col=0)
      test.iseq((0, 0, 'a'), eprs.pos())
      eprs.reset()
      test.iseq((2, 1, ' '), eprs.pos())
    end method reset;

    method summary #:
      Print out a summary of current state of expr.
    params:
      var fp : ostream = out #:
        Where to write summary.
      var verbose : bool = false #:
        If true, print out all source lines, otherwise print out the 5 lines
        before and after the current line.
    scope:
      start = self.start()
      crow, ccol, _ = self.pos()
      fp.write(
        'ExprParser starts at R%dC%d, currrently at R%dC%d seeing "%s"\n' %
        (start[0], start[1], self.row(), self.col(),
        self.peek().replace('\n', '\\n')))

      nrows = self.numrows()
      start = 0 if verbose else max(0, self.row() - 5)
      end = nrows if verbose else min(nrows, self.row() + 5)
      for row in range(start, end):
        /# We use set() here so that we have a single place within which to
        /# abstract away details about the exact structure of 'source'.
        self.set(row=row)
        fp.write('  [%3d] %s' % (row, self.line()))
      fp.write('        ' + '0123456789' * 7 + '\n')

      errors = self.errors()
      if errors:
        fp.write('ERRORS:\n')
        for e in errors:
          fp.write('  ' + e + '\n')

      /# Reinstate position we entered this method at.
      self.set(row=crow, col=ccol)
    test:
      eprs = metax.c.ExprParser(test.metafileFor('a \nb\ncd\n'))

      fp = test.newStr()
      eprs.summary(fp=fp, verbose=False)
      test.startswith(
        'ExprParser starts at R0C0, currrently at R0C0 seeing "a"',
        fp.getvalue())

      eprs.set(row=2, col=1)
      fp = test.newStr()
      eprs.summary(fp=fp, verbose=False)
      test.startswith(
         'ExprParser starts at R0C0, currrently at R2C1 seeing "d"',
         fp.getvalue())
    end method summary;

    method error #:
      Record an error during parsing
    params:
      var msg : str;
    scope:
      self.errors().append('R%dC%d: %s' % (self.row(), self.col(), msg))
    test:
      eprs = metax.c.ExprParser(test.metafileFor('a \nb\ncd\n'))
      test.iseq([], eprs.errors())
      eprs.error('This is a test')
      test.iseq(['R0C0: This is a test'], eprs.errors())
    end method error;

    method clearErrors #:
      Remove all recorded errors.
    scope:
      self.errorsIs([])
    test:
      eprs = metax.c.ExprParser(test.metafileFor('a \nb\ncd\n'))
      eprs.error('error1')
      eprs.error('error2')
      eprs.error('error3')
      test.iseq(3, len(eprs.errors()))
      eprs.clearErrors()
      test.iseq(0, len(eprs.errors()))
    end method clearErrors;

    method errorText : str #:
      A string containing all reported errors.
    scope:
      return '\n'.join(self._errors) if self._errors else None
    test:
      eprs = metax.c.ExprParser(test.metafileFor('a \nb\ncd\n'))
      test.isnull(eprs.errorText())
      eprs.error('this is an error')
      test.iseq('R0C0: this is an error', eprs.errorText())
      eprs.error('this is a second error')
      test.iseq(
        'R0C0: this is an error\n'
        'R0C0: this is a second error',
        eprs.errorText())
    end method errorText;

    method skipws : tuple<str,int> #:
      Advance past whitespace.

      Returns:
       [0] the current line
       [1] the current column within the current line
    params:
      var nonl : bool = false #:
        If True, stop if newline encountered.
    scope:
      done = False
      line, i = self.current()
      n = len(line)
      while i < n:
        c = line[i]
        if c == ' ':
          /# advance past
          i += 1
        elif c == '\n':
          if nonl:
            /# We are not to advance past newlines
            break
          else:
            /# advance to next line and continue
            self.colIs(i)
            assert self.getc() == '\n'
            line = self.line()
            if line is None:
              /# We are at EOF
              done = True
              break
            n = len(line)
            i = 0
        else:
          /# Non-whitespace ... stop.
          break
      self.colIs(i)
      return (self.line(), self.col())
    test:
      eprs = metax.c.ExprParser(
        test.metafileFor('abc\n  def   more \n      \n  \n   abc\n'))

      /# Test normal skipping
      eprs.skipws()
      test.iseq((0, 0, 'a'), eprs.pos())
      eprs.set(row=1)
      test.iseq(('  def   more \n', 2), eprs.skipws())
      test.iseq((1, 2, 'd'), eprs.pos())
      eprs.set(1, 5)
      test.iseq(('  def   more \n', 8), eprs.skipws())
      test.iseq((1, 8, 'm'), eprs.pos())
      eprs.set(1, 12)
      test.iseq(('   abc\n', 3), eprs.skipws())
      test.iseq((4, 3, 'a'), eprs.pos())

      /# Test nonl=True
      eprs.set(row=2)
      test.iseq(('      \n', 6), eprs.skipws(nonl=True))
      test.iseq((2, 6, '\n'), eprs.pos())
    end method skipws;

    method text : str #:
      Obtain text in a specified region.
    params:
      var srow : int #:
        start row
      var scol : int #:
        start col
      var erow : int #:
        end row (inclusive)
      var ecol : int #:
        end col (inclusive!)
    scope:
      result = ''
      metafile = self.source()
      lines = metafile.lines()
      text = metafile.text()
      start = lines[srow]
      end = lines[erow]
      result = text[start.start() + scol:end.start() + ecol + 1]
      return result
    test:
      eprs = metax.c.ExprParser(
        test.metafileFor('a lad had a fall\nin the hall\nwith a keg\n'))

      test.iseq('lad had', eprs.text(0, 2, 0, 8))
      test.iseqtext('lad had a fall\nin the ha', eprs.text(0, 2, 1, 8))
      test.iseqtext(
        'lad had a fall\nin the hall\nwith a ke', eprs.text(0, 2, 2, 8))
    end method text;

    method parse : Expr #:
      Parse this expression.

      Returns:
        null is returned in two situations:
          1) If an error occurs during parsing (errors are writting to
             self.errors())
          2) If an end-of-expression character is seen after initial white
             space has been consumed. This is most commonly seen if there is
             a trailing comma after the last element in a list, plist or hash.
        One can distinguish between the above two situations by checking whether
        self.errors() has any elements.

        Otherwise, returns an Expr instance.
    params:
      var nonl : bool = false #:
        If true, do not go past newline
    scope:
      result = None
      terms = self.terms()

      /# Skip whitespace
      line, i = self.skipws(nonl=nonl)
      c = line[i]
      func = ExprParser.CharMap.get(c, None)

      if c == '\n':
        /# Only possible if nonl is true, and means we failed to find an
        /# expression
        self.error('No expression found on this line')
        result = None

      elif c == terms[-1]:
        /# We are currently parsing a complex expression that is terminated
        /# when character c is encountered.
        result = None

      elif func is False:
        /# This is special indicator informing us that 'c' represents an
        /# end-of-expression character.  This commonly occurs when a trailing
        /# comma apears after the last element in a plist, list or hash.
        /# It is not an error ... we just indicate that we are done parsing
        /# the multi-valued expression by returning None to the caller.
        result = None

      elif func:
        /# line[i] is a non-whitespace char that uniquely identifies the
        /# expression to parse.

        /# Establish the kind of expr being parsed.
        fname = func.func_name
        assert fname.startswith('_parse')
        kind = fname[6:].lower()

        /# Remember where this expression starts.
        srow, scol, _ = self.pos()

        /# Invoke the kind-specific parsing function.
        expr = func(self)

        /# Establish result
        if expr is None:
          /# An error occurred (already written to field 'errors')
          result = None
        else:
          col = self.col() - 1
          if col < 0:
            raise Error('Can this happen?')
          else:
            /# print 'Here with kind=%s srow=%d scol=%d erow=%d ecol=%d' % (
            /#   kind, srow, scol, self.row(), col)
            text = self.text(srow, scol, self.row(), col)
          result = Expr(kind, text, expr)

      else:
        /# line[i] is not the initial char in any legal expression.
        self.error('Char "%s" does not start any expression' % c)
        result = None

      return result
    test:
      eprs = metax.c.ExprParser(test.metafileFor(' 1   apple"hello"\n'))

      test.iseq('<kind=num str=1 expr=1>', str(eprs.parse()))
      test.iseq('<kind=var str=apple expr=apple>', str(eprs.parse()))
      test.iseq('<kind=str str="hello" expr="hello">', str(eprs.parse()))
      /# TODO(wmh): More tests needed, for all kinds of expressions, with
      /# edgecases!
    end method parse;

    protected
    method _parseNum : double #:
      Parse a number.

      The current position must start the number (e.g. no whitespace is
      skipped).

      This will never advance the row, but will advance col if a number
      was found (if not found, col not affected).
    scope:
      line, i = self.current()
      /# line[i] assumed to be in [-+0-9] without verification

      /# TODO(wmh): How efficient is python about text[i:]?  Is it making
      /# a copy, or just returning a datastructure starting at an index within
      /# previously interned space?  If it is poorly implemented, is there some
      /# way to start the query at index i that doesn't use text[i:] and
      /# doesn't require us to compile a regexp each time thru this func?
      numstr = line[i:]
      m = MetaExprParser.NUM_RE.match(numstr)
      if m:
        ival, fraction, exponent = m.groups()
        if fraction or exponent:
          expr = float(ival + fraction + (('e' + exponent) if exponent else ''))
        else:
          expr = int(ival)
        self.colIs(self.col() + m.end())
      else:
        self.error('Failed to match a number: "%s"' % numstr)
        expr = None

      return expr
    test:
      eprs = metax.c.ExprParser(test.metafileFor('  \n  10\n'))
      eprs.set(row=1, col=2)
      test.iseq(10, eprs._parseNum())
      test.iseq((1, 4, '\n'), eprs.pos())
      eprs.set(col=0)
      test.iseq((1, 0, ' '), eprs.pos())
      test.isnull(eprs._parseNum())
      test.iseq(['R1C0: Failed to match a number: "  10\n"'], eprs.errors())
      test.iseq((1, 0, ' '), eprs.pos())
    end method _parseNum;

    protected
    method _parseVar : str #:
      Parse a id.

      Note that pseudo vars like 'true', 'false', 'null' and native vars like
      'out', 'err', etc. are also parsed by this method

      Some variables accessible within a particular scope are not entirely
      local. For example, suppose class 'A' within namespace 'nm.sp' has a
      method 'f', a public raw class field 'M' and a public raw static variable
      'S'. From within method 'm', both 'M' and 'S' may (or may not) be 
      considered visible.  If they are visible, what syntax is used to access
      them?
       - for class fields, we have callsite notation for this:
           @nm.sp.A!M
         and if M wasn't raw, we could use accessor notation instead:
           @nm.sp.A.M
       - for static vars, there is a bit of an issue around the semantics of
         fields vs variables (it would be nice to reserve '!' for fields only),
         but it seems sensible, if static vars can have accessors, to extend
         '!' to apply to them too, in which case we can access 'S' similar
         to 'M':
           @nm.sp.A!S
         or, if S is not raw and has a getter:
           @nm.sp.A.S
       - alternatively, we could allow variables to contain '.', so that
           nm.sp.A.S
         is a reference to static variable S within class A of namespace
         'nm.sp'. But in Meta we really want to hide away fields (and vars) as
         much as possible by putting them behind accessors, and this notation
         does NOT hide them away as well as the callsite notation, so we are
         NOT supporting fully-qualified vars ... only callsites.
    scope:
      line, i = self.current()
      /# Assumes line[i] is underscore or alpha without verifying
      /# No array bounds checking needed because all lines end in '\n'
      m = MetaExprParser.ID_PREFIX_RE.match(line[i:])
      if m:
        expr = m.group()
        self.colIs(i + m.end())
      else:
        self.error('Failed to parse an identifier at "%s"' % line[i:])
        expr = None
      return expr
    test:
      eprs = metax.c.ExprParser(
        test.metafileFor('a val true meta!out a.bc.def.Hex\n'))
      eprs.set(row=0, col=0)

      self.iseq('a', eprs._parseVar())
      self.iseq(' ', eprs.getc())

      self.iseq('val', eprs._parseVar())
      self.iseq(' ', eprs.getc())

      self.iseq('true', eprs._parseVar())
      self.iseq(' ', eprs.getc())

      self.iseq('meta!out', eprs._parseVar())
      self.iseq(' ', eprs.getc())

      self.iseq('a', eprs._parseVar())
      self.iseq('.', eprs.getc())
      self.iseq('bc', eprs._parseVar())
      self.iseq('.', eprs.getc())
      self.iseq('def', eprs._parseVar())
      self.iseq('.', eprs.getc())
      self.iseq('Hex', eprs._parseVar())
      self.iseq('\n', eprs.getc())
    end method _parseVar;

    protected
    method _parseStr : str #:
      Parse a str.

      Current position must be a single or double quote.
    scope:
      line, i = self.current()
      /# line[i] assumed to be either ' or "
      expr = None
      error = None
      start = i
      delim = line[i]
      try:
        while True:
          i += 1
          if line[i] == '\\':
            /# escapes next char.
            i += 1
          elif line[i] == delim:
            break
        i += 1
        expr = line[start:i]
        self.colIs(i)
      except IndexError:
        self.error('Failed to parse literal string')
        expr = None
      return expr
    test:
      eprs = metax.c.ExprParser(
        test.metafileFor(
          '  "this is a test"\n\'another test\'?  \n'))
      eprs.set(row=0, col=2)
      test.iseq('"this is a test"', eprs._parseStr())
      test.iseq((0, 18, '\n'), eprs.pos())
      eprs.set(row=1, col=0)
      test.iseq("'another test'", eprs._parseStr())
      test.iseq((1, 14, '?'), eprs.pos())
    end method _parseStr;

    protected
    method _parseGenericList : map #:
      Parse a list of expressions delimited by start and end
    params:
      var schr : char #:
        The start-of-expr character.
      var echr : char #:
        The end-of-expr character.
      var default : bool = false #:
        If true, support default expressions for elements of kind 'id'.
    scope:
      srow, scol, _ = self.pos()
      line, i = self.current()
      assert line[i] == schr
      /# NOTE: No array bounds checking is needed because all lines end in '\n'

      /# We record the end-of-terminator char with our list of such indicators
      /# to handle trailing commas.  If parse() encounters a character
      /# matching self.terms()[-1], it knows to return None immediately.
      self.terms().append(echr)

      /# expr is the list of parsed elements in the list. If an error occurs
      /# during parsing, expr is set to None (and errors added to field 'errors')
      expr = []

      /# Repeatedly consume expressions terminated by ',' or echr,
      /# accumulating into 'expr' until matching echr is reached.
      while True:
        /# line[i] is a schr or comma. Advance one char and parse an expr.
        self.colIs(i+1)

        /# Parse the current arg. Note that parse() skips past initial
        /# whitespace, so we don't have to do so here.
        arg = self.parse()

        if arg is None:
          /# This means one of two things:
          /#  1) an error was encountered (already written to field 'errors')
          /#  2) the matching end-of-expr character has been found after
          /#     whitespace (this happens if a trailing comma exists).
          /# In either case, the correct thing to do is end the loop.
          line, i = self.current()
          if line[i] == echr:
            /# We've reached the end of the plist ... set col to one past the
            /# closing parent and exit the loop.
            self.colIs(i+1)
            break
          elif self.errors():
            /# There was an error during parsing.
            expr = None
            break
          else:
            raise Error('Unknown situation')
        if expr is None:
          break

        /# We've successfully parsed the arg ... register it with the result.
        expr.append(arg)

        /# After the current arg, arbitrary spaces are allowed and skipped
        line, i = self.skipws()
        c = line[i]

        /# Support default values for identifiers.
        if default and arg.kind() == 'var' and c == '=':
          /# Advance past '=' and parse another expression
          self.colIs(i+1)
          defexpr = self.parse()
          arg.defaultIs(defexpr)
          line, i = self.skipws()
          c = line[i]

        /# Check for end-of-list.
        if c == echr:
          /# advance past closing paren
          i += 1
          self.colIs(i)
          break
        elif c == ',':
          /# There is (maybe) another arg. We do not need to increment i, as
          /# it is done as we start the next iteration of the loop.
          pass
        else:
          /# this is an error.
          self.error('Expecting "," or "%s" not "%s"' % (echr, c))
          expr = None

      if expr is None:
        /# We have an error ... reinstate the original position.
        self.set(row=srow, col=scol)
      else:
        /# We've successfully parsed the expression ... pop the echr off the
        /# 'terms' list.
        assert self.terms().pop() == echr

      return expr
    test<py>:
      /# noop ... tested in _parsePList() and _parseList()
      pass
    end method _parseGenericList;

    protected
    method _parsePList : map #:
      Parse a parenthesized list of comma-separated expressions.
    scope:
      return self._parseGenericList('(', ')', default=True)
    test:
      hello = '"hello"'

      /# The empty plist.
      eprs = metax.c.ExprParser(test.metafileFor('()\n'))
      test.iseq([], eprs._parsePList())

      /# A simple single-line plist expression
      eprs = metax.c.ExprParser(test.metafileFor(' (1, "hello", apple)\n'))
      eprs.set(0, 1)
      test.iseq(
        '[<kind=num str=1 expr=1>, <kind=str str="hello" expr="hello">, <kind=var str=apple expr=apple>]',
        str(eprs._parsePList()))

      /# Now a multi-line plist expression
      eprs = metax.c.ExprParser(
        test.metafileFor(
          '  # python method call\n'
          '  self.f(1,\n'
          '         apple,\n'
          '         "hello",\n'
          '        )\n'))
      eprs.set(1, 8)
      test.iseq(
        '[<kind=num str=1 expr=1>, <kind=var str=apple expr=apple>, <kind=str str="hello" expr="hello">]',
        str(eprs._parsePList()))

      /# The same multi-line plist expression using parse() which invokes
      /# _parsePlist().
      eprs.set(1, 8)
      test.iseqtext(
        '<kind=plist str=(1,\n'
        '         apple,\n'
        '         "hello",\n'
        '        ) expr=[<kind=num str=1 expr=1>, <kind=var str=apple expr=apple>, <kind=str str="hello" expr="hello">]>',
        str(eprs.parse()))

      /# Test default values for id expressions.
      eprs = metax.c.ExprParser(test.metafileFor('f(1, a, def=def)\n'))
      eprs.set(0, 1)
      test.iseq(
        '[<kind=num str=1 expr=1>, <kind=var str=a expr=a>, <kind=var str=def expr=def default=<kind=var str=def expr=def>>]',
        str(eprs._parsePList()))
    end method _parsePList;

    protected
    method _parseList : map #:
      Parse a square-bracket list of comma-separated expressions.
    scope:
      return self._parseGenericList('[', ']', default=False)
    test:
      hello = '"hello"'

      /# The empty list.
      eprs = metax.c.ExprParser(test.metafileFor('[]\n'))
      test.iseq([], eprs._parseList())

      /# A simple single-line plist expression
      eprs = metax.c.ExprParser(test.metafileFor(' [1, "hello", apple]\n'))
      eprs.set(0, 1)
      test.iseq(
        '[<kind=num str=1 expr=1>, <kind=str str="hello" expr="hello">, <kind=var str=apple expr=apple>]',
        str(eprs._parseList()))

      /# Now a multi-line plist expression
      eprs = metax.c.ExprParser(
        test.metafileFor(
          '  # python method call\n'
          '  abc = [1,\n'
          '         apple,\n'
          '         "hello",\n'
          '        ]\n'))
      eprs.set(1, 8)
      test.iseq(
        '[<kind=num str=1 expr=1>, <kind=var str=apple expr=apple>, <kind=str str="hello" expr="hello">]',
        str(eprs._parseList()))

      /# The same multi-line plist expression using parse() which invokes
      /# _parselist().
      eprs.set(1, 8)
      test.iseqtext(
        '<kind=list str=[1,\n'
        '         apple,\n'
        '         "hello",\n'
        '        ] expr=[<kind=num str=1 expr=1>, <kind=var str=apple expr=apple>, <kind=str str="hello" expr="hello">]>',
        str(eprs.parse()))
    end method _parseList;

    protected
    method _parseHash : map #:
      Parse a collection of key : value pairs.
    scope:
      schr = '{'
      echr = '}'
      srow, scol, _ = self.pos()
      line, i = self.current()
      assert line[i] == schr
      /# NOTE: No array bounds checking is needed because all lines end in '\n'

      /# We record the end-of-terminator char with 'terms', our list of such
      /# indicators to handle trailing commas. If parse() encounters a
      /# character matching self.terms()[-1], it knows to return None
      /# immediately.
      self.terms().append(echr)

      /# expr is the list of parsed key/value pairs in the hash (in the order
      /# they appeared lexical). Each element is a two-tuple of parsed expr
      /# dicts.
      expr = []

      /# Repeatedly consume key/value expressions terminated by ',' or '}',
      /# accumulating into 'expr' until matching '}' is reached.
      while True:
        /# line[i] is a schr or comma. Advance one char and parse an expr.
        self.colIs(i+1)

        /# Parse a key. Note that parse() skips past initial whitespace,
        /# so we don't have to do so here.
        key = self.parse()

        if key is None:
          /# This means one of two things:
          /#  1) an error was encountered (already written to field 'errors')
          /#  2) the matching end-of-expr character has been found after
          /#     whitespace (this happens if a trailing comma exists).
          /# In either case, the correct thing to do is end the loop.
          line, i = self.current()
          if line[i] == echr:
            /# We've reached the end of the hash ... set col to one past the
            /# closing parent and exit the loop.
            self.colIs(i+1)
            break
          elif self.errors():
            /# There was an error during parsing.
            expr = None
            break
          else:
            raise Error('Unknown situation')

        /# Now confirm the next non-ws char is a ':'
        line, i = self.skipws()
        c = line[i]
        if c != ':':
          self.error(
            'Line %d, column %d: Expecting a colon, encountered "%s"' %
            (self.row()+1, i+1, c))
          expr = None
          break

        /# Skip past the colon and whitespace
        self.colIs(i+1)
        line, i = self.skipws()

        /# Parse a value. Note that parse() skips past initial whitespace,
        /# so we don't have to do so here.
        value = self.parse()

        if value is None:
          /# This means one of two things:
          /#  1) an error was encountered (already written to field 'errors')
          /#  2) an expression-terminating character was encountered. This
          /#     means a value is missing ... an error.
          line, i = self.current()
          if line[i] == echr:
            self.error(
              'Expecting a value but encountered "%s"' % echr)
            expr = None
            break
          elif self.errors():
            expr = None
            break
          else:
            raise Error('Unknown situation')

        /# We've successfully parsed the key/value pair ... register it with
        /# the result.
        expr.append((key, value))

        /# After the current arg, arbitrary spaces are allowed and skipped
        line, i = self.skipws()
        c = line[i]

        /# Check for end-of-list.
        if c == echr:
          /# advance past closing paren
          i += 1
          self.colIs(i)
          break
        elif c == ',':
          /# There is (maybe) another key/value pair. We do not need to
          /# increment i, as it is done as we start the next iteration of the
          /# loop.
          pass
        else:
          /# this is an error.
          self.error('Expecting "," or "%s" not "%s"' % (echr, c))
          expr = None

      if expr is None:
        /# We have an error ... reinstate the original position.
        self.set(row=srow, col=scol)
      else:
        /# We've successfully parsed the expression ... pop the echr off the
        /# 'terms' list.
        assert self.terms().pop() == echr

      return expr

    test:
      /# An empty hash.
      eprs = metax.c.ExprParser(test.metafileFor('{}n'))
      test.iseq([], eprs._parseHash())

      /# A simple single-line hash expression
      eprs = metax.c.ExprParser(
        test.metafileFor(' {"a": 1, \'b\': 2, 3 : apple, "a" : "hello" } \n'))
      eprs.set(0, 1)
      test.iseqtext(
        '[(<kind=str str="a" expr="a">, <kind=num str=1 expr=1>), (<kind=str str=\'b\' expr=\'b\'>, <kind=num str=2 expr=2>), (<kind=num str=3 expr=3>, <kind=var str=apple expr=apple>), (<kind=str str="a" expr="a">, <kind=str str="hello" expr="hello">)]',
        str(eprs._parseHash()))

      /# A multi-line hash expression
      eprs = metax.c.ExprParser(
        test.metafileFor(
          "data = {\n"
          "  'S': 1,\n"
          "  'H': 2,\n"
          "  'C': 3,\n"
          "  'D': 4,\n"
          "}\n"))
      eprs.set(row=0, col=7)
      test.iseqtext(
        "[(<kind=str str='S' expr='S'>, <kind=num str=1 expr=1>), (<kind=str str='H' expr='H'>, <kind=num str=2 expr=2>), (<kind=str str='C' expr='C'>, <kind=num str=3 expr=3>), (<kind=str str='D' expr='D'>, <kind=num str=4 expr=4>)]",
        str(eprs._parseHash()))
    end method _parseHash;

    protected
    method _parseCall : map #:
      Parse a callsite.

      A callsite consists of: '@' <rec> {<sep> <name> [<arglist>]}...

      Examples:
        @this!a(1);
        @this.f;
        @this.g(1);
        @this.g(@f.h(1,'a',z'));

      Note that the semicolon in the above is NOT part of the callsite (it is
      part of the callsite (it is part of the construct within which the expr
      resides). The semicolon is critically important though, as it is how
      we can determine when to end the callsite.  Other places where we end
      a callsite:
        @self.f(@a.b,@c!f)
      Note that the ',' ends '@a.b' and the ')' ends '@c!f'. Similarly for
        var a : map = { 'a': @a.b, 'b': @c!f }
      in which the comma ends '@a.b' and the '}' ends @c!f. In general,
      the chars in MetaExprParser.TERMCHARS represent when to end a call construct.

    params:
      var receiver : str = null #:
        If null (the normal case), we are parsing the complete callsite.
        If not null, it is a string, and representing the name of a variable
        that has previously been parsed. If provided, we are to skip the
        parsing of the receiver, because 'receiver' specifies the receiver.
    scope:
      line, i = self.current()
      /# No array bounds checking needed because all lines end with '\n'

      expr = None

      if not receiver:
        /# If an explicit receiver has not been provided for us, we parse it
        /# now.
        assert line[i] == '@'
        self.colIs(i+1)
        receiver = self._parseVar()

      if receiver is not None:
        subcalls = []
        expr = {'rec': receiver, 'subcalls': subcalls}

        /# Advance past whitespace
        line, i = self.skipws()

        while True:
          /# Parse <sep> <ws> <name> <ws> [<arglist>] <ws>
          /# Note that we cannot use a regexp (which would be faster) because we
          /# need to handle nested exprs within <arglist>.

          /# Establish <sep>
          sep = line[i]
          if sep != '!' and sep != '.':
            self.error('Expecting . or ! not "%s"' % sep)
            expr = None
            break

          /# Advance past the '.' or '!' and whitespace
          self.colIs(i+1)
          line, i = self.skipws()

          /# Obtain the <name>
          name = self._parseVar()
          if name is None:
            /# We encountered an error while parsing the name, so we exit.
            /# The error message has already been written to field 'errors'.
            expr = None
            break

          /# Skip past whitespace
          line, i = self.skipws()

          /# Obtain optional arglist
          arglist = None
          if line is not None:
            if line[i] == '(':
              arglist = self._parsePList()
              if arglist is None:
                break
          line, i = self.current()

          /# The var 'i' is now one char beyond <subcall>
          /#   <subcall> ::- <sep> <name> [<arglist>]
          subcall = {'name': name}
          if sep == '!': subcall['field'] = True
          if arglist: subcall['args'] = arglist
          subcalls.append(subcall)

          /# Advance past whitespace
          line, i = self.skipws()

          /# A call expr ends at any of the following:
          /#  - we've reached end of string at this point
          /#  - we are seeing a ')', which means we are at end of an arglist
          /#  - we are seeing a ',', which means we are at end of an arg inside an arglist
          /#  - we are seeing a ';', which means we are at end of expr construct.
          if line is None or line[i] in MetaExprParser.TERMCHARS:
            break

      return expr
    test:
      /# Simple method invocation with no args
      eprs = metax.c.ExprParser(test.metafileFor('@self.meth; \n'))
      test.iseq(
        {'rec': 'self', 'subcalls': [{'name': 'meth'}]},
        eprs._parseCall())

      /# Simple field get
      eprs = metax.c.ExprParser(test.metafileFor('@self!fld; \n'))
      test.iseq(
        {'rec': 'self', 'subcalls': [{'name': 'fld', 'field': True}]},
        eprs._parseCall())

      /# Simple method invocation with two args
      eprs = metax.c.ExprParser(test.metafileFor('@self.meth(a, 1); \n'))
      test.iseq(
        "{'rec': 'self', 'subcalls': ["
        "{'args': [<kind=var str=a expr=a>, <kind=num str=1 expr=1>], "
        "'name': 'meth'}]}",
        str(eprs._parseCall()))

      /# Simple field set
      eprs = metax.c.ExprParser(test.metafileFor('@self!fld(1); \n'))
      test.iseq(
        "{'rec': 'self', 'subcalls': [{'field': True, 'args': [<kind=num str=1 expr=1>], 'name': 'fld'}]}",
        str(eprs._parseCall()))

      /# Nested method invocation.
      eprs = metax.c.ExprParser(
        test.metafileFor('@self.meth1.meth2(a).meth3(b, 1); \n'))
      test.iseq(
        "{'rec': 'self', 'subcalls': [{'name': 'meth1'}, {'args': [<kind=var str=a expr=a>], 'name': 'meth2'}, {'args': [<kind=var str=b expr=b>, <kind=num str=1 expr=1>], 'name': 'meth3'}]}",
        str(eprs._parseCall()))

      /# Nested method invocation with nested calls.
      /# expr = metax.c.ExprParser(['@test.iseq(2, 1);\n'])
      eprs = metax.c.ExprParser(
        test.metafileFor('@test.iseq(@test!hex.q, 1);\n'))
      test.iseq(
        "{'rec': 'self', 'subcalls': [{'args': [<kind=call str=@test!hex.q expr={'rec': 'test', 'subcalls': [{'field': True, 'name': 'hex'}, {'name': 'q'}]}>, <kind=num str=1 expr=1>], 'name': 'iseq'}]}",
        str(eprs._parseCall()))

      /# Nested method invocation with nested calls spanning multiple lines.
      eprs = metax.c.ExprParser(
        test.metafileFor(
          "        @test.iseq(\n"
          "          'Edge between <1,0,-1> (n) and <1,-1,0> (s) with center <0,-52>',\n"
          "          @edge.summary);\n"),
          col=8)
      test.iseqtext(
        "{'rec': 'self', 'subcalls': [{'args': [<kind=str str='Edge between <1,0,-1> (n) and <1,-1,0> (s) with center <0,-52>' expr='Edge between <1,0,-1> (n) and <1,-1,0> (s) with center <0,-52>'>, <kind=call str=@edge.summary expr={'rec': 'edge', 'subcalls': [{'name': 'summary'}]}>], 'name': 'iseq'}]}",
        str(eprs._parseCall()))

    end method _parseCall;

    method consumeOperator : map #:
      Consume an operator.
    scope:
      legal = MetaExprParser.LEGAL_OP_CHARS
      line, i = self.current()

      /# Obtain the operator
      start = i
      while line[i] in legal:
        i += 1
      op = line[start:i]

      /# When this method starts, i MUST be pointing to a legal op char. If
      /# it did not, the following will fail.
      assert len(op) > 0

      /# Parse an arbitrary expression.
      /#  - we do not need to skip whitespace here, as it is skipped in parse()
      self.colIs(i)
      rhs = self.parse()

      if rhs:
        result = {'op': op, 'rhs': rhs}
      else:
        /# There are two possible reasons for there to be no rhs:
        /#  - an error occurred during parsing
        /#  - self.terms()[-1] was seen after arbitrary whitespace was consumed,
        /#    which indicates end of construct.
        if self.errors():
          /# bad rhs ... error already written to errors().
          result = None
        else:
          /# We are at the end of the callsite. We return null and allow the
          /# caller to determine that this means stop-parsing-construct. Note
          /# that we do NOT pop terms[-1] ... that is for the code parsing
          /# the nested expr to do ... we are just using terms to determine
          /# that the callsite has ended.
          result = None

      return result

    test:
      eprs = metax.c.ExprParser(test.metafileFor('1 + 2\n'))
      eprs.parse()
      eprs.skipws()
      test.iseq(
        "{'rhs': <kind=num str=2 expr=2>, 'op': '+'}",
        str(eprs.consumeOperator()))
    end method consumeOperator;

    method isCallConstruct : bool #:
      Establish if the given text represents a complex call construct.

      TODO(wmh): Delete this in favor of some other mechanism? e.g.
      if data is parsed (which it always should be before invoking this method),
      check 'kind' == 'call' or define a kind() method so that callers can
      use it as they see fit.
    scope:
      return self.line().lstrip()[0] == '@';
    test:
      eprs1 = metax.c.ExprParser(test.metafileFor('@self.meth; \n'))
      eprs2 = metax.c.ExprParser(test.metafileFor('10 a\n'))
      test.istrue(eprs1.isCallConstruct())
      test.isfalse(eprs2.isCallConstruct())
    end;

  end class ExprParser;

  class Expr #:
    A parsed expression as returned by ExprParser.parse().
  scope:
    field kind : str #:
      One of 'num', 'real', 'str', 'id', 'list', 'hash', 'plist', 'call',...
    field text : str #:
      The (possibly multiline) string representation of the expression
    field value : any #:
      Type of this field depends on kind:
        num: int or float
        str: str
        id: str
        plist: list of dicts (each dict is same format as 'expr' above)
        call: dict
          rec: str (receiver)
          field: bool (true if field access)
          name: str (name of field or method being accessed)
          args: list of dicts (each format as returned by parse())
        op: dict
          op: str
          rhs: dict (same format as returned by parse())
            kind: str
            str: str
            expr:
    field default : str #:
      Used in, for example, plist expressions to represent default values
      for a variable.
      TODO(wmh): Make this an optional field?

    lifecycle params:
      var kind -> kind;
      var text -> text;
      var value -> value;
    scope:
    end;

    method __repr__ : str #:
      The printable representation of this Expr
    scope:
      parts = ['kind=' + self._kind, 'str=' + self._text, 'expr=' + str(self._value)]
      if self._default:
        parts.append('default=' + str(self._default))
      return '<' + ' '.join(parts) + '>'
    test:
      eprs = metax.c.ExprParser(test.metafileFor(' 1   apple"hello"\n'))
      expr = eprs.parse()
      test.iseq('<kind=num str=1 expr=1>', repr(expr))
    end method __repr__;

    method asStr : str #:
      The expr as a string. Most commonly invoked if kind is 'str', but also
      legal for any kind.
    params:
      var unquote : bool = false #:
        If true, and kind is 'str', remove quotes if they exist.
      var quote : bool = false #:
        If true, and kind is 'str', add quotes if they do not exist.
      var delim : str = null #:
        If non-null, and kind is 'str', use the specified quote delimiter.
        If null, uses the quoting provided in the str value itself.
    scope:
      kind = self.kind()
      if kind == 'str':
        result = self.value()
        if unquote and result and result[0] == "\"" and result[-1] == "\"":
          result = result[1:-1]
        elif quote and result and (result[0] != "\"" and result[0] != "'"):
          if delim is None:
            delim = "'"
          result = delim + result + delim
      else:
        /# TODO(wmh): Do a better for the more complex types.
        result = str(self.value())
      return result
    end method asStr;

  end class Expr;

  class VarSet comment:
    Maintain a collection of var/value/Attribute tuples.

    A VarSet is used to instantiate a baselang-specific template associated
    with some construct. The template contains special variable interpolation
    requests, and a Varset provides the variables, the associated value of the
    variable, and the source (an Attribute instance) of the var/value. The
    VarSet allows us to convert the template into a specific instantiation of
    some baselang-level syntactic construct.
  assocs:
    std assoc re;
  scope:

    field map : @map #:
      Maps variable names to lists containing [value, attribute, delim, width]
    end field map;

    lifecycle params:
      var items : vec<tuple> = null;
    scope:
      /# Populate map with any data from 'items'.
      /#  - each element of items is a tuple containing 2-5 elements
      /#     [0] var
      /#     [1] value
      /#     [2] attribute (optional)
      /#     [3] delim (optional)
      /#     [4] width (optional)
      if items:
        for item in items:
          n = len(item)
          var = item[0]
          value = item[1]
          attribute = item[2] if n > 2 else None
          delim = item[3] if n > 3 else None
          width = item[4] if n > 4 else -1
          self.addVar(var, value, attribute=attribute, delim=delim, width=width)
    end lifecycle;

    method clone : VarSet #:
      TODO(wmh): Move to lifecycle 'copy' when it is implemented.
    scope:
      result = self.__class__()
      for var, data in self._map.iteritems():
        value, attribute, delim, width = data
        result.addVar(var, value, attribute=attribute, delim=delim, width=width)
      return result
    test:
      varset = test.varset
      varset2 = varset.clone()
      test.notsame(varset, varset2)
      s1 = varset.asStr()
      s2 = varset2.asStr()
      test.iseq(s1, s2)
    end method clone;

    method addVar #:
      Add a var/value/attribute triple.

      If 'var' already exists, it is replaced with the new data.
    params:
      var var : str #:
        The variable to add
      var value : any #:
        The value to associate with the var. This is either a str, a vec<str>,
        or a BaseSegment.  The 'str' can have newlines, but the elements
        of a vec<str> should not.
      var attribute : Attribute = null #:
        The meta-level attribute
      var delim : str = null #:
        Only meaningful if the value is a list, and indicates what
        str separates elements of the list.  If None, the list of values
        is assumed to represent lines (i.e. delim == '\n').  If it is, for
        example, ', ', then the values of the list are to be separated by
        comma-space.  The advantage of maintaining the value as a list with
        delimiter is that it allows us to perform line-wrapping at element
        boundaries.
      var width : int = -1 #:
        The width of lines generated by this var.  Currently only meaningful
        when value is a list and delim is not None or '\n'.
    scope:
      self._map[var] = [value, attribute, delim, width]
    test:
      test.iseq(['age', 'name'], sorted(test.varset._map))
    end method addVar;

    method appendVar #:
      Append a value to a var.

      If the current value of the variable is a string:
       - append the str-valued 'value' to it.
      If the current value of the variable is a list:
       - if value is a list, add all elements to the end of current
       - if value is a string, add one element to end of current
    params:
      var var : str #:
        The pre-existing variable to append to.
      var value : any #:
        What to add to the variable. Can be a str or vec<str>.
    scope:
      current = self._map[var][0]
      if isinstance(current, list):
        if isinstance(value, list):
          current.extend(value)
        else:
          current.append(value)
      else:
        if isinstance(value, list):
          raise Error(
            'Invalid (list) value "%s" for (string) current "%s"' %
            (value, current))
        else:
          self._map[var][0] += value
    test:
      varset = test.varset
      test.iseqtext(
        'age             = 25\nname            = Bob',
        varset.asStr())
      varset.appendVar('name', 'Smith')
      test.iseqtext(
        'age             = 25\nname            = BobSmith',
        varset.asStr())
    end method appendVar;

    method prependVar #:
      Prepend a value to an existing value.
    params:
      var var : str #:
        The variable to augment. This must exist or an error is raised.
      var value : str #:
        The value to prepend to an existing value.
      var default : str = null #:
        What to set the value to if it is currently empty.  If null, uses
        value.
    scope:
      current = self._map[var][0]
      if not current:
        if default is None:
          default = value
        self._map[var][0] = default
      else:
        self._map[var][0] = value + self._map[var][0]
    test:
      varset = test.varset
      test.iseqtext(
        'age             = 25\nname            = Bob',
        varset.asStr())
      varset.prependVar('name', 'Silly')
      test.iseqtext(
        'age             = 25\nname            = SillyBob',
        varset.asStr())
    end method prependVar;

    method __contains__ : bool #:
      Allow the 'in' operator to be applied to an instance of this class.

      TODO(wmh): This is a python-specific method ... need something more
      language-independent.
    params:
      var var;
    scope:
      return var in self._map
    test:
      test.iseq(True, 'age' in test.varset)
      test.iseq(False, 'height' in test.varset)
    end method __contains__;

    method get : tuple<str,Attribute,str,int> #:
      Obtain the value, Attribute, delim and width associated with a given
      variable name.
    params:
      var var : str #:
        The variable name to obtain info for.
    scope:
      return self._map.get(var, None) or [None, None, None, None]
    test:
      varset = test.varset
      test.iseq(['Bob', None, None, -1], varset.get('name'))
      test.iseq([None]*4, varset.get('height'))
      varset.addVar('empty', '')
      test.iseq(['', None, None, -1], varset.get('empty'))
    end method get;

    method getValue : str #:
      Obtain the value of a variable.
    params:
      var var : str #:
        The name of the variable to obtain the value of.
    scope:
      data = self._map.get(var, None)
      if data is None:
        raise Error('Failed to find varset var %s' % var)
      return data[0]
    test:
      varset = test.varset
      test.iseq(25, varset.getValue('age'))
      test.iseq('Bob', varset.getValue('name'))
    end method getValue;

    method setValue : str #:
      Set the value of a variable.
    params:
      var var : str #:
        The name of the variable to obtain the value of.
      var value : any #:
        The value of the variable.
    scope:
      data = self._map.get(var, None)
      if data is None:
        raise Error('Failed to find varset var %s' % var)
      data[0] = value
    test:
      varset = test.varset
      test.iseq(25, varset.getValue('age'))
      test.iseq('Bob', varset.getValue('name'))
    end method setValue;

    method asStr : str #:
      Format as string
    params:
      var name : str = '?' #:
        Name of construct
      var indent = '';
    scope:
      lines = []
      varmap = self._map
      for var in sorted(varmap):
        value, attribute, delim, width = varmap[var]
        if isinstance(value, str):
          value_str = value.replace('\n', '\\n')
        else:
          value_str = str(value)
        lines.append('%s%-15s = %s' % (indent, var, value_str))
        if attribute:
          lines[-1] += ' [%s.%s line %d]' % (
            name, attribute.key(), attribute.line())
      return '\n'.join(lines)
    test:
      test.iseqtext(
        'age             = 25\n'
        'name            = Bob',
        test.varset.asStr(None))
    end method asStr;

    method show params:
      var fp : ostream = out #:
        Where to write this varset.
    scope:
      fp.write(self.asStr() + '\n')
    test:
      fp = test.newStr()
      test.varset.show(fp=fp)
      test.iseqtext(
        'age             = 25\n'
        'name            = Bob\n',
        fp.getvalue())
    end method show;

    test
    lifecycle setup:
      self.varset = metax.c.VarSet()
      self.varset.addVar('age', 25)
      self.varset.addVar('name', 'Bob', attribute=None)
      self.varset2 = metax.c.VarSet(items=(('age', 25), ('name', 'Bob', None)))
    end lifecycle;
  end class VarSet;

  class BaseStreams #:
    Provides support for writing output to multiple streams with aggregation.

    When compiling a Meta construct into base language constructs, the following
    functionality is useful:
      - ability to write to multiple conceptual streams incrementally, and to
        serialize various streams to files
      - ability to know what a line number in the meta source code corresponds
        to in a base language file.
      - ability to form base language output by instantiating a multi-line
        template string.
      - ability to enforce various constraints on the generated output (for
        example, no line longer than 80 characters, etc.)

    This class provides support for all of the above.
  scope:

    field streams : @map #:
      Maps conceptual stream names to lists of elements, each of which can
      be a str or BaseSegment.

    lifecycle scope:
    end;

    method clear #:
      Remove all streams from this instance.
    scope:
      self._streams.clear()
    test:
      bs = test.bs2
      test.iseqvec(['a', 'b', 'c'], bs.streamNames())
      bs.clear()
      test.iseqvec([], bs.streamNames())
    end method clear;

    method streamNames : vec<str> #:
      Obtain all of the names of streams in this instance.
    scope:
      return sorted(self._streams)
    test:
      test.iseqvec([], test.bs.streamNames())
      test.iseqvec(['a', 'b', 'c'], test.bs2.streamNames())
    end method streamNames;

    method stream : vec #:
      Obtain the stream with the given name.

      Returns:
        A list of elements, each of which can be a str or BaseSegment.
    params:
      var name : str #:
        The conceptual stream name to return.
      var clear : bool = false #:
        If true, a new stream is created even if it already exists.
        Note that the stream is completed replaced, not just cleared.
      var create : bool = false #:
        If True, create if it does not exist.  By default, we want to
        report an error, because we usually want to explicilty create
        streams in parent compilation methods.
    scope:
      streams = self._streams
      result = streams.get(name, None)
      if clear:
        if name in streams:
          streams[name] = []
      if result is None:
        if create:
          result = []
          streams[name] = result
        else:
          raise metax.c.InternalError(
            'Failed to find stream named "%s"' % name)
      if False:
        /# Use this if you want to debug the actions taken on individual
        /# stream collections.  All the code is designed to handle lists
        /# or Stream wrappers around lists (albeit with some inefficiency
        /# builtin), so this can be turned on and off trivially.
        result = Stream(name, result)
      return result
    test:
      test.raises(metax.c.InternalError, test.bs.stream, 'a')
      test.iseq([], test.bs2.stream('a'))
      test.iseq([], test.bs.stream('a', create=True))
    end method stream;

    method initStreams #:
      Create streams for each name specified.
    params:
      multi var names : vec;
    scope:
      for name in names:
        self.stream(name, clear=True, create=True)
    test:
      /# setup has invoked initStreams() on test.bs2
      test.iseqvec(['a', 'b', 'c'], test.bs2.streamNames())
    end method initStreams;

    method addLine #:
      Add a single line to a named stream.
    params:
      var name : str #:
        The name of the stream.
      var line : str #:
        The line to add.
    scope:
      stream = self.stream(name)
      stream.append(line)
      /#if name.endswith('classes'):
      /#  print 'Adding "%s" to %s: %s' % (line, name, stream)
    test:
      bs = test.bs2
      test.iseq([], bs.stream('a'))
      bs.addLine('a', 'this is a test')
      test.iseq(['this is a test'], bs.stream('a'))
    end method addLine;

    method addLines #:
      Add multiple lines, in order, to a named stream.
    params:
      var name : str #:
        The name of the stream
      var lines : vec<str> #:
        The lines to add.
    scope:
      stream = self.stream(name)
      stream.extend(lines)
      /#if name.endswith('classes'):
      /#  print 'Adding "%s" to %s: %s' % (line, name, stream)
    test:
      bs = test.bs2
      test.iseq([], bs.stream('a'))
      bs.addLines('a', ['this is a test', 'and another'])
      test.iseq(['this is a test', 'and another'], bs.stream('a'))
    end method addLines;

    method addOpaque #:
      Add an arbitrary element to a named stream.
      TODO(wmh): Any code that uses this should be modified to instead
      write into construct-subclass-specific fields, leaving streams for
      strs and BaseSegments.
    params:
      var name : str #:
        The name of the stream to write to.
      var obj : any #:
        The object to write to the stream.
    scope:
      stream = self.stream(name)
      stream.append(obj)
      /#if name.endswith('classes'):
      /#  print 'Adding "%s" to %s: %s' % (obj, name, stream)
    test:
      bs = test.bs2
      test.iseq([], bs.stream('a'))
      bs.addOpaque('a', {'a': 1})
      test.iseq([{'a': 1}], bs.stream('a'))
    end method addOpaque;

    method addSegment #:
      Add a segment to a stream.
    params:
      var name : str #:
        The stream to add to.
      var segment : BaseSegment #:
        The segment to add.
      var create : bool = false #:
        Whether to create the named stream if it doesn't already exist.
        TODO(wmh): Is this param needed?
    scope:
      stream = self.stream(name, create=create)
      stream.append(segment)
    end method addSegment;

    method flatten : str #:
      Collapse a stream into a single multi-line text stream.
    params:
      var name : str #:
        Name of stream.
      var spaces : int = 0 #:
        How many blank lines to insert between segments.
      var indent : int = 0 #:
        How many spaces to insert at the beginning of each line.
    scope:
      lines, mapping = self.flattenWithMap(name, spaces=spaces, indent=indent)
      return '\n'.join([line.rstrip() for line in lines])
    end method flatten;

    method flattenWithMap : tuple<str,vec<tuple<int,int>>> #:
      Collapse a stream into a single multi-line text stream.

      Returns: two-tuple
        0) text : str
        1) mapping: vec<tuple>
           list of tuples (local file line numbers to meta file line numbers)
    params:
      var name : str #:
        Name of stream.
      var spaces : int = 0 #:
        How many blank lines to insert between segments.
      var indent : int = 0 #:
        How many spaces to insert at the beginning of each line.
    scope:
      dentstr = ' ' * indent
      lines = []
      stream = self.stream(name)

      segment = BaseSegment(stream)
      mapfile = MapFile(None, None)
      lines = []
      segment.flattenLines(lines, mapfile, indent=dentstr)
      return lines, mapfile.mapping()
    end method flattenWithMap;

    method flattenAll : str #:
      Flatten all streams.
    params:
      var spaces : int = 0 #:
        How many blank lines to insert between segments.
      var indent : int = 0 #:
        How many spaces to insert at the beginning of each line.
      var empty : bool = false #:
        If True, show empty streams too.
    scope:
      result = ''
      for stream in sorted(self._streams):
        text = self.flatten(stream, spaces=spaces, indent=indent + 2)
        if empty or text:
          result += '\n\n' + stream + '\n'
          result += text
      return result
    end method flattenAll;

    method dump #:
      Show all streams.
    params:
      var title : str = null #:
        A title to show.
      var fp : ostream = out #:
        Where to write output.
    scope:
      indent = ''
      if title:
        fp.write('%s%s\n%s\n' % (indent, '#' * 80, title))
      fp.write(self.flattenAll())
      fp.write('\n')
    end method dump;

    test
    lifecycle setup:
      self.bs = metax.c.BaseStreams()
      self.bs2 = metax.c.BaseStreams()
      self.bs2.initStreams('a', 'b', 'c')
    end lifecycle;
  end class BaseStreams;

  class Stream #:
    Wrapper around a list of lines/segments.

    Used for debugging purposes to give insight into usage. Not used normally
    in the interests of efficiency (but may be neglible in impact).
    TODO(wmh): Look into always storing Stream instances ... would provide
    for a cleaner interface upon which additional functionality could be built.
  scope:

    field name : str;
    field data : map;

    lifecycle params:
      var name -> name;
      var data -> data;
    scope:
    end;

    method append params:
      var elem : any;
    scope:
      self._data.append(elem)
    test:
      stream = test.stream
      stream.append('c')
      test.iseqvec(['a', 'b', 'c'], stream.data())
    end method append;

    method extend params:
      var lst : vec;
    scope:
      self._data.extend(lst)
    test:
      stream = test.stream
      stream.extend(['c', 'd'])
      test.iseqvec(['a', 'b', 'c', 'd'], stream.data())
    end method extend;

    method insert params:
      var index : int;
      var elem : any;
    scope:
      self._data.insert(index, elem)
    test:
      stream = test.stream
      stream.insert(1, 'c')
      test.iseqvec(['a', 'c', 'b'], stream.data())
    end method insert;

    method __iter__ scope:
      /#return self._data
      for x in self._data:
        yield x
    test:
      test.iseqvec(['a', 'b'], list(test.stream))
    end method __iter__;

    method __len__ scope:
      return len(self._data)
    test:
      test.iseq(2, len(test.stream))
    end method __len__;

    method __add__ params:
      var other : any;
    scope:
      if isinstance(other, Stream):
        o = other._data
      elif isinstance(other, list):
        o = other
      else:
        raise ValueError('Stream does not know how to add to %s' % other.__class__)
      return self._data + o
    end method __add__;

    test
    lifecycle setup:
      test.stream = metax.c.Stream('decl', ['a', 'b'])
    end;

  end class Stream;

  class BaseSegment #:
    A collection of contiguous lines of baselang text originating at a specific
    line in a .meta file.
  scope:

    meta
    lifecycle scope:
      cls.TMPL_RE = re.compile(
        '((?:^|\n) *)?\$\{([a-zA-Z0-9_-]+)(?:\?([^\}]*))?\}')
    end lifecycle;

    field chunks : vec<any> #:
      The collection of str and BaseSegment instances making up this
      BaseSegment.  The str values cannot contain any newlines (including
      at end of string), and each str value represents exactly one line
      of output. Each BaseSegment represents multiple lines of output (and
      has an associated position in the .meta source file).
      TODO(wmh): Add support to Meta for type specifications of the form:
        vec<line:str|segment:BaseSegment>

    field indent : @str #:
      How much indentation exists before each line in this BaseSegment.

    field attribute : Attribute #:
      The metalevel Attribute instance associated with this base-lang text.
      Identifies the meta-level line number.  If null, no meta-level
      attribute is associated with the text in question (e.g. implicit
      code, etc.)

    field metaline : int #:
      The meta-level line number corresponding to the first element of chunks().
      This is often 0, in which case the line is obtained from 'attribute'. It
      is necessary to specify explicitly in situations where implicit code is
      inserted before the user-level content (for example, in simple-blocks
      containing preamble.

    field attrs : @map<int,Attribute> #:
      Maps integer indices within self.chunks() to Attribute instances. The
      chunk at the index should be an string.

    lifecycle params:
      var attribute -> attribute;
      var metaline -> metaline = -1;
      var chunks : vec = null;
      var indent -> indent = '';
    scope:
      if chunks is None:
        chunks = []
      self.chunksIs(chunks)
    end lifecycle;

    method show #:
      Print out details.
    params:
      var fp : ostream = out #:
        Where to write output.
      var indent : str = '' #:
        What to insert before each line.
      var nostr : bool = false #:
        If true, do not show string-valued chunks
    scope:
      for i, chunk in enumerate(self.chunks()):
        if isinstance(chunk, BaseSegment):
          attr = chunk.attribute()
          metaline = self.metaline()
          if metaline == -1 and attr:
            metaline = attr.line()
          fp.write(
            '%s%2d: seg %s (%d)\n' %
            (indent, i, attr.key() if attr else None, metaline))
          chunk.show(fp=fp, indent=indent + '  ', nostr=nostr)
        else:
          if not nostr:
            fp.write('%s%2d: %s\n' % (indent, i, chunk))
    test:
    end method show;

    method updateIndent params:
      var indent : str;
    scope:
      self._indent += indent
    end method updateIndent;

    method numLines #:
      Obtain the number of lines this segment represents.
    scope:
      count = 0
      for chunk in self.chunks():
        if isinstance(chunk, BaseSegment):
          count += chunk.numLines()
        else:
          /# If this assert fails, something is broken in the code to allow
          /# a str-value with newlines to not get split.
          assert '\n' not in chunk
          count += 1
      return count
    end method numLines;

    method flattenLines : vec<str> #:
      Obtain a sequence of lines from this segment and the meta/base mapping.

      This code produces a list of lines in baselanguage syntax, based on the
      compilation of meta-syntax constructs. We want to know the correspondence
      between base language line numbers and meta-level line numbers.

      SideEffect:
        The mapfile instance is populated with base/meta mappings.

      Returns:
        The lines making up the segment.
    params:
      var lines : vec<str> #:
        Where to write the flattened lines.
      var mapfile : MapFile #:
        Where to write line mapping info.
      var indent : str = '' #:
        The amount of indentation before each line.  This is in addition
        to any indentation specified in self._indent.
      var strip_special : bool = false #:
        If true, any line starting with spaces followed by '>|' is replaced
        with the text after >|.
      var debug : bool = false;
    scope:
      /# debug = True
      start_index = len(lines)

      indent = self._indent + indent
      mapping = mapfile.mapping()
      attrs = self.attrs()
      for chunk_index, chunk in enumerate(self.chunks()):
        /# The current baselang line number.
        /#  - increment by 1 to adjust from 0-based to 1-based.
        baseline = len(lines) + 1

        /# Now add the line (which may be an entire BaseSegment that needs to
        /# be expanded).
        if isinstance(chunk, BaseSegment):
          attribute = chunk.attribute()
          if attribute:
            /# print 'ATTRIBUTE: %s (%d)' % (attribute.path(), attribute.line())
            fqn = attribute.parent().fqn()
            fullid = fqn + ':' + attribute.key()
            metaline = chunk.metaline()
            if metaline == -1:
              metaline = attribute.line()
            if metaline < 0:
              /# No metaline info is known. This usually indicates that a
              /# dynamically created construct (in some expandMeta() methods)
              /# is not properly specifying attribute line numbers.
              pass
            else:
              /# The attribute line number is the position of the attribute
              /# key.  For list-valued attributes, the value starts on the
              /# next line. Note that if we start supporting text on same line
              /# as block key we'll need a different way of assessing when to
              /# increment.
              if attribute.isBlock():
                metaline += 1
              /# We increment metaline by one to adjust from 0-based to 1-based.
              metaline += 1

            /# Record the baseline/metaline/fullid triplet.
            mapping.append((baseline, metaline, fullid))
          else:
            /# print 'ATTRIBUTE: None'
            pass
          chunk.flattenLines(lines, mapfile, indent=indent, debug=False)
        else:
          attribute = attrs.get(chunk_index, None)
          if attribute:
            fqn = attribute.parent().fqn()
            fullid = fqn + ':' + attribute.key()
            /# We increment metaline by one to adjust from 0-based to 1-based.
            metaline = attribute.line() + 1
            mapping.append((baseline, metaline, fullid))
          lines.append(indent + chunk if chunk else '')

      if strip_special:
        dentre = metax.c.SPECIAL_PREFIX_RE
        for i in range(start_index, len(lines)):
          m = dentre.match(lines[i])
          if m:
            lines[i] = lines[i][m.end(0):]
    end method flattenLines;

    method flattenStr : str #:
      Obtain a multi-line string for this stream.

      Instantiates variables into a template, with special logic:
       - replace ${var} with the value of the variable
          - if the value is a list
             - if there is exactly one variable in the current line (with
               $prefix and $postfix text before and after the var), then
               each element in the value is rendered on a separate line,
               preceeded by $prefix and succeeded by $postfix.
             - if there is more than one variable on the current line,
                - if the value of the variable is list-valued, the elements
                  are to be joined together separated by a special string
                  indidcated in the variable (for example, ${var?, } means
                  elements should be joined together with ', ').
          - if the value if the variable is not list-valued, it is inserted
            as-is. If the variable is of the form ${var?, }, it means 'if the
            value is empty, print nothing. If it is not empty, print the value
            followed by ', '.
    params:
      var indent : str = '' #:
        What to insert at the beginning of each line.
      var linenum : int = 0 #:
        If zero, no line numbering is desired, otherwise produce line numbers
        starting at specified value.
    scope:
      mapfile = metax.c.MapFile(None, None)
      lines = []
      self.flattenLines(lines, mapfile, indent=indent)
      if linenum:
        result = '\n'.join(
          ['%4d: %s' % (i, line) for i, line in enumerate(lines, start=linenum)])
      else:
        result = '\n'.join(lines)
      return result + '\n'
    end method flattenStr;

    method instantiate #:
      Add text to self by instantiating a template into self via a varset.
    params:
      var template : str #:
        The template string
      var varset : VarSet #:
        The varset providing var/value/attr triples to instantiate into
        the template.
      var kind : str #:
        The construct kind for which we are instantiating.
      var fqn : str #:
        The fully qualified name of the construct producing this text.
      var joins : map = null #:
        Maps variable names to join strings, for use when a variable doesn't
        specify a join explicitly.
    scope:
      cls = self.__class__

      debug = False
      if template[-1] != '\n':
        raise InvariantViolated('Templates must end with newline')

      /# There are two kinds of variable substitutions to deal with:
      /#  1) A variable appearing on a line by itself, possibly indented.
      /#     These generate BaseSegment instances. Values of list type are
      /#     allowed and common, and indentation must be handled properly.
      /#  2) A variable with non-space text before it or any text after it.
      /#     These produce strings, and if values are lists the elements
      /#     are joined into a string via a template-provided separator.
      /#     Supports max-width logic and line wrapping.
      r = re.compile(r'\$\{(?P<var>[a-zA-Z0-9_-]+)(?:\?(?P<join>[^\}]*))?\}')
      lines = template.split('\n')
      while not lines[-1]: lines.pop()
      for line in lines:
        if debug: print 'LINE: %s' % line

        m = r.search(line)
        if not m:
          /# No variable ... add the line verbatim.
          self.addChunk(line)

        else:
          /# We have found a variable interpolation request.
          /#  - we repeat the following code over and over as long as we
          /#    continue to find a variable interpolation on the line.
          /#    (so the code MUST replace variable references with non-variable
          /#    references to avoid an infinite loop).
          /#  - the 'chunk' variable is accumulated as the line is processed,
          /#    and a single value is added after all variable interpalations
          /#    on the line have been processed.
          chunk = ''
          count = 0
          attributes = []
          while m:
            count += 1
            pre = line[:m.start(0)]
            post = line[m.end(0):]
            var = m.group('var')
            join = m.group('join')

            /# Obtain the information about the variable to be interpolated.
            value, attribute, elem_delim, line_width = varset.get(var)
            if value is None:
              raise Error(
                "Missing variable '%s' for %s template:\n%s\nvarset is:\n%s" %
                (var, kind, template, varset.asStr(indent='  ')))
            if attribute:
              if attribute not in attributes:
                attributes.append(attribute)

            if debug:
              print str({
                'count': count, 'pre': pre, 'post': post, 'var': var,
                'join': join, 'value': value, 'attribute': attribute,
                'elem_delim': elem_delim, 'width': line_width})

            if count == 1 and not post and not pre.strip():
              /# There is a single variable on the line (preceeded by indentation
              /# stored in 'pre').
              if isinstance(value, (list, tuple)):
                /# We have a variable that produces a BaseSegment.
                if debug: print 'In multi with attribute=%s' % attribute
                if value:
                  /# Non-empty value.
                  chunk = cls(attribute, chunks=value, indent=pre)
                else:
                  /# Empty value ... treat the variable as if it doesn't exist.
                  chunk = None
              else:
                /# The value is a string
                if not value:
                  /# Empty value, so the entire line is ignore.
                  chunk = None
                else:
                  chunk += pre + value
              /# There is only one variable on this line, so we can terminate
              /# the iterations.
              break
            else:
              /# We have a variable that produces a str
              /#  - if the value is a list, it is turned into a string by
              /#    joining with join (which must exist).
              if debug: print 'In simple'
              chunk += pre
              if isinstance(value, (list, tuple)):
                if join is None:
                  if joins:
                    join = joins.get(var, None)
                  if join is None and len(value) < 2:
                    join = ' '
                if join is None:
                  raise Error('Found list-valued %s without join' % var)
                chunk += join.join(value)
              else:
                if value:
                  /# We replace the var with the value, and maybe with some
                  /# additional text.
                  chunk += value
                  if join:
                    chunk += join
                else:
                  /# If the value is empty, we do replace the var with nothing.
                  pass

            /# Prepare for next iteration
            line = post
            m = r.search(line)

          if chunk is None:
            /# An indication that we are to not add anything.
            pass
          elif isinstance(chunk, BaseSegment):
            self.addChunk(chunk)
          else:
            na = len(attributes)
            if na == 0:
              attribute = None
            elif na > 1:
              attribute = attributes[0]
              metafile = attribute.parent().metafile()
              metafile.warning(
                'Found multiple template variables with associated attributes. '
                'Dropping some.', attr=attribute)
            else:
              attribute = attributes[0]
            chunk += post
            self.addChunk(chunk, attribute=attribute)
    test:
      BaseSegment = metax.c.BaseSegment
      VarSet = metax.c.VarSet

      /# NOTE: The 'construct' instance is not part of a full stack, so
      /# fqn() will fail. Pass fqn into al calls to Instantiate to
      /# avoid it being called.
      construct = self.basics()

      class_scope = construct.rawattr('scope:')
      primattr = metax.c.IdAttribute(
        test.construct, 'method', 'test', line=3, col=6)
      paramsattr = metax.c.ComplexBlock(construct, 'params:', [], line=3, col=20)
      comattr = metax.c.IdAttribute(
        test.construct, 'comment',
        ['This is a comment', 'with multiple lines', 'that should be indented'],
        line=7, col=23)

      /# First, a simple variable substitution
      segment = BaseSegment(class_scope)
      varset = VarSet()
      varset.addVar('method', primattr.value(), attribute=primattr)
      segment.instantiate(
        '@decorators\nmethod ${method}():\n', varset,
        'test', 'demo.cards1.Card.test')
      test.iseqtext(
        '@decorators\nmethod test():\n',
        segment.flattenStr())

      /# Now a list-valued variable with join suffix.
      segment = BaseSegment(class_scope)
      varset.addVar('params', ['a', 'b=1'], attribute=paramsattr)
      segment.instantiate(
        '@decorators\nmethod ${method}(${params?, }):\n', varset,
        'test', 'demo.cards1.Card.test')
      test.iseqtext(
        '@decorators\nmethod test(a, b=1):\n',
        segment.flattenStr())

      /# Now a multi-line value with indentation
      segment = BaseSegment(class_scope)
      varset = VarSet()
      varset.addVar('comment', comattr.value(), attribute=comattr)
      segment.instantiate(
        'Hello\n  ${comment}\nMore here\n', varset,
        'person', 'nm.sp.person')
      test.iseqtext(
        'Hello\n'
        '  This is a comment\n'
        '  with multiple lines\n'
        '  that should be indented\n'
        'More here\n',
        segment.flattenStr())

      /####
      /# Now we parse a real .meta2 file, obtain a method, and instantiate
      /# the method template to provide a more comprehensive test.

      /# Obtain the 'method' template for python.
      _, _, _, compiler = test.cachedInfo()
      metalang = compiler.metalang()
      context = metalang.context()
      template = context.consinfo('method').templateNamed('python')

      /# Parse the testdata/ex2.meta file
      ex2, scope, construct, path = test.getMetaFile(
        'oopl', 'ex2', debuglevel=0)
      method = scope.child('/demo.cards0/Card/test')
      method_comment = method.rawattr('comment:')
      method_scope = method.rawattr('scope:')

      /# Obtain the lines in the metafile.
      fs = compiler.fs()
      with fs.open(path, 'r') as fp:
        metatext = fp.read()
      metalines = metatext.split('\n')

      /# Create and initialize a VarSet for use with the method template.
      varset = VarSet()
      comlines = method_comment.value()
      comlines[0] = '\"\"\"' + comlines[0]
      if len(comlines) == 1:
        comlines[0] += '\"\"\"'
      else:
        comlines.append('\"\"\"')
      varset.addVar('modifiers', '')
      varset.addVar('method', method.id())
      varset.addVar('params', '(%s)' % ', '.join(['a', 'b=1']))
      varset.addVar('comment', comlines, attribute=method_comment)
      varset.addVar('preamble', [])
      varset.addVar('scope', method_scope.value(), attribute=method_scope)
      varset.addVar('postamble', [])

      /# Instantiate the method template with the varset.
      segment = BaseSegment(method.primary())
      segment.instantiate(template, varset, method.kind(), method.fqn())
      mapfile = metax.c.MapFile(None, None)
      baselines = []
      segment.flattenLines(baselines, mapfile)
      mapping = mapfile.mapping()
      test.iseqvec(
        [
          '',
          'def test(a, b=1):',
          '  """Some method on a card."""',
          '  a = 1',
          '  return a',
        ],
        baselines)
      /# print segment.flattenStr(linenum=1)

      /# Verify that the base/meta line mappings are correct.
      for bline, mline, fullid in mapping:
        baseline = baselines[bline-1]
        metaline = metalines[mline-1]
        if metaline.strip() not in baseline:
          test.fail(
            'baseline %d does not match metaline %d:\n  %s\n  %s' %
            (bline, mline, baseline, metaline))
    end method instantiate;

    method appendChunk #:
      Add a string or BaseSegment to the end of the last line in self.chunks(),
      handling multi-line strings and BaseSegment instances.

      This is addToLast in old code.
    params:
      var chunk : any #:
        str or BaseSegment
    scope:
      chunks = self._chunks

      /# We ensure there is always a last chunk in the initializer.
      last_chunk = chunks[-1]
      if isinstance(last_chunk, BaseSegment):
        raise Error(
          'Cannot append to the end of another BaseSegment: use add()')

      if isinstance(chunk, BaseSegment):
        /# Adding a BaseSegment to the end of chunks[-1] is only valid when
        /# chunks[-1] consists solely of whitespace. It establishes how much
        /# indentation to add to the BaseSegment.
        /#
        /# Adding the BaseSegment to the end of chunks[-1] involves adjusting
        /# the indent of the BaseSegment and replacing chunks[-1] with the
        /# BaseSegment.
        /#
        /# TODO(wmh): We should clone chunk before adding it to
        /# chunks, so that its state is maintained here but the original
        /# obj can be modified later without affecting the snapshot.
        indent = chunks[-1]
        if indent.strip():
          raise Error(
            'Cannot append BaseSegment to a line with non-whitespace text')
        chunk.updateIndent(indent)
        chunks[-1] = chunk

      else:
        /# Simple (possibly multi-line) string ... append first element to
        /# last line, add all others.
        if chunk:
          lines = self.__class__.StrChunkToList(chunk)
          chunks[-1] += lines[0]
          chunks.extend(lines[1:])
    test:
      attr = metax.c.ComplexBlock(None, 'comment:', [], line=77, col=69)
      segment = metax.c.BaseSegment(attr, chunks=['Hello'])

      /# Add a simple line.
      test.iseq(['Hello'], segment.chunks())
      segment.appendChunk(' Goodbye')
      test.iseq(['Hello Goodbye'], segment.chunks())
      test.iseq('', segment.indent())

      /# Add a BaseSegment.
      segment2 = metax.c.BaseSegment(attr, chunks=['HPB', 'is a brat', '    '])
      segment2.appendChunk(segment)
      test.iseq('    ', segment.indent())
      test.iseq(['HPB', 'is a brat', segment], segment2.chunks())

      /# Add a multi-line string
      segment.appendChunk('. This is a\nmulti-line string\nwith ending newline\n')
      test.iseq(
        ['Hello Goodbye. This is a', 'multi-line string', 'with ending newline'],
        segment.chunks())
      segment.appendChunk('. And one\nwithout ending newline')
      test.iseq(
        ['Hello Goodbye. This is a', 'multi-line string',
         'with ending newline. And one', 'without ending newline'],
        segment.chunks())
    end method appendChunk;

    method addChunk #:
      Add a new str or BaseSegment to my list of items.

      This is appendItem in old code.
    params:
      var chunk : any #:
        The str or BaseSegment to add to self.chunks(). If null, nothing is
        done (but if empty, an empty line is produced).
      var indent : str = '' #:
        The indentation of the new chunk (in addition to any indentation
        it may already have).
      var attribute : Attribute = null #:
        Only needed for str-valued chunks ... allows one to associate an
        attribute with the string.
    scope:
      chunks = self._chunks

      if isinstance(chunk, BaseSegment):
        segment = chunk
        segment.updateIndent(indent)
        /# TODO(wmh): Verify that updating segment indent will properly convey
        /# the indentation to all sub-segments of that segment as well!
        chunks.append(segment)
        if attribute:
          raise Error('Do not provide attribute to addChunk for BaseSegments')
      else:
        if chunk is not None:
          /# TODO(wmh): If chunk is a string without newlines, the following
          /# somewhat more expensive than it needs to be. But performing a check
          /# for newlines is redundant too. Should we disallow newlines are
          /# support them?
          lines = self.__class__.StrChunkToList(chunk)
          if attribute:
            self.attrs()[len(chunks)] = attribute
          chunks.extend([indent + line for line in lines])
    test:
      attr = metax.c.ComplexBlock(None, 'comment:', [], line=77, col=69)
      segment = metax.c.BaseSegment(attr, chunks=['Hello'])
      test.iseq(['Hello'], segment.chunks())
      segment.addChunk('fun', indent='  ')
      test.iseq(['Hello', '  fun'], segment.chunks())
      segment2 = metax.c.BaseSegment(attr, chunks=['World'])
      test.iseq('', segment2.indent())
      segment.addChunk(segment2, indent='    ')
      test.iseq(['Hello', '  fun', segment2], segment.chunks())
      test.iseq('    ', segment2.indent())
    end method addChunk;

    method appendAddChunks #:
      Given multiple chunks, append the first and add the rest.

      If new_chunks[0] is a BaseSegment instance, chunks[-1] must consist solely
      of whitespace, and it indicates how much the indentation of new_chunks[0]
      should be increased as it is added. Note that subsequent elements of
      new_chunks are not currently indented, so this is really only meaningful
      for a single element lines. TODO(wmh): do we want to indent all values in
      new_chunks by chunks[-1]?

      This was extendFromInterpolationData() in old code.
    params:
      var new_chunks : vec<any> #:
        list of str|BaseSegment
        The chunks to add to self.chunks().'
      var indent : str = '' #:
        How much indentation to add before each chunk in new_chunks when
        adding to self.chunks().
    scope:
      chunks = self.chunks()
      last_chunk = chunks[-1]
      k = len(new_chunks)
      if k and (k > 1 or (k == 1 and new_chunks[0])):
        /# We need to add the first chunk of new_chunks to the end of
        /# chunks[-1].
        assert isinstance(last_chunk, basestring) and indent == last_chunk, 'indent="%s" last_chunk="%s"' % (indent, last_chunk)
        self.appendChunk(new_chunks[0])
        /# Append all subsequent chunks.
        for item in new_chunks[1:]:
          self.addChunk(item, indent)
      else:
        raise Error('What should we do here?')
    test:
      attr = metax.c.ComplexBlock(None, 'comment:', [], line=77, col=69)
      segment = metax.c.BaseSegment(attr, chunks=['Hello', '  '])
      test.iseq(['Hello', '  '], segment.chunks())

      segment.appendAddChunks(['fun', 'crazy', ''], indent='  ')
      test.iseq(['Hello', '  fun', '  crazy', '  '], segment.chunks())

      segment2 = metax.c.BaseSegment(attr, chunks=['World'])
      test.iseq('', segment2.indent())
      segment.appendAddChunks([segment2, 'testing'], indent='  ')
      test.iseqvec(
        ['Hello', '  fun', '  crazy', segment2, '  testing'],
        segment.chunks())
      test.iseq('  ', segment2.indent())
    end method appendAddChunks;

    meta
    method StrChunkToList : vec<str> #:
      Convert a potentially multi-line string into a list of strings.

      If the string ends with a newline, it is treated the same as if the
      newline did not exist (the value 'hello\n' is the same as 'hello').
      However, if multiple newlines exist, they represent empty lines (the
      value 'hello\n\n' yields ['hello', '']).
    params:
      var chunk : str #:
        The str-valued chunk to turn into a list.
    scope:
      if chunk and chunk[-1] == '\n':
        chunk = chunk[:-1]
      result = chunk.split('\n')
      return result
    test:
      test.iseqvec(['hello'], metax.c.BaseSegment.StrChunkToList('hello'))
      test.iseqvec(['hello'], metax.c.BaseSegment.StrChunkToList('hello\n'))
      test.iseqvec(['hello', ''], metax.c.BaseSegment.StrChunkToList('hello\n\n'))
    end method StrChunkToList;

    test
    lifecycle setup:
    end;

  end class BaseSegment;

  class BaseFile #:
    An output file generated when compiling Meta source into a base language.

    Provides an abstraction layer between on-disk vs in-memory files. Also
    provides a mechanism for maintaining a mapping between line numbers in
    Meta source code and associated lines in the baselang code (for BaseFile
    instances that represent baselang source files)
  scope:

    field subpath : str #:
      The on-disk path of the file relative to Compiler.repositoryPath().

    field contents : str #:
      The contents of the file.

    field metafile : MetaFile #:
      The meta file that generated this BaseFile.

    field mapfile : MapFile #:
      The mapfile associated with this BaseFile. Not all BaseFile instance
      have mapfiles (e.g. BUILD, etc.)

    lifecycle params:
      var subpath -> subpath;
      var contents -> contents;
      var metafile -> metafile = null;
      var mapfile -> mapfile = null;
    scope:
      /# We ensure that contents is either empty or always end with a newline
      /# and do not have any spurious trailing whitespace.
      if contents:
        if contents[-1] != '\n':
          print '#' * 70
          print subpath
          print contents
          raise Error('contents must end with newline')
        if contents[-2] in (' ', '\n'):
          print '=' * 70
          print subpath
          print contents
          raise Error('contents should not have spurious trailing whitespace')
      if False:
        print '-' * 70
        print subpath
        print contents
    end lifecycle;

    test
    lifecycle setup:
      contents = 'MetaLanguage Test config:\nend;\n'
      self.base = metax.c.BaseFile('faux/path', contents)
    end lifecycle;

  end class BaseFile;

  class MapFile #:
    Associated with a BaseFile. Contains file lines number mappings from base to
    MetaFile.
  scope:

    field path : str #:
      The path of the mapfile.

    field metapath : str #:
      The absolute real path of the meta file that produced the basefile
      associated with this map.

    field mapping : vec<tuple<int,int,str>> #:
      Each element contains <baseline,metaline,fullid>.
      The fullid is some meta-level attribute (comment, primary, scope, etc.),
      the metaline is the line number in the metafile of that attribute,
      and baselin is the line number in the baselang file generated by
      compiling the metafile.

    lifecycle params:
      var path -> path;
      var metapath -> metapath;
      var mapping : vec = null;
    scope:
      if mapping is None:
        mapping = []
      self.mappingIs(mapping)
    end lifecycle;

    method addSubFile #:
      Add additional entries by adjusting a given sub-mapfile.
    params:
      var mapfile : MapFile #:
        The mapfile to add.
      var offset : int #:
        The offset to apply to baseline numbers in the subfile.
    scope:
      data = self.mapping()
      for baseline, metaline, fullid in mapfile.mapping():
        data.append((baseline + offset, metaline, fullid))
    test:
    end method addSubFile;

    method serialize #:
      Write a mapfile to disk.

      This method is paired with Compiler.loadMapFile().

      Returns:
        The path written to.
    params:
      var fp : ostream = out #:
        Where to write the map.
      var indent : str = '' #:
        What to insert before each line.
    scope:
      close = False
      fp.write('%s%s\n' % (indent, self.metapath()))
      mapping = self.mapping()
      for bline, mline, fullid in mapping:
        fp.write('%s  %8d %8d %s\n' % (indent, bline, mline, fullid))
      if close: fs.close(fp)
    test:
      mapfile = metax.c.MapFile(
        '/some/path/to/mapfile', '/some/path/to/file.meta',
        [(1, 1, 'note1'), (2, 3, 'note2'), (6, 17, 'note3')])
      fp = test.newStr()
      mapfile.serialize(fp, indent='  ')
      test.iseqtext(
        '  /some/path/to/file.meta\n'
        '           1        1 note1\n'
        '           2        3 note2\n'
        '           6       17 note3\n',
        fp.getvalue())
    end method serialize;

    method baseToMeta : tuple<str,int> #:
      Convert a line number in a given base file to a metafile/line pair.

      Returns: two-tuple
       0) the metafile path
       1) the line number within the metafile identified by (0).
    params:
      var basenum : int #:
        A line number within self._mapfile.
    scope:
      metapath = self.metapath()
      mapping = self.mapping()

      j = None
      for i, info in enumerate(mapping):
        if basenum < info[0]:
          j = i - 1
          break
      if j is None:
        meta_line = None
      else:
        smap = mapping[j]
        if len(smap) < 1:
          import pprint
          print 'Here with %s, %s and j=%d' % (self.path(), self.metapath(), j)
          pprint.pprint(smap)

        base_start = smap[0]
        meta_start = smap[1]
        if meta_start == -1:
          meta_line = None
        else:
          diff = basenum - base_start
          /# print 'diff=%d (%d - %d for meta_start %d)' % (diff, basenum, base_start, meta_start)
          if diff < 0:
            /#print metapath
            /#print self.path()
            /#pprint.pprint(mapping)
            /#raise InternalError('Should not be possible for diff to be %d' % diff)
            print 'ERROR: Should not be possible for diff to be %d' % diff
          meta_line = meta_start + diff

      return metapath, meta_line
    end method baseToMeta;

  end class MapFile;

  class ConsInfo #:
    An optimized representation of a construct. Maintains:
     - for every feature attribute
       - feature key
       - aliases of feature key
       - all feature values and their aliases
       - default feature value
       - whether multiple values are allowed
     - for primary attribute
       - aliases of the primary attribute
     - for secondary attributes
       - aliases of the secondary attributes
       - type of the attribute value
       - default value
       - whether the attribute key is optional
       - whether the attribute value is optional
     - for each template
       - mapping from template name to template body.
  assocs:
    usertest std assoc copy;
  scope:
    field name : str #:
      Name of the construct.
    field aliases : *vec<str> #:
      A collection of abbreviations of the construct kind.  For example,
      the 'associations' construct has a 'assocs' abbrev.
    field featvals : @map #:
      Maps legal feature values to canonical feature key.
      Each feature value and all of its aliases map to associated feature key.
    field features : @map #:
      Maps legal feature keys and aliases to maps containing:
        cankey: str
        type: str
          Always 'feature'
        attribute: Attribute (or null)
          The attribute instance to use in attrpair() when the specified
          attribute was looked up and not found.
        default: str (optional)
          Default value of this feature
        delim: str (optional)
          Usually not present. If it is present, values are split on this
          value into a list of strings, instead of a single string.
    field secondaries : @map #:
      Maps legal secondary keys and aliases to maps containing:
        cankey: str
        type: str
        keyopt: bool
        valopt: bool
        attribute: Attribute (or null)
          The attribute instance to use in attrpair() when the specified
          attribute was looked up and not found.
        children: vec<str>
          Only present if type is 'complex' or (optionally) 'simple'.
    field primary : @map #:
      Maps legal primary keys and aliases to maps containing:
        cankey: str
        type: str
        keyopt: bool
        valopt: bool
    field autokeys : @map #:
      Maps single-char to secondary key, for those secondary attributes that
      are uniquely identified by the first character in the value (and thus
      do not need to specify a key)
    field templates : @map<str,str> #:
      Maps template names to multi-line template bodies.
    field construct_class : class #:
      The class implementing the construct.

    lifecycle params:
      var name -> name;
      var type : str #:
        The type of the primary attribute value.
      var construct_class -> construct_class;
      var aliases : vec<str> = null #:
        Abbrevs/aliases for the primary key.
      var valopt : bool = false #:
        If true, the primary attribute does not require an explicit value
        (a value is auto-generated if not provided).
      var replacer : str = null #:
        The name of a valopt secondary key that be given the value after the
        primary in situations where the secondary key does not appear
        explicitly.
    scope:
      primary_data = {
        'cankey': name, 'type': type, 'keyopt': False, 'valopt': valopt}
      if replacer:
        primary_data['replacer'] = replacer
      prims = [name]
      if aliases: prims.extend(aliases)
      primary = self.primary()
      for prim in prims:
        primary[prim] = primary_data
    end lifecycle;

    method clone : ConsInfo #:
      Create a copy of myself.
    scope:
      result = self.__class__(self.name(), 'id', self._construct_class)
      result._aliases = copy.copy(self.aliases())
      result._featvals = copy.copy(self.featvals())
      result._features = copy.copy(self.features())
      result._secondaries = copy.copy(self.secondaries())
      result._primary = copy.copy(self.primary())
      result._autokeys = copy.copy(self.autokeys())
      result._templates = copy.copy(self.templates())
      return result
    test:
      _, context = test.schemaParser('\n')

      for consinfo in context.consmap().values():
        /# Make a copy of each consinfo and verify that its show() output
        /# is exactly the same as the original's show() output.
        conscopy = consinfo.clone()
        fp = self.newStr()
        consinfo.show(fp=fp)
        s1 = fp.getvalue()
        fp = self.newStr()
        conscopy.show(fp=fp)
        s2 = fp.getvalue()
        test.iseq(s1, s2)
    end method clone;

    method show #:
      Print out this class.
    params:
      var fp : ostream = out #:
        Where to write output.
      var indent : str = '' #:
        What to insert before each line of output.
    scope:
      klass = self._construct_class
      fp.write(
        '%s%s: %s\n' %
        (indent, self.name(), klass.__name__ if klass else 'No class (generic)'))
      fp.write('%s  featvals:\n' % (indent))
      featvals = self.featvals()
      for featval in sorted(featvals):
        fp.write('%s    %-20s = %s\n' % (indent, featval, featvals[featval]))
      fp.write('%s  features:\n' % (indent))
      features = self.features()
      for featkey in sorted(features):
        feature = features[featkey]
        fp.write(
          '%s    %-20s = %-20s %s\n' %
          (indent, featkey, feature['cankey'], feature['default']))
      primary = self.primary()
      fp.write('%s  primary:\n' % indent)
      for pkey in sorted(primary):
        data = primary[pkey]
        fp.write(
          '%s    %-20s = %-20s %-20s %-20s %-1s %-1s\n' %
          (indent, pkey,
           data['cankey'], '<required>', data['type'],
           str(data['keyopt'])[0], str(data['valopt'])[0]))
      secondaries = self.secondaries()
      fp.write('%s  secondaries:\n' % indent)
      for secondary in sorted(secondaries):
        data = secondaries[secondary]
        type = data['type']
        typestr = type if len(type) <= 20 else type[:19] + '$'
        if 'children' in data:
          children = '  <%s>' % '|'.join(data['children'])
        else:
          children = ''
        fp.write(
          '%s    %-20s = %-20s %-20s %-20s %-1s %-1s%s\n' %
          (indent, secondary,
           data['cankey'], data['default'], typestr,
           str(data['keyopt'])[0], str(data['valopt'])[0], children))
    test:
      cons = test.cons
      cons.registerSecondary('birthday', 'str', '<empty>', aliases=['dob'])
      cons.registerFeature(
        'gender',
        values={'female': ['f'], 'male': ['m'], 'trans': ['t']},
        default='female',
        aliases=['sex'])
      cons.registerFeature(
        'day',
        values={d: None for d in ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']},
        default='mon')
      cons.registerSecondary(
        'test:', 'complex', '<empty>', children=['birthday'])
      fp = self.newStr()
      cons.show(fp=fp)
      test.iseqtext(
        >|"""person: No class (generic)
        >|  featvals:
        >|    f                    = gender
        >|    female               = gender
        >|    fri                  = day
        >|    m                    = gender
        >|    male                 = gender
        >|    mon                  = day
        >|    sat                  = day
        >|    sun                  = day
        >|    t                    = gender
        >|    thu                  = day
        >|    trans                = gender
        >|    tue                  = day
        >|    wed                  = day
        >|  features:
        >|    day                  = day                  mon
        >|    gender               = gender               female
        >|    sex                  = gender               female
        >|  primary:
        >|    person               = person               <required>           id                   F F
        >|  secondaries:
        >|    birthday             = birthday             <empty>              str                  F F
        >|    dob                  = birthday             <empty>              str                  F F
        >|    test:                = test:                <empty>              complex              F F  <birthday>
        >|""",
        fp.getvalue())
    end method show;

    method registerFeature : ConsInfo #:
      Add a feature to this construct.
       - feature keys and aliases must be unique
       - feature values/aliases do NOT need to be unique
    params:
      var key : str #:
        The canonical name of the feature key
      var values : map = null #:
        Maps legal feature values to list of value aliases or None if there are
        no aliases.  If null, no values added ... useful when creating
        a ConsInfo that will be used to extend a pre-existing ConsInfo.
      var default : str = null #:
        The default value of this feature if not provided explicitly. Can
        be null if extending pre-existing ConsInfo without changing the
        default (although this is the most common thing to change when
        extending).
      var aliases : vec<str> = null #:
        Any aliases for the feature key
      var delim : str = null #:
        If null, only one value is supported.
        If non-null, it is a string by which multiple values can be joined
        together.
    scope:
      /# Register the key and its aliases in featkeys()
      features = self.features()
      fkeys = [key]
      if aliases:
        fkeys.extend(aliases)
      feature = {'cankey': key, 'type': 'feature'}
      if delim is not None:
        feature['delim'] = delim
        fcls = MultiFeatureAttribute
      else:
        fcls = FeatureAttribute
      if default is not None:
        feature['default'] = default
        /# TODO(wmh): Create an Attribute instance for use when LOOKUP is
        /# requested in calls to Construct.attr() and Construct.attrpair() ...
        /# obtain feature['attribute'] and clone it each time.
        feature['attribute'] = fcls(None, key, default)

      for fkey in fkeys:
        if fkey in features:
          raise Error(
            'Attempt to register feature key %s->%s when already maps to %s' %
            (fkey, key, features[fkey]))
        features[fkey] = feature

      /# Register the values and all their aliases in featvals()
      if values:
        featvals = self.featvals()
        for featval in values:
          fvals = [featval] + (values[featval] or [])
          for fval in fvals:
            if fval in featvals:
              raise ConflictingFeatureValues(
                'Attempt to register feature value %s (canonical %s) when already maps to canonical %s' %
                (fval, featval, featvals[fval]))
            featvals[fval] = key

      return self
    test:
      cons = test.cons
      cons.registerFeature(
        'gender',
        values={'female': ['f'], 'male': ['m'], 'trans': ['t']},
        default='female',
        aliases=['sex'])
      cons.registerFeature(
        'day',
        values={d: None for d in ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']},
        default='mon')
      /#cons.show()

      features = {}
      attrs = []
      for key in ('gender', 'day', 'sex'):
        feature = copy.copy(cons._features[key])
        attrs.append(feature.pop('attribute'))
        features[key] = feature
      test.iseq(
        {'gender': {'cankey': 'gender', 'default': 'female', 'type': 'feature'},
         'day': {'cankey': 'day', 'default': 'mon', 'type': 'feature'},
         'sex': {'cankey': 'gender', 'default': 'female', 'type': 'feature'},
        },
        features)
      test.iseqvec(
        ['gender female', 'day mon', 'gender female'],
        [attr.asStr() for attr in attrs])

      test.iseqmap(
        {
          'male': 'gender',
          'm': 'gender',
          'female': 'gender',
          'f': 'gender',
          'trans': 'gender',
          't': 'gender',
          'mon': 'day',
          'tue': 'day',
          'wed': 'day',
          'thu': 'day',
          'fri': 'day',
          'sat': 'day',
          'sun': 'day',
        },
        cons._featvals)

      /# Verify that we cannot register two different features that use the
      /# same feature value.
      cons = metax.c.ConsInfo('person', 'id', None)
      cons.registerFeature(
        'location', default='user',
        values={'user': None, 'test': None, 'meta': None})
      test.raises(
        metax.c.ConflictingFeatureValues,
        cons.registerFeature, 'kind', default='instance',
        values={'instance': None, 'static': None, 'meta': None})
      /# cons.show()
    end method registerFeature;

    method registerSecondary : ConsInfo #:
      Add a secondary to this construct.
    params:
      var key : str #:
        The canonical name of the secondary key. If type is 'simple' or 'complex'
        this key must end with ':'.
      var type : str = null #:
        The type of the attribute value. May be null when extending
        a pre-existing ConsInfo.
      var default : str = null #:
        The default value of this attribute when attribute not specified.
        May be null when extending a pre-existing ConsInfo.
      var aliases : vec<str> = null #:
        Aliases for this secondary key.
      var keyopt : bool = false #:
        If True, the key is optional
      var valopt : bool = false #:
        if True, the value is optional
      var autokey : str = null #:
        A single character which, if present as the current character when
        expecting a secondary key, implicitly identifies this secondary. Useful
        when the first character in a value uniquely identifies a secondary
        attribute so that we don't need to specify the secondary key.
      var children : vec<str> = null #:
        Only present if type is 'complex' or (optionally) 'simple'. The
        list of construct kinds that are legal to appear within the block
        (if simple, those construct kinds legal if the block is upgraded to
        complex via a <*> selector).
    scope:
      isblock =  type in ('simple', 'complex')
      if isblock:
        if key[-1] != ':':
          raise Error(
            'Construct %s attribute "%s" must end with ":" (%s)' %
            (self.name(), key, type))
      data = {
        'cankey': key,
        'type': type,
        'default': default,
        'keyopt': keyopt,
        'valopt': valopt,
        'autokey': autokey,
      }

      if autokey:
        autokeys = self.autokeys()
        if autokey in autokeys:
          raise Error(
            'Attempt to register autokey "%s" for %s and %s' %
            (autokey, key, autokeys[autokey]))
        autokeys[autokey] = key
      if children:
        data['children'] = children
      keys = [key]
      if aliases:
        for alias in aliases:
          if isblock:
            if alias[-1] != ':':
              raise Error(
                'Construct %s attribute %s alias "%s" must end with ":" (%s)' %
                (self.name(), key, alias, type))
          keys.append(alias)
      secondaries = self.secondaries()
      for k in keys:
        secondaries[k] = data

      /# The following code must occur after the code above.
      /#  - the code below invokes methods that eventually invoke this method
      /#    again, and the state in self.secondaries() must already be
      /#    populated to a catch-22.

      /# We create an Attribute instance that will be used when an EMPTY version
      /# of this attribute is requested (explicitly or via lookup)
      empty_func = MetaFile.AttrValueEmpty[data['type']]
      try:
        empty_value = empty_func()
        empty = MetaFile.CreateNewAttribute(
          None, self, key,
          key=key, value=empty_value, typecheck=False, secondary=True)
      except InvalidAttributeType:
        empty = None
      data['empty'] = empty

      /# Now we create an Attribute instance that will be returned if this
      /# attribute key is requested from a construct with LOOKUP semantics
      /# and the key (or an alias) is not specified explicitly in the construct.
      attribute = None
      done = False
      if default == '<required>':
        /# No need to create an default Attribute because one is always required.
        done = True
      elif default == '<empty>':
        /# We are to return an empty attribute ... we already have such an
        /# attribute, so we use it.
        attribute = empty
        done = True
      elif type == 'expr' and default == '<special>':
        /# TODO(wmh): Can we avoid making this check here? Very specialized,
        /# and every additional check slows down the compiler, as this method
        /# is called very often.
        default = None
      elif type == 'type':
        /# We need to upgrade the string-valued default to a Type instance.
        default = Type.Instance(default)
      /# TODO(wmh): We may need to add additional elif clauses above to handle
      /# other attribute types.
      if not done:
        attribute = MetaFile.CreateNewAttribute(
          None, self, key,
          key=key, value=default, typecheck=False, secondary=True)
      data['attribute'] = attribute

      return self
    test:
      cons = test.cons
      cons.registerSecondary('birthday', 'str', '<empty>', aliases=['dob'])
      cons.registerSecondary(
        'test:', 'complex', '<empty>', children=['birthday'])

      secondaries = cons._secondaries
      attrs = []
      empties = []

      copysecs = {}
      for key in ('dob', 'birthday', 'test:'):
        secondary = copy.copy(secondaries[key])
        if 'attribute' in secondary:
          attrs.append(secondary.pop('attribute'))
        if 'empty' in secondary:
          empties.append(secondary.pop('empty'))
        copysecs[key] = secondary
      test.iseq(
        {
          'dob': {
            'default': '<empty>',
            'valopt': False,
            'keyopt': False,
            'type': 'str',
            'cankey': 'birthday',
            'autokey': None,
          },
          'birthday': {
            'default': '<empty>',
            'valopt': False,
            'keyopt': False,
            'type': 'str',
            'cankey': 'birthday',
            'autokey': None,
          },
          'test:': {
            'valopt': False,
            'cankey': 'test:',
            'default': '<empty>',
            'children': ['birthday'],
            'keyopt': False,
            'type': 'complex',
            'autokey': None,
          },
        },
        copysecs)
      test.iseqvec(
        [attr.key() for attr in attrs], ['birthday', 'birthday', 'test:'])
      test.iseqvec(
        [attr.key() for attr in empties], ['birthday', 'birthday', 'test:'])
    end method registerSecondary;

    method registerTemplate #:
      Add a named template.
    params:
      var name : str #:
        The name of the template.
      var text : str #:
        The text of the template, with variable interpolation requests.
    scope:
      self._templates[name] = text
    test:
    end method registerTemplate;

    method templateNamed : str #:
      Obtain the template with given name.
    params:
      var name : str;
    scope:
      result = self._templates.get(name, None)
      /#if result is not None:
      /#  result += '\n'

      if result is None:
        raise Error(
          'Failed to find template named %s in %s' % (name, self.name()))
      return result
    test:
    end method templateNamed;

    method findTemplate : str #:
      Find a template.
    params:
      var names : vec<str> #:
        The names of possible templates. First one found is returned.
    scope:
      result = None
      for name in names:
        result = self._templates.get(name, None)
        if result:
          break
      if result is None:
        raise Error(
          'Failed to find template named %s in %s' % (name, self.name()))
      return result
    test:
    end method findTemplate;

    test
    lifecycle setup:
      self.cons = metax.c.ConsInfo('person', 'id', None)
    end;
  end class ConsInfo;

  class ConsGroup #:
    Maintains a collection of ConsInfo instances.
     - keeps the list of all tokens that can appear before a construct kind
     - keeps the regexp identifiying a construct kind
     - ensures that constraints related to feature keys, feature values,
       primary keys and secondary keys are abided by.
  scope:

    field kinds : vec<str> #:
      A list of kinds.

    field primaries : map<str,ConsInfo> #:
      Maps all tokens representing primary keys (including aliases) to
      ConsInfo instances.

    field features : map<str,tuple<str,str,vec<str>>> #:
      Maps all feature keys/aliases and feature values/aliases to tuples:
       0) fkind : str
         One of 'key' or 'value'
       1) fkey : str
         A canonical feature key
       2) kinds : vec<str>
         A list of construct kinds (aka primary key) that have this
         feature key or value.

    lifecycle params:
      var kinds -> kinds;
      var primaries -> primaries;
      var features -> features;
    scope:
    end;

    method show #:
      Print out this instance in humand-readable format.
    params:
      var fp : ostream = out #:
        Where to write to.
    scope:
      fp.write('ConsGroup: %s\n' % ','.join(self.kinds()))

      primaries = self.primaries()
      fp.write('  Primaries:\n')
      for token in sorted(primaries):
        fp.write('    %-20s = %s\n' % (token, primaries[token].name()))

      fp.write('  Features:\n')
      features = self.features()
      for token in sorted(features):
        info = features[token]
        fp.write(
          '    %-20s = %-20s %-20s %s\n' %
          (token, info[0], info[1], ','.join(sorted(info[2]))))
    test:
      _, _, _, compiler = test.cachedInfo(metal='meta')
      context = compiler.bootstrapContext()
      /# TODO(wmh): The following is not a sensible collection of constructs to
      /# pass to legalInfo. When the new schema for Meta(Oopl) is defined, use
      /# ['method', 'field'] for a more realistic example.
      consgroup = context.legalInfo(
        ['MetaLanguage', 'Construct', 'Attribute', 'FeatureValue'])
      fp = test.newStr()
      consgroup.show(fp=fp)
      /# print fp.getvalue()
    end method show;

  end class ConsGroup;

  class Context #:
    A Context maintains the set of (modified) ConsInfo instances that apply when
    parsing a Construct (based on the set of constructs legal in the Meta
    language and any 'config' blocks in the lexical chain above the current
    construct).

    We do NOT create a Context for every Construct or even every ComplexBlock.
    Only if a Construct has a 'config' attribute do we need to introduce a
    new Context.
  scope:

    meta
    lifecycle scope:
      /# A collection of constants. Code should use self.token('<key>')
      /# instead of hard-coding any of these.  For now they are stored here
      /# in a class var, but we may want to allow customization within
      /# config blocks, in which case they will become instance fields.
      cls.TOKENS = {
        /# What character starts a new scope. Block-valued attributes must
        /# end with this.
        'scope': ':',

        /# What separates identifiers in a fully qualified scope. For
        /# example, nm.sp.Class.meth is separated by '.'.
        'scope_sep': '.',

        /# What terminates a construct.
        'term': ';',

        /# The secondary terminator text.
        'end': 'end',

        /# Meta-level one-line comment
        'remark': '/#',

        /# How many characters is each scope indented relative to parent.
        'blockdent': 2,

        /# What is inserted before field names to produce raw field name
        /#  - CODETANGLE(fieldinit): See FieldConstruct.expandMeta() and
        /#    BaseLanguageOopl.initCode()
        'field_prefix': '_',

        /# What is inserted after field names to produce raw field name
        /#  - CODETANGLE(fieldinit): See FieldConstruct.expandMeta() and
        /#    BaseLanguageOopl.initCode()
        'field_suffix': '',

        /# The character used to indicate that the class in a type is
        /# to be treated "as is".
        'explicit_class_indicator': '^',
      }
    end lifecycle;

    field parent : Context #:
      The parent context.  Only null when parsing a schema file. When
      parsing a metafile, the Context associated with the MetaLanguage
      is used to start the parsing process.

    field consmap : map<str,ConsInfo> #:
      Maps construct primary keys to ConsInfo instances. Represents all
      constructs defined in the MetaLanguage, along with any changes made to
      constructs/attributes by 'config' blocks in the lexical chain above the
      construct this context belongs to.

      A MetaLanguageConstruct exists for each MetaLanguage, and its 'config' block
      contains a collection of Construct constructs whose 'config' block
      contains a collection of Attribute constructs whose 'config' block
      contains a collection of FeatureValue constructs. The information
      within a Construct relevant to parsing the construct is summarized in
      a ConsInfo instance.

      Most constructs in most Meta Languages define a 'config' secondary
      attribute that allows one to change aspects of constructs that will
      apply to all (recursive) complex blocks within the construct. The
      Construct instances within the 'config' block imply the creation of a
      new ConsInfo (inheriting from the parent ConsInfo with new values
      for the modified items).
    end field consmap;

    field compiler : Compiler #:
      Since every construct maintains a Context, by storing a compiler instance
      in Context every construct has access to everything (metafile, baselang,
      metalang, compiler, etc.).  Not needed for proper functioning of the
      class itself, just cached here as a convenient means of providing the
      compiler to constructs without requiring that each construct store
      the compiler explicitly (same rationale applies to 'metafile' below).

    field autocount : int = 0 #:
      Used to generate auto-assigned ids.

    field legals : @map #:
      Maps strings of comma-separated (alphabetically sorted) construct kinds
      to maps of all kinds/aliases to ConsInfo instances. This is used by
      legalInfo() to cache computed results.

    field metafile : MetaFile #:
      The MetaFile that this Context resides within. Since every Construct
      maintains a Context, by storing a MetaFile in the Context each Construct
      has access to its MetaFile without having to traverse its parent chain.

      Note that this does mean that we must create a new Context for every
      MetaFile, even if no explicit config block exists at top-level within the
      MetaFile.
    end field metafile;

    lifecycle params:
      var parent -> parent;
      var consmap -> consmap;
      var compiler -> compiler;
      var metafile -> metafile;
    scope:
    end lifecycle;

    method subclone : Context #:
      Make a copy of myself and set the copy's parent to self.
    params:
      var metafile : MetaFile = null;
    scope:
      if metafile is None:
        metafile = self.metafile()
        if metafile is None:
          raise Error('Must provide metafile when self has no metafile')
      compiler = self.compiler()

      /# Group all tokens sharing same ConsInfo together
      tmp = {}
      for key, consinfo in self.consmap().iteritems():
        tmp.setdefault(consinfo, []).append(key)

      /# Create a copy of consmap
      consmap = {}
      for consinfo, keys in tmp.iteritems():
        /# TODO(wmh): It is not technically necessary to create clones of
        /# every ConsInfo ... it is only those constructs that have 'config'
        /# blocks that need to be cloned.  How can we detect this
        /# efficiently?
        conscopy = consinfo.clone()
        for key in keys:
          consmap[key] = conscopy
      return self.__class__(self, consmap, compiler, metafile)
    test:
      metafile, parent = test.schemaParser('\n')
      parent.metafileIs(None)
      test.raises(metax.c.Error, parent.subclone)
      context = parent.subclone(metafile=metafile)
      test.issame(metafile, context.metafile())
      /# TODO(wmh): Add some tests to verify that parent and context are
      /# now truly independent from one another (changes to one do not
      /# result in changes in the other).
    end method subclone;

    method autoId : str #:
      Obtain a new id.
    scope:
      self.autocountIs(self.autocount() + 1)
      return 'Meta__%d__' % self.autocount()
    test:
      test.iseq('Meta__1__', test.context.autoId())
      test.iseq('Meta__2__', test.context.autoId())
    end method autoId;

    meta
    method IsAutoId : bool #:
      True if the id is auto-assigned.
    params:
      var id : str;
    scope:
      return bool(re.match('^Meta__(\d+)__$', id))
    test:
      test.istrue(metax.c.Context.IsAutoId('Meta__39__'))
      test.isfalse(metax.c.Context.IsAutoId('foo'))
    end method IsAutoId;

    method consinfo : ConsInfo #:
      Obtain the consinfo for a given construct kind.
    params:
      var kind : str #:
        The construct kind (aka primary key).
    scope:
      return self.consmap().get(kind, None)
    test:
      test.iseq('Construct', test.context.consinfo('Construct').name())
      _, _, context, compiler = test.cachedInfo()
      consinfo = context.consinfo('lifecycle')
      test.iseq(
        {'lifecycle': {
          'valopt': True, 'keyopt': False, 'type': 'id', 'cankey': 'lifecycle'}},
        consinfo.primary())
      /# consinfo.show()
    end method consinfo;

    method attrinfo : any #:
      docstr
    params:
      var kind : str #:
        The construct kind (or alias) that attr info is desired for.
      var key : str #:
        The attribute key (or alias) that info is desired for
    scope:
      consinfo = self.consinfo(kind)
      if consinfo is None:
        /# context.show()
        raise Error('Failed to find consinfo for "%s"' % kind)
      info = (
        consinfo.features().get(key) or consinfo.secondaries().get(key))
      return info, consinfo
    test:
      _, metalang, context, _ = test.cachedInfo()
      info, consinfo = context.attrinfo('method', 'location')
      info = copy.copy(info)
      attribute = info.pop('attribute')
      test.iseqmap(
        {'default': 'user', 'type': 'feature', 'cankey': 'location'},
        info)
    end method attrinfo;

    method register #:
      Register a ConsInfo instance with this Context.  This method is invoked
      in two related situations:
       - when parsing a MetaLanguage schema, a Context is created, and
         Context.register() is invoked on the ConsInfo instance associated with
         the Construct.
       - when parsing an arbitrary construct, if a 'config' secondary attribute
         is encountered, the Context associated with the construct is changed
         (a copy of the parent Context is created and modified by calling
         Context.register() for the ConsInfo version of each Construct found
         within the 'config' block).
    params:
      var consinfo : ConsInfo #:
        The 'compiled' version of a Construct to be registered into this
        Context.
    scope:
      consmap = self.consmap()
      primary = consinfo.name()
      if primary in consmap:
        /# We are probably in a 'config' block modifying a construct relative to
        /# what exists in the parent context. One should make a copy of the
        /# pre-existing ConsInfo and invoke registerFeature() or
        /# registerSecondary on that copy, rather than re-registering a
        /# ConsInfo.
        raise Error('Attempt to re-register ' + primary)
      else:
        /# We are registering this construct for the first time.
        consmap[primary] = consinfo
    test:
      /# Note that bootstrapContext() invokes register() once for each
      /# construct it emulates (5 times).
      context = self.context
      test.iseqvec(
        ['Attribute', 'BaseLanguage', 'Construct', 'FeatureValue', 'File',
         'MetaLanguage', 'Template'],
        sorted(context.consmap()))

      /# Now we verify that invoking register on a pre-existing construct
      /# raises an exception.
      consinfo = metax.c.ConsInfo('Attribute', 'id', metax.c.AttributeConstruct)
      test.raises(metax.c.Error, context.register, consinfo)
    end method register;

    method token : any #:
      Obtain the value of a named token. Raises KeyError if not recognized.
    params:
      var name : str;
    scope:
      return self.__class__.TOKENS[name]
    test:
      context = test.context
      test.iseq(';', context.token('term'))
    end method token;

    method show #:
      Print out this class.
    params:
      var fp : ostream = out #:
        Where to write output.
      var indent : str = '' #:
        What to insert before each line of output.
    scope:
      metafile = self.metafile()
      fp.write('Context: %s\n' % (metafile.path() if metafile else 'null'))
      subindent = indent + '  '
      consmap = self.consmap()
      for key in sorted(consmap):
        consinfo = consmap[key]
        consinfo.show(fp=fp, indent=subindent)
    test:
      fp = test.newStr()
      test.context.show(fp=fp)
      out = fp.getvalue()
      test.contains(
        '      Attribute            = Attribute            <required>           word                 F F\n',
        out)
    end method show;

    method legalInfo : ConsGroup #:
      Obtain all legal tokens that can appear at/before any of a given set
      of construct kinds.
    params:
      var kinds : vec<str> #:
        The constructs legal in a particular complex block.  May be null,
        in which case all constructs provided by the meta language are
        legal.
    scope:
      consmap = self.consmap()
      if kinds is None:
        kinds = sorted(consmap.keys())
      else:
        kinds = sorted(kinds)
      kindskey = ','.join(kinds)

      legals = self.legals()
      result = legals.get(kindskey, None)
      if result is None:
        primaries = {}
        features = {}
        for kind in kinds:
          consinfo = consmap.get(kind, None)
          if consinfo is None:
            /# No information has been found in consmap for this kind. This can
            /# happen, for example, when parsing a schema file for a sublang of
            /# Meta(Meta) ... the legal kinds include construct from the sublang
            /# but consmap may only support Meta(Meta).
            continue
          assert consinfo.name() == kind
          for key in consinfo.primary().keys():
            if key in primaries:
              raise Error('Attempt to add %s twice' % key)
            primaries[key] = consinfo

          /# consinfo.features() maps feature keys/aliases to maps containing
          /# cankey, etc.
          for token, fkeyinfo in consinfo.features().iteritems():
            fkey = fkeyinfo['cankey']
            info = features.get(token, None)
            if info:
              if info[0] != 'key':
                raise Error(
                  'Token "%s" is a feature key for %s and a feature value for %s' %
                  (token, kind, info[2]))
              elif info[1] != fkey:
                raise Error(
                  'Token "%s" is a feature key for both %s and %s' %
                  (token, kind, info[2]))
              else:
                info[2].append(kind)
            else:
              features[token] = ('key', fkey, [kind])

          /# consinfo.featvals() maps legal feature values to canonical feature
          /# keys.
          for token, fkey in consinfo.featvals().iteritems():
            info = features.get(token, None)
            if info:
              if info[0] != 'value':
                raise Error(
                  'Token "%s" is a feature value for %s and a feature key for %s' %
                  (token, kind, info[2]))
              /#elif info[1] != fkey:
              /#  raise Error(
              /#    'Token "%s" is a feature value for both %s and %s' %
              /#    (token, kind, info[2]))
              else:
                info[2].append(kind)
            else:
              features[token] = ('value', fkey, [kind])
        result = ConsGroup(kinds, primaries, features)
        legals[kindskey] = result
      return result
    test:
      context = self.context
      test.iseqmap({}, context.legals())
      res1 = context.legalInfo(['Construct'])
      test.iseqvec(['Construct'], sorted(res1.primaries()))
      res2 = context.legalInfo(['Construct'])
      test.issame(res1, res2)
      res3 = context.legalInfo(['Construct', 'Attribute'])
      test.iseqvec(['Attribute', 'Construct'], sorted(res3.primaries()))
    end method legalInfo;

    test
    lifecycle setup:
      _, _, _, compiler = test.cachedInfo(metal='meta')
      self.compiler = compiler
      self.context = compiler.bootstrapContext()
    end lifecycle;
  end class Context;

  abstract
  class Attribute #:
    Abstract superclass of all Attribute classes.

    A parsed MetaFile contains Construct instances, which map attribute
    keys to Attribute instances.

    Attribute
      SimpleAttribute         --> value is a string
        FeatureAttribute      --> value comes from a pre-defined construct-specific list
        IdAttribute           --> value is an identifier
        WordAttribute         --> value is a string containing no whitespace
        StrAttribute          --> value is an unquoted string (TODO(wmh): This implies free-form parsing ... do we want to support it?)
      ExprAttribute           --> value is an Expr instance
        LitStrAttribute       --> value is an Expr representing a literal string (e.g. single or double-quoted)
        NumAttribute          --> value is an Expr representing a literal number
      TypeAttribute           --> value is an Type instance
      BlockAttribute          --> value is a list
        SimpleBlock           --> value is a list of str
        ComplexBlock          --> value is a list of Construct
  assocs:
    std assoc cStringIO;
  scope:

    field parent : Construct #:
      The construct within which this attribute resides.

    field key : str #:
      The canonical key. See litkey for the actual key/abbrev used in the source.

    field litkey : str #:
      The key or an abbrev, as used in the input source.  A value of null means
      the canonical key was used. A value of '' means the key was not explicitly
      provided.

      Initially, it was hoped that we could store only the canonical key in this
      Attribute and use the litkey as the key in Construct.attributes(), but
      that approach would allow two instances of the same attribute to appear in
      a construct (by using the canonical key for one, abbrev 1 for another,
      abbrev 2 for another, etc.). For now, we always store litkey, but it may
      be worthwhile to mark it as optional.
    end field litkey;

    field line : int #:
      The line number on which the attribute key appears (from 0)

    field col : int #:
      The column at which the attribute key starts (from 0)

    optional
    field basel : str #:
      The baselang selector for this attribute.
      TODO(wmh): Get optional fields working in meta or meta2

    lifecycle params:
      var parent -> parent;
      var key -> key;
      var litkey -> litkey = null;
      var line -> line = -1;
      var col -> col = -1;
    scope:
    end lifecycle;

    abstract
    method clone : Attribute #:
      Make a copy of this Attribute that shares no intrinsic state but does
      share extrinsic state.
    params:
      var cloned_parent : Construct #:
        The construct within which the cloned Attribute resides.
    end method clone;

    method pos : str #:
      The position of this attribute as a string in human units (1-indexed)
    scope:
      return 'L%dC%d' % (self.line() + 1, self.col() + 1)
    test:
      test.defineAttributes()
      test.iseq('L11C3', test.feature.pos())
      test.iseq('L11C10', test.id.pos())
    end method pos;

    method changeParent #:
      Move myself out of my current parent into the new parent.
    params:
      var new_parent : Construct #:
        The parent to move this attribute into.
      var position : str = null #:
        A string that starts with '+' or '-' followed optionally by the name of
        a pre-existing attribute within the construct. If the position is '+' or
        null, insert at end. If the position is '-', insert at beginning.
        Otherwise, insert before (if first char is '-') or after (if first
        char is '+') the attribute key identified by position.
    scope:
      parent = self.parent()
      parent.unregisterAttribute(self)
      new_parent.registerAttribute(self, position=position)
    test:
    end method changeParent;

    method write : int #:
      Write this attribute to a stream.

      Returns:
        The number of characters written. If the output contains multiple
        lines, the return value is -1.
    params:
      var fp : ostream = out #:
        Where to write output.
      var indent : str = '' #:
        What to write before each non-first line.  The first line
        (containing the attribute key) is NOT indented (the caller, which
        is printing out all attributes in a construct, is responsible for
        providing the correct indentation before each attribute).
      var mode : map = null #:
        See Construct.write() for details on mode semantics.
    scope:
      if mode is None: mode = {}

      /# Establish the kind of attribute.
      /#  - TODO(wmh): can we do this more efficiently?
      parent = self.parent()
      if isinstance(self, FeatureAttribute):
        kind = 'feature'
      elif parent and parent.primary() is self:
        kind = 'primary'
      else:
        kind = 'secondary'

      /# Establish formatting variants
      form = mode.get('form', 'code')
      keykey = kind[0] + 'key'
      valkey = kind[0] + 'val'
      keyform, keyplus = Attribute.ModeFor(mode, keykey)
      valform, valplus = Attribute.ModeFor(mode, valkey)

      /# Determine how to format the attribute key.
      if keyform == 'user':
        /# Use whatever the user provided.
        /#  - litkey() may be the empty string, to indicate that no explicit key
        /#    was present from user.
        key = self.litkey()
        /# TODO(wmh): Unless we make litkey optional, consider storing the
        /# key within litkey when litkey matches key so that we don't have
        /# to do this kind of special casing.
        if key is None: key = self.key()
      elif keyform == 'no':
        /# Do not show the value
        key = ''
      elif keyform == 'show':
        /# Use canonical key
        key = self.key()
      elif keyform == 'alias':
        /# Use first alias if present else canonical key.
        /# TODO(wmh): Decide if this is worth implementing and if so, fix the
        /# following.
        key = self.key()
      else:
        raise Error('Invalid mode %s = %s' % (keykey, keyform))
      if keyplus:
        /# A request to show the object associated with the attribute. Useful
        /# in validating clone code.
        key += '[%s]' % id(self)

      /# Handle htmlization of key
      /#  - add a kind-specific class
      /#  - if there is a construct-specific color, add a 'style'
      /#  - make test HTML safe (keys can have selectors like 'scope<py>:')
      if key and form == 'html':
        style = ''
        /# TODO(wmh): This color map should come from the current context!
        color = Compiler.ConstructColorMap.get(parent.kind(), None)
        spanparts = ['span']
        spanparts.append('class="face-%s"' % kind)
        if kind == 'primary' and color:
          spanparts.append('style="color:%s;"' % color)
        postamble = ''
        if self.isBlock():
          htmlid = self.htmlId()
          spanparts.append(
            'onclick="tv(\'%s\')"' % htmlid)
          postamble = '<span id="%s:e" class="ellipsis">...</span>' % htmlid
          out = mode.setdefault('out', {})
          bout = out.setdefault('block', {})
          bout.setdefault('all', []).append(htmlid)
          bout.setdefault(self.key(), []).append(htmlid)
          basel = self.basel()
          if basel:
            lout = out.setdefault('lang', {}).setdefault(basel, {})
            lout.setdefault('all', []).append(htmlid)
            lout.setdefault(self.key(), []).append(htmlid)

        key = '<%s>%s%s</span>' % (
          ' '.join(spanparts), HtmlSafe(key), postamble)

      /# Render the key.
      if key and not self.isBlock():
        key += ' '
      fp.write(key)
      count = len(key)

      /# Determine how to format the attribute value.
      if valform == 'user':
        /# Show the value as provided by user.
        vcnt = self.writeValueLines(fp=fp, indent=indent, mode=mode)
        result = -1 if vcnt < 0 else count + vcnt
      elif valform == 'no':
        /# Do not show the value.
        result = count
      else:
        raise Error('Invalid mode %s = %s' % (valkey, valform))

      return result
    test:
    end method write;

    static
    method ModeFor : tuple<str,bool> #:
      Obtain mode info for a kind and part.

      Returns:
       0) one of 'no', 'user', 'show' or 'alias'
       1) true if the value for key in mode ends in '+' (a request to
          show an id).
    params:
      var mode : map #:
        See Construct.write() for details on mode structure.
      var key : str #:
        [fps](key|val)
    scope:
      plus = False
      val = mode.get(key, 'user')
      if val[-1] == '+':
        val = val[:-1]
        plus = True
      return (val, plus)
    test:
      test.iseq(('no', False), metax.c.Attribute.ModeFor({'pkey': 'no'}, 'pkey'))
      test.iseq(('user', False), metax.c.Attribute.ModeFor({}, 'fkey'))
      test.iseq(('show', True), metax.c.Attribute.ModeFor({'skey': 'show+'}, 'skey'))
    end method ModeFor;

    method asStr : str #:
      Produce the string representation.
    params:
      var mode : map = null #:
        See Construct.write() for details on mode semantics.
    scope:
      fp = cStringIO.StringIO()
      self.write(fp=fp, mode=mode)
      return fp.getvalue()
    test:
      test.defineAttributes()
      test.iseq('gender male', test.feature.asStr())
      test.iseq('person bob', test.id.asStr())
      test.iseq('count 42', test.num.asStr())

      test.iseq('value "this is a test"', test.expr.asStr())
      test.iseq('type vec<str>', test.type.asStr())

      test.iseqtext(
        'comment:\n'
        '  this is a\n'
        '  test of a simple block\n',
        test.simple.asStr())

      test.iseqtext(
        'scope:\n',
        test.complex.asStr())
    end method asStr;

    method path : str #:
      The path to this attribute within the metafile.
    scope:
      parent = self.parent()
      if isinstance(parent, FileConstruct):
        result = ''
      else:
        result = self.parent().path()
        /# TODO(wmh): We cannot strip the colon off the key if the parent
        /# construct defines both block and nonblock versions of the key.
        key = self.key().rstrip(':')
        result += '@' + key
      return result.replace('@scope/', '/')
    test:
      /# Tested in ComplexBlock.child()
      pass
    end method path;

    method htmlId : str #:
      A unique id by which this block can be identified in HTML.
    scope:
      return '%s.%s%s' % (self.parent().fqn(), self.key(), self.basel() or '')
    test:
    end method htmlId;

  end class Attribute;

  abstract
  class SimpleAttribute < Attribute #:
    An attribute that has a string value.
  scope:
    field value : str #:
      The value. Subclasses may place requirements on the format of the
      string, but will always have a value of type string (even something
      like NumAttribute).

    lifecycle params:
      var parent : Construct;
      var key : str;
      var value : str;
      var litkey : str = null;
      var line : int = -1;
      var col : int = -1;
    super (parent, key, litkey=litkey, line=line, col=col)
    scope:
      self.valueIs(value)
    end;

    method clone : Attribute #:
      Make a copy of this Attribute.
    params:
      var cloned_parent : Construct #:
        The construct within which the cloned Attribute resides.
    scope:
      cls = self.__class__
      result = cls(
        /# We do not need to copy the value since it is a readonly string.
        cloned_parent, self.key(), self.value(),
        litkey=self.litkey(), line=self.line(), col=self.col())
      return result
    test:
      test.defineAttributes()
      feature2 = test.feature.clone(None)
      id2 = test.id.clone(None)
      num2 = test.num.clone(None)
    end method clone;

  end class SimpleAttribute;

  class FeatureAttribute < SimpleAttribute #:
    An attribute that appears before the primary attribute.
    The feature value comes from a pre-defined set of feature-key-specific
    legal values.
  scope:
  end class FeatureAttribute;

  class IdAttribute < SimpleAttribute #:
    An attribute whose value is an identifier.
  scope:
  end class IdAttribute;

  class WordAttribute < SimpleAttribute #:
    An attribute whose value is a single word.
  scope:
  end class WordAttribute;

  class NumAttribute < SimpleAttribute #:
    An attribute whose value is an integer. Note that this is a subclass
    of SimpleAttribute so its value is a string (but required to only contain
    digits optionally preceeded by a sign)
  scope:
  end class NumAttribute;

  class ExprAttribute < Attribute #:
    An attribute whose value is an Expr.
  scope:

    field value : Expr #:
      The value, as an Expr instance (which may or may not be pre-parsed).
    scope:
      accessor set scope:
        /# Remember that we must support null values because
        /# parseSecondaryAttribute() creates the Attribute instance before it has
        /# parsed the value.
        if value is None:
          pass
        /# elif value == '<special>':
        /#  value = None
        elif not isinstance(value, Expr):
          /# Temporary transitional code.
          /# - while we convert the 'default' attribute of 'var', 'field' and
          /#   'flag' from 'word' to 'expr', we implicitly convert some basic
          /#   string values to Expr instances.
          /# TODO(wmh): Remove this code when we are fully migrated!
          print 'In ExprAttribute.valueIs() with non-expr "%s"' % value
          if value == '""':
            raise Error('here')
          error = True
          m = re.match(r'^[-+](\d+)(?:\.\d+)?$', str(value))
          if m:
            /# We have an int or float
            error = False
            kind = 'num'
            if m.group(2) is None:
              val = int(value)
            else:
              val = float(value)
          elif value == '<special>':
            /# TODO(wmh): This is actually supposed to be a type-specific
            /# default (so if the variable is of type 'int', we assign 0, if it
            /# is a Ptr, we assign baselang null, if it is a str, we assign
            /# baselang empty string, etc. We do not have enough info here in
            /# this method to establish that default (needs Type instance), so
            /# we set the value to None so that downstream clients can deals
            /# with it.
            /# CODETANGLE(special_expr): TODO(wmh): Decide whether <special> is
            /# indicated by an Expr with value() None, or by an Expr that is
            /# None.
            if False:
              val = None
              kind = 'str'
            else:
              value = None
            error = False
          else:
            /# The only other string-valued Expr's we handle are vars and
            /# strings.  For now, we just always assume str.
            error = False
            kind = 'str'
            val = value

          if error:
            raise Error(
              'ExprAttribute value must be an Expr not %s (%s %s)' %
              (type(value), self.litkey(), str(value)))
          elif value is None:
            /# CODETANGLE(special_expr): TODO(wmh): Decide whether <special> is
            /# indicated by an Expr with value() None, or by an Expr that is
            /# None.
            pass
          else:
            value = Expr(kind, value, val)

        /# NOTE(wmh): The user defining the accessor scope needs access to
        /# both the receiver variable and the field name. If the scope is
        /# implemented in <*>, both of these can be abstracted away, but if
        /# the scope is baselang-specific (the common case), we need to provide
        /# a baselang-independent receiver and some means of referring to
        /# field and rawfield, maybe using ${field} and ${rawfield}?
        self._value = value
    end field value;

    field code : str #:
      The baselang code.

    field codetype : Type #:
      The metatype of the expr.

    lifecycle params:
      var parent : Construct;
      var key : str;
      var value : str;
      var litkey : str = null;
      var line : int = -1;
      var col : int = -1;
    super (parent, key, litkey=litkey, line=line, col=col)
    scope:
      self.valueIs(value)
    end;

    method clone : Attribute #:
      Make a copy of this Attribute.
    params:
      var cloned_parent : Construct #:
        The construct within which the cloned Attribute resides.
    scope:
      cls = self.__class__
      result = cls(
        /# NOTE: For now, we do not copy the Expr value, as it is presumably
        /# read-only. If necessary, we can add Expr.clone().
        cloned_parent, self.key(), self.value(),
        litkey=self.litkey(), line=self.line(), col=self.col())
      return result
    test:
      test.defineAttributes()
      expr2 = test.expr.clone(None)
    end method clone;

    method cacheCompilationResults params:
      var code : str;
      var codetype : str;
    scope:
      self._code = code
      self._codetype = codetype
    end method cacheCompilationResults;

    method getCompilationResults : tuple<str,str> scope:
      return (self._code, self._codetype)
    end method getCompilationResults;

  end class ExprAttribute;

  class TypeAttribute < Attribute #:
    An attribute whose value is a Type.
  scope:

    field value : Type #:
      The type value.
    scope:
      accessor set scope:
        assert value is None or isinstance(value, (Type, TypeWrapper)), (
          'Expecting value of type Type but encountered %s (%s)' %
          (value, value.__class__))
        self._value = value
      end accessor set;
    end field value;

    lifecycle params:
      var parent : Construct;
      var key : str;
      var value : str;
      var litkey : str = null;
      var line : int = -1;
      var col : int = -1;
    super (parent, key, litkey=litkey, line=line, col=col)
    scope:
      self.valueIs(value)
    end;

    method clone : Attribute #:
      Make a copy of this Attribute.
    params:
      var cloned_parent : Construct #:
        The construct within which the cloned Attribute resides.
    scope:
      cls = self.__class__
      result = cls(
        /# We do NOT make a copy of the Type value because Type's are
        /# interned and read-only.
        cloned_parent, self.key(), self.value(),
        litkey=self.litkey(), line=self.line(), col=self.col())
      return result
    test:
      test.defineAttributes()
      type2 = test.type.clone(None)
    end method clone;

  end class TypeAttribute;

  abstract
  class ListAttribute < Attribute #:
    An attribute whose value is a list of strings.
  scope:

    field value : vec<str> #:
      The list of legal words.

    lifecycle params:
      var parent : Construct;
      var key : str;
      var value : str;
      var litkey : str = null;
      var line : int = -1;
      var col : int = -1;
    super (parent, key, litkey=litkey, line=line, col=col)
    scope:
      self.valueIs(value)
    test:

      /# Test an EnumAttribute (a subclass of ListAttribute)
      construct = test.basics()
      enum = metax.c.EnumAttribute(
        construct, 'children', '<field|method|native|category>')
      test.iseqvec(['field', 'method', 'native', 'category'], enum.value())
      enum2 = metax.c.EnumAttribute(
        construct, 'test', ',<a,bc,def>')
      test.iseqvec(['a', 'bc', 'def'], enum2.value())
      test.raises(TypeError, metax.c.EnumAttribute, 'bad', 'blah')
    end;

  end class ListAttribute;

  class EnumAttribute < ListAttribute #:
    An attribute containing a list of words separated by '|' (by default) or
    some other delimiter.  The normal format is <val1|val2|val3>, with
    variants like ,<val1,val2,val3> or #<val1#val2#val3> or ... allowed.

    NOTE: For now, we require the enum value to have no spaces (one word), but
    we may generalize this in the future ... can easily consume chars
    until we get to matching '>'.
  scope:

    method valueIs : EnumAttribute #:
      Set the value of an EnumAttribute
    params:
      var value : any #:
        A string or vec<str> or null.
    scope:
      if value is None:
        /# Attribues are usually created with a null value before the
        /# value is parsed, so we need to handle null.
        pass
      elif isinstance(value, basestring):
        value = EnumAttribute.StrToEnum(value)
      elif isinstance(value, (list, tuple)):
        /# We support tuple so that CreateNewAttribute() can create an
        /# empty attribute of type 'enum' using readonly tuple() instead
        /# of writeable [].  We support list for the general case, but we
        /# may want to make this case a tuple too.
        pass
      else:
        raise TypeError('Invalid EnumAttribute value "%s"' % value)
      self._value = value
      return self
    end method valueIs;

    method clone : Attribute #:
      Make a copy of this Attribute.
    params:
      var cloned_parent : Construct #:
        The construct within which the cloned Attribute resides.
    scope:
      cls = self.__class__
      result = cls(
        /# The value is a list of legal enum values, which we copy.
        cloned_parent, self.key(), self.value()[:],
        litkey=self.litkey(), line=self.line(), col=self.col())
      return result
    test:
      test.defineAttributes()
      enum2 = test.enum.clone(None)
    end method clone;

    meta
    method StrToEnum : vec<str> #:
      Convert a string representation of an enum to a list of str.

      Raises:
        TypeError: if value is invalid
    params:
      var value : str #:
        The string reprsentation of an enum: <val1|val2|val3>, #<val1#val2>, etc.
    scope:
      m = ExprParser.ENUM_RE.match(value)
      if not m:
        raise TypeError('Invalid EnumAttribute value "%s"' % value)
      delim = m.group(1) or '|'
      value = m.group(2).split(delim)
      return value
    test:
      test.iseqvec(
        ['val1', 'val2', 'val3'],
        metax.c.EnumAttribute.StrToEnum('<val1|val2|val3>'))
      test.iseqvec(
        ['val1', 'val2', 'val3'],
        metax.c.EnumAttribute.StrToEnum('#<val1#val2#val3>'))
      /# Test some esoteric enums.
      test.iseqvec(['<'], metax.c.EnumAttribute.StrToEnum('<<>'))
      test.iseqvec(['<<'], metax.c.EnumAttribute.StrToEnum('<<<>'))
      test.iseqvec(['<<<'], metax.c.EnumAttribute.StrToEnum('<<<<>'))
      test.iseqvec(['->'], metax.c.EnumAttribute.StrToEnum('<->>'))
      test.iseqvec(['->:'], metax.c.EnumAttribute.StrToEnum('<->:>'))
    end method StrToEnum;

  end class EnumAttribute;

  class MultiFeatureAttribute < ListAttribute #:
    An attribute that appears before the primary attribute. The feature value is
    a list of strings, each of which comes from a pre-defined set of
    feature-key-specific legal values
  scope:
  end class MultiFeatureAttribute;

  class EndAttribute < Attribute #:
    This is an experiment in reprsenting the termination syntax for a construct
    using an Attribute instead of an integer termcode.  Pros and cons are:
      + allows us to record the line and column of the 'end' syntax.
      - incurs significantly more memory, especially if it is present for
        every single construct.
        # This may be amelioratable by not creating EndAttribute instances
          during parsing, and only doing so during instantiation of templates.
          This requires more effort to find the end-of-construct unless we
          record end-of-construct during parsing (we could encode this inside
          termcode!)

    Things to do:
     - Modify (at least) the MethodConstruct templates to introduce an ${end}
       variable that stores an empty string and an instance of EndAttribute.
     - Provide a mechanism for establishing the line number within meta source
       code of the end of a construct (either the explicit 'end ...;' or ';',
       or from implicit analysis).
       - this can be done heuristically within ExecutableConstruct.translateMeta
         while populating the varset (expensive) or can be made much more
         efficient by encoding line number of end syntax within
         MetaFile.parseSecondaryAttribute() ... for example by packing it within
         termcode.
  scope:
  end class EndAttribute;

  abstract
  class BlockAttribute < Attribute #:
    An attribute whose value is a list.
  scope:

    lifecycle params:
      var parent : Construct;
      var key : str;
      var litkey : str = null;
      var line : int = -1;
      var col : int = -1;
    super (parent, key, litkey=litkey, line=line, col=col)
    scope:
      if key[-1] != ':':
        self.keyIs(key + ':')
    end lifecycle;

    method size : int #:
      Return number of elements in value.
    scope:
      return len(self.value())
    test:
      test.defineAttributes()
      test.iseq(2, test.simple.size())
    end method size;

  end class BlockAttribute;

  class SimpleBlock < BlockAttribute #:
    An attribute whose value is a list of str.
  scope:

    field value : vec<str> #:
      A simple block is an ordered list of lines.

    lifecycle params:
      var parent : Construct;
      var key : str;
      var value : vec<str>;
      var litkey : str = null;
      var line : int = -1;
      var col : int = -1;
    super (parent, key, litkey=litkey, line=line, col=col)
    scope:
      assert key[-1] == ':'
      self.valueIs(value)
    end lifecycle;

    method clone : Attribute #:
      Make a copy of this Attribute.
    params:
      var cloned_parent : Construct #:
        The construct within which the cloned Attribute resides.
    scope:
      cls = self.__class__
      /# We make a copy of the lines in the simple block.
      cloned_value = self.value()[:]
      result = cls(
        cloned_parent, self.key(), cloned_value,
        litkey=self.litkey(), line=self.line(), col=self.col())
      return result
    test:
      test.defineAttributes()
      simple2 = test.simple.clone(None)
    end method clone;

    method valueAsStr : str #:
      Convert value to multi-line string.  Handles special >| notation.
      Always ends with newline.
    scope:
      /# NOTE: The handling of SPECIAL_PREFIX_RE is NOT being done to support
      /# baselang code generation. Rather, it is done to strip off prefixes from
      /# Template bodies, which use the |> syntax for readability. For the
      /# baselang code stripping, see BaseSegment.flattenLines() and the
      /# strip_special param.
      r = metax.c.SPECIAL_PREFIX_RE
      result = '\n'.join([r.sub('', line) for line in self.value()]) + '\n'
      return result
    test:
      test.defineAttributes()

      simple = test.simple
      test.iseqtext(
        'this is a\ntest of a simple block\n',
        simple.valueAsStr())

      return
      simple2 = metax.c.SimpleBlock(
        test.construct, 'scope:',
        ['  >|this is a', '  >|test of a simple block'],
        line=11, col=2)
      test.iseqtext(
        'this is a\ntest of a simple block\n',
        simple2.valueAsStr())
    end method valueAsStr;

  end class SimpleBlock;

  class ComplexBlock < BlockAttribute #:
    An attribute whose value is a list of Contruct.
  scope:

    field value : vec<str> #:
      A complex block is an ordered list of Construct. May be null if the
      value has not yet been initialized.
      See the _map field for a per-id mapping.

    field map : @map #:
      Maps construct keys to Construct instances.  Keys must be unique.

    field postcount : int #:
      The number of blank lines after the last construct within this indent
      level.

    lifecycle params:
      var parent : Construct;
      var key : str;
      var value : vec<Construct>;
      var litkey : str = null;
      var line : int = -1;
      var col : int = -1;
    super (parent, key, litkey=litkey, line=line, col=col)
    scope:
      assert key[-1] == ':'
      self.valueIs(value)
    end lifecycle;

    method clone : Attribute #:
      Make a copy of this Attribute.
    params:
      var cloned_parent : Construct #:
        The construct within which the cloned Attribute resides.
    scope:
      cls = self.__class__

      /# We create the clone with an empty value initially.
      cloned_value = []
      result = cls(
        cloned_parent, self.key(), cloned_value,
        litkey=self.litkey(), line=self.line(), col=self.col())

      /# Now we register cloned versions of every construct within self.value()
      /# into the cloned result.
      for construct in self.value():
        cloned_construct = construct.clone(result)
        result.registerConstruct(cloned_construct)

      /# Update the postcount of the clone.
      result.postcountIs(self.postcount())

      return result
    test:
      test.defineAttributes()
      complex2 = test.complex.clone(None)
    end method clone;

    method cons : Construct #:
      Obtain the construct with given id
    params:
      var id : str #:
        The id of the desired construct.
      var default : any = REQUIRED #:
        What to return if the id does not exist. If metax.c.REQUIRED, raises
        MissingConstruct
        TODO(wmh): Fix the REQUIRED vs metax.c.REQUIRED issued.
    scope:
      result = self._map.get(id, default)
      if result is metax.c.REQUIRED:
        raise MissingConstruct('Failed to find %s within complex block' % id)
      return result
    test:
      /# TODO(wmh): Reading 'ex1' is overkill for this method.
      _, _, _, metalang = test.cachedInfo(metal='meta')
      ex1, scope, _, _ = test.getMetaFile(
        'meta', 'ex1', context=metalang.bootstrapContext())
      cons = scope.cons('Test')
      test.iseq('Test', cons.id())
      test.iseq(None, scope.cons('missing', default=None))
      test.raises(metax.c.MissingConstruct, scope.cons, 'missing')
    end method cons;

    method findIndex : int #:
      Obtain index of given construct within order.
    params:
      var cid : str #:
        The construct id to search for.
    scope:
      cmap = self._map
      if cid not in cmap:
        metafile.error(
          "Attempt to add construct '%s' relative to undefined '%s'" %
          (construct.fqn(), cid))
        result = -1
      else:
        construct = cmap[cid]
        result = self._value.index(construct)
      return result
    test:
    end method findIndex;

    method registerConstruct #:
      Add a construct to this block.
    params:
      var construct : Construct #:
        The construct to add.
      var position : str = null #:
        The name of some construct in the new parent preceeded by '+'
        (insert after) or '-' (insert before).  If the position is '+' or
        null, insert at end.  If the position is '-', insert at beginning.
      var postcount : int = 0 #:
        Number of empty lines to insert after this construct in output stream.
        This is implemented as an adjustment on the precount of the next
        construct (or, if at the last construct, an adjustment on the
        postcount of the block). Note that the adjustment postcount of block
        is fragile in the face of subsequent insertions at the end, which
        may not have wanted extra lines inserted after.
    scope:
      /# The construct into which we want to register
      parent = self.parent()
      /# The parent the construct is currently registered within
      existing_parent = construct.parent()
      /# Where to write errors, etc.
      metafile = construct.metafile()

      register_in_metafile = True

      /# print 'registerConstruct: %s and %s' % (construct.kindfqn(), parent.kindfqn() if parent else None)
      is_namespace = isinstance(construct, NamespaceConstruct)

      if is_namespace:
        /# print 'Registering namespace %s in %s' % (construct.id(), parent.kindfqn())
        pass

      if existing_parent:
        if existing_parent is not self:
          print (
            'ERROR: Attempting to register %s within %s when it is already '
            'registered within %s' %
            (construct.kindid(),
             parent.path() if parent else ' unknown parent',
             existing_parent.path()))
          raise Error('here')
      else:
        /# D.parsing.info(
        /#  'Registering %s (%d)' % (construct.path(), id(construct)),
        /#  level=2)
        pass

      cid = construct.id()
      if cid is None:
        print '********** WARNING: Here with %s' % construct.kindid()
        raise Error('Cannot register a construct before id is established')

      cmap = self._map
      value = self._value
      if cid in cmap:
        /# The construct already exists. This is an error unless it is the
        /# same construct.
        if cmap[cid] is construct:
          register_in_metafile = False
        else:
          ppath = '' if parent.kind() == 'File' else parent.path()

          primary = construct.primary()
          current_construct = cmap[cid]
          metafile.error(
            "Attempt to register construct '%s'\n"
            "      when a construct with that id already exists in\n"
            "      %s as %s (%d vs %d)" %
            (construct.kindid(), ppath, current_construct.kindid(),
             id(construct), id(current_construct)),
            line=primary.line() if primary else -1)
      else:
        construct.linkParent(self)

        if position is None or position == '+':
          /# The most common case ... add the construct at the end of the list.
          value.append(construct)
          cmap[cid] = construct

        elif position == '-':
          /# Insert the construct before all others.
          value.insert(0, construct)
          cmap[cid] = construct

        elif position[0] == '+':
          /# We are to insert after the construct identified by position.
          /#  - TODO(wmh): adjust postcount.
          /#    See old code ComplexBlockAttribute.registerConstruct
          index = self.findIndex(position[1:])
          value.insert(index+1, construct)
          cmap[cid] = construct

        elif position[0] == '-':
          /# We are to insert before the construct identified by position.
          /#  - TODO(wmh): adjust postcount.
          /#    See old code ComplexBlockAttribute.registerConstruct
          index = self.findIndex(position[1:])
          value.insert(index, construct)
          cmap[cid] = construct

        else:
          raise Error('Invalid position "%s"' % position)

      if register_in_metafile and metafile:
        metafile.registerConstructInMetaFile(construct)
    test:
    end method registerConstruct;

    method unregisterConstruct #:
      Remove specified construct from myself.
    params:
      var construct : Construct;
    scope:
      cid = construct.id()
      cmap = self._map
      value = self._value
      if cid in cmap:
        del cmap[cid]
        value.remove(construct)

        metafile = construct.context().metafile()
        if metafile:
          metafile.unregisterConstructInMetaFile(construct)

        if construct.parent() is not self:
          raise Error('Something wacked')
        construct.unlinkParent(self)

      else:
        raise Error(
          'Attempt to unregister non-existent %s from %s' %
          (construct.path(), self.keyStr()))
    test:
    end method unregisterConstruct;

    method child : any #:
      Obtain a Construct or Attribute descendent node
    params:
      var spec : str #:
        Format is:
          <term> ::- <id> ['@' <attr> ]
          <spec> ::- <term> | <spec> '/' <term>
      var fp : ostream = null #:
        If non-null, where to write failure information.
    scope:
      parts = spec.split('/')

      if parts[0] == '':
        /# The path is relative to the File construct.
        block = self.parent().metafile().construct().rawattr('scope:')
        parts.pop(0)
      else:
        block = self

      m = len(parts) - 1
      for i, part in enumerate(parts):
        idattr = part.split('@')
        if len(idattr) == 1:
          id = idattr[0]
          attr = None if i == m else 'scope'
        else:
          id, attr = idattr
        construct = block.cons(id, default=None)
        if construct is None:
          result = None
          if fp:
            fp.write('Failed to find child construct %s' % id)
          break
        if attr is None:
          /# This is only allowed for the last part, and is a request
          /# to return the current construct rather than an attribute on
          /# the construct.
          assert i == m
          result = construct
          break
        block = (
          construct.rawattr(attr, default=None)
          or construct.rawattr(attr + ':', default=None))
        if not block:
          result = None
          if fp:
            fp.write('Failed to find attribute %s' % attr)
          break
        result = block

      return result
    test:
      _, _, _, meta = test.cachedInfo(metal='meta')
      ex1, scope, _, _ = test.getMetaFile(
        'meta', 'ex1', context=meta.bootstrapContext())

      for path in (
        '/Test@config/cons@config/presence',
        '/Test@config/cons@config',
      ):
        obj = scope.child(path)
        path2 = obj.path()
        test.iseq(path2, path)
    end method child;

  end class ComplexBlock;

  behavior isBlock #:
    Convenience method for determining if an attribute is a BlockAttribute.
  scope:
    receiver Attribute scope:
      return False

    receiver BlockAttribute scope:
      return True
    test:
      test.defineAttributes()
      test.isfalse(test.feature.isBlock())
      test.istrue(test.simple.isBlock())
      test.istrue(test.complex.isBlock())
    end receiver BlockAttribute;

  end behavior isBlock;

  behavior isSimpleBlock #:
    Convenience method for determining if an attribute is a SimpleBlock
  scope:
    receiver Attribute scope:
      return False

    receiver SimpleBlock scope:
      return True
    test:
      test.defineAttributes()
      test.isfalse(test.complex.isSimpleBlock())
      test.istrue(test.simple.isSimpleBlock())
    end receiver SimpleBlock;

  end behavior isSimpleBlock;

  behavior isComplexBlock #:
    Convenience method for determining if an attribute is a ComplexBlock
  scope:
    receiver Attribute scope:
      return False

    receiver ComplexBlock scope:
      return True
    test:
      test.defineAttributes()
      test.isfalse(test.simple.isComplexBlock())
      test.istrue(test.complex.isComplexBlock())
    end receiver ComplexBlock;

  end behavior isComplexBlock;

  behavior valueStr #:
    A string representation of the value of an Attribute.

    TODO(wmh): Decide if this will stay around or be subsumed by writeValueLines()
     - valueStr() is problematic for values spanning multiple lines
       (e.g. block-valued attributes)
     - valueStr() is less efficient than writeValueLines() since it has to
       form an in-memory string, which then gets written to a stream
     + valueStr() allows us to know how many bytes a value takes up before
       we write it, which can be used in determining whether to add
       line breaks, etc.
  params:
    var mode : map = null #:
      See Construct.write() for details on mode semantics.
  scope:

    receiver Attribute scope:
      raise NotImplementedError

    receiver IdAttribute scope:
      return str(self.value())
    test:
      test.defineAttributes()
      test.iseq('bob', test.id.valueStr())

    receiver NumAttribute scope:
      return str(self.value())
    test:
      test.defineAttributes()
      test.iseq('42', test.num.valueStr())

  end behavior valueStr;

  behavior writeValueLines : int #:
    Write the lines making up the attribute value.

    TODO(wmh): Fix this.  Writing to a stream directly (instead of using
    valueStr() to obtain a value string first) is more efficient, but poses
    problems when we need to know the size of the value string before we
    write it (to determine if newlines need adding, etc.).  I suspect we
    need to move away from writeValueLines to valueStr().

    Returns:
      The number of characters written. If the output contains multiple
      lines, the return value is -1.
  params:
    var fp : ostream = out #:
      Where to write the lines.
    var indent : str = '' #:
      How much to indent each line.
    var mode : map = null #:
      See Construct.write() for details on mode semantics.
  scope:

    receiver Attribute scope:
      /# This is a sensible default that can be used by various subclasses,
      /# but certain subclasses will need to override.
      val = str(self.value())
      fp.write(val)
      return len(val)
    test:
      test.defineAttributes()
      mode = {}
      fp = test.newStr()
      test.iseq(4, test.feature.writeValueLines(fp=fp, indent='..', mode=mode))
      fp.write('\n')
      test.iseq(3, test.id.writeValueLines(fp=fp, indent='..', mode=mode))
      fp.write('\n')
      test.iseq(2, test.num.writeValueLines(fp=fp, indent='..', mode=mode))
      fp.write('\n')
      test.iseqmap('male\nbob\n42\n', fp.getvalue())

    receiver FeatureAttribute scope:
      val = str(self.value())
      if mode.get('form', 'code') == 'html':
        val = '<span class="face-featval">%s</span>' % val
      fp.write(val)
      return len(val)
    test:
      test.defineAttributes()

      fp = test.fp()
      test.iseq(
        4, test.feature.writeValueLines(fp=fp, mode={}))
      test.iseq('male', test.out())

      fp = test.fp()
      test.iseq(
        38, test.feature.writeValueLines(fp=fp, mode={'form': 'html'}))
      test.iseq('<span class="face-featval">male</span>', test.out())
    end;

    receiver WordAttribute scope:
      val = str(self.value())
      if mode.get('form', 'code') == 'html':
        val = HtmlSafe(val)
      fp.write(val)
      return len(val)
    test:
      test.defineAttributes()
      fp = test.fp()
      test.iseq(
        9, test.word.writeValueLines(fp=fp, indent='..', mode={}))
      test.iseq('<special>', test.out())

      fp = test.fp()
      test.iseq(
        15,
        test.word.writeValueLines(fp=fp, indent='..', mode={'form': 'html'}))
      test.iseq('&lt;special&gt;', test.out())

    receiver ExprAttribute scope:
      val = self.value().text()
      fp.write(val)
      return len(val)
    test:
      test.defineAttributes()
      fp = test.newStr()
      test.iseq(16, test.expr.writeValueLines(fp=fp, indent='..'))
      test.iseq('"this is a test"', fp.getvalue())

    receiver EnumAttribute scope:
      val = '<%s>' % '|'.join(self.value())
      fp.write(val)
      return len(val)
    test:
      test.defineAttributes()
      fp = test.newStr()
      test.iseq(24, test.enum.writeValueLines(fp=fp, indent='..'))
      test.iseq('<apple|banana|cantelope>', fp.getvalue())

    receiver TypeAttribute scope:
      val = self.value().raw()
      if mode.get('form', 'code') == 'html':
        val = HtmlSafe(val)
      fp.write(val)
      return len(val)
    test:
      test.defineAttributes()
      fp = test.newStr()
      test.iseq(8, test.type.writeValueLines(fp=fp, indent='..', mode={}))
      test.iseq('vec<str>', fp.getvalue())

    receiver SimpleBlock scope:
      form = mode.get('form', 'code')
      ishtml = form == 'html'
      construct = self.parent()
      context = construct.context()

      /# Block always starts on new line.
      fp.write('\n')

      /# If this is html, we insert a special control line at start and end.
      if ishtml:
        basel = self.basel() or '?'
        attrkey = self.key()
        block_uid = self.htmlId()
        control_line = (
          ' simple %s %s %s %s ' %
          (construct.kind(), block_uid, self.key(), basel))
        fp.write(control_line + 'start\n')

      blockdent = context.token('blockdent')
      indent += ' ' * blockdent
      for line in self.value():
        if line.strip():
          /# The line isn't empty
          fp.write(indent + line + '\n')
        else:
          /# The line is empty. We don't add indent either.
          fp.write('\n')

      if ishtml:
        fp.write(control_line + 'end\n')

      return -1
    test:
      test.defineAttributes()
      fp = test.newStr()
      test.simple.writeValueLines(fp=fp, indent='..', mode={})
      out = fp.getvalue()
      test.iseqtext(
        '\n'
        '..  this is a\n'
        '..  test of a simple block\n',
        out)

    receiver ComplexBlock scope:
      parent = self.parent()
      blockdent = parent.context().token('blockdent') if parent else 2
      subdent = indent + (' ' * blockdent)

      /# The value of a complex block (for now) always starts on a new line.
      fp.write('\n')
      for construct in self.value():
        construct.write(fp=fp, indent=subdent, mode=mode)

      /# postcount records how many empty lines exist after the last construct
      /# in the block.
      for i in range(0, self.postcount()):
        fp.write('\n')

      return -1
    test:
      test.defineAttributes()
      fp = test.newStr()
      test.complex.writeValueLines(fp=fp, indent='..')
      /# Add some constructs to the complex block to test this properly.
      test.iseqtext(
        '\n',
        fp.getvalue())

      _, _, _, meta = test.cachedInfo(metal='meta')
      metafile, scope, _, _ = test.getMetaFile(
        'meta', 'ex1', context=meta.bootstrapContext())
      fp = test.newStr()
      scope.writeValueLines(fp=fp, indent='..')
      test.iseqtext("""
        >|..  MetaLanguage Test name Test parent Meta toplevel <test> #:
        >|..    THIS FILE SHOULD STAY FROZEN (it is used verbatim by unittests)
        >|..  config:
        >|
        >|..    Construct cons config:
        >|..      feature Attribute presence : <abstract|concrete> = concrete;
        >|..      primary Attribute cons : id = <required>;
        >|..      secondary Attribute parent : xid = <empty>;
        >|..    end Construct;
        >|
        >|..    Construct attr config:
        >|..      feature Attribute kind : <undef|feature|primary|secondary> = undef #:
        >|..        There are three kinds of attributes, feature, primary and secondary.
        >|..      primary Attribute attr : id = <required> #:
        >|..        The canonical name of the attribute.
        >|..      secondary Attribute comment: : simple = <empty> aliases <#:> #:
        >|..        A description of the attribute.
        >|..    end Construct;
        >|
        >|..  end MetaLanguage Test;
        >|""",
        fp.getvalue())

  end behavior writeValueLines;

  class Construct #:
    Abstract root class of the Construct hierarchy.  Each instance represents
    the parsed representation of a syntactic construct obtained from a
    user-provided meta file (or auto-generated internally).
  assocs:
    std assoc re;
    std assoc cStringIO;
  scope:

    ro
    field id : str #:
      An identifier by which this construct can be uniquely identified among
      all other constructs within the same parent ComplexBlock.

    field parent : ComplexBlock #:
      The complex block within which this construct resides.
    scope:
      accessor set scope:
        if value is not None and not isinstance(value, ComplexBlock):
          raise Error('Construct.parentIs with %s (%s)' % (value, value.__class__))
        self._parent = value

    field context : Context #:
      The context within which this construct appears. The Context provides
      access to the MetaFile and everything else needed to parse, expand
      and compile a construct.

    field order : @vec<Attribute> #:
      The collection of Attribute instances making up this Construct, in
      the order they appear in the source. Important when providing
      construct canonicalization.

    field attributes : @map<str,Attribute> #:
      Maps attribute key (or abbrev) to Attribute instance. Note that
      Attribute instances store their canonical key but do NOT store the
      actual key/abbrev seen in the source (that key/abbrev is what is
      used as the key in this attributes field).

    field terminator : int = 0 #:
      A field within which termcode and termline are encoded.
      TODO(wmh): When packed semantics is available, we will not need to
      define an explicit field for terminator, and can instead just define
      fields termcode and termline.

    field termcode : int = TERM_UNINIT #:
      Encodes how this construct was terminated:
        0 (or TERM_UNINIT) = implicit (no terminator specified)
        1 = ';'
        3 = 'end;'
        7 = 'end <cons>;'
       11 = 'end <id>;'
       15 = 'end <cons> <id>;'
       16+= uninitialized

      The above values are based on the following bit mask semantics:
        bit 0 = 0x1 = ';'
        bit 1 = 0x2 = 'end'
        bit 2 = 0x4 = <cons>
        bit 3 = 0x8 = <id>
      where bit i cannot be set unless all bits less than i are also set
      (although this last part isn't really necessary ... maybe we want
      to allow <id> to be present without allow <cons> to be present?)

      TODO(wmh): Pack this field
    end field termcode;

    field precount : int = 0 #:
      How many empty lines appear before this construct in the source file.
      TODO(wmh): Pack this field

    field autogen : bool #:
      Set to true if this construct was auto-generated.
      TODO(wmh): Make this an optional field or a packed field!

    field metadata : map #:
      A collection of key/value pairs representing information that not
      every instance will need to maintain. Some keys include:
        masked: Construct (if not present, is not replaced ... i.e. is active)
          If present, it indicates that this construct should be ignored
          in most situations (especially compilation), as the construct
          is subsumed by the construct stored in the value.  For example,
          when a class within a namespaces 'tests' block is moved into
          the test namespace, the original construct is marked as masked.
        masks: Construct (if not present, doesn't mask anyting)
          Indicates that this construct replaces the construct stored in
          the value. If this is set, the construct was auto-generated.
        auto: bool (if not present, false)
          True if this construct was auto-generated (not user-provided)

      TOOD(wmh): This field is not currently being used in meta2. Consider
      whether it should be used or deleted.
    end field metadata;

    lifecycle params:
      var uid -> id;
      var parent -> parent;
      var context -> context;
      var precount -> precount = 0;
    scope:
      /# IMPORTANT: Subclasses (e.g. NamespaceConstruct) rely on this
      /# constructor NOT registering the id ... they may need to change it.
      if not isinstance(self, MetaLanguageConstruct):
        assert context is not None, 'Construct %s has null context' % uid

      /#if self.kind() == 'class':
      /#  print 'CREATING %s (%s)' % (uid, id(self))

    end;

    method kindid : str #:
      The kind and id of this construct.
    scope:
      return self.kind() + ' ' + self.id()
    test:
      construct = test.basics()
      test.iseq('class Person', construct.kindid())
    end method kindid;

    method kindfqn : str #:
      The kind and fqn of this construct.
    scope:
      return self.kind() + ' ' + self.fqn()
    test:
      construct = test.basics()
      test.iseq('class nm.sp.Person', construct.kindfqn())
    end method kindfqn;

    method metafile : MetaFile #:
      Obtain the metafile that this construct resides within.
    scope:
      return self._context._metafile
    test:
      construct = test.basics()
      test.issame(test.metafile, construct.metafile())
    end method metafile;

    method compiler : Compiler #:
      Obtain the compiler instance.
    scope:
      /# This is available via either metafile.compiler() or context.compiler().
      return self._context._compiler
    end method compiler;

    method metalang : MetaLanguageConstruct #:
      Obtain the current metalang.
    scope:
      return self._context._compiler._metalang
    test:
    end method metalang;

    method baselang : BaseLanguage #:
      Obtain the current baselang.
    scope:
      return self._context._compiler._baselang
    test:
    end method baselang;

    method primary : Attribute #:
      The primary attribute for this construct.
    scope:
      return self._attributes.get(self.kind(), None)
    test:
    end method primary;

    method clone : Construct #:
      Make a copy of this construct that shares no instrinsic state with its
      prototype (but does share extrinsic state)
    params:
      var cloned_parent : ComplexBlock #:
        The ComplexBlock within which the cloned version of self resides.
    scope:
      cls = self.__class__
      result = cls(
        self.id(), cloned_parent, self.context(), precount=self.precount())
      for attribute in self.order():
        cloned_attribute = attribute.clone(result)
        result.registerAttribute(cloned_attribute)
      result.termcodeIs(self.termcode())
      return result
    test:
      _, _, _, meta = test.cachedInfo(metal='meta')
      ex1, _, construct, _ = test.getMetaFile(
        'meta', 'ex1', context=meta.bootstrapContext())
      clone = construct.clone(None)
      construct.verifyClone(clone)
    end method clone;

    method verifyClone #:
      Verify that a clone is correct (different where it should be different,
      and the same where it should be the same).

      Raises:
        Error: If the clone does not match expectations.
    params:
      var clone : Construct #:
        An instance returned by self.clone().
    scope:
      construct = self
      construct2 = clone

      r = re.compile(r'(\[\d+\])')

      def StripNum(ln):
        m = r.search(ln)
        if m:
          num = m.group(1)
          result = ln[:m.start(0)] + ln[m.end(0):]
        else:
          result = ln
          num = None
        return (result, num)

      def NewStr():
        return cStringIO.StringIO()

      assert construct is not construct2

      /# Verify the string representations are identical.
      fp = NewStr()
      construct.write(fp=fp)
      fp2 = NewStr()
      construct2.write(fp=fp2)
      assert fp.getvalue() == fp2.getvalue()

      /# Now verify that all attributes different.
      mode = {'pkey': 'user+', 'fkey': 'user+', 'skey': 'user+'}
      fp = NewStr()
      construct.write(fp=fp, mode=mode)
      out = fp.getvalue()
      fp2 = NewStr()
      construct2.write(fp=fp2, mode=mode)
      out2 = fp2.getvalue()

      /# We parse each line of out and out2 in parallel, stripping out [\d+]
      /# chunks and verifying that the numbers differ but the resulting lines
      /# match.
      lines = out.split('\n')
      lines2 = out2.split('\n')
      assert len(lines) == len(lines2)
      for i in range(0, len(lines)):
        line = lines[i]
        line2 = lines2[i]

        /# We remove successive [<num>] text from both line and line2, verifying
        /# that <num> and <num2> are different.
        while True:
          line, num = StripNum(line)
          line2, num2 = StripNum(line2)
          if num is not None:
            assert num != num2
          else:
            assert num2 is None
            break
        /# After removing all the [<num>] blocks, the lines should be identical.
        assert line == line2
    test:
      /# This is a test method in its own right, but has been exposed at
      /# user level so we can verify an arbitrary construct whenever we need to.
      /# As a test method, it doesn't have a test of its own.
      pass
    end method verifyClone;

    meta
    method NewFromData : Construct #:
      Create a new construct from provided data.
    params:
      var id : str;
      var context : Context;
      var parent : ComplexBlock = null #:
        The block this contruct is being added to. Note that this may be null
        (caller responsibility to register as desired). Note also that
        registration happens at end of method if parent provided.
      var features : vec<tuple<str,str>> = null #:
        Key/value[/line] tuples for feature attributes.
      var secondaries : vec<tuple<str,any>> = null #:
        Key/value[/line] tuples pairs for secondary attributes. The values must
        be of the proper type (e.g. if the type is 'type', the value must be a
        Type, not a str), or can also be Attribute subclass instances
        wrapping the proper value type (thus, 'scope:' can either be a
        list of strings or a SimpleBlock, 'params:' can be a ComplexBlock, etc.
      var precount : precount = 0 #:
        How many empty lines appear before this construct in the source file.
      var termcode : int = 15;
      var position : str = null #:
        The name of some construct in the new parent preceeded by '+'
        (insert after) or '-' (insert before).  If the position is '+' or
        null, insert at end.  If the position is '-', insert at beginning.
      var primary_line : int = -1 #:
        The line number of the primary token in the .meta file.
    scope:
      /# We reordered context and parent so this verifies things.
      assert isinstance(context, Context)

      /# Create the construct.
      construct = cls(id, parent, context, precount=precount)
      consinfo = construct.consinfo()
      if consinfo is None:
        raise Error(
          'Construct %s is not legal in given context' % construct.kind())
      metafile = construct.metafile()

      /# Create the feature attributes
      if features:
        if not isinstance(features, list):
          raise Error('features must be list of tuples, not %s' % str(features))
        legalfeatures = consinfo.features()
        for ftup in features:
          fkey = ftup[0]
          fval = ftup[1]
          line = ftup[2] if len(ftup) > 2 else -1
          /# TODO(wmh): Validate that fkey and fval are legal!
          /# TODO(wmh): Need to set line and col correctly for each attribute!
          /# By passing litkey='', we are indicating that the feature key is
          /# not to be shown explicitly.
          feature = FeatureAttribute(construct, fkey, fval, litkey='', line=line)
          construct.registerAttribute(feature)

      /# Create the primary attribute
      /#  - we pass None into CreateNewAttribute() for parent to indicatee
      /#    primary, then set it afterward.
      priminfo = consinfo.primary()
      primary = MetaFile.CreateNewAttribute(
        None, consinfo, construct.kind(), value=id, metafile=metafile,
        line=primary_line)
      primary.parentIs(construct)
      construct.registerAttribute(primary)

      /# Create the secondary attributes
      if secondaries:
        if not isinstance(secondaries, list):
          raise Error('secondaries must be list of tuples, not %s' % str(secondaries))
        legalseconds = consinfo.secondaries()
        for stup in secondaries:
          skey = stup[0]
          sval = stup[1]
          line = stup[2] if len(stup) > 2 else -1
          if sval is None:
            /# An indication that this secondary is to not be generated at
            /# all.  Useful when forming the tuples passed in as secondaries
            /# from code that may or may not produce null values ... avoids
            /# caller having to do checks.

            /# print '**** WARNING: IGNORING %s (None) within %s' % (skey, construct.kindfqn())
            continue
          elif isinstance(sval, Attribute):
            secondary = sval
            if len(stup) > 2:
              secondary.lineIs(line)
          else:
            secondary = MetaFile.CreateNewAttribute(
              construct, consinfo, skey, value=sval, metafile=metafile, line=line)
          construct.registerAttribute(secondary)

      construct.termcodeIs(termcode)
      construct.autogenIs(True)

      /# We intentionally register with parent at end of method so that there
      /# is little diff between doing it within this method or within the
      /# caller afterward.
      /#  - it is possible that early registration will be needed for something
      /#    but hopefully not.
      if parent:
        parent.registerConstruct(construct, position=position)
        consparent = parent.parent()
        if consparent and consparent.kind() == 'class':
          construct.myclassIs(consparent)
      elif position:
        raise Error('Specified position "%s" without parent' % position)

      return construct
    test:
      _, _, context, _ = self.cachedInfo()

      file_construct = metax.c.FileConstruct.NewFromData(
        'cards1.meta', context,
        secondaries=[('scope:', [])])

      namespace_construct = metax.c.NamespaceConstruct.NewFromData(
        'cards1.meta', context, parent=file_construct.rawattr('scope:'),
        secondaries=[
          ('comment:', ['Playing cards.']),
          ('scope:', []),
        ])

      class_construct = metax.c.ClassConstruct.NewFromData(
        'Card', context, parent=namespace_construct.rawattr('scope:'),
        features=[('visibility', 'public')],
        secondaries=[
          ('<', 'metax.root.Object'),
          ('#:', [
            'A card with suit and rank, belonging to a Deck.',
            '',
            'The Deck is responsible for display functionality.']),
          ('scope:', []),
        ])

      fp = test.newStr()
      file_construct.write(fp=fp)
      out = fp.getvalue()
      test.iseqtext(
        'File cards1.meta scope:\n'
        '  namespace cards1.meta comment:\n'
        '    Playing cards.\n'
        '  scope:\n'
        '    public class Card < metax.root.Object #:\n'
        '      A card with suit and rank, belonging to a Deck.\n'
        '\n'
        '      The Deck is responsible for display functionality.\n'
        '    scope:\n'
        '    end class Card;\n'
        '  end namespace cards1.meta;\n'
        'end File cards1.meta;\n',
        out)
    end method NewFromData;

    method rawattr : Attribute #:
      Obtain the attribute with given key.

      This does not perform any baselang-specific logic ... use attr() for that.
    params:
      var key : str #:
        The attribute key.
      var default : any = REQUIRED #:
        The value to return if the key isn't present. If metax.c.REQUIRED, raises
        MissingAttribute error.
        TODO(wmh): Fix the REQUIRED vs metax.c.REQUIRED issue.
    scope:
      result = self._attributes.get(key, default)
      if result is metax.c.REQUIRED:
        raise MissingAttribute(
          'rawattr: On %s failed to find required rawattr("%s")' % (self.kindid(), key))
      return result
    test:
      construct = test.defineConstructs()
      test.iseq('male', construct.rawattr('gender').value())
      test.isnull(construct.rawattr('missing', default=None))
      test.raises(metax.c.MissingAttribute, construct.rawattr, 'missing')
    end method rawattr;

    method rawval : any #:
      Obtain the value of an attribute with a given key.

      This does not perform any baselang-specific logic ... use attrval() for
      that.
    params:
      var key : str #:
        The attribute key.
      var default : any = REQUIRED #:
        The value to return if the attribute isn't present.
        If metax.c.REQUIRED, raises MissingAttribute error.
        TODO(wmh): Fix the REQUIRED vs metax.c.REQUIRED issue.
    scope:
      attribute = self._attributes.get(key, None)
      if attribute is None:
        if default is metax.c.REQUIRED:
          raise MissingAttribute(
            'rawval: On %s failed to find required rawattr("%s")' %
            (self.kindid(), key))
        else:
          result = default
      else:
        result = attribute.value()
      return result
    test:
      construct = test.defineConstructs()
      test.iseq('male', construct.rawval('gender'))
      test.isnull(construct.rawval('missing', default=None))
      test.raises(metax.c.MissingAttribute, construct.rawval, 'missing')
    end method rawval;

    method consinfo : ConsInfo #:
      Obtain the consinfo for this construct.
    scope:
      return self.context().consinfo(self.kind())
    test:
    end method consinfo;

    method attrinfo : info #:
      Obtain the attribute info for a given key.
    params:
      var key : str #:
        The attribute key (or alias) that info is desired for
    scope:
      res = self.context().attrinfo(self.kind(), key)
      if res[0] is None:
        raise Error('Failed to find key %s in %s' % (key, self.kind()))
      return res
    end method attrinfo;

    method attrpair : tuple<Attribute,any> #:
      Obtain the attribute with given key and its value.

      Supports LOOKUP, EMPTY and REQUIRED semantics.
    params:
      var key : str #:
        The attribute key.
      var default : any = REQUIRED #:
        The value to return for the attribute if the key isn't present.
        - if None, returns None for attr and value.
        - if metax.c.REQUIRED, raises MissingAttribute error.
        - if metax.c.LOOKUP, we perform lookup in the lexical context chain.
           - it is inefficient to make this the default (more efficient to
             use EMPTY or REQUIRED where they are valid).
        - if metax.c.EMPTY, create a new Attribute with empty value.
           - when an actual attribute is not needed if not present, it is best
             to pass in None instead of EMPTY.
        - else, it must be an Attribute instance (rarely the case)
    scope:
      /# TODO(wmh): Fix the REQUIRED vs metax.c.REQUIRED issue.
      attr = self.rawattr(key, default=None)
      if attr is None:
        /# No explicit value ... 'default' tells us what to do in this case.
        if default is metax.c.LOOKUP:
          info, _ = self.attrinfo(key)
          attr = info['attribute']
          /# TODO(wmh): Should 'attr' be cloned!!!??
          if attr is None:
            /# We've encountered an attr that should never be found during
            /# lookup.
            self.metafile().error(
              'Failed to find attribute "%s"' % key,
              line=self.primary().line())
            /#print info
            /#raise Error(
            /#  'Here with attr %s : %s in %s' %
            /#  (key, info['type'], self.kindid()))
        elif default is metax.c.EMPTY:
          /# NOTE(wmh): This is a variant of code in ConsInfo.registerSecondary()
          attrinfo, consinfo = self.attrinfo(key)
          func = MetaFile.AttrValueEmpty[attrinfo['type']]
          try:
            value = func()
            /# TODO(wmh): Instead of creating a new Attribute every time, we
            /# could maintain the empty Attribute instances in ConsInfo. The
            /# 'attribute' key in ConsInfo dicts could then use this 'empty'
            /# instance as well, which would remove the code redundancy between
            /# here and ConsInfo.registerSecondary. Alternative, we can just be
            /# careful about using metax.c.EMPTY ... only when truly needed.

            /# print '****** HERE with key %s type %s value %s'  % (key, attrinfo['type'], str(value))
            attr = MetaFile.CreateNewAttribute(
              self, consinfo, key, key=key, value=value, typecheck=False,
              /# Not necessary since we are passing in parent, but that may
              /# change in the future in which case secondary must be set true
              secondary=True)
          except InvalidAttributeType as e:
            raise MissingAttribute(
              '*** Failed to find empty value for %s in %s (%s)' % (
                key, self.kindid(), str(e)))
        elif default is metax.c.REQUIRED:
          raise MissingAttribute(
            'Failed to find %s in %s' % (key, self.kindid()))
        else:
          attr = default

      /# TODO(wmh): If attr was found via LOOKUP, consider returning None
      /# for attr (but keeping the value as-is). This signals the caller that
      /# the attr cannot be used to form a meta-line number, so the caller
      /# can use some other attribute (e.g. primary) instead.
      return (attr, attr.value() if attr else None)
    test:
      cards1, scope, namespace, path = test.getMetaFile(
        'oopl', 'cards1', debuglevel=0)

      card = namespace.child('Card')
      deck = namespace.child('Deck')

      IGNORE = object()

      def Chk(pair, cls=IGNORE, attr=IGNORE, key=IGNORE, value=IGNORE, head=IGNORE):
        actual_attr, attrvalue = pair
        if cls is not IGNORE:
          test.isinst(actual_attr, cls)
        if attr is not IGNORE:
          test.iseq(attr, actual_attr)
        if key is not IGNORE:
          test.iseq(key, actual_attr.key())
        if head is not IGNORE:
          attrvalue = attrvalue[:head]
        if value is not IGNORE:
          test.iseq(value, attrvalue)

      /# A feature attribute that exists in the source.
      Chk(
        card.attrpair('visibility'),
        cls=metax.c.FeatureAttribute, key='visibility', value='public')
      /# A feature attribute that does not exist in source: None
      Chk(
        card.attrpair('presence', default=None),
        attr=None, value=None)
      /# A feature attribute that does not exist in source: LOOKUP.
      Chk(
        card.attrpair('presence', default=metax.c.LOOKUP),
        cls=metax.c.FeatureAttribute, key='presence', value='concrete')
      /# A feature attribute that does not exist in source: EMPTY
      test.raises(
        metax.c.MissingAttribute,
        card.attrpair, 'presence', default=metax.c.EMPTY)
      /# A feature attribute that does not exist in source: REQUIRED
      test.raises(
        metax.c.MissingAttribute,
        card.attrpair, 'presence', default=metax.c.REQUIRED)


      /# A non-block attribute that exists in the source.
      Chk(
        card.attrpair('parent'),
        cls=metax.c.WordAttribute, key='parent', value='metax.root.Object')
      /# A non-block attribute that does not exist in the source: None
      Chk(
        card.attrpair('testparent', default=None),
        attr=None, value=None)
      /# A non-block attribute that does not exist in the source: LOOKUP
      Chk(
        card.attrpair('testparent', default=metax.c.LOOKUP),
        cls=metax.c.WordAttribute, key='testparent', value='<special>')
      /# A non-block attribute that does not exist in the source: EMPTY
      Chk(
        card.attrpair('testparent', default=metax.c.EMPTY),
        cls=metax.c.WordAttribute, key='testparent', value='')
      /# A non-block attribute that does not exist in the source: REQUIRED
      test.raises(
        metax.c.MissingAttribute,
        card.attrpair, 'testparent', default=metax.c.REQUIRED)


      /# An block-valued attribute that exists in the source.
      Chk(
        namespace.attrpair('comment:'),
        cls=metax.c.SimpleBlock, key='comment:',
        value=['Playing cards.', 'CONTENTS TESTED IN UNITTEST. DO NOT MODIFY.'])
      /# A block-valued attribute that does not exist in source: None
      Chk(
        namespace.attrpair('preports:', default=None),
        attr=None, value=None)
      /# A block-valued attribute that does not exist in source: EMPTY
      Chk(
        namespace.attrpair('preports:', default=metax.c.EMPTY),
        cls=metax.c.SimpleBlock, value=tuple())
      /# A block-valued attribute that does not exist in source: LOOKUP
      Chk(
        namespace.attrpair('preports:', default=metax.c.LOOKUP),
        cls=metax.c.SimpleBlock, value=tuple())
      /# A block-valued attribute that does not exist in source: REQUIRED
      test.raises(
        metax.c.MissingAttribute,
        namespace.attrpair, 'preports:', default=metax.c.REQUIRED)

    end method attrpair;

    method attrval : any #:
      Obtain the value of an attribute with a given key.
    params:
      var key : str #:
        The attribute key.
      var default : any = LOOKUP #:
        The value to return if the attribute isn't present.
        If metax.c.REQUIRED, raises MissingAttribute error.
        TODO(wmh): Fix the REQUIRED vs metax.c.REQUIRED issue.
    scope:
      attr, value = self.attrpair(key, default=default)
      return value
    test:
      construct = test.defineConstructs()
      test.iseq('male', construct.attrval('gender'))
    end method attrval;

    method attr : tuple<Attribute,any> #:
      Obtain the attribute given a key.
    params:
      var key : str #:
        The attribute key.
      var default : any = LOOKUP #:
        TODO(wmh): Change from LOOKUP to REQUIRED?
        The value to return if the attribute isn't present.
        If metax.c.REQUIRED, raises MissingAttribute error.
        TODO(wmh): Fix the REQUIRED vs metax.c.REQUIRED issue.
    scope:
      attr, value = self.attrpair(key, default=default)
      return attr
    test:
      construct = test.defineConstructs()
      test.iseq('male', construct.attr('gender').value())
    end method attr;

    method allpairs : map #:
      Obtain all key/value pairs.
    params:
      var stripcolon : bool = false #:
        If true, remove the colon from block-valued keys. Note that if the
        construct has two different attribute keys that differ only in colon,
        one will tromp the other.
      var simpletext : bool = false #:
        If True, simple block values are converted to multi-line strings.
      var ignore : vec<str> = null #:
        Keys to ignore.
    scope:
      result = {}
      for attribute in self.order():
        key = attribute.key()
        if ignore and key in ignore: continue

        /#isfeat = isinstance(attribute, metax.c.FeatureAttribute)
        /#isprim = key == self.kind()

        value = attribute.value()
        if isinstance(value, metax.c.Expr):
          vkind = value.kind()
          if vkind == 'str':
            value = value.value()[1:-1]
          else:
            /# TODO(wmh): May need to perform additional special-casing based
            /# on vkind.
            value = value.value()
        elif attribute.isComplexBlock():
          constructs = value
          value = []
          for construct in constructs:
            value.append(construct.allpairs(stripcolon=stripcolon, simpletext=simpletext))
        elif attribute.isSimpleBlock():
          if simpletext:
            value = '\n'.join(value) + '\n'

        if stripcolon:
          if key[-1] == ':':
            key = key[:-1]

        result[key] = value
      return result
    test:
    end method allpairs;

    method parentConstruct : Construct #:
      Obtain parent construct.
    scope:
      parent_block = self.parent()
      parent_construct = parent_block.parent() if parent_block else None
      return parent_construct
    test:
      construct = test.defineConstructs()
      test.iseq('namespace nm.sp', construct.parentConstruct().kindid())
    end method parentConstruct;

    method child : any #:
      Obtain a Construct or Attribute descendent node
    params:
      var spec : str #:
        Format is:
          <term> ::- <id> ['@' <attr> ]
          <spec> ::- <term> | <spec> '/' <term>
      var fp : ostream = null #:
        If non-null, where to write failure information.
      var attr : str = 'scope:' #:
        Which complex-block attribute of self to start in.
    scope:
      block = self.attr(attr, default=None)
      if block is None:
        result = None
      else:
        result = block.child(spec, fp=fp)
      return result
    test:
    end method child;

    method ancestor : Construct #:
      Obtain the nearest ancestor construct of a given kind.
    params:
      var kind : str #:
        The kind of the ancestor construct desired.
      var proper : bool = true #:
        If true, do not consider self. If false, do consider self.
    scope:
      target = self.parent().parent() if proper else self
      if isinstance(kind, re._pattern_type):
        while target and not kind.search(target.kind()):
          target = target.parentConstruct()
      else:
        while target and target.kind() != kind:
          target = target.parentConstruct()
      return target
    test:
      construct = test.defineConstructs()
      /# construct.write()
      test.iseq('namespace nm.sp', construct.ancestor('namespace').kindid())
      test.iseq('File a.meta', construct.ancestor('File').kindid())
      test.isnull(construct.ancestor('method'))
    end method ancestor;

    method registerAttribute : any #:
      Register an attribute with this construct, maintaining order.
    params:
      var attribute : Attribute #:
        The attribute to register.
      var position : str = null #:
        A string that starts with '+' or '-' followed optionally by the name of
        a pre-existing attribute key within the construct. If the position is
        '+' or null, insert at end. If the position is '-', insert at beginning.
        Otherwise, insert before (if first char is '-') or after (if first char
        is '+') the attribute key identified by position.
    scope:
      key = attribute.key()
      if attribute.isBlock():
        assert key[-1] == ':'

      /# If the attribute has a baselang selector, we need to encode the basel
      /# in the key so that multiple baselangs can be stored together.
      /#  - we do NOT use attribute.litkey() because that might contain
      /#    an alias followed by a baselang selector, when we always want
      /#    the canonical key and baselang selector.
      /#  - we don't both to try to insert the baselang selector before the
      /#    final ':' (for block-valued attributes), nor do we use the <>
      /#    syntax ... we just add ':' + basel to the end of the canonical
      /#    key.
      basel = attribute.basel()
      key2 = None
      if basel:
        cankey = key
        key += '.' + basel
        /# By adding 'attribute' to _attributes at key 'key', we ensure that
        /# we can maintain multiple baselangs for the same key.  However, when
        /# expanding and translating, we only care about attributes associated
        /# with a specific baselang. When code invokes Construct.attr(key),
        /# it is a request to find the baselang-specific attribute with
        /# canonical key 'key', but we store baselang-specific attributes
        /# using the non-canonical key. When resolving baselang-specific
        /# attributes, the order is always:
        /#    scope<py>:
        /#  before
        /#    scope<*>:
        /#  before
        /#    scope:
        /#
        /# We also introduce a rule that 'scope:' cannot appear explicitly if
        /# either of 'scope<xx>:' or 'scope<*>:' appears explicitly. By doing
        /# so, we can, here in registerAttribute, always ensure that the
        /# canonical key exists in a construct if the baselang-specific key
        /# is introduced, by checking basel against self.baselang().suffix().
        baselang = self.baselang()
        if baselang and baselang.hasSuffix(basel):
          if cankey in self._attributes:
            self.metafile().error(
              'Cannot specify both %s and %s in same construct' %
              (cankey, attribute.litkey()))
          else:
            /# We should add cankey to _attributes too.
            key2 = cankey

      if key in self._attributes:
        self.metafile().error(
          'Found duplicate key %s in %s' % (key, self.kindid()),
          line=attribute.line())
        attribute = None
      else:
        /# Register the attribute in the specified key(s).
        self._attributes[key] = attribute
        if key2:
          self._attributes[key2] = attribute

        order = self._order
        if position is None or position == '+':
          order.append(attribute)

        elif position == '-':
          order.insert(0, attribute)

        else:
          /# We are to insert before or after a pre-existing attribue.
          index = None
          aid = position[1:]
          for i, attr in enumerate(order):
            if attr.key() == aid:
              index = i
              break
          if index is None:
            self.metafile().error(
              'Failed to insert %s before missing %s' % (key, aid),
              line=attribute.line())
            raise Error('Here')
          elif position[0] == '+':
            order.insert(index + 1, attribute)
          elif position[0] == '-':
            order.insert(index, attribute)
          else:
            raise Error('Invalid position "%s"' % position)

        if attribute.isBlock():
          attribute.parentIs(self)
    tests:
      testx basics scope:
        construct = test.defineConstructs()
        /# defineConstructs() invokes registerAttribute() for a feature, primary
        /# and multiple secondaries.
        test.iseq(
          ['scope:', 'gender', 'class', 'person', 'count', 'value', 'type',
           'fruit', 'comment:'],
          [c.key() for c in construct.order()])

      testx multilang scope:
        /# Register scope<py>: and scope<cc>: and verify that 'scope:' provides
        /# access to scope<py>: (because current baselang is python) and that
        /# the canonicalized version of construct matches expectations.
        text = 'method f scope<py>:\nscope<cc>:\nend;\n'
        metafile = test.parserFor('Oopl', text, debuglevel=0)
        construct = metax.c.MethodConstruct.NewFromData(
          'f', metafile.context())
        attribute = metax.c.ComplexBlock(
          construct, 'scope:', [], litkey='scope<py>:')
        attribute.baselIs('py')
        attribute2 = metax.c.ComplexBlock(
          construct, 'scope:', [], litkey='scope<cc>:')
        attribute2.baselIs('cc')
        construct.registerAttribute(attribute)
        construct.registerAttribute(attribute2)
        test.iseqvec(
          ['method', 'scope:', 'scope:.cc', 'scope:.py'],
          sorted(construct._attributes.keys()))
        test.issame(attribute, construct.attr('scope:'))
        fp = test.newStr()
        construct.write(fp=fp)
        test.iseqtext(
          >|"""method f scope<py>:
          >|scope<cc>:
          >|end method f;
          >|""",
          fp.getvalue())
    end method registerAttribute;

    method unregisterAttribute : Attribute #:
      Remove the attribute with given key.

      Returns:
        The removed attribute.  Returns null if 'key' does not represent an
        attribute on self.
    params:
      var key : str;
    scope:
      result = None
      order = self._order
      attrs = self._attributes
      if key in attrs:
        result = attrs.pop(key)
        order.remove(result)
      return result
    test:
      construct = test.defineConstructs()
      scope = construct.unregisterAttribute('scope:')
      test.iseq('scope:', scope.key())
      gender = construct.unregisterAttribute('gender')
      test.iseq('male', gender.value())
      test.isnull(construct.unregisterAttribute('missing'))
    end method unregisterAttribute;

    method linkParent #:
      Link parent.
    params:
      var parent : Construct;
    scope:
      self.parentIs(parent)
    test:
      construct = test.defineConstructs()
      block = metax.c.ComplexBlock(None, 'scope:', [])
      construct.linkParent(block)
      test.issame(block, construct.parent())
    end method linkParent;

    method unlinkParent #:
      Unlink parent.
    params:
      var parent : Construct;
    scope:
      assert self._parent is parent
      self.parentIs(None)
    test:
      construct = test.defineConstructs()
      parent = construct.parent()
      test.notnull(parent)
      construct.unlinkParent(parent)
      test.isnull(construct.parent())
    end method unlinkParent;

    method changeParent #:
      Move myself out of my current parent into the new parent.
    params:
      var new_parent : ComplexBlock #:
        The parent to move this construct into.
      var position : str = null #:
        The name of some construct in the new parent preceeded by '+'
        (insert after) or '-' (insert before).  If the position is '+' or
        null, insert at end.  If the position is '-', insert at beginning.
    scope:
      parent = self.parent()
      parent.unregisterConstruct(self)
      new_parent.registerConstruct(self, position=position)
      /# TODO(wmh): Find myclass = new_parent.parent().ancestor('class')
      /# and set self.myclassIs(myclass)
    end method changeParent;

    method write : int #:
      Serialize this construct.

      Returns:
        For now, always -1, but this may change in the future.
    params:
      var fp : ostream = out #:
        Where to write output.
      var indent : str = '' #:
        How much indentation before each line.
      var mode : map = null #:
        A mechanism for controlling how the output is generated.
          form: str
            controls overall form of output. Values:
              code: render as parsable code
              html: render as HTML
          [fps]key: str
            controls how feature (s), primary (p) and secondary (s) attribute
            keys are rendered. Values:
              no: do not show key
              user: show user version (which may mean not showing)
              show: show canonical key
              alias: show first alias if present else canonical
            If any value ends with '+' it is a request o
          [fps]val: str
            controls how feature (f), primary (p) and secondary (s) attribute
            values are rendered. Values:
              no: do not show value
              user: show user value
              TODO(wmh): Define others?
          term: map
            code: int (always use this termcode)
            min: int (minimum termcode)
            max: int (maximum termcode)
    scope:
      nl = '\n' + indent
      space = ' '
      if mode is None: mode = {}
      form = mode.get('form', 'code')
      html = form == 'html'

      /# Add blank lines before the construct
      precount = self.precount()
      for i in range(0, precount):
        fp.write('\n')

      order = self.order()
      n = len(order)
      prev = None
      numc = 0
      for i, attribute in enumerate(self.order()):
        /# Determine if we need a space, newline or nothing before this
        /# attribute:
        /#  - if this is the first attribute, add nothing
        /#  - if mode is 0:
        /#     - if previous attribute was on a different line, insert newline,
        /#       else space
        /#  - if mode is 1:
        /#     - if the string representation of 'attribute', plus the
        /#       text already written on the first line, exceeds the maximum
        /#       column width, insert a newline else space.
        if i == 0:
          fp.write(indent)
        else:
          if numc < 0:
            /# The attribute was multi-lined, which means it was a block
            /# attribute (or multi-line expr). Newline should already be added,
            /# so we need to add indent.
            fp.write(indent)
          elif prev and attribute.line() != prev.line():
            /# The previous attribute is on a different line.
            fp.write(nl)
          else:
            fp.write(space)

        /# Write the attribute
        numc = attribute.write(fp=fp, indent=indent, mode=mode)

        /# Prepare for next iteration
        prev = attribute

      /# Print the terminator
      /#  - if the last attribute was multi-lined, insert indentation.
      termcode = self.termcode()
      if termcode > 0 and termcode != TERM_UNINIT:
        if termcode == 1:
          if prev and prev.isBlock():
            fp.write(indent + self.termstr() + '\n')
          else:
            fp.write(self.termstr() + '\n')
        else:
          /# TODO(wmh): Sometimes we need a newline, sometimes we dont
          if prev and prev.isBlock():
            /# If the last attribute was a block, we do not need to add
            /# a newline, but otherwise we do.
            pass
          else:
            fp.write('\n')
          termstr = self.termstr()
          if html:
            termstr = '<span class="face-end">' + termstr + '</span>'
            htmlid = self.fqn()
            cout = mode.setdefault('out', {}).setdefault('construct', {})
            cout.setdefault('all', []).append(htmlid)
            cout.setdefault(self.kind(), []).append(htmlid)

          fp.write(indent + termstr + '\n')

      /# Number of lines/chars written is unknown
      return -1
    test:
      construct = test.defineConstructs()

      fp = test.newStr()
      construct.write(fp=fp)
      test.iseqtext(
        'scope:\n'
        'gender male\n'
        'class Person\n'
        'person bob count 42 default <special> value "this is a test"\n'
        'type vec<str>\n'
        'fruit <apple|banana|cantelope>\n'
        'comment:\n'
        '  this is a\n'
        '  test of a simple block\n'
        'end class;\n',
        fp.getvalue())

      _, _, _, meta = test.cachedInfo(metal='meta')
      ex1, _, construct, _ = test.getMetaFile(
        'meta', 'ex1', context=meta.bootstrapContext())
      fp = test.newStr()
      construct.write(fp=fp)
      out = fp.getvalue()

      fp = test.newStr()
      construct.write(fp=fp, mode={'pkey': 'user+'})
      out = fp.getvalue()
    end method write;

    method writeIndex : vec<str> #:
      Add this construct to a hierarchy list.
    params:
      var level : int = 0 #:
        Current level (number of parents processed).  0 means initial
        invcation.
      var adj : int = 0 #:
        When computing the 'indent' value, a certain number of repeats of
        delim are used, based on the sum of level and adj.  Useful for example
        when minlevel is specified and one wants to remove excess levels of
        indentation by passing adj=-minlevel.
      var output : vec<str> = null #:
        Where to write output.
      var form : str = null #:
        A description of what should be printed out for each construct.
        Certain variables are interpolated:
         - line: the line number
         - indent: replaced with delim*level
         - kind: the construct kind
         - id: the construct id
         - fqn: the construct fqn
         - sep: arbitrary constant string specified as param in 'sep'
      var delim : str = null #:
        What to use as the indent indicator (per level).
        TODO(wmh): The default value should be '  ', but Meta currently
        types the 'default' attribute as 'word' instead of 'expr' and thus
        cannot properly parse '  '!
      var sep : str = '' #:
        What to replace the named value 'sep' with in the formatted line.
      var minlevel : int = 0 #:
        Do not print an entry if level less than this.
      var maxlevel : int = 100000 #:
        Do not print an entry if level greater than this.
      var width : int = 60 #:
        How much width to reserve for text before the suffix (if present)
      var suffix : str = null #:
        If present, another format string to print, after primary text
        is aligned to width chars. Same escapes available as in 'form'.
      var filter : regexp = null #:
        If present, only display a summary line if level is less than 3
        or if the summary line contains the specified regexp.
    scope:
      if form is None:
        form = '%(line)4d  %(indent)s%(kind)s %(id)s'
      if delim is None:
        delim = '  '

      if output is None:
        if level != 0:
          raise Error('Error: output null and level %d' % level)
        output = []

      scope = self.attrval('scope:', default=None)

      if level >= minlevel and level <= maxlevel:
        data = {
          'line': self.primary().line() + 1,
          'indent': delim * (level + adj),
          'kind': self.kind(),
          'id': self.id(),
          'fqn': self.fqn(),
          'sep': sep,
        }
        summary = form % data
        matches = filter and re.search(filter, summary)

        if filter and (level > 2 or not scope or self.kind() == 'native') and not matches:
          /# We are filtering, and the current line doesn't match the filter,
          /# so we don't show it.
          pass
        else:
          output.append(summary)

      if scope:
        if self.kind() in ('File', 'namespace', 'class', 'behavior'):
          sublevel = level + 1

          currdex = len(output)
          for child in scope:
            child.writeIndex(
              level=sublevel, adj=adj, output=output, form=form, delim=delim,
              sep=sep, minlevel=minlevel, maxlevel=maxlevel,
              width=width, suffix=suffix, filter=filter)

          /# print 'For "%s" there were %d children and %s' % (output[-1], len(output) - currdex, matches)
          if len(output) <= currdex and filter:
            /# We are filtering, and there was no match amongst any children,
            /# so we remove this entry too.
            if not matches and output:
              output.pop()
              pass

      return output
    test:
    end method writeIndex;

    method asStr : str #:
      Return a string representation of self.
    scope:
      fp = cStringIO.StringIO()
      self.write(fp=fp)
      return fp.getvalue()
    test:
    end method asStr;

    method termstr : str #:
      The terminator string to use for self.
    params:
      var context : Context = null;
    scope:
      if not context:
        context = self.context()
      termcode = self.termcode()

      if termcode == 0 or termcode == TERM_UNINIT:
        result = ''
      else:
        items = []
        if termcode & 0x2:
          items.append(context.token('end'))
        if termcode & 0x4:
          items.append(self.kind())
        if termcode & 0x8:
          items.append(self.id())
        result = ' '.join(items)
        if termcode & 0x1:
          result += context.token('term')
      return result
    test:
      construct = test.basics()
      for tc, termstr in (
        (0, ''), (1, ';'), (3, 'end;'), (7, 'end class;'),
        (15, 'end class Person;'),
      ):
        construct.termcodeIs(tc)
        test.iseq(termstr, construct.termstr())
    end method termstr;

    method path : str #:
      The path to this construct within the metafile.
    scope:
      parent = self.parent()
      if parent:
        result = parent.path() + '/' + self.id()
      else:
        raise Error('%s is missing a parent!' % self)
      return result.replace('@scope/', '/')
    test:
      /# Tested in ComplexBlock.child()
      pass
    end method path;

    method fqn #:
      Compute a fully-qualified id. Only meaningful for constructs in
      scope blocks.
    scope:
      revlist = []
      obj = self
      while obj:
        if obj.kind() == 'File':
          break
        revlist.append(obj.id() or '?')
        obj = obj.parent()
        if obj:
          obj = obj.parent()
      return '.'.join(reversed(revlist))
    test:
    end method fqn;

    method splitComment : tuple<str,str> #:
      Obtain the comment: of this construct and return a summary and desc.

      In various constructs, the comment is often structure as a one-line
      summary followed by a multi-line description. This method provides
      a means of obtaining summary and desc strings for that use-case .
    scope:
      comment = self.attrval('comment:', default=None)
      if comment is not None:
        n = len(comment)
        summary = comment[0].strip()
        if not summary.endswith('.') and n > 1 and comment[1].strip():
          /# If the first line doesn't end with a period, and the second line
          /# is not empty, we add a bit of flavor to the summary.
          summary += '...'
        desc = '\n'.join(comment[1:]).strip()
      else:
        summary = ''
        desc = ''
      return summary, desc
    test:
    end method splitComment;

    abstract
    method expandMeta #:
      Perform all actions needed to expand this construct (and its children).
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    end method expandMeta;

    method importMeta : vec<BaseFile> #:
      Import dependent metafiles and link data-structures based on resulting
      constructs. For most constructs this is a noop ... really only meaningful
      for files, namespaces and classes, so we provide a default noop
      implementation.
    scope:
      /# noop
    end method importMeta;

    abstract
    method translateMeta : vec<BaseFile> #:
      Perform all actions needed to translate this construct into a specific
      baselang.
    end method translateMeta;

    method compileMeta : vec<BaseFile> #:
      Perform all actions needed to compile the baselang code associated with
      this construct. For most constructs this is a noop ... really only
      meaningful for files, namespaces and classes, so we provide a default noop
      implementation.
    scope:
      /# noop
    end method compileMeta;

  end class Construct;

  class GenericConstruct < Construct #:
    A construct that can be used to represent any construct kind, but which
    does not have any kind-specific fields.
  scope:
    field kind : str #:
      The kind of the construct.

    lifecycle params:
      var id : str;
      var parent : ComplexBlock;
      var context : Context;
      var kind -> kind;
    super (id,parent,context)
    scope:
      if id != 'Person':
        print 'CREATING GenericConstruct for %s %s' % (kind, id)
        /# raise Error('blah')
    end lifecycle;

  end class GenericConstruct;

  abstract
  class MetaConstruct < Construct #:
    Abstract superclass of all construct classes in Meta(Meta).
  scope:

    method expandMeta #:
      Perform all actions needed to expand this construct (and its children).
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      print '**** MetaConstruct no expansion needed for %s' % self.kindid()
    end method expandMeta;

    method translateMeta : vec<BaseFile> #:
      Perform all actions needed to translate this construct into a specific
      baselang.

      No translation needed for constructs in Meta(Meta), at least not
      currently.  We may want to implement the parsing of meta languages in
      terms of expandMeta() and translateMeta().
    scope:
    end method translateMeta;

  end class MetaConstruct;

  class MetaLanguageConstruct < MetaConstruct #:
    Used to represent MetaLanguage constructs, which define Meta languages.
  assocs:
    resource metameta path "../schema/meta/schema.meta";
    resource metaoopl path "../schema/oopl/schema.meta";
  scope:

    field name : str #:
      The human-presentable name of this Meta language. It is what is inserted
      for X in Meta(X).

    field metalangparent : MetaLanguageConstruct #:
      The parent MetaLanguage of this MetaLanguage. Only null for Meta(Meta).

    field toplevel : vec<str> #:
      The list of construct kinds that are legal at top-level within .meta files
      implemented in this MetaLanguage. The toplevel kinds of ancestor languages
      are also legal and do not need to be explicitly specified here.

    field baselangs : @map<str,BaseLanguage> #:
      The collection of BaseLanguage instances supported by this
      MetaLanguage.  A key is added for the id, name, aliases and
      suffix(es) of the language.

    field baselist : @vec<BaseLanguage> #:
      The collection of BaseLanguage instances in this MetaLanguage.

    field basesels : @map<str,str> #:
      Maps suffix to BaseLanguage for legal suffixes that can appear in
      attribute key selectors. Only the first suffix associated with each
      BaseLanguage is allowed here.

    field consmap : @map<str,class> #:
      Maps construct kind to subclass of Construct.  If a particular
      construct id is not present, GenericConstruct is assumed.

    lifecycle params:
      var id : str;
      var parent : ComplexBlock #:
        Should always be null.  Required so that the MetaLanguage initializer
        matches the Construct initializer.
      var context : Context #:
        Should always be null.  Required so that the MetaLanguage initializer
        matches the Construct initializer.
      var precount : int = 0 #:
        Should always be zero. Required so that the MetaLanguage initializer
        matches the Construct initializer.
    super (id, parent, context, precount=precount)
    scope:
      /# The special Meta* baselang suffix is always legal.
      self.basesels()['*'] = None

      /# IMPORTANT: This construct is not properly initialized until
      /# postCreationInitialization() is invoked, which cannot be invoked
      /# until the name, toplevel and metalangparent fields have been
      /# initialized.
    end lifecycle;

    method postCreationInitialization #:
      Perform post-creation initialization
    scope:
      name = self.name()
      assert name is not None
      toplevel = self.toplevel()
      assert toplevel is not None
      uid = self.id()

      metalangparent = self.metalangparent()
      if uid != 'meta':
        assert metalangparent is not None

      if metalangparent:
        toplevel = metalangparent.toplevel() + toplevel
        self.toplevelIs(toplevel)

        /# Inherit parent constructs into self.
        pmap = metalangparent.consmap()
        for kind, ccls in pmap.iteritems():
          self.registerConstructClass(kind, ccls)
    end method postCreationInitialization;

    method kind : str scope:
      return 'MetaLanguage'

    method registerConstructClass #:
      Associate a construct with a subclass of Construct.
    params:
      var kind : str #:
        A construct kind.
      var cls : class<Construct> #:
        The subclass of Construct to use to represent instances of
        construct 'kind'.
    scope:
      /# print 'Registering %s %s for %s' % (kind, cls.__name__, self.id())
      assert issubclass(cls, Construct)
      self._consmap[kind] = cls
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      test.iseqvec(test.metaoopl_consids, sorted(metaoopl._consmap))
    end method registerConstructClass;

    method getConstructClass : class<Construct> #:
      Obtain the construct class to use for instances of constructs of
      kind 'kind'.
    params:
      var kind : str #:
        A construct kind.
    scope:
      return self._consmap.get(kind, None)
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      conscls = metaoopl.getConstructClass('Construct')
      test.issame(metax.c.ConstructConstruct, conscls)
    end method getConstructClass;

    method registerBase #:
      Add a BaseLanguage to this MetaLanguage
    params:
      var base : BaseLanguage #:
        The baselanguage to add.
    scope:
      bases = self.baselangs()
      suffixes = base.suffixes()
      for key in [base.id(), base.name()] + suffixes:
        current = bases.get(key, None)
        if current and current is not base:
          raise InternalError(
            "Attempt to register base %s with key '%s' already used by %s"
            % (base.id(), key, current.id()))
        bases[key] = base
      self.basesels()[suffixes[0]] = base
      self.baselist().append(base)
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      test.iseqvec(
        ['C++', 'Javascript', 'Python'],
        sorted([baselang.name() for baselang in metaoopl.baselist()]))
    end method registerBase;

    method baselangNamed : BaseLanguage #:
      The BaseLanguage instance associated with a given name.
    params:
      var nora : str #:
        The name, alias, suffix or id of the baselang desired.
    scope:
      return self.baselangs().get(nora, None)
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      ooplpy = metaoopl.baselangNamed('Python')
      test.isinst(ooplpy, metax.c.OoplPython)
    end method baselangNamed;

    method toplevelConstructKinds : vec<str> #:
      The list of construct kinds that can appear at top-level within a
      meta file implemented in this meta language.
    scope:
      return self.toplevel()
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      test.iseqvec(
        ['MetaLanguage', 'File', 'namespace'],
        metaoopl.toplevelConstructKinds())
    end method toplevelConstructKinds;

    method isValidBase : bool #:
      Determine if a given string is a valid string to appear within a
      attribute key selector to identify a baselang.
    params:
      var basesel : str #:
        The baselang selector found within an attribute key.
    scope:
      return basesel in self.basesels()
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      test.istrue(metaoopl.isValidBase('py'))
      test.istrue(metaoopl.isValidBase('js'))
      test.isfalse(metaoopl.isValidBase('xx'))
    end method isValidBase;

  end class MetaLanguageConstruct;

  abstract
  class BaseLanguageConstruct < MetaConstruct #:
    The abstract superclass of all baselanguage instances.  There will
    an abstract subclass for each MetaLanguage, and concrete subclasses of
    that class for each base language within the Meta Language.

    TODO(wmh): Must ensure that all suffixes are unique across all
    BaseLanguages in a MetaLanguage.
  scope:

    field name : str #:
      A human-readable name for this base lang. Anything is allowed.

    field suffixes : vec<str> #:
      A list of suffixes associated with this baselang.

    field basekey : str #:
      The priviledged suffix (the one used in attribute key params).

    field keywords : @vec<str> #:
      The keywords of this baselang.

    field configs : @map #:
      A collection of var/value pairs. A particular Meta language will often
      require that each base language of that meta language define the same
      set of variables, with baselang-specific values. Used in the code.

    field pseudovars : @map #:
      Maps meta-level pseudovars to baselang equivalents.

    method kind : str scope:
      return 'BaseLanguage'

    method postCreationInitialization #:
      Perform post-creation initialization
    params:
      var metalang : MetaLanguageConstruct = null;
      var name : str = null;
      var suffixes : vec<str> = null;
    scope:
      /# TODO(wmh): When we have migrated fully to a construct-based
      /# implementation of BaseLanguageConstruct, this method can be cleaned
      /# up by not testing the fields against None first.

      if self.metalang() is None:
        if metalang is None:
          metalang = self.parent().parent()
        self.metalangIs(metalang)

      if self.name() is None:
        if name is None:
          name = self.attrval('name')
        self.nameIs(name)

      if self.suffixes() is None:
        if suffixes is None:
          suffixes = self.attrval('suffixes')
        self.suffixesIs(suffixes)
    end method postCreationInitialization;

    method suffix : str #:
      The suffix to use for a given location
    params:
      var location : str = 'defn';
    scope:
      suffixes = self.suffixes()
      if location == 'defn':
        result = suffixes[0]
      elif location == 'decl':
        result = suffixes[1] if len(suffixes) > 1 else suffixes[0]
      else:
        raise Error('Unknown suffix location "%s"' % location)
      return '.' + result
    test:
      _, metalang, _, _ = test.cachedInfo()
      py = metalang.baselangNamed('python')
      cpp = metalang.baselangNamed('cpp')
      test.iseq('.py', py.suffix())
      test.iseq('.py', py.suffix(location='decl'))
      test.iseq('.cc', cpp.suffix())
      test.iseq('.h', cpp.suffix(location='decl'))
    end method suffix;

    method hasSuffix : bool #:
      Detemine if this baselang is associated with the specified suffix.
    params:
      var suffix : str #:
        A suffix (without '.') to match against
    scope:
      return suffix in self._suffixes
    test:
      _, metalang, _, _ = test.cachedInfo()
      py = metalang.baselangNamed('python')
      cpp = metalang.baselangNamed('cpp')
      test.istrue(py.hasSuffix('py'))
      test.isfalse(py.hasSuffix('cc'))
      test.istrue(cpp.hasSuffix('h'))
      test.istrue(cpp.hasSuffix('cc'))
      test.isfalse(cpp.hasSuffix('py'))
    end method hasSuffix;

    method config : any #:
      Obtain a config var by value.
    params:
      var name : str;
      var default : any = REQUIRED;
    scope:
      result = self._configs.get(name, default)
      if result is metax.c.REQUIRED:
        raise Error(
          'Failed to find config var "%s" in baselang %s' %
          (name, self.name()))
      return result
    test:
    end method config;

    method updateConfigs #:
      Add key/value pairs to configs.
    params:
      var configs : map;
    scope:
      self.configs().update(configs)
    end method updateConfigs;

  end class BaseLanguageConstruct;

  abstract
  class BaseLanguageOopl < BaseLanguageConstruct #:
    The abstract superclass of all base languages in Meta(Oopl).

    The following config variables should be given values in subclasses via
    self.updateConfigs():
      namespace_primary : bool
        true if this baselang treats namespaces as primary (e.g. does not have
        per-class source files). ex. python is namespace_primary. javascript
        can be either namespace_primary or not. C++ and Java are not
        namespace_primary.
      definition_separate : bool
        true if this baselang has a separate source file for declarations.
        ex: C++ is definition_separate, while python, javascript and java are
        not.
      rem : str
        The character sequence used to start a one-line comment.
        TODO(wmh): Must add endrem for those languages that do not have a
        comment syntax for one-line comments (e.g. CSS has no such thing, so
        some OOPL may also).
      self : str
        The variable used to refer to the receiver within instance methods.
      cls : str
        The variable used to refer to the receiver within class methods.
      selfsep : str
        What separates the receiver variable from a method invocation.
        Ex. In Java and Python, this is '.', while in C++ and Perl it is '->'.
      stmtend : str
        What character(s) end statements in this baselang.
        ex: In python, this is empty.  In C++, Java and Javscript it is ';'.

      setup : map
        name : str
          The name of the method used to initialize a test before invoking
          a test method.
        level : str
          One of 'user', 'meta' or 'static'. Note that this is really a mixture
          of the 'location' and 'kind' attributes within a field, but is a
          more concise shorthand.
      teardown : map
        same as setup but represents the method used to cleanup after a test
        method has been run.
      setupcase : map
        same as setup but represents the method used to initialize an entire
        TestCase instance before invoking the tests on it.
      teardowncase : map
        same as setup but represents the method used to cleanup an entire
        TestCase instance after invoking all tests on it.
  scope:

    meta
    lifecycle scope:
      /# This class var has the same keys as SPECIALS in BaseLanguageOopl and its
      /# children, but instead of the value being a baselang representation of
      /# the meta identifier specified by the key, the value here is the Type
      /# instance that the value is an instance of.
      cls.PSEUDOVARS = {
        /# TODO(wmh): With the advent of TypeWrapper, should we have these be
        /# TypeWrapper instances whose underlying type is the fqcn of the actual
        /# class?
        'false': Type.Instance('bool'),
        'out': Type.Instance('meta.ostream'),
        'err': Type.Instance('meta.ostream'),
        'in': Type.Instance('meta.istream'),
        /# TODO(wmh): What is the type of null in Meta??
        'null': Type.Instance('meta.Null'),
        'self': SELF,
        'test': SELF,
        'this': SELF,
        'true': Type.Instance('bool'),
      }

      /# TODO(wmh): Change to std::any
      any = Type.Instance('any')
      cls.TEMPLATES = {
        'vec': (('TV', any),),
        /# NOTE: In C++, we need the map key to be 'std::string' (rather than
        /# std::string* or std::string&) if we are using std::string to
        /# implement 'str' (will be better when we move to IStr). It is possible
        /# that javascript instead expects *str ... TBD.
        'map': (('TK', Type.Instance('@str')), ('TV', any)),
      }

      cls.SPECIAL_RE = re.compile(
        r'^(?P<indent>\s*)Meta:(?P<action>[a-zA-Z0-9_<>]+):\s*(?P<text>.*)')
    end lifecycle;

    field metatypes : map #:
      Maps meta-level primitive/native types to base-lang information
      about those types. Some metatypes require a parameter (e.g. int<32>,
      real<64>), in which case the value is a recursive map ... this is
      determined by whether key 0 exists with value True or not). The value
      maps contain:
        base: str or two-tuple of str
          The base-language base type associated with the metatype.
          For Java, two base types are provided, raw and boxed.
        default: str or None
          This should always be a string, not a python int or bool or anything
          else. This is the base-language syntax to use for a meaningful
          default value for variables of the specified meta (and base) type.
          If None, it means there is no meaningful default value for the type
          in question.
    end field metatypes;

    method metabase : any #:
      Obtain base-lang info for a given (base) metatype.

      If you want to convert an arbitrary meta-level type to a baselang,
      use typeToBase() instead. This method is lower-level.

      Returns:
        Returns a dict if kind is null
        Returns a string if kind is 'base' or 'default'
        Returns null if mtypestr or params is invalid.
    params:
      var mtypestr : str #:
        A primitive or native meta-type (usually without any prefixes,
        although in special situations certain prefixed types may also have
        info).  One of the keys in self.__class__.METATYPES
      var param : str = null #:
        For types like 'int' and 'real', a numeric param is allowed. If None,
        and one is required, 32 is used.
      var kind : str = 'base' #:
        If None, returns the entire dict, else returns the value of key
        'kind' within the base dict.  Keys are: base, default.
      var metatypes : map = null #:
        Where to find the metatype info.  If None, uses self.metatypes()
    scope:
      if metatypes is None:
        metatypes = self.metatypes()
      baseinfo = metatypes.get(mtypestr, None)
      /# print 'metabase: mtypestr=%s param=%s kind=%s baseinfo=%s' % (mtypestr, param, kind, baseinfo)
      if not baseinfo:
        /# The given mtypestr is not a hardcoded meta type ... return None
        result = None
      else:
        if 0 in baseinfo:
          /# This metatype accepts a (numeric) param. If one is given, we find the
          /# closest integer in baseinfo equal-greater the specified param. If one
          /# is not given, we use the info from baseinfo[None].
          if param is None:
            arg = None
          else:
            arg = int(param)
            while arg < 65 and arg not in baseinfo:
              arg += 1
            if arg > 64:
              raise Error('Invalid type %s<%d>' % (mtypestr, arg))
              return None
          baseinfo = baseinfo[arg]
        if kind is None:
          result = baseinfo
        elif kind in ('base', 'boxed'):
          result = baseinfo['base']
          if isinstance(result, tuple):
            result = result[0] if kind == 'base' else result[1]
          elif kind == 'base':
            pass
          else:
            result = None
        elif kind == 'default':
          result = baseinfo['default']
        else:
          raise Error('Invalid kind %s' % kind)
      return result
    end method metabase;

    method metabaseValue : str #:
      Obtain the baselang representation of a meta-level value (for example,
      the attr value of a 'default' attribute of 'var', etc.)
    params:
      var value : any #:
        TODO(wmh): The value should probably always be an Expr, but currently
        the type of 'default' in 'var', 'field' and 'flag' is 'word' instead
        of 'expr'.
    scope:
      if isinstance(value, str):
        /# This is old-school ... should be removed in favor of Expr.
        /#  - support converting 'true', 'false', 'null', etc. to baselang
        /#    representations, but does not properly handle string literals,
        /#    list literals, hash literals, method invocations, or any of the
        /#    other things that Expr handles.
        result = self.pseudovars().get(value, value)
      elif isinstance(value, Expr):
        raise Error('Not yet handling Expr ... may need to define a behavior')
      else:
        raise Error('Unknown type %s of value in metabaseValue' % type(value))
      return result
    test:
      ooplpy = test.cachedInfo(basel='python')[0]
      oopljs = test.cachedInfo(basel='javascript')[0]
      ooplcc = test.cachedInfo(basel='cpp')[0]

      for metaval, py, js, cc in (
        ('true', 'True', 'true', 'true'),
        ('false', 'False', 'false', 'false'),
        ('null', 'None', 'null', 'nullptr'),
        ('out', 'sys.stdout', '?', 'std::cout'),
        ('err', 'sys.stderr', '?', 'std::cerr'),
        ('in', 'sys.stdin', '?', 'std::cin'),
      ):
        test.iseq(py, ooplpy.metabaseValue(metaval))
        test.iseq(js, oopljs.metabaseValue(metaval))
        test.iseq(cc, ooplcc.metabaseValue(metaval))
    end method metabaseValue;

    method typeToBase : str #:
      Convert a metatype to a string representation of its base-language
      equivalent.
    params:
      var metatype : Type #:
        The metatype to convert.
      var class_construct : ClassConstruct = null #:
        If specified, the class within which the type is being defined.
        Some baselangs cannot support fully-qualified references to the
        class currently being defined, and this allows such fully-qualified
        types to be localized.
      var value : any = null #:
        If present, the value being assigned to the variable of type 'metatype'.
        Used, for example, if metatype is 'str' (rather than '&str' or '*str')
        to heuristically decide between '&str' or '*str'.
      var defqn : bool = false #:
        If true, convert fully-qualified class-based types to class-name only.
        Used to support situations where the fully-qualified name poses
        problems in the baselang.
    scope:
      defqn = False

      cls = self.__class__
      debug = False
      if debug:
        print 'In BaseLanguageOopl.typeToBase with metatype=%s' % (
          metatype.raw() if metatype else None)

      if metatype is None:
        result = 'METATYPE is NONE'

      elif not metatype.isValid():
        result = metatype.raw()
        if result.startswith('{#') and result.endswith('#}'):
          result = result[2:-2].replace('_', ' ')
        if debug:
          print '  type is invalid'

      else:
        params = metatype.params()

        /# Obtain the core metatype
        metabase = metatype.base() or '?'
        if metabase == 'str':
          /# The 'str' type is unusual in that *str and &str exist in
          /# METATYPES as separate entities, so we add those annotations in.
          if metatype.isPtr():
            metabase = '*' + metabase
          elif metatype.isRef():
            metabase = '&' + metabase
          elif metatype.isValue():
            metabase = '@' + metabase

        /# Check if the metabase type is a known metatype (e.g. in METATYPES).
        numeric = metatype.numericParam() or None
        basetype = self.metabase(metabase, param=numeric if params else None)

        if debug:
          print '  metabase=%s basetype=%s numeric=%s' % (
            metabase, basetype, numeric)

        if basetype:
          /# We've found a mapping from meta-level to base-level.

          if numeric:
            /# We've obtained a primitive type
            result = basetype
          else:
            /# We set up a default mapping from parameter name to type, in case
            /# we have a metatype that does not specify all of the types.
            param_map = {}
            param_pairs = cls.TEMPLATES.get(metabase, [])

            if False:
              print '-' * 70
              print metatype
              print basetype
              print param_pairs
              print params

            np = len(params) if params else 0

            if param_pairs:
              /# This type has a certain number of parameters that can be
              /# provided (defaults are supported for parameters not given).
              for i in range(0, len(param_pairs)):
                pkey, defmtype = param_pairs[i]
                if i < np:
                  mtype = params[i]
                else:
                  mtype = defmtype
                param_map[pkey] = self.typeToBase(
                  /# TODO(wmh): Should some variant of 'value' be passed down?
                  mtype, class_construct=class_construct, defqn=defqn)
            result = basetype % param_map
        else:
          /# The metatype is not native/primitive, so it must be a class.
          if defqn:
            if metabase == 'metax.root.ObjectMetaRoot':
              /# TODO(wmh): Fix this hackery!
              result = metabase
            else:
              result = metabase.split(Context.TOKENS['scope_sep'])[-1]
          else:
            result = metabase

          /# The base part may be prefixed by EXTERNAL_CLASS_INDICATOR to
          /# indicate a non-meta class.
          if result[0] == Type.EXTERNAL_CLASS_INDICATOR:
            result = result[1:]

        /# In javascript, we cannot (for some reason I really want to address)
        /# refer to the fully-qualified name of the class from within the
        /# class itself. Instead, we must use the non-qualified class name.
        scope_sep = Context.TOKENS['scope_sep']
        if class_construct:
          nmspfqn = class_construct.namespace().fqn()
          /#print 'HERE with %-30s and %s' % (nmspfqn, result)
          if result == class_construct.fqn():
            result = result.split('.')[-1]
          elif False and result.startswith(nmspfqn):
            result = result.split('.')[-1]

        result = self._annotateBaseType(metatype, result)

      if debug:
        print '  result is "%s" for "%s"' % (result, metatype.raw())

      return result
    test:
      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      oopljs, _, _, _ = test.cachedInfo(basel='javascript')
      ooplcc, _, _, _ = test.cachedInfo(basel='cpp')

      cc_any = metax.c.OoplCpp.CC_ANY
      cc_str = metax.c.OoplCpp.CC_STR
      cc_str_value = metax.c.OoplCpp.CC_STR_VALUE

      for metastr, epy, ejs, ecc in (
        ('int', 'int', '!number', 'int32_t'),
        ('*demo.cards2.Card', 'demo.cards2.Card', '?demo.cards2.Card', 'demo::cards2::Card*'),
        ('any', 'any', '?*', cc_any + '*'),
        ('*any', 'any', '?*', cc_any + '*'),
        ('&any', 'any', '!*', cc_any + '&'),
        ('@any', 'any', '!*', cc_any),
        ('str', 'str', '?string', cc_str + '*'),
        ('*str', 'str', '?string', cc_str + '*'),
        ('&str', 'str', '!string', cc_str + '&'),
        ('@str', 'str', '!string', cc_str_value),
        ('&*str', 'str', '?string', cc_str + '*&'),
        ('@vec', 'list', '!Array.<?*>', 'std::vector<%s*>' % cc_any),
        ('@map', 'dict', '!Object.<!string,?*>', 'std::map<%s,%s*>' % (cc_str_value, cc_any)),
        ('ostream', 'file', '?Object', 'std::ostream*'),
        ('*#nm.sp.A', 'nm.sp.A', '?nm.sp.A', 'const nm::sp::A*'),
        ('#*nm.sp.A', 'nm.sp.A', '?nm.sp.A', 'nm::sp::A*const'),
        ('@vec<@str>', 'list', '!Array.<!string>', 'std::vector<%s>' % cc_str_value),
      ):
        metatype = metax.c.Type.Instance(metastr)
        pybase = ooplpy.typeToBase(metatype)
        test.iseq(epy, pybase, '%s != %s for %s' % (epy, pybase, metastr))
        jsbase = oopljs.typeToBase(metatype)
        test.iseq(ejs, jsbase, '%s != %s for %s' % (ejs, jsbase, metastr))
        ccbase = ooplcc.typeToBase(metatype)
        test.iseq(ecc, ccbase, '%s != %s for %s' % (ecc, ccbase, metastr))

      test.iseq(
        '?nm.sp.A',
        oopljs.typeToBase(metax.c.Type.Instance('nm.sp.A'), defqn=True))
      test.iseq(
        '?Array.<?nm.sp.A>',
        oopljs.typeToBase(metax.c.Type.Instance('vec<nm.sp.A>'), defqn=True))

    end method typeToBase;

    method _compileExprAttr : tuple<str,Type> #:
      Service routine for compiling an 'expr'-typed attribute.

      Any attribute that is typed as 'expr' can be passed to this method to
      obtain the baselang-specific code representing the expr. Errors are added
      to metafile for various issues (and None returned), otherwise the result
      is baselang code representing the expression.

      Returns:
       0. The baselang code representing the expr. Returns None if exprattr is
          None.
       1. The meta type of the expr.
    params:
      var metafile : MetaFile #:
        Where to report errors.
      var exprattr : ExprAttribute #:
        The expr attribute.  If None, returns None.
      var default : any = null #:
        What to return if exprattr is None
      var legal : vec<str> = null #:
        The enumerable of legal expr kinds allowed.
      var paren : bool = false #:
        If True, the expr is expected to be parenthezied.
      var executable : ExecutableConstruct = null #:
        The context within which this expr is being compiled.  Used in order
        to establish type of result from type analysis.
      var typecheck : bool = true #:
        If False, do not typecheck.
    scope:
      result = default
      metatype = None
      if exprattr:
        result, metatype = exprattr.getCompilationResults()
        if result is None:
          expr = exprattr.value()
          linenum = exprattr.line()
          data = expr.data()
          if paren and data['kind'] not in ('plist', 'arglist'):
            metafile.error('Expecting parenthesized expr', line=linenum)
          else:
            /# If data represents an arglist, it should only have one element.
            error = False
            while data['kind'] in ('plist', 'arglist'):
              parts = data['expr']
              if len(parts) != 1:
                metafile.error(
                  'Expecting one expr, not %d' % len(parts), line=linenum)
                error = True
              else:
                data = parts[0]
            if not error:
              kind = data['kind']
              if legal and kind not in legal:
                metafile.error('Expecting a callsite or variable, not %s' % kind)
              else:
                /# We record the line number in metafile first.
                metafile.setLineNum(exprattr.line(), STATE_COMPILE)
                /# Compile the expression.
                result, metatype = self.compileExpr(
                  data, metafile, executable=executable)
                /# Cache the compilation results so that subsequent invocations are
                /# fast.  TODO(wmh): How often is the same exprattr compiled? Is
                /# the savings in time (if any) worth the increase in memory?
                exprattr.cacheCompilationResults(result, metatype)
      return result, metatype
    end method _compileExprAttr;

    method compileExpr : tuple<str,Type> #:
      Compile an Expr instance into a baselang.

      Returns:
       0. the baselang code representing the expression
       1. the meta type of the expression.
    params:
      var expr : any #:
        The expr to compile. If it is an Expr, expr.data() should return
        the already-parsed dict.  If it is a dict, that dict is the pre-parsed
        data.
      var metafile : MetaFile #:
        The meta file being parsed/compiled.
      var executable : ExecutableConstruct = null #:
        The context within which this expr is being compiled.  Used in order
        to establish type of result from type analysis.
        TODO(wmh): This should probably be renamed to symbol_construct of type
        SymbolConstruct ... for vars it will be a MethodConstruct, but for
        fields it will be a ClassConstruct.
      var typecheck : bool = true #:
        If False, do not typecheck, even if executable is provided.
        Useful for disabling certain warnings.
    scope:
      indent = ''
      lines = ['']
      metatype = self._compileExpr(
        expr, metafile, lines,
        indent=indent, executable=executable, typecheck=typecheck)
      return '\n'.join(lines), metatype
    test:
      def Chk(expected_code, expected_type, pair):
        code, mtype = pair
        test.iseq(expected_code, code)
        if expected_type is None:
          test.isnull(mtype)
        elif isinstance(expected_type, list):
          for i, etype in enumerate(expected_type):
            mt = mtype[i]
            if mt is None:
              test.isnull(mt)
            else:
              test.iseq(etype, mt.raw())
        else:
          test.iseq(expected_type, mtype.raw())

      ooplpy, _, context, compiler = test.cachedInfo(basel='python')
      metafile = metax.c.MetaFile('/faux/path', compiler, text='\n')

      expr_true = metax.c.ExprParser(test.metafileFor('true\n')).parse()
      Chk('True', 'bool', ooplpy.compileExpr(expr_true, metafile))

      expr_null = metax.c.ExprParser(test.metafileFor('null\n')).parse()
      Chk('None', 'cls.Null', ooplpy.compileExpr(expr_null, metafile))

      expr_one = metax.c.ExprParser(test.metafileFor('1\n')).parse()
      Chk('1', 'uint', ooplpy.compileExpr(expr_one, metafile))

      expr_var = metax.c.ExprParser(test.metafileFor('apple\n')).parse()
      Chk('apple', None, ooplpy.compileExpr(expr_var, metafile))

      expr_params = metax.c.ExprParser(test.metafileFor('(a, b=1)\n')).parse()
      Chk('(a, b=1)', [None, None], ooplpy.compileExpr(expr_params, metafile))

      expr_list = metax.c.ExprParser(
        test.metafileFor('[false, true, null, 1, a]\n')).parse()
      Chk('[\n  False,\n  True,\n  None,\n  1,\n  a,\n]',
          'vec', ooplpy.compileExpr(expr_list, metafile))

      expr_map = metax.c.ExprParser(
        test.metafileFor("{'a': false, 'b': true, 'c': a}\n")).parse()
      Chk("{\n  'a' : False,\n  'b' : True,\n  'c' : a,\n}", 'map',
          ooplpy.compileExpr(expr_map, metafile))
    end method compileExpr;

    method _compileExpr : Type #:
      Compile an Expr instance into a baselang.

      Returns: Type
        The meta type of the expression.  None if no type could be established.
    params:
      var expr : any #:
        The expr to compile. If it is an Expr, expr.value() is the data. If it
        is a dict, that dict is the pre-parsed data. 
        TODO(wmh): Can this ever be a dict in this new code?
      var metafile : MetaFile #:
        The meta file being parsed/compiled.
      var lines : vec<str>;
      var indent : str = '';
      var executable : ExecutableConstruct = null #:
        The context within which this expr is being compiled.  Used in order
        to establish type of result from type analysis.
      var typecheck : bool = true #:
        If False, do not typecheck, even if executable is provided.
        Useful for disabling certain warnings.
    scope:
      /# caller should set lineno before invoking _compileExpr!
      lnum = metafile.lnum()
      numerrs = metafile.numErrors()
      metatype = None
      basel = self.id()
      kind = expr.kind()

      if kind == 'num':
        /# The representation of numbers is pretty consistent across languages.
        /# In Meta, the legal syntax for a number matches that in json, which
        /# should be valid in all baselangs.
        /# TODO(wmh): Do we want to support Perl's 100_000 syntax?
        /#
        /# For now, meta literal numbers are valid in all baselangs.
        /# We use the verbatim str value provided by the user (data['str'])
        /# rather than the int/float available in data['expr'] to maintain
        /# scientific notation.
        numval = expr.value()
        lines[-1] += str(numval)

        /# The metatype is int<?>, uint<?>, or real<?>, depending on exact value.
        /# TODO(wmh): We can do a better job of establishing an exact parameter
        /# value. For now, we just return int, uint or double.
        if isinstance(numval, int):
          tstr = 'int' if numval < 0 else 'uint'
        else:
          tstr = 'double'
        if typecheck:
          metatype = Type.Instance(tstr)

      elif kind == 'str':
        /# A string literal is always quoted in the Meta source
        /#  - In C++ and Java, strings must always use double quotes.
        /#  - Python and Javascript, double or single quotes are fine (use
        /#    whatever user provided in source.
        /#  - Perl allows interpolation within double quoted strings and
        /#    doesn't do interpolation within single-quoted strings.
        strlit = expr.value()
        if basel in ('cpp', 'java'):
          result = expr.asStr(quote=True, delim='\"')
        elif basel in ('python', 'javascript'):
          result = expr.asStr(quote=True)
        elif basel == 'perl':
          /# TODO(wmh): Clean this up.
          result = expr.asStr(quote=True)
        else:
          raise Error('Provide implementation of str literals in %s' % basel)
        lines[-1] += result
        if typecheck:
          metatype = Type.Instance('&str')

      elif kind == 'var':
        /# This is just an identifier.
        /# TODO(wmh): Rename 'var' to 'id'.
        /#
        /# There are some special values that look like identifiers that are to
        /# be treated differently (e.g. self, true, false, null, ...). Any key
        /# in BaseLanguageOopl.PSEUDOVARS is mapped to an associated value.
        /#
        /# Also, if data contains a 'default' key (another full expr), this
        /# overall expression is presumably part of a parameter list with a
        /# default value, and the compiled version of the default value is added
        /# to the result.
        /#
        /# For a var Expr
        /#   kind: 'var'
        /#   expr: the meta-level variable (an identifier)
        /#   str: the meta-level variable (an identifier)
        varname = expr.value()
        result, metatype = self.analyzeVariable(varname, executable=executable)
        if not metatype and typecheck:
          /# metafile.info('Failed to type var %s' % varname, line=lnum)
          pass

        /# Handle the special 'default' key, which exists for 'var' expressions
        /# with default values.
        default = expr.default()
        if default is not None:
          defcode, deftype = self.compileExpr(
            default, metafile, executable=executable)
          result += '=' + defcode

        lines[-1] += result

      elif kind == 'op':
        /# TODO(wmh): Currently blindly dumping verbatim operators, but we
        /# need to do type analysis on lhs, establish the operators defined on
        /# that type, and map the operator to the baselang specific syntax
        /# (which may or may not be an actual operator).
        metatype = None
        expr = data['expr']

        lhs_code, lhs_type = self.compileExpr(
          expr['lhs'], metafile, executable=executable, typecheck=typecheck)
        rhs_code, rhs_type = self.compileExpr(
          expr['rhs'], metafile, executable=executable, typecheck=typecheck)

        opname = expr['op']
        baselang_syntax = '%(lhs)s %(op)s %(rhs)s'
        lines[-1] += baselang_syntax % (
          {'lhs': lhs_code, 'op': opname, 'rhs': rhs_code})

      elif kind == 'call':
        /# A call site. The value() dict is:
        /#   rec: receiver of call
        /#   subcalls: list of dict
        /#     name: name of method or field to invoke on current receiver.
        /#     field: boolean true means field access (if not present, method call)
        /#     args: list of dict
        /#       same structure as 'data' itself
        val = expr.value()
        rec = val['rec']
        subcalls = val['subcalls']
        subcall_index = 0

        /# Establish the baselang receiver and its type.
        recstr, metatype = self.analyzeVariable(rec, executable=executable)

        /# TODO(wmh): This code is currently broken ... fix it!
        print 'HERE with recstr=%s metatype=%s' % (recstr, metatype)
        print '#' * 70
        print metafile.path()
        print expr
        print executable.kindfqn()
        print executable.primary().line()
        print '#' * 70

        if metatype:
          rec = recstr

        else:
          /# It is possible that 'rec' is the name of a top-level namespace,
          /# and that we are attempting to access some method or field within
          /# a non-local namespace or class.
          filecons = metafile.construct()
          namespace = filecons.symbol(rec)
          if namespace:
            /# TODO(wmh): Define meta!namespace as shorthand for
            /# meta.lang.Namespace, and implement that class. Each namespace
            /# results in an auto-generated singleton class being defined within
            /# the namespace, with a single instance that provides first-class
            /# object status to namespaces. It will also be where namespace-level
            /# variables will be implemented in languages that do not support them
            /# directly.
            construct = namespace
            for i in range(0, len(subcalls)):
              subcall = subcalls[i]
              subvar = subcall['name']
              /# print 'Looking for %s (%s)' % (subvar, subcall)
              /#construct.showSymbols()
              child = construct.symbol(subvar)
              if not child:
                break
              elif child.isnamespace():
                /# we continue iterating thru subcalls.
                construct = child
                subcall_index = i + 1
                rec += '.' + subvar
                pass
              elif child.isclass():
                /# We've reached a point where subsequent subcalls should be
                /# processed as method invocations or field accesses, using
                /# child as the executable.
                subcall_index = i + 1
                executable = child
                rec += '.' + subvar
                /#print 'HERE with %s' % child.kindfqn()
                /#child.showSymbols()
                metatype = child.implicitType()
                /#print subcalls[subcall_index:]
                /#print metatype
                break
              else:
                raise Error('Unexpected %s' % child.kindfqn())

          if not metatype and typecheck:
            metafile.warning(
              'Failed to establish a type for receiver "%s"' % recstr, line=lnum)
            global DC
            DC += 1
            if DC > 10:
              raise Error('here')
            /# print 'Here with %s and %s' % (executable.kindfqn() if executable else executable, rec)
            if executable:
              executable.showSymbols()

        /#print 'Here with receiver %s : %s' % (rec, metatype)

        /# Now process the cascading call-sites.
        /#  - update what the receiver looks like, in 'rec'
        /#  - maintain the metatype of the receiver
        /#  - typecheck arguments
        for subcall in subcalls[subcall_index:]:
          is_field = subcall.get('field', False)
          argsdata = subcall.get('args', None)

          /# First, we establish the separator that appears between the receiver
          /# and the method/field.
          /#  - almost always '.'
          /#  - in C++ and Perl, is '->' if the receiver is a ptr type
          sep = '.'
          if basel in ('python', 'cpp'):
            /# If metatype is pointer type.
            if False:
              sep = '->'

          /# Establish the field/method name
          /#  - note that for field access, it is the raw field name, which is
          /#    highly discouraged in Meta except for public raw fields.
          /#  - this name may be changed (later, when we do type analysis), if
          /#    the receiver is a native type.
          name = subcall['name']

          /# Now process the args.
          /#  - Each element of argsdata is a dict suitable for passing into a
          /#    recursive call to _compileExpr.
          if is_field:
            /# For a field, there are two possibilities:
            /#  - an arglist with exactly one arg, representing a request to set
            /#    the field to a given value.
            /#  - no arglist, which is a request to get the value of a field.
            /#     - the return value of a getter is the type of the field being
            /#       gotten.
            /#  - note that if the receiver is a native type, no field access
            /#    is allowed (the native interface is method-only).
            if argsdata:
              if len(argsdata) != 1:
                raise Error('bad!')
              /# We have a field assignment request.
              /#  - there can be no further subcalls, since we need to return
              /#    a single baselang statement (TODO(wmh): maybe in some
              /#    baselangs we can assign and proceed in the same statement?
              /#    Also, are we sure that we have to return a single statement?
              /#    Maybe that is too limiting (oh ... but this will often be the
              /#    rhs or an arg to a method invocation, so yeah, almost certainly
              /#    needs to be a single statement).
              valcode, valtype = self.compileExpr(
                argsdata[0], metafile, executable=executable)
              callcode = name + ' = ' + valcode

              /# NOTE: Do NOT need to update the current receiver type 'metatype'
              /#  - the return value of a setter (at least one generated by
              /#    Meta) is the receiver, so the return type after is the same
              /#    as the return type before.
              /#  - No updates needed normally, but what if a person overrides a
              /#    getter/setter with an explicit method? (note that if they
              /#    override via the field 'scope' block they have no ability to
              /#    change the return type and self is implicitly returned if they
              /#    don't do it themselves.
              /#  - Overriding of getters via explicit method is disallowed by
              /#    the unique-id-per-scope rule, but one could override fieldIs()
              /#    or fieldRef()
              /#  - TODO(wmh): explicitly disallow overriding of field accessors
              /#    via 'method' constructs!

              /# TODO(wmh): enforce no subcalls after field set elsewhere!

            else:
              /# We have a field access request. No args.
              callcode = name

              /# TODO(wmh): Update the rectype ... the type of the field being
              /# accessed.
              if typecheck:
                /# Note that rectype will be None if no type info was found.
                metatype = self.typecheckField(metafile, metatype, name)

            rec += sep + callcode

          else:
            /# For a method, we just process each arg.
            /#  - Note that meta doesn't require () for no-arg method invocations,
            /#    but baselangs do.
            /#     - In C++, this->f returns a pointer to the function, and
            /#       this->f() invokes the function.
            /#     - In Meta, this!f returns a pointer to the function, and
            /#       this.f (and this.f()) invokes the function.
            args = []
            if argsdata:
              for argdata in argsdata:
                argcode, argtype = self.compileExpr(
                  argdata, metafile, executable=executable)
                args.append(argcode)

            /# Establish the method name/type.
            /#  - note that for field access, it is the raw field name, which is
            /#    highly discouraged in Meta except for public raw fields.
            /#  - we perform type analysis to establish the legality of the given
            /#    name (and to convert native-type names to baselang equivalents)
            name = subcall['name']
            if typecheck and metatype:
              /# We have enough info to do type analysis on the requested
              /# method invocation ... maybe.
              rec, metatype = self.compileMethodInvocation(
                metafile, rec, metatype, name, args)
              /# print 'FOUND return type "%s" [%s]' % (str(metatype), metatype.raw())
            else:
              /# Without typechecking (or without a receiver type), we cannot
              /# handle native-type method renaming, so the following code is
              /# very likely to be incorrect.
              metatype = None
              callcode = name + '(' + ', '.join(args) + ')'
              rec += sep + name + '(' + ', '.join(args) + ')'
            /# TODO(wmh): Update the rectype ... the return type of the method

        lines[-1] += rec

      elif kind == 'hash':
        metatype = self._compileHash(
          expr, metafile, lines,
          indent=indent, executable=executable, typecheck=typecheck)

      elif kind == 'list':
        metatype = self._compileList(
          expr, metafile, lines,
          indent=indent, executable=executable, typecheck=typecheck)

      elif kind == 'plist':
        /# An parenthesized list.
        /# The value is a list of Expr.
        parts = []
        metatype = []
        for argexpr in expr.value():
          argcode, argtype = self.compileExpr(argexpr, metafile, executable=executable)
          parts.append(argcode)
          metatype.append(argtype)
        lines[-1] += '(' + ', '.join(parts) + ')'

      else:
        raise Error('Invalid expr kind "%s"' % kind)

      if metafile.numErrors() > numerrs:
        print 'WARNING: Ignoring _compileExpr result due to errors'
        result = None

      return metatype
    test:
      /# Tested in compileExpr().  Do we need more tests?
      pass
    end method _compileExpr;

    method _compileHash : str #:
      Compile a literal hash into python syntax.

      Returns:
        The baselang syntax representing this expr.
    params:
      var expr : Expr #:
        An Expr of kind 'hash'
      var metafile : MetaFile;
      var lines : vec<str> #:
        Where to write the output.
      var indent : str = '';
      var executable : ExecutableConstruct = null;
      var typecheck : bool = true;
    scope:
      /# The 'indent' variable represents the amount of indentation to put
      /# before the closing '}' and should match the amount of indentation
      /# present on lines[-1] at the beginning of this method.  Each
      /# key/value pair is placed on a separate line indented by subindent.
      assert expr.kind() == 'hash'
      data = expr.value()
      keytypes = []
      valtypes = []
      subindent = indent + '  '
      lines[-1] += '{'
      lines.append(indent)
      for keyexpr, valexpr in data:
        lines[-1] += '  '
        keytype = self._compileExpr(
          keyexpr, metafile, lines,
          indent=subindent, executable=executable, typecheck=typecheck)
        keytypes.append(keytype)
        lines[-1] += ' : '
        valtype = self._compileExpr(
          valexpr, metafile, lines,
          indent=subindent, executable=executable, typecheck=typecheck)
        valtypes.append(valtype)
        lines[-1] += ','
        lines.append(indent)
      lines[-1] += '}'
      /# TODO(wmh): Analyze keytypes and valtypes to determine if there
      /# is consistency amongst them. If the keys are all the same type K,
      /# and the values are all the same type V, we can return type
      /# map<K,V>. If either keytypes or valtypes is multi-typed, we can
      /# use 'any' or a disjunctive type.
      metatype = Type.Instance('map')
      return metatype
    test:
      /# Tested in compileExpr().  Do we need more tests?
      pass
    end method _compileHash;

    method _compileList : str #:
      Compile a literal list into python syntax.

      Returns: str
        The baselang syntax representing this expr.
    params:
      var expr : Expr #:
        An Expr of kind 'list'.
      var metafile : MetaFile;
      var lines : vec<str> #:
        Where to write the output.
      var indent : str = '';
      var executable : ExecutableConstruct = null;
      var typecheck : bool = true;
    scope:
      /# The 'indent' variable represents the amount of indentation to put
      /# before the closing ']' and should match the amount of indentation
      /# present on lines[-1] at the beginning of this method.  Each
      /# value is placed on a separate line indented by subindent.
      assert expr.kind() == 'list'
      data = expr.value()
      valtypes = []
      subindent = indent + '  '
      lines[-1] += '['
      lines.append(indent)
      for valexpr in data:
        lines[-1] += '  '
        valtype = self._compileExpr(
          valexpr, metafile, lines,
          indent=subindent, executable=executable, typecheck=typecheck)
        valtypes.append(valtype)
        lines[-1] += ','
        lines.append(indent)
      lines[-1] += ']'
      /# TODO(wmh): Analyze valtypes to determine if there is consistency
      /# amongst them.  If they are all the same type T, we can return a
      /# metatype of type 'vec<T>', else 'vec<any>' aka 'vec'
      metatype = Type.Instance('vec')
      return metatype
    test:
      /# Tested in compileExpr().  Do we need more tests?
      pass
    end method _compileList;

    method analyzeVariable : tuple<str,Type> #:
      Identify the baselang representation for a varname (and its metatype).

      Also handles pseudo vars like 'true', 'self', 'out', etc.

      Returns: tuple<str,Type>
       0. the baselang representation of the variable
       1. the meta-level Type instance of the variable. None means unable to type.
    params:
      var varname : str;
      var executable : ExecutableConstruct = null;
    scope:
      basestr = self.pseudovars().get(varname, None)
      if basestr:
        /# We have a pseudovar, and basestr is the baselang representation.
        result = basestr
        /# The metatype of this special identifier is stored in
        /# BaseLanguageOopl.PSEUDOVARS. Note that this code intentionally
        /# assumes the key exists in PSEUDOVARS as a forcing function to keep
        /# PSEUDOVARS in sync with pseudovars().
        cls = self.__class__
        metatype = cls.PSEUDOVARS[varname]
        if metatype is SELF:
          /# Special indicator that the type matches that of the receiver.
          if executable:
            myclass = executable.myclass()
            metatype = myclass.typeOfSelf(dothis=(varname=='this'))
          else:
            metatype = None
            /# print 'Warning: no executable - cannot currently identify type of self'
        /# print 'In analyzeVariable, varname=%s basestr=%s metatype=%s' % (varname, basestr, metatype)
      else:
        /# We have a variable reference.  It must be one of the variables
        /# available in the current lexical context.
        result = varname
        metatype = executable.establishType(varname) if executable else None
      return result, metatype
    test:
      def Chk(expected_varname, expected_type, pair):
        varname, mtype = pair
        test.iseq(expected_varname, varname)
        test.iseq(expected_type, mtype.raw())

      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      filec = metax.c.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.c.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.c.ClassConstruct.NewFromData(
        'Card', context, parent=namespace.attr('scope:'),
        secondaries=[('scope:', [])])
      method = metax.c.MethodConstruct.NewFromData(
        'f', context, parent=klass.attr('scope:'))
      method.myclassIs(klass)

      Chk('True', 'bool', ooplpy.analyzeVariable('true', executable=method))
      Chk('False', 'bool', ooplpy.analyzeVariable('false', executable=method))
      Chk('None', 'cls.Null', ooplpy.analyzeVariable('null', executable=method))
      Chk(metax.c.SELF, '&nm.sp.Card', ooplpy.analyzeVariable('self', executable=method))
    end method analyzeVariable;

    method initCode #:
      Write baselang code to initialize all uninitialized fields in preamble
    params:
      var method : ExecutableConstruct #:
        The method for which super code is desired.
      var output : vec<str> #:
        Where to append lines of baselang code representing the super-call.
    scope:
      stmtend = self.config('stmtend')
      recsepstr = self.receiverStr(method, style='base', sep=True)

      myclass = method.myclass()
      initmap = self.analyzeExecutableForFields(method)
      scope_attr = method.attr('scope:', default=None)
      attrkind = method.attrval('kind')
      basel = self.baselang().id()
      params = method.parsedParams()
      fieldmap = params.get('fields', {})

      for field in myclass.fields():
        fid = field.id()
        metatype = field.attrval('type')
        fkind = field.attrval('kind')

        /# We first see if the field exists in fieldmap
        defval = fieldmap.get(fid, None)
        if defval is None:
          /# TODO(wmh): Should we do LOOKUP on 'default' to get '<special>', or
          /# set it to null here?
          default = field.attrval('default', default=None)
          defval = self.formatExpr(default, metatype, field)
        if fkind == 'static':
          /# Static fields are not initialized in initializers. They are handled
          /# on a per-baselang basis in FieldConstruct.translateMeta(),
          /# *Oopl.formatFieldDefintiion(), etc.
          pass
        elif fid in initmap:
          /# There is an explicit initialization of this field in the
          /# user-provided code, so we do NOT provide a default initialization.
          fval = initmap[fid]
          /# print 'HERE with %s and %s = %s = %s' % (method.fqn(), fid, fval, defval)
          if fval == defval:
            method.metafile().warning(
              'Explicit initalization of %s to %s not necessary (is default)' %
              (fid, defval), attr=scope_attr)
        elif basel == 'cpp' and metatype.isValue() and not metatype.isPrimitive():
          /# There is no need to initialize the field, because C++ has already
          /# invoked a constructor on the field class to initialize the field
          /# before this method was entered.
          /# print 'Skipping %s = %s' % (field.rawfield(), defval)
          pass
        else:
          output.append(
            '%s%s = %s%s' % (recsepstr, field.rawfield(), defval, stmtend))
    test:
      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      metafile = test.parserFor('Oopl', '')
      filec = metax.c.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.c.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.c.ClassConstruct.NewFromData(
        'Card', context, parent=namespace.attr('scope:'),
        secondaries=[('scope:', [])])
      method = metax.c.MethodConstruct.NewFromData(
        '__init__', context, parent=klass.attr('scope:'),
        secondaries=[('scope:', [])])
    end method initCode;

    method analyzeExecutableForFields : map #:
      Analyze an executable (simple) block looking for explicit field references.

      Returns:
        Mapping from fieldname to value.
        Will be empty if the scope: of the executable is complex.
    params:
      var executable : ExecutableConstruct #:
        The executable for which a receiver is desired.
    scope:
      initmap = {}
      stmtend = self.config('stmtend')

      location = executable.attrval('location')
      scope, lines = executable.attrpair('scope:', default=None)
      initmap = {}

      /# Look for field assignments in the source code.
      /#  - The user is always allowed to refer to receiver by baselang
      /#    syntax ('self.' in python, 'this->' in C++, etc.)
      /#  - The user may also refer to the receiver by a special meta-level
      /#    name, dictated by the 'location' of the method (user, test, meta)
      /#    and which always uses '.' to access methods/state.
      /#     - for location user the variable is self
      /#     - for location test the variable is test
      /#     - for location meta the variable is meta
      if scope and scope.isSimpleBlock():
        recs = set()
        baserec = self.receiverStr(
          executable, style='base', location=location, sep=True)
        recs.add(baserec)
        if baserec == 'this->':
          recs.add('(*this).')
        metarec = self.receiverStr(
          executable, style='meta', location=location, sep=True)
        recs.add(metarec)
        recstr = '|'.join([re.escape(rec) for rec in recs])

        /# print '%-12s  %s = %s' % (self.id(), location, recstr)

        fre = re.compile(
          /# Note that we only consider assignments that are NOT indented,
          /# as they are the only ones guaranteed to always be executed.
          /# For example, if we have the code:
          /#   if some_expr:
          /#     self._debug = True
          /# we cannot assume self._debug is always initialized, so we must
          /# provide a default initialization in the preamble.
          r'^'
          r'(?P<rec_op>' + recstr + ')'
          r'(?:'
          /# Intentionally not looking for statement terminator in case the
          /# value continues on next line (in which case <rawval> won't be
          /# fully correct but will at least detect the field initialization).
          r'(?P<rawfield>[a-zA-Z0-9_]+)\s*=\s*(?P<rawval>.*)'
          r'|'
          /# Intentionally not closing parenthesis in case it continues on
          /# next line (in which case <value> won't be fully correct but will
          /# at least detect the field initialization.
          r'(?P<field>[a-zA-Z0-9_]+)Is\s*\((?P<value>.*)'
          r')')
        for line in lines:
          m = fre.search(line)
          if m:
            /# print m.groupdict()
            rawfield = m.group('rawfield')
            if rawfield:
              /# CODETANGLE(fieldinit): See FieldConstruct.expandMeta(), which
              /# specifies how rawfields are formed from field names. 
              /# TODO(wmh): Generalize this code to use the 'field_prefix' and
              /# 'field_suffix' keys of Context.TOKENS. Make sure to handle
              /# public fields that do not make a difference between rawfield
              /# and field.
              fname = rawfield
              if fname[0] == '_':
                fname = fname[1:]
              fval = m.group('rawval').rstrip(stmtend).rstrip()
            else:
              fname = m.group('field')
              fval = re.sub(r's*\);?\s*$', '', m.group('value'))
            /# print 'LINE: %s [fname=%s fval=%s]' % (line, fname, fval)
            initmap[fname] = fval
      return initmap
    test:
      init_lines = [
        'self._py_js_cc = 1',
        'bob.c = 2',
        'self.pyjsccIs(21)',
        'this->cc = 7;',
        'this->cc2Is(8);',
        'meta._height = 183',
        'meta.weightIs(50);',
      ]

      def Chk(basel, location, expected):
        test.defineClassAndMethods(basel, init_lines=init_lines)
        baselang = test.baselang
        init = test.initializer
        location_attr = init.attr('location')
        assert location_attr.value() == 'user'
        try:
          location_attr.valueIs(location)
          test.iseq(expected, baselang.analyzeExecutableForFields(init))
        finally:
          location_attr.valueIs('user')

      Chk('py', 'user', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk('js', 'user', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk('cc', 'user', {'cc': '7', 'cc2': '8', 'pyjscc': '21', 'py_js_cc': '1'})

      Chk('py', 'meta', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk('js', 'meta', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk('cc', 'meta', {'cc': '7', 'cc2': '8', 'pyjscc': '21', 'py_js_cc': '1'})

    end method analyzeExecutableForFields;

    method defaultValue : str #:
      The default value for a given metatype.
    params:
      var metatype : Type;
    scope:
      if metatype.isPtr():
        default = self.pseudovars()['null']
      elif metatype.isStr():
        /# Special handling.
        default = self.metabase(metatype.raw(), kind='default')
      elif metatype.isRef():
        raise Error('No defaults for ref type %s' % metatype.raw())
      else:
        default = self.metabase(metatype.base(), kind='default')
      return default
    test:
      py, _, _, _ = test.cachedInfo(basel='python')
      MetaType = metax.c.Type.Instance
      test.iseq('0', py.defaultValue(MetaType('@int')))
      test.iseq('None', py.defaultValue(MetaType('*int')))
      test.iseq('0.0', py.defaultValue(MetaType('@double')))
      test.iseq('None', py.defaultValue(MetaType('*str')))
      test.iseq('None', py.defaultValue(MetaType('str')))
      test.iseq("''", py.defaultValue(MetaType('&str')))
      test.iseq("''", py.defaultValue(MetaType('@str')))
    end method defaultValue;

    method simpleToBase : vec<str> #:
      Given a SimpleBlock, return the contents converted to
      this baselang.
    params:
      var simple : SimpleBlock #:
        The block to convert. If null, method is a noop.
      var output : vec<str> = null #:
        Where to write output.  If not given, new list is returned.
      var comment : bool = false #:
        If true, each line added to output is preceeded by the baselang
        comment character (and meta comments are not escaped).
      var strip_comments : bool = false #:
        If true, any meta-level comment prefixes are simply removed, rather
        than being replaced with the base-lang comment prefix. Useful when
        obtaining the lines in a 'comment:' attribute in which lines have
        been explicitly (and unnecessarily) quoted.
      var strip_empty : bool = false #:
        If true, empty lines at the beginning and end of the block are
        removed.
      var replace_receiver : bool = false #:
        If true, replace meta-level receiver variables with baselang version.
    scope:
      if output is None:
        output = []
      rem = '' if strip_comments else self.config('rem')
      if simple is None:
        pass
      elif comment:
        /# We are to add the content of simple preceeded by baselang comments.
        if rem:
          rem += ' '
        for line in simple.value():
          output.append(rem + line)
      else:
        /# We perform a small set of rewrites on the user-provided data.
        /#  - '^ */# ' is replaced with baselang comment one-line comment
        /#  - meta-level receiver replaced with baselang receiver.
        /#     - must be careful not to replace things that aren't receivers!
        /#     - to do a truly safe job, will need to parse the baselang,
        /#       but for now we use a heuristic.
        /#  - replace __metafile__ with the absolute path of the .meta file
        /#    that the __metafile__ is found within.
        /#  - IMPORTANT: The replacement of '^ *>|' with '' does NOT occur
        /#    here
        parent = simple.parent()
        if replace_receiver and isinstance(parent, ExecutableConstruct):
          baserec = self.receiverStr(parent, deref=True)
          metarec = self.receiverStr(parent, style='meta')
          /# This regexp is carefully crafted to avoid grabbing non-receivers:
          /#  - the basics: don't replace inside another variable
          /#  - a bit more subtle: do not replace '.test.var' ... that is NOT
          /#    the 'test' receiver.
          /#  - TODO(wmh): avoid replacing within string literals!
          recre = re.compile(r'(^|[^a-zA-Z0-9_.])%s\.' % metarec)
          replacement = r'\1%s.' % baserec
          /# print 'For %s base=%s meta=%s auto=%s repl=%s' % (parent.kindfqn(), baserec, metarec, parent.autogen(), replacement)
        else:
          recre = None

        comre = re.compile(
          r'^( *)%s( ?)(.*)' % re.escape(Context.TOKENS['remark']))
        lines = simple.value()
        s = 0
        e = len(lines)
        if strip_empty:
          while s < e and not lines[s].strip():
            s += 1
          while e > 0 and not lines[e-1].strip():
            e -= 1

        /#metac = metafile.compiler()
        /#fs = metac.fs()
        metafile = simple.parent().metafile()
        metafile_str = "'" + metafile.path() + "'"

        for i in range(s, e):
          line = lines[i]
          line = line.replace('__meta' + 'file__', metafile_str)
          m = comre.match(line)
          if m:
            line = m.group(1) + rem + ('' if strip_comments else m.group(2)) + m.group(3)
          if recre:
            line = recre.sub(replacement, line)
          output.append(line)
      return output
    test:
    end method simpleToBase;

    method formatBuildRule : str #:
      Form a BUILD rule from data.

      Returns:
        A multi-line string representing a BUILD target definition.
    params:
      var rule : str #:
        The name of the BUILD rule to generate.
        Example: cc_library, cc_test, java_test, etc.
      var data : map #:
        See, for example, http://www.bazel.io/docs/be/c-cpp.html.
    scope:
      lines = [rule + '(']
      k = set(data)
      keys = []
      for key in ('name', 'main', 'srcs', 'hdrs', 'data', 'deps', 'tests'):
        if key in data:
          k.remove(key)
          keys.append(key)
      keys.extend(sorted(k))
      for key in keys:
        value = data[key]
        if isinstance(value, basestring):
          lines.append('  %s = "%s",' % (key, value))
        elif isinstance(value, int):
          lines.append('  %s = %d,' % (key, value))
        elif isinstance(value, (list, set)):
          /# TODO(wmh): This is a hack to get meta2 code working while using
          /# root.meta from meta1. When we have root.meta2 implemented we can
          /# remove this hackery
          if key == 'deps' and self.id() == 'python':
            for i in range(0, len(value)):
              m = re.match(r'//meta/([^:]+):.*', value[i])
              if m:
                value[i] = '//meta:%s' % m.group(1)
          /# End hackery

          if len(value) == 0:
            pass
          elif len(value) < 2:
            lines.append(
              '  %s = [%s],' %
              (key, ', '.join(["'%s'" % elem for elem in value])))
          else:
            lines.append('  %s = [' % key)
            for elem in value:
              lines.append('    "%s",' % elem)
            lines.append('  ],')
        else:
          raise Error('Invalid build rule data value: %s' % str(value))
      lines.append(')')
      return '\n'.join(lines)
    end method formatBuildRule;

    method nameToBuildTarget : str #:
      Convert a name to BUILD target.
    params:
      var fqn : str #:
        The fully qualified  name to convert to a target.
        If null or empty, returns null.
      var lib : bool = false #:
        If true, the fqn is a namespace, not a class.
    scope:
      if fqn:
        parts = fqn.split(Context.TOKENS['scope_sep'])
        if lib:
          last = parts[-1]
        else:
          last = parts.pop()
        target = '//' + '/'.join(parts) + ':' + last
      else:
        target = None
      return target
    test:
    end method nameToBuildTarget;

    method parseComment : tuple<SimpleBlock,map> #:
      Obtain and parse a comment.

      Almost every construct in Meta(Oopl) supports a simple-block 'comment:'
      secondary attribute. This method obtains the SimpleBlock and a parsed
      representation of the lines in it.

      Returns:
       0) The comment SimpleBlock
       1) A map containing:
         user: vec<str>
         returns: vec<str>
         actions: map
    params:
      var construct : Construct = null #:
        The construct whose comment is to be parsed. One of 'construct' or
        'attribute' must be provided.
      var attribute : SimpleBlock = null #:
        The SimpleBlock representing the comment. One of 'construct' or
        'attribute' must be provided.
      var parse_return : bool = false #:
        If true, look for a 'Returns:' section.
    scope:
      /# The comment simple block of an executable has the following structure:
      /#   <comment> ::-
      /#      <text> [<nl> 'Returns:' <return_text>]
      if not attribute:
        if not construct:
          raise Error('Must provide either attribute or construct')
        attribute, lines = construct.attrpair('comment:', default=None)
      else:
        lines = attribute.value()

      userlines = []
      retlines = []
      specials = {}

      if lines:
        inret = False
        retstr = 'Returns:'
        prefix = Context.TOKENS['remark'] + ' '
        spre = BaseLanguageOopl.SPECIAL_RE
        metafile = self.metafile()

        for i, line in enumerate(lines):
          if parse_return and line.startswith(retstr):
            t = line[len(retstr):]
            if t:
              /# We have found the 'Returns:' marker, so all subsequent lines
              /# go to retlines instead of userlines.
              metafile.error(
                'No text allowed after "Returns:"',
                line=attribute.line() + i)
              retlines.append(t)
            inret = True
          else:
            /# We remove meta-level comment prefixes from the comment.
            if line.startswith(prefix):
              line = line[len(prefix):]

            /# We check if the line matches a special control line.
            m = spre.match(line)
            if m:
              /# We found a special action line. It is consumed and the data
              /# stored in specials.
              action = m.group('action')
              if action in specials:
                metafile.error(
                  'Invalid repeat of special "%s"' % action,
                  line=attribute.line() + i)
              else:
                specials[action] = m.group('text')
            elif inret:
              retlines.append(line)
            else:
              userlines.append(line)

      data = {'user': userlines, 'special': specials}
      if parse_return:
        data['returns'] = retlines

      return (attribute, data)
    test:
    end method parseComment;

    remark #:
      The following are template methods that subclass must define. Each
      is defined by a behavior.

      accessorType(ftype:Type,acc:str):Type
      augmentVarset(construct:Construct,varset:VarSet)
      buildPreambleText():str
      classSubPath(klass:ClassConstruct):str
      createBuildFragment(
        construct:Construct,targets:vec<str>,
        test:bool=false,name:str=null,src:str=null)
      emptyBlockCode(returns:Type,message:str=null):vec<str>
      finalizerName(klass:ClassConstruct):str
      formatClassConstruct(
        attribute:SimpleBlock,width:int=80,suppress:map=null):vec<str>
      formatClassType(metafile:MetaFile,cstr:str):str
      formatComment(comment:vec<str>,width:int=80):vec<str>
      formatDependencies(
        class_construct:ClassConstruct,
        triples:vec<tuple<str,str,str>>):tuple<vec<str>,vec<str>>
      formatDependency(
        class_construct:ClassConstruct,
        triples:vec<tuple<str,str,str>>,index:int):tuple<str,str>
      formatFieldDefinition(field:FieldConstruct):vec<str>
      formatMethodComment(construct:ExecutableConstruct,width:int=80):vec<str>
      formatParams(
        executable:ExecutableConstruct,
        preamble:vec<str>,decl:bool=false):vec<str>
      formatParentSpec(
        class_construct:ClassConstruct):tuple<str,tuple<str,str,str>>
      initializerName(klass:ClassConstruct):str
      metaMethodBody(metainst:str,metaclass:ClassConstruct):vec<str>
      parseBazelLog(logdata:str,tdata:map,debug:bool=false):any
      repl()
      superCode(method:ExecutableConstruct,output:vec<str>,width:int=80):void
      _annotateBaseType(metatype:Type,basetype:str):str
    end;

  end class BaseLanguageOopl;

  class OoplPython < BaseLanguageOopl #:
    Functionality for compiling Meta(Oopl) code into Python.
  assocs:
    std assoc code;
  scope:

    lifecycle params:
      var id : str;
      var parent : ComplexBlock;
      var context : Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('python')
      self.nameIs('Python')
      self.suffixesIs(['py'])

      strptr = {'base': 'str', 'default': 'None'}
      self.metatypesIs({
        'bool': {'base': 'bool', 'default': 'False'},
        'char': {'base': 'str', 'default': "''"},
        'int': {'base': 'int', 'default': '0'},
        'uint': {'base': 'int', 'default': '0'},
        'real': {'base': 'float', 'default': '0.0'},
        'double': {'base': 'float', 'default': '0.0'},
        'float': {'base': 'float', 'default': '0.0'},
        /# The 'str' type has some special handling.
        /#   *str and str should be the same
        /#   &str should be a version that cannot be null
        /#   @str may be disallowed or will be same as &str.
        /#   (see BaseLanguageOopl.{typeToBase,metabase}).
        'str': strptr,
        '*str': strptr,
        '&str': {'base': 'str', 'default': "''"},
        '@str': {'base': 'str', 'default': "''"},
        'string': {'base': 'str', 'default': 'None'},
        'vec': {'base': 'list', 'default': '[]'},
        'map': {'base': 'dict', 'default': '{}'},

        'ostream': {'base': 'file', 'default': 'sys.stdout'},
        'istream': {'base': 'file', 'default': 'sys.stdin'},
        'strstream': {'base': 'file', 'default': 'None'},

        /# TODO(wmh): Need a better means of specifying regexp class in python.
        'regexp': {'base': 're._pattern_type', 'default': 'None'},

        'nulltype': {'base': 'types.NoneType', 'default': 'None'},
        'class': {'base': 'type', 'default': 'None'},
        'method': {'base': 'types.MethodType', 'default': 'None'},
        'function': {'base': 'types.LambdaType', 'default': 'None'},

        /# How to handle 'void' is still being worked out.
        'void': {'base': 'void', 'default': None},
      })

      /# https://docs.python.org/3/reference/lexical_analysis.html#keywords
      self.keywordsIs(
        /# import keyword; keyword.kwlist
        ['and', 'as', 'assert', 'break', 'class', 'continue',
         'def', 'del', 'elif', 'else', 'except', 'exec',
         'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is',
         'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try',
         'while', 'with', 'yield'])

      self.updateConfigs({
        'namespace_primary': True,
        'definition_separate': False,
        'rem': '#',
        'self': 'self',
        'cls': 'cls',
        'selfsep': '.',
        'stmtend': '',

        'setup': {'name': 'setUp'},  # https://docs.python.org/2/library/unittest.html#test-cases
        'teardown': {'name': 'tearDown'},
        'setupcase': {'name': 'setUpClass', 'level': 'meta'},
        'teardowncase': {'name': 'tearDownClass', 'level': 'meta'},
      })

      self.pseudovarsIs({
        'self': SELF,
        'true': 'True',
        'false': 'False',
        'null': 'None',
        /# TODO(wmh): Accumulate the values used across various baselangs and
        /# decide what should be used for stdin, stdout and stderr. Using
        /# 'in' and 'out', 'err' may be too ambiguous ... might be more
        /# readable to prefix with 'std' or something else.
        'out': 'sys.stdout',
        'in': 'sys.stdin',
        'err': 'sys.stderr',
      })
    end;

    test
    lifecycle setup:
      baselang, _, context, _ = self.cachedInfo(basel='python')
      self.baselang = baselang
      self.context = context
    end lifecycle;
  end class OoplPython;

  class OoplJavascript < BaseLanguageOopl #:
    Functionality for compiling Meta(Oopl) code into Javascript

    References:
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
      https://www.nczonline.net/blog/2014/01/21/private-instance-members-with-weakmaps-in-javascript/
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
      http://javascriptissexy.com/oop-in-javascript-what-you-need-to-know/
      http://davidbcalhoun.com/2011/different-ways-of-defining-functions-in-javascript-this-is-madness/
      https://philipwalton.com/articles/implementing-private-and-protected-members-in-javascript/
      https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/

    Important:
      - When generating javascript code for method scope, keep the commentary
        from https://www.sitepoint.com/google-closure-how-not-to-write-javascript/
        in mind.
  assocs:
    std assoc subprocess;
  scope:

    lifecycle params:
      var id : str;
      var parent : ComplexBlock;
      var context : Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('javascript')
      self.nameIs('Javascript')
      self.suffixesIs(['js'])

      /# In javascript, which lacks static typing, this type mapping wouldn't
      /# usually be as important as in languages with static typing. However,
      /# because we are using Google Closure, which enforces static typing
      /# information more stringently than many statically typed languages,
      /# the mapping becomes quite important.
      /#
      /# See
      /#   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
      /#   https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System
      /#   https://developers.google.com/closure/compiler/docs/js-for-compiler
      strptr = {'base': 'string',  'default': 'null' }
      self.metatypesIs({
        'bool':   {'base': 'boolean', 'default': 'false'},
        'char':   {'base': 'str',     'default': "''"   },
        'int':    {'base': 'number',  'default': '0'    },
        'uint':   {'base': 'number',  'default': '0'    },
        'real':   {'base': 'number',  'default': '0.0'  },
        'float':  {'base': 'number',  'default': '0.0'  },
        'double': {'base': 'number',  'default': '0.0'  },
        /# The 'str' type has some special handling.
        /#   *str and str should be the same
        /#   &str should be a version that cannot be null
        /#   @str may be disallowed or will be same as &str.
        /#   (see BaseLanguageOopl.{typeToBase,metabase}).
        'str':    strptr,
        '*str':   strptr,
        '&str':   {'base': 'string',  'default': "''"   },
        '@str':   {'base': 'string',  'default': "''"   },
        'string': {'base': 'String',  'default': 'null' },
        'vec':    {'base': 'Array.<%(TV)s>',   'default': '[]'   },
        /# TODO(wmh): Need to distinguish between map (keys can be anything) and
        /# smap (keys are always strings).  The builtin Map class should be
        /# used instead of Object (and literal {} needs to be handled somehow).
        'map':    {'base': 'Object.<%(TK)s,%(TV)s>',  'default': '{}'   },
        'any':    {'base': '*', 'default': None},

        /# IO in Javascript ... via phantomjs 'fs' module?
        /#   http://phantomjs.org/api/fs/
        'ostream': {'base': 'Object', 'default': 'null'},
        'istream': {'base': 'Object', 'default': 'null'},
        'strstream': {'base': 'Object', 'default': 'null'},

        'regexp': {},

        /# https://www.w3schools.com/js/js_datatypes.asp
        'nulltype': {'base': 'Object', 'default': 'null'},
        'class': {'base': 'Object', 'default': 'null'},
        'method': {'base': 'Function', 'default': 'null'},
        'function': {'base': '(Function|string)', 'default': 'null'},
        /# NOTE(wmh): TestCase.raises() accepts a function, and closure is
        /# insisting it be (Function|string). I can easily imagine other
        /# variations on this, so we may need to generalize or hack.

        /# How to handle 'void' is still being worked out.
        'void': {'base': 'void', 'default': None},
      })

      /# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Reserved_Words
      self.keywordsIs(
        [
          'break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete',
          'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof',
          'new', 'return', 'switch', 'this', 'throw', 'try', 'typeof', 'var',
          'void', 'while', 'with',
          /# future
          'class', 'enum', 'export', 'extends', 'import', 'super',
          /# future if strict
          'implements', 'interface', 'let', 'package', 'private', 'protected',
          'public', 'static', 'yield',
        ])

      self.updateConfigs({
        'namespace_primary': False,
        'definition_separate': False,
        'rem': '//',
        'self': 'this',
        'cls': 'this',
        'selfsep': '.',
        'stmtend': ';',

        'setup': {'name': 'setUp', 'level': 'instance'},  # $CLOSURE_ROOT/library/closure/goog-orig/testing/testcase.js
        'setupcase': {'name': 'setUpPage', 'level': 'instance'},
        'teardown': {'name': 'tearDown', 'level': 'instance'},
        'teardowncase': {'name': 'tearDownPage', 'level': 'instance'},

        /# specific to this baselang.
        'use_es2015': True,
      })

      self.pseudovarsIs({
        'self': SELF,
        'true': 'true',
        'false': 'false',
        'null': 'null',
        'out': '?',
        'in': '?',
        'err': '?',
      })
    end;

    test
    lifecycle setup:
      baselang, _, context, _ = self.cachedInfo(basel='javascript')
      self.baselang = baselang
      self.context = context
    end lifecycle;

    test
    method test_typeToBase scope:
      oopljs, _, context, _ = test.cachedInfo(basel='javascript')
      MetaType = metax.c.Type.Instance
      /# TODO(wmh): Decide how to deal with 'str'
      /#  - See notes in README.md in "Implementing interned string support".
      test.iseq('?string', oopljs.typeToBase(MetaType('str')))
      test.iseq('?string', oopljs.typeToBase(MetaType('*str')))
      test.iseq('!string', oopljs.typeToBase(MetaType('&str')))
      test.iseq('!string', oopljs.typeToBase(MetaType('@str')))
    end method;

  end class OoplJavascript;

  class OoplCpp < BaseLanguageOopl #:
    Functionality for compiling Meta(Oopl) code into C++

    Notes on Bazel:
     - For C++, Bazel uses a CROSSTOOL file to specify details about
       the C++ compiler and associated programs used to interact with
       the C++ code.
     - One can provide a custom toolchain, but it is currently non-trivial:
       - About the CROSSTOOL: https://github.com/bazelbuild/bazel/wiki/About-the-CROSSTOOL
       - Building with a custom toolchain: https://github.com/bazelbuild/bazel/wiki/Building-with-a-custom-toolchain
       - Generating C++ crosstool with a Skylark Remote Repository: https://bazel.build/designs/2016/02/16/cpp-autoconf.html
       - Using Skylark remote repositories to auto-detect the C++ toolchain: https://blog.bazel.build/2016/03/31/autoconfiguration.html
       - Yet Another CROSSTOOL Writing Tutorial: https://github.com/bazelbuild/bazel/wiki/Yet-Another-CROSSTOOL-Writing-Tutorial

    Documentation on CROSSTOOL:

  assocs:
    std assoc subprocess;
  scope:

    meta
    lifecycle scope:
      /# cls.CC_ANY = 'long long'
      cls.CC_ANY = 'void*'
      cls.CC_STR = 'const std::string'
      cls.CC_STR_VALUE = 'std::string'
      cls.PTR_MAP = {
        'u': 'std::unique_ptr',
        's': 'std::shared_ptr',
        'w': 'std::weak_ptr',
      }
    end;

    lifecycle params:
      var id : str;
      var parent : ComplexBlock;
      var context : Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('cpp')
      self.nameIs('C++')
      self.suffixesIs(['cc', 'h'])

      /# See
      /#  http://en.cppreference.com/w/cpp/language/types
      strptr = {'base': OoplCpp.CC_STR, 'default': 'nullptr'}
      self.metatypesIs({
        'bool': {'base': 'bool', 'default': 'false'},
        'char': {'base': 'char', 'default': "''"},
        'int': {
           #  http://en.cppreference.com/w/cpp/types/integer
           0: True,
           8: {'base': 'int8_t',  'default': '0'},
          16: {'base': 'int16_t', 'default': '0'},
          32: {'base': 'int32_t', 'default': '0'},
          64: {'base': 'int64_t', 'default': '0'},
          None: {'base': 'int32_t', 'default': '0'},
        },
        'uint': {
          0: True,
          7: {'base': 'uint8_t', 'default': '0'},
          15: {'base': 'uint16_t', 'default': '0'},
          31: {'base': 'uint32_t', 'default': '0'},
          63: {'base': 'uint64_t', 'default': '0'},
          None: {'base': 'int', 'default': '0'},
        },
        'real': {
          0: True,
          32: {'base': 'float', 'default': '0.0'},
          64: {'base': 'double', 'default': '0.0'},
          80: {'base': 'long double', 'default': '0.0'},
          None: {'base': 'float', 'default': '0.0'},
        },
        /# The 'str' type has some special handling.
        /#   *str and str should be the same
        /#   &str should be a version that cannot be null
        /#   @str may be disallowed or will be same as &str.
        /#   (see BaseLanguageOopl.{typeToBase,metabase}).
        'str': strptr,
        '*str': strptr,
        '&str': {
          'base': OoplCpp.CC_STR, 'default': 'std::string("")'},
        '@str': {
          'base': OoplCpp.CC_STR_VALUE, 'default': 'std::string("")'},
        'string': {'base': 'std::string', 'default': 'std::string("")'},
        'vec': {'base': 'std::vector<%(TV)s>', 'default': None},
        'map': {'base': 'std::map<%(TK)s,%(TV)s>', 'default': None},
        'void': {'base': 'void', 'default': None},
        'any': {'base': OoplCpp.CC_ANY, 'default': None},

        'ostream': {'base': 'std::ostream', 'default': 'std::cout'},
        'istream': {'base': 'std::istream', 'default': 'std::cin'},
        'strstream': {'base': 'std::stringstream', 'default': 'std::stringstream()'},

        'regexp': {},

        'nulltype': {'base': 'std::nullptr_t', 'default': 'nullptr'},
        /# TODO(wmh): Change to metax.root.ObjectMetaRoot when we have support
        /# for including required implicit targets implemented.
        /# TODO(wmh): Change 'long long' to 'std::any' when c++17 support available
        /# in bazel.
        'class': {'base': OoplCpp.CC_ANY, 'default': 'nullptr'},
        /# TODO(wmh): Can we use std::function? Sometimes (e.g.
        /# TestCase.raises()) we do not know the signature ... can std::function
        /# handle varargs?
        'method': {'base': 'void*', 'default': 'nullptr'},
        'function': {'base': 'void*', 'default': 'nullptr'},

        /# How to handle 'void' is still being worked out.
        'void': {'base': 'void', 'default': None},
      })

      self.keywordsIs(
        /# http://en.cppreference.com/w/cpp/keyword
        ['alignas', 'alignof', 'and', 'and_eq', 'asm', 'auto', 'bitand', 'bitor',
         'bool', 'break', 'case', 'catch', 'char', 'char16_t', 'char32_t', 'class',
         'compl', 'const', 'constexpr', 'const_cast', 'continue', 'decltype',
         'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
         'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend',
         'goto', 'if', 'inline', 'int', 'long', 'mutable', 'namespace', 'new',
         'noexcept', 'not', 'not_eq', 'nullptr', 'operator', 'or', 'or_eq',
         'private', 'protected', 'public', 'register', 'reinterpret_cast',
         'return', 'short', 'signed', 'sizeof', 'static', 'static_assert',
         'static_cast', 'struct', 'switch', 'template', 'this', 'thread_local',
         'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union',
         'unsigned', 'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while',
         'xor', 'xor_eq'])

      self.updateConfigs({
        'namespace_primary': False,
        'definition_separate': True,
        'rem': '//',
        'self': 'this',
        'cls': 'this',
        'selfsep': '->',
        'stmtend': ';',

        /# https://github.com/google/googletest/blob/master/googletest/docs/Primer.md
        'setup': {'name': 'SetUp', 'dispatch': 'virtual'},
        'setupcase': {'name': 'SetUpTestCase', 'level': 'static'},
        'teardown': {'name': 'TearDown', 'dispatch': 'virtual'},
        'teardowncase': {'name': 'TearDownTestCase', 'level': 'static'},
      })

      self.pseudovarsIs({
        'true': 'true',
        'false': 'false',
        'null': 'nullptr',
        'out': 'std::cout',
        'in': 'std::cin',
        'err': 'std::cerr',
        'self': SELF,
      })

    end lifecycle;

    test
    lifecycle setup:
      baselang, _, context, _ = self.cachedInfo(basel='cpp')
      self.baselang = baselang
      self.context = context
    end lifecycle;

    test
    method test_typeToBase #:
      BaseLanguageOopl.typeToBase usually does not need overriding, but
      it is still useful to have some C++-specific tests for it.
    scope:
      baselang, _, context, _ = test.cachedInfo(basel='cpp')
      MetaType = metax.c.Type.Instance
      cc_str = metax.c.OoplCpp.CC_STR
      cc_str_value = metax.c.OoplCpp.CC_STR_VALUE

      test.iseq('%s*' % cc_str, baselang.typeToBase(MetaType('str')))
      test.iseq('%s'  % cc_str_value, baselang.typeToBase(MetaType('@str')))
      test.iseq('%s&' % cc_str, baselang.typeToBase(MetaType('&str')))
      test.iseq('%s*' % cc_str, baselang.typeToBase(MetaType('*str')))
    end method test_typeToBase;

  end class OoplCpp;

  behavior accessorType : Type #:
    The Type to use for a return value or arg of an accessor.

    Suppose a field has type T. What type should its getter, setter and
    reffer return? What is the type of the arg of the setter?
    This method answers those questions.
  params:
    var ftype : Type #:
      The type of the field for which a return type is desired.
    var acc : str #:
      One of 'get', 'set', 'setarg', or 'ref'.
    var namespace_function : function = null #:
      A function accepting no args that returns the namespace within which
      the Type appears.  Used to resolve relative class types.  If resolution
      is needed, it is an error not to provide such a function
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if acc == 'get':
        result = ftype
      elif acc == 'set':
        result = None
      elif acc == 'setarg':
        result = ftype
      elif acc == 'ref':
        result = ftype
      else:
        raise Error('Unhandled acc "%s"' % acc)
      return result
    test:
      metatype = metax.c.Type.Instance('*demo.cards1.Card')
      test.iseq(
        metatype, test.baselang.accessorType(metatype, 'get'))
      test.iseq(
        /# TODO(wmh): Decide whether setters return self or not. If they do,
        /# the return type here should be the klass, not None
        None, test.baselang.accessorType(metatype, 'set'))
      test.iseq(
        metatype, test.baselang.accessorType(metatype, 'ref'))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if acc == 'get':
        result = ftype
      elif acc == 'set':
        result = None
      elif acc == 'setarg':
        result = ftype
      elif acc == 'ref':
        result = ftype
      else:
        raise Error('Unhandled acc "%s"' % acc)
      return result
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      base = ftype.base() + ftype.paramStr()
      prefix = ftype.prefix()

      res = ''
      if acc == 'get':
        /# if T is primitive, getter is T
        /# If field is @T, getter is &#T
        /# If field is &T, getter is &#T
        /# If field is *T, getter is *#T
        /# If field is **T, getter is *#*#T
        if ftype.isPrimitive():
          result = ftype
        else:
          if ftype.isStr():
            /# We have the 'str' type. Note that 'str' is inherently const so
            /# we do NOT need to prefix the type with '#'.
            /#  get *str returns *str
            /#  get &str returns &str
            /#  get @str returns &str
            res = '*' if ftype.isPtr() else '&'
          elif ftype.isValue():
            /# The only possible prefixes are '@' and '@#'.
            res = '&#'
          elif ftype.isRef():
            /# The prefix starts with '&', then zero or more '*' each
            /# optionally preceeded by '#', then an optional '#'.
            /# (regexp '^&(?:#?\*)*#?$').  In all cases, we return a reference,
            /# with all pointers being const, and the base value itself
            /# also const.
            numast = prefix.count('*')
            res = '&' + '#*' * numast + '#'
          elif ftype.isPtr():
            /# Just like isRef() except does not start with '&'.
            numast = prefix.count('*')
            res = '#*' * numast + '#'
          else:
            raise InternalError('Should never reach this')
          result = Type.Instance(
            res + base, namespace_function=namespace_function)

      elif acc == 'set':
        /# We used to have setters return 'this', but with the concept of
        /# the '..' operator that is no longer needed.
        result = None

      elif acc == 'setarg':
        /# The setter arg type.
        /#  - we very rarely want pass-by-value semantics here (only for
        /#    primitives and 'super-light' class types like 'std::string_view')
        /#  - whether the arg should be const or not depends on whether we
        /#    are copying or moving ... how do we allow the user to specify
        /#    this?

        if ftype.isStr():
          cc_str = OoplCpp.CC_STR
          if cc_str == 'const std::string':
            if ftype.isPtr():
              result = Type.Instance('*std.string')
            else:
              result = Type.Instance('&#std.string')
          else:
            result = ftype
        else:
          /# TODO(wmh): We need to add more special-casing here.
          result = ftype

      elif acc == 'ref':
        /# If field is base const (#T, *#T, &#T, etc.), it is an error to
        /# generate a reffer for it.
        /# If field is @T, reffer is &T
        /# If field is &T, reffer is &T
        /# If field is *T, reffer is &*T
        result = None
        if ftype.isStr():
          /# If a field is of type 'str', it does not mean the field cannot
          /# be modified.  An 'int' type is conceptually interned (there is
          /# only one 7) but a variable of type 'int' can be assigned to a
          /# different number. So reffers are fine for strings.  The value
          /# type depends on which class is doing the implementing:
          /#   const std::string  --> use 'std::string&'       (special-case)
          /#   std::string_view   --> use 'std::string_view&'  (e.g &str)
          /#   metax::root::IStr  --> use 'metax::root::IStr&' (e.g &str)
          p = '*' if ftype.isPtr() else ''
          if OoplCpp.CC_STR == 'const std::string':
            result = Type.Instance('&' + p + 'std.string')
          else:
            res = '&' + p
        elif ftype.isBaseConst():
          raise Error('Cannot generate reffer for type "%s"' % ftype.raw())
        elif ftype.isValue():
          /# The only possible prefix is '@' (since '@#' is not allowed).
          res = '&'
        elif ftype.isRef():
          /# The prefix starts with '&', then zero or more '*' each
          /# optionally preceeded by '#' (regexp '^&(?:#?\*)*$').
          res = prefix
        elif ftype.isPtr():
          /# The prefix starts with '*' or '#*', then zero or more '*' each
          /# optionally preceeded by '#'. Cannot contain '&' or '@' anywhere.
          res = '&' + prefix
        else:
          raise InternalError('Should never reach this')

        if result is None:
          result = Type.Instance(
            res + base, namespace_function=namespace_function)
      else:
        raise Error('Unhandled acc "%s"' % acc)

      /# print '*** FTYPE %-5s %-20s %-20s %s' % (acc, ftype, result, self.typeToBase(result))

      return result
    test:
      MetaType = metax.c.Type.Instance
      test.iseq(
        'int',
        test.baselang.accessorType(MetaType('int'), 'get').raw())
      test.iseq(
        '&#demo.cards2.Card',
        test.baselang.accessorType(MetaType('&demo.cards2.Card'), 'get').raw())

      test.iseq(
        '#*#ostream',
        test.baselang.accessorType(MetaType('ostream'), 'get').raw())

      /# TODO(wmh): Add more.
    end receiver OoplCpp;

  end behavior accessorType;

  behavior _annotateBaseType : str #:
    Baselang specific metatype conversion to baselang.

    This is a template method invoked within typeToBase.
    Adds ptr/ref/const/etc annotations to a baselang basetype.

    Returns:
      The baselang version of the core part of metatype.
  params:
    var metatype : Type #:
      The meta-level type being converted.
    var basetype : str #:
      The baselang version of the core part of metatype.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      /# In Python:
      /#   @int is int
      /#   &int is not yet supportable
      /#   *int .... do we use meta.lang.Integer (java-like boxing?)
      /#
      /#   @vec is list
      /#   &vec is list
      /#   *vec is list
      /#
      /#   @map is dict
      /#   &map is dict
      /#   *map is dict
      /#
      /#   @str is not allowed (interned does not support copy semantics ... but we could use move semantics?)
      /#   &str is str
      /#   *str is str (implicitly const)
      return basetype
    test:
      baselang = test.baselang
      MetaType = metax.c.Type.Instance

      def Chk(expected, metatype, basetype):
        res = baselang._annotateBaseType(metatype, basetype)
        self.iseq(expected, res)

      Chk('demo.cards1.Card',
          MetaType('*demo.cards1.Card'), 'demo.cards1.Card')
      Chk('demo.cards1.Card',
          MetaType('*demo.cards1.Card'), 'demo.cards1.Card')
      Chk('demo.cards1.Card',
          MetaType('*demo.cards1.Card'), 'demo.cards1.Card')

      Chk('file', MetaType('ostream'), 'file')
      Chk('file', MetaType('&ostream'), 'file')
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# https://developers.google.com/closure/compiler/docs/js-for-compiler#types
      base = metatype.base()
      if metatype.isTemplate():
        result = basetype[1:]
        prefix = None
      elif metatype.isPtr():
        prefix = '?'
      else:
        prefix = '!'

      /# Javascript supports union types like '(Function|string)' [see
      /# http://usejsdoc.org/tags-type.html]. When specifying optional or
      /# required status, use '(?Function|?string)' rather than
      /# '?(Function|string)'.
      if basetype[0] == '(' and basetype[-1] == ')':
        result = (
          '(' +
          '|'.join([prefix + bt for bt in basetype[1:-1].split('|')]) +
          ')')
      else:
        result = prefix + basetype
      return result
    test:
      oopljs, _, context, _ = test.cachedInfo(basel='javascript')

      test.iseq(
        '!number',
        oopljs._annotateBaseType(metax.c.Type.Instance('int'), 'number'))
      test.iseq(
        '?number',
        oopljs._annotateBaseType(metax.c.Type.Instance('*int'), 'number'))
      test.iseq(
        '?Function',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('function'), 'Function'))
      test.iseq(
        '!Function',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('&function'), 'Function'))
      test.iseq(
        '(?Function|?string)',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('function'), '(Function|string)'))
      test.iseq(
        '(!Function|!string)',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('&function'), '(Function|string)'))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      /# In C++
      /#       @int is int
      /#       &int is int&
      /#       *int is int*
      /#
      /#       @vec is std::vector<T>
      /#       &vec is std::vector<T>&
      /#       *vec is std::vector<T>*
      /#
      /#       @map is std::hashmap<K,V>
      /#       &map is std::hashmap<K,V>&
      /#       *map is std::hashmap<K,V>*
      /#
      /#       @str is not allowed (interned does not support copy semantics ... but we could use move semantics?)
      /#       &str is const metax.lib.IStr&
      /#       *str is const metax.lib.IStr*
      /#
      /#         *T is T*
      /#        *#T is const T*
      /#        #*T is T*const
      /#       #*#T is const T*const
      /#        u*T is std::unique_ptr<T>
      /#       u*#T is std::unique_ptr<const T>
      /#       #u*T is const std::unique_ptr<T>
      /#      #u*#T is const std::unique_ptr<const T>
      /#
      /#       u**T is std::unique_ptr<T*>
      /#      u*s*T is std::unique_ptr<std::shared_ptr<T>>
      /#   #u*#s*#T is const std::unique_ptr<const std::shared_ptr<const T>>

      result = basetype.replace('.', '::')

      if metatype.isPtr():
        /# We handle any number of [#][usw]* specs.
        /#  - parts will contain (1 + 3K) elements, where
        /#     - K is the number of '*' chars
        /#     - parts[0] is either '' or '&'
        /#     - parts[1+k] is '#' if ptr const else ''
        /#     - parts[1+k+1] is 'u' or 's' or 'w' or ''
        /#     - parts[1+k+2] is empty except when 1+k+2==n-1 in which case it
        /#       is empty if the base type is not const and is '#' if the
        /#       base type is const.
        prefix = metatype.prefix()
        parts = Type.METATYPE_SPLIT.split(prefix)
        /#print '%-30s = %s' % (metatype.raw(), str(parts))

        n = len(parts)
        assert ((n-1)%3) == 0
        k = (n-1) / 3
        isconst = parts[-1] == '#'

        /# We process from the back.
        /#  - we start three back from the end
        i = n - 3
        first = True
        while i > 0:
          ptrconst = parts[i] == '#'
          special = parts[i+1]
          if special:
            /# We have something like u*T or #u*T or #u*#T
            if isconst:
              result = 'const ' + result
            result = OoplCpp.PTR_MAP[special] + '<' + result + '>'
            if ptrconst:
              result = 'const ' + result
          else:
            /# We have something like *T or #*T or #*#T
            result = result + '*'
            if ptrconst:
              result += 'const'
            if isconst and first:
              result = 'const ' + result
          i -= 3
          first = False
        if parts[0] == '&':
          result += '&'
      else:
        if metatype.isPtr():
          /# We have '&T' or '&#T' (anything else has a pointer and is handled
          /# above.
          /# TODO(wmh): Handle rvalue refs!
          result += '*'
        elif metatype.isRef():
          result += '&'
        if metatype.isBaseConst() and not result.startswith('const ') and not metatype.isStr():
          result = 'const ' + result
      return result
    test:
      baselang = test.baselang
      MetaType = metax.c.Type.Instance

      def Chk(expected, metatype, basetype):
        res = baselang._annotateBaseType(metatype, basetype)
        self.iseq(expected, res)

      Chk('nm::sp::A', MetaType('@nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A&', MetaType('&nm.sp.A'), 'nm.sp.A')

      Chk('nm::sp::A*', MetaType('*nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A', MetaType('@nm.sp.A'), 'nm.sp.A')

      Chk('const nm::sp::A*', MetaType('*#nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A*const', MetaType('#*nm.sp.A'), 'nm.sp.A')
      Chk('const nm::sp::A*const', MetaType('#*#nm.sp.A'), 'nm.sp.A')

      Chk('std::unique_ptr<nm::sp::A>',MetaType('u*nm.sp.A'), 'nm.sp.A')
      Chk('std::unique_ptr<const nm::sp::A>',MetaType('u*#nm.sp.A'), 'nm.sp.A')
      Chk('const std::unique_ptr<nm::sp::A>',MetaType('#u*nm.sp.A'), 'nm.sp.A')
      Chk('const std::unique_ptr<const nm::sp::A>',
          MetaType('#u*#nm.sp.A'), 'nm.sp.A')
      Chk('const std::unique_ptr<const nm::sp::A>',
          MetaType('#u*#nm.sp.A'), 'nm.sp.A')

      Chk('nm::sp::A**', MetaType('**nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A*const*', MetaType('*#*nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A*const*const', MetaType('#*#*nm.sp.A'), 'nm.sp.A')
      Chk('const nm::sp::A*const*', MetaType('*#*#nm.sp.A'), 'nm.sp.A')

      Chk('const std::weak_ptr<const const std::shared_ptr<'
          'const const std::unique_ptr<const nm::sp::A>>>',
          MetaType('#w*#s*#u*#nm.sp.A'), 'nm.sp.A')

      Chk('std::ostream*', MetaType('ostream'), 'std::ostream')
      Chk('std::ostream&', MetaType('&ostream'), 'std::ostream')

      Chk('const std::string&', MetaType('&str'), 'const std::string')
      Chk('std::string', MetaType('@str'), 'std::string')
    end receiver OoplCpp;

  end behavior _annotateBaseType;

  behavior augmentVarset #:
    Perform baselang-specific modifications of the varset.
  params:
    var construct : Construct;
    var varset : VarSet;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      kind = construct.kind()

      if kind == 'class':
        /# The __metaclass__ attribute of a class specifies the metaclass.
        metaclass = construct.metaclass()
        if metaclass:
          /# Remember that a class may not have a metaclass even if it is
          /# a user class (if autogen=nometa).
          preamble = varset.getValue('preamble')
          preamble.append('__metaclass__ = %s' % metaclass.id())
          variant = construct.variant()
          if variant in ('user', 'test'):
            /# Meta guarantees that for every user-level class nm.sp.Foo, there is
            /# a metaclass nm.sp.FooMeta and a singleton instance of that
            /# metaclass named nm.sp.MetaFoo. In python, since we've defined
            /# Foo.__metaclass__ to be FooMeta, MetaFoo is just Foo.
            postclass = varset.getValue('postclass')
            name = construct.id()
            postclass.append('')

            /# TODO(wmh): Look into the best way to handle this issue.
            /#  - When creating test classes, if we define:
            /#      MetaFooTest = FooTest
            /#    then the testcase infrastructure will invoke the tests on
            /#    the class twice (once via FooTest, once via MetaFootTest).
            /#  - For now, we do not define this variable for test classes,
            /#    and require users to use self.meta() to gain access to
            /#    the metaclass of a testclass.
            /#  - We should consider not defining the MetaFoo variable for
            /#    class Foo in any situation (require use of self.meta()).
            /#  - If Meta implemented its own xUnit infrastructure from
            /#    scratch (so baselangs do not use baselang-specific
            /#    implementations) we would have easy control over this kind
            /#    of issue.
            if variant == 'user':
              /# CODETANGLE(metainst_for_testclass)
              postclass.append(
                '%s = %s' % (ClassConstruct.MetaInstifyName(name), name))

        /# If this class has a clinit method, invoke it after the class
        /# definition.
        clinit = construct.clinit()
        if clinit is not None:
          postclass = varset.getValue('postclass')
          postclass.append('%s.%s()' % (construct.id(), clinit.id()))

      elif kind == 'method':
        attrkind = construct.attrval('kind')
        modifiers = varset.getValue('modifiers')
        if attrkind == 'cls':
          modifiers.append('@classmethod')
        elif attrkind == 'static':
          modifiers.append('@staticmethod')
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      kind = construct.kind()
      use_es2015_classes = self.config('use_es2015')

      if kind == 'class':
        namespace = construct.namespace()
        nmsp = namespace.id()
        clsname = construct.id()
        metaname = ClassConstruct.MetaifyName(clsname)

        /# In Javascript, an initial comment block with @fileoverview allows
        /# one to specify @suppress commands.
        local_list, _ = construct.suppressInfo()
        overview_lines = [' * @fileoverview']
        if local_list:
          overview_lines.append(' * @suppress {%s}' % ','.join(local_list))
        overview = '/**\n' + '\n'.join(overview_lines) + '\n */\n'
        varset.addVar('overview', overview)

        if construct.isTest() and not use_es2015_classes:
          varset.addVar('test_method_restr', '')
          /# We currently are not producing a 'goog.provide' statement in test
          /# classes (because this disables some implicit testing we currently
          /# rely on). However, goog.provide() is what ensures that the
          /# namespace is initialized. We ensure that the namespace is defined.
          /#  - TODO(wmh): There must be a cleaner way of doing this using
          /#    something in goog/base.js (e.g. goog.constructNamespace_) that
          /#    does not disable unittesting (which goog.provide apparently
          /#    does).
          /#  - TODO(wmh): If the top-level namespace is not defined by the
          /#    time this class is imported, closure will complain. I'm not
          /#    clear how to get around that, so the code has been organized
          /#    to ensure that a goog.require() of some class that does
          /#    define the toplevel namespace is present.
          imports = varset.getValue('imports')
          imports.append('')
          nparts = nmsp.split('.')
          for i in range(0, len(nparts)):
            npref = '.'.join(nparts[:i+1])
            if i == 0:
              imports.append('%s = %s || {};' % (npref, npref))
            else:
              imports.append(
                '/** @type {?Object} */ %s;  // find cleaner way' % npref)
              imports.append('%s = %s || {};' % (npref, npref))

        if use_es2015_classes:
          assert clsname == varset.getValue('class')
          underclass = construct.underclass()
          postclass = varset.getValue('postclass')

          /# We look for the (very special) situation where we are defining
          /# a class nm.sp.Foo whose parent is Foo, for some javascript
          /# builtin class (e.g. 'Object', 'Error', etc.). In such situations
          /# the code generated is:
          /#   class Foo extends Foo {...}
          /# which is obviously problematic. We fix this by change it to
          /#   class Foo_ extends Foo {...}
          /# and updating all relevant references to Foo_ instead of Foo.
          parentspec = varset.getValue('parentspec')
          if parentspec == ' extends ' + clsname:
            clsname += '_'
            varset.setValue('class', clsname)

          /# When defining javascript classes using ES2015 syntax (and the
          /# goog.module()), we need to add postamble to the class as follows:
          /#  - all variants (user, test, meta) need to specify the value of the
          /#    special 'exports' variable to the object (or objects) we want to
          /#    make visible to callers who goog.require() the module.
          /#     - for user and test, this is simply
          /#          exports = <classname>;
          /#       but for meta classes, this is:
          /#          exports = {<metainst>, <metaclass>};
          /#  - for meta classes, before setting exports, we need to create
          /#    the singleton Meta<classname> instance of <classname>Meta.
          /#  - for test classes, after setting exports, we need to invoke
          /#    the test-harness infrastructure.
          if construct.isMeta():
            if underclass:
              metaclass_instname = ClassConstruct.MetaInstifyName(underclass.id())
              /# Create the singleton instance of the metaclass.
              postclass.append(
                "const %s = new %s('%s', [], {});" %
                (metaclass_instname, clsname, construct.id()))

              /# Define the two-valued export.
              postclass.append(
                'exports = {%s, %s};' % (metaclass_instname, clsname))
            else:
              postclass.append('exports = %s;' % clsname)
          else:
            /# For both user and test classes we add a simple one-value 'export'.
            /# TODO(wmh): Is it necessary to make a module for the test class?
            /# Only if we want to allow other test classes to import this test
            /# class, which may indeed be useful.
            postclass.append('exports = %s;' % clsname)

            /# For test classes, we invoke the test machinery.
            if construct.isTest() and underclass:
              postclass.append('')
              postclass.append(
                /# TODO(wmh): For now, passing in the fully-qualified name of
                /# the test class, as opposed to the underlying user class,
                /# but if we can figure out how to change class names in
                /# all baselangs, it might be better to use the userlevel fqn.
                "var tc = new %s('%s');" % (clsname, construct.fqn()))
              postclass.append('tc.runSelfTests();')

      elif kind == 'method':
        dot = Context.TOKENS['scope_sep']
        myclass = construct.myclass()
        method_prefix = myclass.fqn()
        kind = construct.attrval('kind')
        if kind == 'instance':
          method_prefix += dot + 'prototype'
        elif kind == 'initializer':
          /# Javascript is a snowflake. In most languages, class nm.sp.Class has
          /# initializer nm.sp.Class.Class, but in javascript it is nm.sp.Class
          /# And while instance methods in Javascript are defined as
          /#   nm.sp.Class.prototype.methname = function ...
          /# the initializer is
          /#   nm.sp.Class = function ...
          method_prefix = dot.join(myclass.fqn().split(dot)[:-1])

          /# postmethod stores the invocation of the goog.inherits()
          if not use_es2015_classes:
            parentinfo = myclass.parentclasses()[0]
            varset.getValue('postmethod').append(
              'goog.inherits(%s, %s);' % (myclass.fqn(), parentinfo['fqn']))

          /# TODO(wmh): Use @name <class>#<method> per
          /#   https://stackoverflow.com/questions/10490713/how-to-document-the-properties-of-the-object-in-the-jsdoc-3-tag-this
          preamble = varset.getValue('preamble')
          baselang = construct.baselang()
          for field in myclass.fields():
            ftype = field.attrval('type', default=metax.c.LOOKUP)
            /# print 'HERE with %s = %s' % (str(ftype), baselang.typeToBase(ftype))

            /# TODO(wmh): See the comment within the scope of
            /# OoplJavascript.formatMethodComment() discussing defqn. We need
            /# to do the same thing here.
            preamble.append(
              '/** @type {%s} */ this.%s;' %
              (baselang.typeToBase(ftype, class_construct=myclass, defqn=True),
              field.rawfield()))

        method_prefix += dot
        varset.addVar('method_prefix', method_prefix)
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      kind = construct.kind()

      if kind == 'class':
        metaclass = construct.metaclass()
        underclass = construct.underclass()

        namespace = construct.namespace()
        fqn = namespace.id()
        lines = []
        postlines = []

        /# Define the vars related to namespace start/end.
        varset.addVar('namespace_under', fqn.replace('.', '_'))
        for part in fqn.split('.'):
          lines.append('namespace %s {' % part)
          postlines.append('}  // %s' % part)
        varset.addVar('namespace_spec', '\n'.join(lines))
        varset.addVar('end_namespace', list(reversed(postlines)))

        /# The ${header} exists in the defn (.cc) template to include the
        /# header (.h) file.
        varset.addVar('header', construct.fqn().replace('.', '/') + '.h')

        /# TODO(wmh): Deal with these...
        varset.addVar('imports_local', '')
        varset.addVar('imposts_local', '')
        varset.addVar('imposts', '')

        /# Define preclass (before class) and postclass (after class)
        preclass = varset.getValue('preclass')
        postclass = varset.getValue('postclass')
        preamble = varset.getValue('preamble')
        preclass_defn = []
        postclass_defn = []
        if construct.isMeta():
          if underclass:
            /# Each metaclass FooMeta associated with userclass Foo should
            /# declare a namespace variable MetaFoo to contain the singleton
            /# instance of FooMeta.
            /#
            /# TODO(wmh): Should MetaFoo be of type *FooMeta or @FooMeta?.
            /# TODO(wmh): Should MetaFoo be a method returning the singleton
            /# instance, rather than a variable? Matches better with Meta's
            /# "everything should be a function" philosophy.
            metaclass_instname = ClassConstruct.MetaInstifyName(underclass.id())
            postclass.append(
              'extern %s* %s;' % (construct.id(), metaclass_instname))
            postclass_defn.append(
              'static std::vector<%s*> _bases;' % OoplCpp.CC_ANY)
            postclass_defn.append(
              'static std::map<%s, %s*> _symbols;' %
              (OoplCpp.CC_STR_VALUE, OoplCpp.CC_ANY))
            postclass_defn.append(
              '%s* %s = new %s("%s", _bases, _symbols);' %
              (construct.id(), metaclass_instname, construct.id(),
               construct.fqn()))

        /# If the class has no initializer, but has a parent class, we
        /# explicitly inherit the constructors of the parent.
        if not construct.initializer():
          parentclasses = construct.parentclasses()
          if parentclasses:
            parentclass = parentclasses[0]
            preamble.append(
              'using %s::%s;' % (parentclass['fqn'], parentclass['id']))

        varset.addVar('preclass_local', preclass_defn)
        varset.addVar('postclass_local', postclass_defn)

      elif kind == 'method':
        modifiers = varset.getValue('modifiers')
        assert not modifiers
        mods = []

        /# Visibility
        visibility = construct.attrval('visibility')
        vis = visibility
        mods.append('%s:' % vis)

        /# misc.
        attrkind = construct.attrval('kind')
        if attrkind == 'static':
          mods.append('static')
        elif attrkind == 'initializer':
          /# No return type for initializers.
          varset.setValue('returns', '')
        else:
          /# Virtual or non-virtual dispatch?
          /#  - only valid if not static and not initializer!
          attrkind = construct.attrval('kind')
          if attrkind != 'initializer':
            dispatch = construct.attrval('dispatch')
            if dispatch == 'virtual':
              mods.append('virtual')

        if mods:
          mods.append('')

        modifiers.extend(mods)

        /# Handle constructor initialization list
        /#  - the initlist is part of defn not decl, so instead of adding
        /#    it to $params we define $initlist
        kind = construct.attrval('kind')
        initlist_str = ''
        super_attr = None
        if kind == 'initializer':
          /# The initialization list of C++ constructors is considered, by Meta,
          /# to be part of the params.
          super_attr, super_args = construct.attrpair('super', default=None)
          if super_args:
            init_str, _ = self.compileExpr(
              super_args, construct.metafile(), executable=construct)
            /# TODO(wmh): Fix this. Because ${initlist} appears in the cpp_defn
            /# template on the same line as ${method}, there are two different
            /# variables on the same line with differing attributes, and
            /# BaseSegment.addChunk() only handles one attribute.
            super_attr = None
            myclass = construct.myclass()
            parentclasses = myclass.parentclasses()
            pinfo = parentclasses[0]
            /# TODO(wmh): If the parent class is in the same namespace as
            /# myclass, we should use pinfo['id'] instead of pinfo['fqn']
            initlist_str = ' : %s%s' % (pinfo['fqn'], init_str)
        varset.addVar('initlist', initlist_str, attribute=super_attr)
    test:
    end receiver OoplCpp;

  end behavior augmentVarset;

  behavior classPath : str #:
    Obtain the baselang specific path in which a class is stored.
  params:
    var fqn : str #:
      An fqn to convert to a subpath.
    var suffix : str = null #:
      Usually null, in which case the primary suffix for the baselang is used,
      but may be an alternative suffix.
  scope:
    receiver BaseLanguageOopl scope:
      if suffix is None:
        suffix = self.suffix()
      return self.context().compiler().basePath(fqn, prefix='', suffix=suffix)

    receiver OoplPython scope:
      if suffix is None:
        suffix = self.suffix()
      return self.context().compiler().basePath(fqn, prefix='.', suffix=suffix)
  end behavior classPath;

  behavior buildPreambleText : str #:
    The baselang-specific preamble at the top of a BUILD file.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      return ''
    test:
      test.iseq('', test.baselang.buildPreambleText())
    end receiver OoplPython;

    receiver OoplJavascript scope:
      return (
        >|"""load("@io_bazel_rules_closure//closure:defs.bzl", "closure_js_library")
        >|load("@io_bazel_rules_closure//closure:defs.bzl", "closure_js_binary")
        >|load("@io_bazel_rules_closure//closure:defs.bzl", "closure_js_test")
        >|""")
    test:
      test.contains('io_bazel_rules_closure', test.baselang.buildPreambleText())
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      return ''
    test:
      test.iseq('', test.baselang.buildPreambleText())
    end receiver OoplCpp;

  end behavior buildPreambleText;

  behavior classSubPath : str #:
    The path (relative to WORKSPACE dir) of the file that contains the
    definition of a given class.
  params:
    var klass : ClassConstruct;
    var location : str = 'defn' #:
      One of 'defn' or 'decl'. Only meaningful for baselangs that
      distinguish between declaration and definition.
  scope:
    receiver BaseLanguageOopl scope:
      metac = klass.compiler()
      return metac.basePath(klass.fqn(), suffix=self.suffix())
    end receiver BaseLanguageOopl;

    receiver OoplPython scope:
      /# For class 'nm.sp.Class', the class-specific file is usually written to
      /# nm/sp/Class.<suff>, but for python we hide these files in
      /# nm/sp/.Class.py (i.e. initial '.' before class name).
      /#
      /# TODO(wmh): If we find a way to support per-class files publicly in
      /# python, we can make each class visible by removing this method
      /# and inheriting the parent definition of this method.
      metac = klass.compiler()
      return metac.basePath(klass.fqn(), prefix='.', suffix=self.suffix())
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# In Javascript, when using Google closure, test classes must end in
      /# '_test.js'.
      /#   - TODO(wmh): Test classes are named ClassTest. Do we want to have
      /#     the files be ClassTest_test.js or Class_test.js? For now, we are
      /#     going with the latter (Class_test.js). A better solution would be
      /#     to implement the javascript Unit infrastructure totally in
      /#     Meta without reliance on goog.testing, and remove the requirement
      /#     that test files end in _test.js (unless that is a Bazel requirement
      /#     rather than a goog.testing requirement?)
      if klass.isTest():
        metac = klass.compiler()
        fqn = klass.fqn()
        if fqn.endswith('Test'):
          /# TODO(wmh): By allowing classes with a 'Test' suffix and without
          /# a test suffix, we open ourselves up to a potential file conflict
          /# Suppose we have a user-provided test class 'Blah' and 'BlahTest'
          /# ... they would both write to 'Blah_test.js'. Solutions:
          /#  - do not remove the 'Test' suffix and use BlahTest_test.js
          /#  - do not allow users to define user-provided test classes that
          /#    end with 'Test'.
          fqn = fqn[:-4]
        return metac.basePath(fqn, suffix='_test' + self.suffix())
      else:
        result = super(OoplJavascript, self).classSubPath(klass)
      return result
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      /# In C++, each class contains two files, a .h and a .cc file.
      /# We consider the .h file to be primary, and the .cc file is handled
      /# specially.
      metac = klass.compiler()
      suffix = self.suffix(location=location)
      return metac.basePath(klass.fqn(), suffix=suffix)
    test:
    end receiver OoplCpp;

  end behavior classSubPath;

  behavior createBuildFragment : tuple<str,map> #:
    Create a BUILD fragment for this construct.

    Returns:
     0) str (build rule)
     1) map (key/values in target)
  params:
    var construct : Construct #:
      A class construct.
    var targets : vec<str> #:
      The targets that this construct depends on.
    var test : bool = false #:
      If true, the targets are for the test class associated with the
      construct.
    var name : str = null #:
      The name of the target.  Usually null, in which case the name of
      the construct is used.
    var src : str = null #:
      The src file.  Usually null, in which case it is computed based on
      the construct name.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      kind = construct.kind()

      if kind == 'namespace':
        if name is None:
          name = construct.id().split('.')[-1]
        if src is None:
          src = name + '.py'
        rule = 'py_test' if test else 'py_library'
        build = {
          'name': name,
          'srcs': [src],
          'deps': targets,
          'visibility': ['//visibility:public'],
        }

        /# NOTE: Although ClassConstruct.registerResource() does register
        /# a mapping from resource name to target, in Python we cannot rely
        /# on that mapping containing all per-class resources (if two
        /# different metafiles define different classes in the same namespace,
        /# something we almost certainly need to support, then if we only
        /# parse one of the .meta files, the class resources in the other
        /# .meta file will be missing).  The easy solution is to simply
        /# scan the namespace directory for any files looking like resource
        /# links.
        metac = construct.compiler()
        fs = metac.fs()
        resource_dir = fs.join(
          /# CODETANGLE(resource_dir)
          metac.repositoryPath(), metac.basePath(construct.fqn()), 'resources')
        if fs.exists(resource_dir):
          build['data'] = ['resources/' + f for f in fs.listdir(resource_dir)]

        if kind == 'class':
          /# TODO(wmh): In Python, since we do not have per-class targets,
          /# we need to instead collect all class resources into the
          /# namespace build fragment.  This is problematic if we allow
          /# two different metafiles to define classes in the same namespace
          /# (something we almost certainly need to support) because we would
          /# need to parse all meta files defining a namespace whenever any
          /# .metafile for the namespace is referenced ... or, alternatively,
          /# record per-class resource data on disk so it can be aggregated.
          /#   - we could just scan for symlinks that look like resource links!
          resources = construct.resources()
          data = []
          for resname, respath in resources.iteritems():
            data.append(respath)
          build['data'] = sorted(data)
        if test:
          build['size'] = 'small'

      elif kind == 'class':
        raise InternalError(
          'Python should not be create per-class build fragments (yet)')
      else:
        rule = None
        build = None

      return rule, build
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      kind = construct.kind()

      if kind == 'class':
        /# TODO(wmh): Need to add this to the BUILD file:
        /#   load("//closure:defs.bzl", "closure_js_library")
        metac = construct.compiler()
        flags = metac.flags()
        fs = metac.fs()
        baselang = construct.baselang()
        variant = construct.variant()

        _, suppress_list = construct.suppressInfo()
        suppress_set = set(suppress_list)

        if name is None:
          name = construct.id()
        if src is None:
          class_subpath = baselang.classSubPath(construct)
          src = fs.basename(class_subpath)
        if test:
          /# assert ClassConstruct.IsTestName(name)
          rule = 'closure_js_test'
          test_dep = '@io_bazel_rules_closure//closure/library:testing'
          if test_dep not in targets:
            targets.append(test_dep)
        else:
          rule = 'closure_js_library'
        build = {
          'name': name,
          'srcs': [src],
          'deps': targets,
          'visibility': ['//visibility:public'],
        }

        /# We always disable extra requires because ...
        suppress_set.add('JSC_EXTRA_REQUIRE_WARNING')
        /# We always disable nuulable returns ... just because the current
        /# program always uses a non-null value doesn't mean it won't change
        /# in the future.
        suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')

        if test:
          build['size'] = 'small'
          build['testonly'] = 1
          /# For user-provided class C, the auto-generated test class CTest
          /# implicitly includes class C (because tests for C must rely on C,
          /# and it is cumbersome for the user to specify something that is
          /# almost always the case).  HOWEVER, if the initialization of
          /# instances of C occurs within a namespace-specific TestCase class
          /# that CTest inherits from, there is actually no need to include C
          /# in CTest. Closure produces the following error when a goog.require()
          /# is specified that is not actually used:
          /#    ERROR - extra require: 'wmh.games.catan.Hex'
          /#      goog.require('wmh.games.catan.Hex');
          /#      ^
          /#        ProTip: "JSC_EXTRA_REQUIRE_WARNING" or "extraRequire" or
          /#        "legacyGoogScopeRequire" can be added to the `suppress`
          /#        attribute of: //wmh/games/catan_test:HexTest_lib
          /#        Alternatively /** @suppress {legacyGoogScopeRequire} */
          /#        can be added to the source file.
          /#
          /# For now, we suppress JSC_EXTRA_REQUIRE_WARNING within test classes.
          /# TODO(wmh): Verify these are still needed
          /# suppress_set.add('JSC_EXTRA_REQUIRE_WARNING')
          /# suppress_set.add('JSC_MISSING_PROVIDE')

          optmap = {
            'off': 'WHITESPACE_ONLY',
            'low': 'SIMPLE,',
            'avg': 'SIMPLE',
            /# Tests actually run faster with less optimization. In fact, it
            /# might be best to use 'WHITESPACE_ONLY', but that is currently
            /# producing errors.
            'high': 'SIMPLE',
            'max': 'ADVANCED'}
          build['compilation_level'] = optmap[flags.optimize_level]
          build['entry_points'] = [construct.fqn()]

        elif name == 'TestCase':
          /# Special case ... we assume the TestCase class inherits from
          /# metax.test.TestCase, which is marked as testonly because it
          /# relies on
          /#   @io_bazel_rules_closure//closure/library:testing
          /# Any class that relies on a testonly target must also be testonly.
          build['testonly'] = 1
          suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')

        elif variant == 'meta':
          /# A auto-generated meta class.
          /#  - preferably, the definition of the class itself should appear
          /#    first in the goog.provide() list, but this is always alphabetically
          /#    after the instance-of-metaclass variable also provided by this
          /#    file, so we disable JSC_PROVIDES_NOT_SORTED.

          /# TODO(wmh): Verify these are still needed.
          /# suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')
          /# suppress_set.add('JSC_PROVIDES_NOT_SORTED')
          pass

        else:
          /# The code prefers to reference classes by long name (since some
          /# baselangs require it, and shortnames can be ambiguous if two
          /# different classes with the same name in different namespaces are
          /# required within the same class), so although closure would prefer
          /# we define
          /#    const Bar = goog.require('nm.sp2.Bar');
          /#    class Foo extends Bar { ... }
          /#                      ^^^
          /# we will often instead use:
          /#    const Bar = goog.require('nm.sp2.Bar');
          /#    class Foo extends nm.sp2.Bar { ... }
          /#                      ^^^^^^^^^^
          /# which generates the following error. Disabling this should never
          /# introduce any errors.
          if False:
            /# Disabled because it causes 'CR_SUPERFLUOUS_SUPPRESS' which
            /# cannot be disabled (see below).
            suppress_set.add('JSC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME')

          /# The previous suppress, when inserted unilaterally, is sometimes
          /# superfluous if the class does not use the long form of a class
          /# name when specifying a parent (for example when the parent is
          /# javascript Object, etc.).
          if False:
            /# This does not work as advertised ... adding it to the target does
            /# not stop the error from occurring.
            suppress_set.add('CR_SUPERFLUOUS_SUPPRESS')
          /#suppress_set.add('superfluousSuppress')

          /# Normal user-provided class.
          /#  - Suppose a method has a meta return type of 'str' (aka interned
          /#    string). In Meta, there is a "null" interned string instance
          /#    (although exactly what this means differs from baselang to
          /#    baseland ... in C++ it is a special instance of IStr, in Python
          /#    it is None, etc.).
          /#  - For now, we are using javascript 'null' to represent the null
          /#    interned string. This means that the javascript return type of a
          /#    method returning a meta 'str' should be '?string' (string or
          /#    null). However, if a particular method returns a literal string,
          /#    the compiler can tell that it is never null, and by default
          /#    produces an error of the form:
          /#      ERROR - The return type of the function "<somefunc>" is
          /#      nullable, but it always returns a non-null value. Consider
          /#      making the return type non-nullable.
          /#  - We cannot, in general, make the return type '!string' because some
          /#    other method that returns a meta 'str' might return null. For
          /#    the time being, we suppress this error within all closure_js_library
          /#    class build targets.
          /#### suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')
          pass

          /# The following is required because in Javascript the <C>Class
          /# singleton instance of <C>MetaClass is defined in <C>MetaClass.js
          /# rather than <C>.js, and <C>.js has to goog.require <C>MetaClass.js
          /# to ensure that <C>Class is available, with no guarantees that the
          /# user will actually use it (and by default closure complains about
          /# extraneous requires).  It would be useful to NOT disable this
          /# warning, but this would require us to move the definition of
          /# <C>Class from <C>MetaClass.js to <C>Class.js (which would result
          /# in there always being a referecnce to <C>MetaClass within <C> to
          /# justify the goog.require.  The downside of this is if we want to
          /# at some point provide some optimizations whereby metaclass are
          /# not included in source code (if noop, not used, etc.), the current
          /# implementation is easy because all metaclass code is in a separate
          /# file, whereas the proposed implementation would scatter it across
          /# <C>.js and <C>MetaClass.js.
          /#### suppress_set.add('JSC_EXTRA_REQUIRE_WARNING')

          /# The following is needed for situations where a circularity exists
          /# between two classes where A needs B and B needs A.  This happens
          /# if in A there is a 'cls assoc B' and in B there is a 'cls assoc A'.
          /# To break this circularity, one must specify a target of "" in one
          /# of the assocs (e.g. 'cls assoc A target ""' in class B), but if
          /# this is done, bazel will complain with:
          /#   file.meta:1 (B.js:10) ERROR - Namespace not provided by any srcs or direct deps of //nm/sp:B.
          /# This error is disabled by CR_NOT_PROVIDED.
          /#
          /# IMPORTANT: We should NOT be inserting this always ... we should
          /# insert only in the special case of a circularity between classes.
          /# TODO(wmh): Figure out how to pass circularity info into this method
          /# so we can conditionally add CR_NOT_PROVIDED.

          /# 20170802: Disabled all of these (for now)
          /# 'CR_NOT_PROVIDED',
          /# Needed because CR_NOT_PROVIDED (above) generates this error.
          /#'CR_SUPERFLUOUS_SUPPRESS',
          /#'superfluousSuppress',

        if suppress_set:
          build['suppress'] = sorted(suppress_set)

      else:
        rule = None
        build = None

      /# print '%s: %s' % (rule, build)
      return rule, build
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if construct.kind() == 'class':
        /# TODO(wmh): Find a better way to handle header files external to Meta.
        /# For now, hacking Any to allow progress on C++ implementation.
        try:
          any_idx = targets.index('//:Any')
        except ValueError:
          pass
        else:
          targets[any_idx] = '//metastrap:Any'

        name = construct.id()
        data = {
          'name': name,
          'srcs': [name + '.cc'],
          'deps': targets,
          'visibility': ['//visibility:public'],
        }
        rule = 'cc_library'
        if test:
          rule = 'cc_test'
          data['size'] = 'small'
          data['srcs'].append(name + '.h')
        else:
          data['hdrs'] = [name + '.h']
        /# The -Iexternal/gtest/include is needed to support gtest.
        data.setdefault('copts', []).append('-Iexternal/gtest/include')

      else:
        rule = None
        data = None
      return rule, data
    test:
      test.defineClassAndMethods('cc')
      test.iseq(
        ('cc_library',
         {
          /# 'copts': ['-Imetastrap', '-Iexternal/gtest/include'],
          'name': 'Card',
          'visibility': ['//visibility:public'],
          'srcs': ['Card.cc'],
          'deps': [],
          'copts': ['-Iexternal/gtest/include'],
          'hdrs': ['Card.h']}),
        test.baselang.createBuildFragment(test.klass, []))
    end receiver OoplCpp;

  end behavior createBuildFragment;

  behavior emptyBlockCode : vec<str> #:
    Returns the lines of baselang code used to represent an empty block.

    In some languages this is an empty list, while others require a special
    syntax (e.g. Python's pass) while others may require some special
    value be returned to satisfy
  params:
    var executable : ExecutableConstruct #:
      The executable for which empty block code is desired.  May be null,
      in which case the code should assume void return type.
    var message : str = null #:
      If present, the returned value should include code that will
      print out the message on stdout.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      /# TODO(wmh): The returned list should contain code within python for
      /# returning an appropriate dummy-value based on method return type!
      result = []
      if message:
        result.append('print "%s"' % message)

      if executable:
        /# We don't require 'returns' because we are currently calling this
        /# code in BehaviorConstruct.expandMeta() for ReceiverConstruct
        /# instances, which do not define a 'returns' but do define 'presence'.
        /# TODO(wmh): Consider cleaning this up.
        returns = executable.attrval('returns', default=None) if executable else None
        presence = executable.attrval('presence')

        if presence == 'abstract':
          /# No formal mechanism for marking a method abstract in Javascript,
          /# so we raise a runtime error.
          result.append(
            "raise NotImplementedError('%s');" % executable.fqn())
        if returns and not returns.isVoid():
          defval = self.defaultValue(returns)
          result.append('return %s' % defval)

      if not result:
        /# TODO(wmh): It is not sufficient to check if result is empty ... if
        /# it has 20 lines, but all of them are comments or empty, we will need
        /# a 'pass' statement.
        result.append('pass')

      return result
    test:
      test.defineClassAndMethods('py')
      test.iseqvec(['return 0'], test.baselang.emptyBlockCode(test.method2))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      result = []
      if message:
        result.append("console.log('%s');" % message)
      if executable:
        returns = executable.attrval('returns', default=None)
        presence = executable.attrval('presence')
        if presence == 'abstract':
          /# No formal mechanism for marking a method abstract in Javascript,
          /# so we raise a runtime error.
          result.append(
            "throw new Error('NotImplemented: %s');" % executable.fqn())
        elif returns and not returns.isVoid():
          /# Closure will complain if we don't return something from methods with
          /# return types, so we return the default value associated with the
          /# return type.
          defval = self.defaultValue(returns)
          result.append('return %s;' % defval)
      return result
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      result = []
      if message:
        result.append('std::cout << "%s" << std::endl;' % message)
      if executable:
        returns = executable.attrval('returns', default=None)
        presence = executable.attrval('presence')
        if presence == 'abstract':
          /# In C++, abstract methods have no body whatsoever.
          result = None
        elif returns is None:
          pass
        elif returns.isPtr():
          result = ['return nullptr;']
        elif returns.isVoid():
          /# We do not return anything.
          pass
        elif returns.isStr():
          /# Applies only to @str and &str (*str and str are isPtr)
          result.append(
            'return %s;' % self.defaultValue(metax.c.Type.Instance('@str')))
        elif returns.isPrimitive() and not returns.isRef():
          result.append('return %s;' % self.defaultValue(returns))
        else:
          /# For ref and value types, we create a static faux instance of the
          /# (base) return type and return it.
          /# TODO(wmh): Need mechanism for supporting class-based return types
          /# that do not have a default constructor.  Could also be useful in
          /# unittests to have a mechanism for creating dummy instances of each
          /# class, so consider adding syntax for such instances and using it
          /# to generate code here.
          /# TODO(wmh): Some class types will need even more specialized handling.
          /# For example, metatype '&ostream' should return std::cout or std::cerr,
          /# rather than creating a new instance.
          metabase = metax.c.Type.Instance('@' + returns.base())
          result.append('static %s dummy;' % self.typeToBase(metabase))
          result.append('return dummy;')
      return result
    test:
      test.defineClassAndMethods('cc')

      /# We make a copy of test.method2 so that we can change the return type.
      faux_parent = metax.c.ComplexBlock(None, 'scope:', [])
      method = test.method2.clone(faux_parent)
      return_attr = method.attr('returns')

      /# Now verify various return types.
      for metatype_str, expected in (
        ('int', ['return 0;']),
        ('str', ['return nullptr;']),
        ('*str', ['return nullptr;']),
        ('@str', ['return std::string("");']),
        ('&str', ['return std::string("");']),
        ('nm.sp.A', ['return nullptr;']),
        ('*nm.sp.A', ['return nullptr;']),
        ('@nm.sp.A', ['static nm::sp::A dummy;', 'return dummy;']),
        ('&nm.sp.A', ['static nm::sp::A dummy;', 'return dummy;']),
      ):
        metatype = metax.c.Type.Instance(metatype_str)
        return_attr.valueIs(metatype)
        res = test.baselang.emptyBlockCode(method)
        test.iseq(
          expected, res, 'For "%s" expecting emptyBlockCode\n  %s\nnot\n  %s' % (
            metatype_str, expected, res))
    end receiver OoplCpp;

  end behavior emptyBlockCode;

  behavior establishTemplateName : str #:
    Obtain the name of the template to use to instantiate a method.
  params:
    var executable : ExecutableConstruct #:
      The executable for which a template is desired.
    var defn : bool = false #:
      If true, obtain the template for the definition, not declaration.
  scope:
    abstract
    receiver BaseLanguageOopl;

    receiver OoplPython scope:
      return self.id()
    test:
      test.defineClassAndMethods('py')
      test.iseq('python', test.baselang.establishTemplateName(test.method))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      result = self.id()
      if not self.config('user_es2015', False):
        /# TODO(wmh): Add support for using oldstyle template if we are not
        /# generating ES2015 classes
        pass
      return result
    test:
      test.defineClassAndMethods('js')
      test.iseq('javascript', test.baselang.establishTemplateName(test.method))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      /# C++ has a distinction between decl and defn, and the output for
      /# testcase methods is quite different than for a normal method.
      result = self.id()
      if defn:
        result += '_defn'
      else:
        result += '_decl'

      if executable.isTestCase():
        result += '_test'

      return result
    test:
      test.defineClassAndMethods('cc')
      method = test.method
      test.iseq(
        'cpp_defn', test.baselang.establishTemplateName(method, defn=True))
      test.iseq(
        'cpp_decl', test.baselang.establishTemplateName(method, defn=False))

      /# We fake up a test class and test method associated with 'method'.
      klass = method.myclass()
      testclass = klass.clone(None)
      testclass.idIs('CardTest')
      testclass.underclassIs(klass)
      testmethod = method.clone(testclass.attr('scope:'))
      testmethod.idIs('test_show')
      testmethod.myclassIs(testclass)
      test.istrue(testclass.isTestCase())
      test.istrue(testmethod.isTestCase())

      /# Verify that we get the test templates for test methods.
      test.iseq(
        'cpp_defn_test',
        test.baselang.establishTemplateName(testmethod, defn=True))
      test.iseq(
        'cpp_decl_test',
        test.baselang.establishTemplateName(testmethod, defn=False))

      /# TODO(wmh): Verify that we do NOT get the test methods for methods in
      /# testcase classes that aren't test methods, and for test methods in
      /# non-testcase classes.
    end receiver OoplCpp;

  end behavior establishTemplateName;

  behavior finalizerName : str #:
    The name of the finalizer for a given class.

    In most baselangs, this is the name of the class. Specific baselangs
    can override this default implementation (e.g. python).
  params:
    var klass : ClassConstruct;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      return '__del__'
    test:
      test.defineClassAndMethods('py')
      test.iseq('__del__', test.baselang.finalizerName(test.klass))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# According to
      /#   https://stackoverflow.com/questions/20266610/finalizers-for-javascript-objects
      /# There is no support for finalizers in Javascript.
      result = None
      return result
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      return '~' + klass.id()
    test:
      test.defineClassAndMethods('cc')
      test.iseq('~Card', test.baselang.finalizerName(test.klass))
    end receiver OoplCpp;

  end behavior finalizerName;

  behavior formatClassComment : vec<str> #:
    Format the 'comment' of a class.  This differs from the generic
    formatComment() method in that class comments may provide important
    information like fields, etc.

    Returns:
      The list of lines representing legal baselang syntax for a class
      comment/docstr.
  params:
    var attribute : SimpleBlock #:
      The comment attribute. If null, obtained from construct.
    var width : int = 80 #:
      Maximum width allowed.
    var suppress : map = null #:
      Where to write suppress commands (and reasons why).
    var default : vec<str> = null #:
      If present, and the comment is missing or empty, use this value
      as the comment.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if attribute:
        comment = self.simpleToBase(attribute, strip_comments=True)
      else:
        comment = []
      if not comment and default:
        comment.extend(default)
      comment = self.formatComment(comment, width=width)
      return comment
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if attribute:
        _, data = self.parseComment(attribute=attribute)
        construct = attribute.parent()
        visibility = construct.attrval('visibility')

        lines = self.simpleToBase(attribute, strip_comments=True)
        comment = []
        comment.append('/**')
        comment.append(' * %s' % construct.fqn())
        if False:
          comment.append(' * @fileoverview %s' % construct.kindfqn())
          comment.append(' *')
        for line in data['user']:
          comment.append(' *   ' + line)
        comment.append(' * @%s' % visibility)

        specials = data['special']
        suppress_str = specials.get('suppress', None)
        if suppress_str:
          suppress_list = re.split('\s*,\s*', suppress_str.strip())
          if suppress is not None:
            for supvar in suppress_list:
              suppress[supvar] = 'Explicit suppression by user in %s' % construct.kindfqn()
          /# This is the wrong place to add @suppress ... must be in a
          /# @fileoverview at the top of the file.
          /# comment.append(' * @suppress {%s}' % ','.join(sorted(suppress_list)))

        comment.append(' */')
      else:
        comment = []
      return comment
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if attribute:
        comment = self.simpleToBase(attribute, strip_comments=True)
        comment = self.formatComment(comment, width=width)
      else:
        comment = []
      return comment
    test:
    end receiver OoplCpp;

  end behavior formatClassComment;

  behavior formatClassType : tuple<str,str> #:
    Format a string representing a class name into a base fqn and meta fqn.

    Returns:
      0) the baselang fqn.
         The special value 'void' means 'no class'.
      1) the meta-level fqn.
  params:
    var metafile : MetaFile #:
      The metafile being processed (for reporting errors).
    var cstr : str #:
      The class string. Examples include the 'parent' value in class
      constructs and the primary value of 'assoc' constructs. May include
      an initial '^' character.
    var namespace : NamespaceConstruct #:
      The namespace within which the class type resides.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      metafqn = ClassConstruct.CanonicalizeClassName(cstr, namespace=namespace)
      if not metafqn:
        raise Error('Should always have a class in python')
      basefqn = metafqn
      return basefqn, metafqn
    test:
      _, oopl, _, _ = test.cachedInfo()
      py = oopl.baselangNamed('python')
      construct = test.basics()
      metafile = test.metafile
      test.iseq(('object', 'object'), py.formatClassType(
        metafile, '^object', construct.namespace()))
      test.iseq(
        ('metax.c.MetaFile', 'metax.c.MetaFile'),
        py.formatClassType(metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('nm.sp.MetaFile', 'nm.sp.MetaFile'),
        py.formatClassType(metafile, 'MetaFile', construct.namespace()))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      metafqn = ClassConstruct.CanonicalizeClassName(cstr, namespace=namespace)
      if not metafqn:
        raise Error('Should always have a class in python')
      basefqn = metafqn
      return basefqn, metafqn
    test:
      baselang = test.baselang
      construct = test.basics()
      metafile = test.metafile
      test.iseq(('Object', 'Object'), baselang.formatClassType(
        metafile, '^Object', construct.namespace()))
      test.iseq(
        ('metax.c.MetaFile', 'metax.c.MetaFile'),
        baselang.formatClassType(
          metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('metax.c.MetaFile', 'metax.c.MetaFile'),
        baselang.formatClassType(
          metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('nm.sp.MetaFile', 'nm.sp.MetaFile'),
        baselang.formatClassType(
          metafile, 'MetaFile', construct.namespace()))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      metafqn = ClassConstruct.CanonicalizeClassName(cstr, namespace=namespace)
      if metafqn:
        basefqn = metafqn.replace('.', '::')
      else:
        basefqn = None
      return basefqn, metafqn
    test:
      baselang = test.baselang
      construct = test.basics()
      metafile = test.metafile
      test.iseq(('std::string', 'std.string'), baselang.formatClassType(
        metafile, '^std.string', construct.namespace()))
      test.iseq(
        ('metax::c::MetaFile', 'metax.c.MetaFile'),
        baselang.formatClassType(
          metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('nm::sp::MetaFile', 'nm.sp.MetaFile'),
        baselang.formatClassType(
          metafile, 'MetaFile', construct.namespace()))
    end receiver OoplCpp;

  end behavior formatClassType;

  behavior formatComment : vec<str> #:
    Format a list of strings representing a comment into syntax valid
    in this baselang.

    Returns:
      A modified copy of the input comment.
  params:
    var comment : vec<str> #:
      The list of lines to format. They can be modified in place.
    var width : int = 80 #:
      Maximum width allowed.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if comment is None:
        result = []
      else:
        result = comment[:]
      ncom = len(result)
      if ncom == 0:
        result = []
      elif ncom == 1:
        result[0] = '\"\"\"' + result[0] + '\"\"\"'
      else:
        result[0] = '\"\"\"' + result[0]
        result.append('\"\"\"')
      return result
    test:
      baselang = test.baselang
      comment = baselang.formatComment(['This is a test'])
      test.iseqvec(['\"\"\"This is a test\"\"\"'], comment)
      comment = baselang.formatComment(['This is a test', 'of two lines'])
      test.iseqvec(['\"\"\"This is a test', 'of two lines', '\"\"\"'], comment)
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if comment is None:
        result = []
      else:
        result = comment[:]
      rem = self.config('rem') + ' '
      for i in range(0, len(result)):
        result[i] = rem + result[i]
      return result
    test:
      _, oopl, _, _ = test.cachedInfo()
      js = oopl.baselangNamed('javascript')
      comment = js.formatComment(['This is a test'])
      test.iseqvec(['// This is a test'], comment)
      comment = js.formatComment(['This is a test', 'of two lines'])
      test.iseqvec(['// This is a test', '// of two lines'], comment)
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if comment is None:
        result = []
      else:
        result = comment[:]
      rem = self.config('rem') + ' '
      for i in range(0, len(result)):
        result[i] = rem + result[i]
      return result
    test:
      _, oopl, _, _ = test.cachedInfo()
      cc = oopl.baselangNamed('cpp')
      comment = cc.formatComment(['This is a test'])
      test.iseqvec(['// This is a test'], comment)
      comment = cc.formatComment(['This is a test', 'of two lines'])
      test.iseqvec(['// This is a test', '// of two lines'], comment)
    end receiver OoplCpp;

  end behavior formatComment;

  behavior formatDependencies : tuple<vec<str>,vec<str>> #:
    Analyze dependency data to produce imports and BUILD targets.

    NOTE: It is usually not necessary for subclasses to override this
    method. Instead, they can override formatDependency().  However, in
    some situations it may be easier to override this method entirely.

    Returns:
     0. The collection of baselang source lines importing dependencies
     1. The collection of BUILD targets needed to obtain dependencies.
  params:
    var class_construct : ClassConstruct #:
      The class for which dependencies are being computed.
  scope:
    receiver BaseLanguageOopl scope:
      /# TODO(wmh): Although it is often possible to handle all dependencies by
      /# iterating over each dependency, there are some situations in some
      /# baselangs where dependencies interact. We may need to go back to a
      /# model where baselangs template formatDependencies() rather than
      /# formatDependency(). For example, javascript has some subtlties around
      /# this.
      deps = class_construct.deps()
      targets = set()
      imports = []
      for fqn in deps:
        import_str, target_str = self.formatDependency(class_construct, fqn)
        if import_str:
          imports.append(import_str)
        if target_str:
          targets.update(target_str.split(','))

      /# TODO(wmh): Sort std imports before non-std!
      imports = sorted(imports)

      return (imports, targets)
    end receiver BaseLanguageOopl;

  end behavior formatDependencies;

  behavior formatDependency : tuple<str,str> #:
    Obtain baselang import text and bazel target for a given dependency.

    Returns:
     0. The baselang import text to add for the dependency. May be null.
     1. The bazel target to add for the dependency.
  params:
    var class_construct : ClassConstruct #:
      The class for which a dependency is being computed.
    var fqn : str #:
      The dependency to format.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      deps = class_construct.deps()
      info = deps[fqn]
      kind = info['kind']
      target = info['target']
      reason = info['reason']

      if kind == 'cls':
        /# Note that 'target' will be class-specific, but Python does not
        /# (currently) have class-specific targets, only namespace targets.
        /# So we convert the class target to a namespace target.
        m = re.match(r'^([^:]+)/([^:]+):(\S+)$', target)
        if not m:
          raise Error(
            'Failed to parse target "%s" when looking for namespace' % target)
        target = '%s/%s:%s' % (m.group(1), m.group(2), m.group(2))

        idx = fqn.rfind('.')
        if idx == -1:
          metafile.error('Invalid class type "%s"' % fqn)
          import_str = None
        else:
          import_str = 'import %s  # target=%s reason=%s' % (fqn[:idx], target, reason)

      elif kind == 'lib':
        /# The target identifies a namespace, so we do not need to
        /# modify it.
        import_str = 'import %s  # target=%s reason=%s' % (fqn, target, reason)

      elif kind == 'std':
        import_str = 'import ' + fqn
      else:
        raise Error('Unknown kind "%s"' % kind)

      return import_str, target
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      deps = class_construct.deps()
      info = deps[fqn]
      kind = info['kind']
      target = info['target']

      /# TODO(wmh): If the base name of the class occurs multiple times amongst
      /# all triples, we will need to use alternative names or not produce
      /# shorthand names at all.

      if kind == 'cls':
        /# There are two special-cases that we need to deal with:
        /#   1) nm.sp.FooMeta is a request for the metaclass
        /#   2) nm.sp.MetaFoo is a request for the metaclass instance.
        /# They both reside in module nm/sp/FooMeta.js.
        /#
        /# CODE TANGLE: meta-disallowed
        if ClassConstruct.IsMetaName(fqn):
          /# A request to import nm.sp.FooMeta.
          /#   const {FooMeta} = goog.require('nm.sp.FooMeta')
          parts = fqn.split('.')
          import_str = "const {%s} = goog.require('%s');" % (parts[-1], fqn)
        elif ClassConstruct.IsMetaInstName(fqn):
          /# A request to import nm.sp.MetaFoo
          /#   const {MetaFoo} = goog.require('nm.sp.FooMeta')
          parts = fqn.split('.')
          metainst = parts[-1]
          parts[-1] = ClassConstruct.MetaifyName(
            ClassConstruct.UnmetainstifyName(metainst))
          import_str = "const {%s} = goog.require('%s');" % (
            metainst, '.'.join(parts))
        else:
          /# We define the assoc basename locally.  Note that if there are any
          /# other assocs in triples with the same basename this will yield an
          /# error ... must fix.
          import_str = "const %s = goog.require('%s');" % (
            fqn.split('.')[-1], fqn)

      elif kind == 'lib':
        /# TODO(wmh): Is there a way to import all classes in a namespace
        /# in Javascript?  Or does Meta need to determine which classes
        /# exist and import them?
        import_str = "goog.require('%s');" % fqn

      elif kind == 'std':
        /# TODO(wmh): Are there any std assocs in Javascript? Maybe the
        /# various modules in phantomjs? http://phantomjs.org/api/
        /#   webpage: http://phantomjs.org/api/webpage/
        /#   child_process: http://phantomjs.org/api/child_process/
        /#   fs: http://phantomjs.org/api/fs/
        /#   system: http://phantomjs.org/api/system/
        /#   webserver: http://phantomjs.org/api/webserver/
        /#
        /# For now, we simply ignore std assocs in javascript.
        import_str = None
      else:
        raise Error('Unknown kind "%s"' % kind)

      return (import_str, target)
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      deps = class_construct.deps()
      info = deps[fqn]
      kind = info['kind']
      target = info['target']
      fqn_path = '/'.join(fqn.split('.'))

      if fqn_path == 'void':
        import_str = None

      elif kind == 'cls':
        import_str = '#include "%s.h"' % fqn_path

      elif kind == 'lib':
        /# TODO(wmh): In Python, this means "make all symbols within a namespace
        /# visible in the importing context, prefixed by the basename of the lib.
        /# What do we do in C++?
        import_str = '#include "%s.h"' % fqn_path

      elif kind == 'std':
        import_str = '#include <%s>' % fqn_path.replace('_h', '.h')
        target = None

      else:
        raise Error('Unknown kind "%s"' % kind)

      return (import_str, target)
    test:
      test.defineClassAndMethods('cc')
      klass = test.klass
      klass.addDependency('metax.root.Object', 'cls', 'test1')
      klass.addDependency('demo.cards1.Card', 'lib', 'test2')
      klass.addDependency('ostream', 'std', 'test3')
      test.iseq(
        ('#include "metax/root/Object.h"', '//metax/root:Object'),
        test.baselang.formatDependency(test.klass, 'metax.root.Object'))
      test.iseq(
        ('#include "demo/cards1/Card.h"', '//demo/cards1/Card:Card'),
        test.baselang.formatDependency(test.klass, 'demo.cards1.Card'))
      test.iseq(
        ('#include <ostream>', None),
        test.baselang.formatDependency(test.klass, 'ostream'))
    end receiver OoplCpp;

  end behavior formatDependency;

  behavior formatExpr #:
    Convert an Expr to baselang syntax.

    TODO(wmh): FIX THIS!  BaseLanguageOopl.compileExpr() already does this,
    and much better.
  params:
    var value : any #:
      TODO(wmh): In the transitional period where we are switching 'default'
      and various other attributes from type 'word' to type 'expr', the value
      passed to this behavior may be an Expr or a string, and the code should
      handle both.  Once we are fully converted, we can remove the string
      handling code.
    var mtype : Type #:
      The type of the expression.  Only used if value is None, in which case
      the default value associated with this type is used.
    var construct : Construct #:
      A MethodConstruct or FieldConstruct, etc.
  scope:

    receiver BaseLanguageOopl scope:
      if value is None:
        /# CODETANGLE(special_expr): TODO(wmh): Decide whether <special> is
        /# indicated by an Expr with value() None, or by an Expr that is None.
        result = self.defaultValue(mtype)
      elif isinstance(value, basestring):
        result = value
      elif isinstance(value, Expr):
        if True:
          metafile = construct.context().metafile()
          executable = construct if isinstance(construct, ExecutableConstruct) else None
          result, restype = self.compileExpr(value, metafile, executable=executable)
        else:
          kind = value.kind()
          if kind == 'str':
            result = value.value()
            /# CODETANGLE(special_expr): TODO(wmh): Decide whether <special> is
            /# indicated by an Expr with value() None, or by an Expr that is None.
            if result is None:
              result = self.defaultValue(mtype)
          elif kind == 'id':
            result = value.value()
            /# TODO(wmh): Handle pseudovars here!
            /# result = self.pseudovars().get(result, result)
          elif kind == 'num':
            result = value.value()
          else:
            print '*** HERE with %s = %s' % (value, mtype.raw())
            result = 'fix me'
      else:
        raise Error('Unknown value type %s for formatExpr' % type(value))
      return result
    end;

  end behavior formatExpr;

  behavior formatFieldDefinition #:
    Obtain the baselang code needed to define this field.
  params:
    var field : FieldConstruct #:
      The field to format.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      /# instance fields are defined in initializers, meta fields are
      /# defined in metaclass initializers, but static fields are defined
      /# here.
      kind = field.attrval('kind')
      if kind == 'static':
        default = field.attrval('default', default=None)
        mtype = field.attrval('type', default=metax.c.LOOKUP)
        /# print '%s : %s = %s' % (field.fqn(), mtype.raw(), default)

        /# TODO(wmh): Replace this with compileExpr() when we are fully
        /# migrated to 'default' always being of type 'expr'.
        basedef = self.formatExpr(default, mtype, field)
        result = ['%s = %s' % (field.rawfield(), basedef)]
      else:
        result = []
      return result
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# Fields are defined in initializers. No field-specific syntax.
      return []
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      result = []
      rawfield = field.rawfield()
      myclass = field.myclass()
      type_attr, metatype = field.attrpair('type', default=metax.c.LOOKUP)
      if metatype.isStr():
        /# The 'str' type should be implementable using:
        /#   const std::string
        /#   std::string_view
        /#   any class that
        /#    - provides the read-only portion of std::string API
        /#    - can support '*str' means nullable
        /#    - can support '&str' means non-nullable
        /#    - does not need to implement '*str' as a pointer to a class
        /#    - does not need to implement '&str' as a ref to a class
        /# Prefixes
        /#  - *str means can be null
        /#  - &str means cannot be null
        /#  - @str means cannot be null
        /#  - str  means *str (can be null)
        basetype = OoplCpp.CC_STR
        if basetype == 'const std::string':
          basetype = 'std::string'
        if metatype.isPtr():
          basetype += '*'
      else:
        basetype = self.typeToBase(metatype, class_construct=myclass)
        /# print '****** %-20s %-30s = %s' % (rawfield, metatype, basetype)

      value = ''
      defn = 'private: %s %s%s;' % (basetype, rawfield, value)
      result.append(defn)
      return result
    test:
    end receiver OoplCpp;

  end behavior formatFieldDefinition;

  behavior formatMethodComment : vec<str> #:
    Format the 'comment' of an executable.  This differs from the generic
    formatComment() method in that method comments often describe parameters,
    return types, etc. (in baselangs that don't have static typing).

    Returns:
      The list of lines representing legal baselang syntax for a method
      comment/docstr.
  params:
    var construct : ExecutableConstruct #:
      The construct to format the comment of.
    var width : int = 80 #:
      Maximum width allowed.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      kind = construct.attrval('kind', default=metax.c.LOOKUP)
      params = construct.parsedParams()
      visibility = construct.attrval('visibility', default=metax.c.LOOKUP)
      returns = construct.attrval('returns', default=metax.c.LOOKUP)

      comment_attr, comdata = self.parseComment(
        construct=construct, parse_return=True)
      clines = comdata['user']

      pdata = params['data']
      if pdata:
        if not clines:
          clines.append('No comment provided.')
        if clines[-1]:
          clines.append('')
        clines.append('Args:')
        for param in pdata:
          clines.append('  %s: %s' % (param['name'], str(param['type'])))
          if 'comment' in param:
            for ln in param['comment']:
              clines.append('    ' + ln)

      if comdata['returns']:
        clines.append('')
        clines.append('Returns:')
        clines.extend(comdata['returns'])

      if clines is None:
        clines = []
      lines = self.formatComment(clines, width=width)
      return lines
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      suppress = set()
      lines = []
      lines.append('/**')

      attrkind = construct.attrval('kind')
      is_init = attrkind == 'initializer'
      myclass = construct.myclass()
      comment_attr, comdata = self.parseComment(
        construct=construct, parse_return=True)
      clines = comdata['user']
      if 'suppress' in comdata['special']:
        suppress.update(re.split('\s*,\s*', comdata['special']['suppress']))

      /# Add the user-provided documentation for this executable.
      lines.append(' * %s' % ('initializer' if is_init else construct.fqn()))
      if clines:
        for line in clines:
          lines.append(' *   ' + line)

      /# Add annotations for all parameters.
      params = construct.parsedParams()
      for param in params['data']:
        default = param.get('default', None)
        /# TODO(wmh): As of 2017-12-22, when providing the fully-qualified
        /# name of a type, closure produces the error:
        /#    metax/test/TestCase.js:445: ERROR - Reference to fully qualified import name 'goog.testing.PropertyReplacer' in JSDoc. Please use the short name 'PropertyReplacer' instead.
        /#       * @return {?goog.testing.PropertyReplacer}
        /#                   ^
        /#      ProTip: "JSC_JSDOC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME" or "lintChecks" or "strictModuleChecks" can be added to the `suppress` attribute of:
        /#      //metax/test:TestCase
        /# Adding JSC_JSDOC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME
        /# to the BUILD rule results in a
        /#    ERROR - Build rule (//metax/root:ObjectMetaRoot) contains superfluous suppress codes: CR_SUPERFLUOUS_SUPPRESS, JSC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME
        /#      ProTip: "CR_SUPERFLUOUS_SUPPRESS" or "superfluousSuppress" can be added to the `suppress` attribute of:
        /#      //metax/root:ObjectMetaRoot
        /# And adding "CR_SUPERFLUOUS_SUPPRESS" to the appropriate build target
        /# does NOT work as advertised ... the superfluous error persists.
        /#
        /# I would very much prefer to keep using fqns (not least of which
        /# because using only class names will not work in situations where
        /# a class needs nm.sp1.A and nm.sp2.A), but until
        /# "CR_SUPERFLUOUS_SUPPRESS" is working properly, we set defqn=True
        /# in the call to typeToBase().

        /#basetype2 = self.typeToBase(
        /#  param['type'], class_construct=myclass, defqn=False)
        basetype = self.typeToBase(
          param['type'], class_construct=myclass, defqn=True)
        /#print '%-30s = %-30s = %s' % (param['type'].raw(), basetype2, basetype)

        if default is None:
          lines.append(' * @param {%s} %s' % (basetype, param['name']))
        else:
          defval = default
          lines.append(' * @param {%s} [%s=%s]' % (
            basetype, param['name'], defval))
        pcom = param.get('comment', [])
        for line in pcom:
          lines.append(' *   ' + line)
      if 'varvec' in params or 'varmap' in params:
        lines.append(' * @param {*} varargs')

      /# Annotate the return type
      returns = construct.attrval('returns', default=metax.c.LOOKUP)
      if not returns.isVoid():
        /# See comment above about defqn - we need to do the same thing here.
        baseret = self.typeToBase(returns, class_construct=myclass, defqn=True)
        lines.append(' * @return {%s}' % baseret)
        if 'returns' in comdata:
          for rline in comdata['returns']:
            lines.append(' *   ' + rline)

      /# Record the visibility
      if is_init:
        /# jsdoc does not want us to annotate the visibility of the constructor.
        /# instead, we annotate the visibility of the class itself (done
        /# in OoplJavascript.formatClassConstruct()).
        pass
      else:
        visibility = construct.attrval('visibility', default=metax.c.LOOKUP)
        lines.append(' * @%s' % visibility)

      /# Handle initializer-specific annotations.
      kind = construct.attrval('kind', default=metax.c.LOOKUP)
      if kind == 'initializer':
        myclass = construct.myclass()
        pspec = myclass.parentclasses()[0]
        if False:
          lines.append(' * @constructor')
          /# TODO(wmh): How to declare the fields of a class properly?
          /# Using @property does not appear to work properly.
          /# TODO(wmh): Add an '@extends {class}' line for the parent.
          lines.append(' * @extends {%s}' % pspec['fqn'])

        if myclass.isTestCase():
          /# Meta<Javascript> generates javascript tests within subclasses of
          /# goog.testing.TestCase. However, the test-harness running code
          /# currently relies on some implicit behavior provided by goog.requiring
          /# goog.testing.jsunit.  This implicit behavior breaks if we add a
          /#   goog.provide('<the_test_class>')
          /# but google closure complains about
          /#   "JSC_MISSING_PROVIDE" or "missingProvide"
          /# if such a provide is not given.  For now, we suppress the warning in this
          /# situation, but finding a way to allow test classes to be defined normally
          /# would be best.
          /#
          /# TODO(wmh): Determine if this is still necessary
          /# suppress.add('missingProvide')
          pass

      /# Handle 'new' vs 'override' semantics.
      inheritance = construct.attrval('inheritance', default=metax.c.LOOKUP)
      if inheritance != 'new':
        lines.append(' * @override ')

      /# Suppress requested warnings.
      if suppress:
        lines.append(' * @suppress {%s}' % (','.join(sorted(suppress))))
      lines.append(' */')

      return lines
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      comment_attr, clines = construct.attrpair('comment:', default=None)
      kind = construct.attrval('kind', default=metax.c.LOOKUP)
      params = construct.parsedParams()
      visibility = construct.attrval('visibility', default=metax.c.LOOKUP)
      returns = construct.attrval('returns', default=metax.c.LOOKUP)

      /# TODO(wmh): Fix this ... using formatComment() temporarily.
      if clines is None:
        clines = []
      lines = self.formatComment(clines, width=width)
      return lines
    test:
      test.defineClassAndMethods('cc')
      test.iseqvec(
        ['// This is a test', '// of a multiline comment'],
        test.baselang.formatMethodComment(test.method))
    end receiver OoplCpp;

  end behavior formatMethodComment;

  behavior formatParams : vec<str> #:
    Format the params into baselang code.

    Returns:
      A list of baselang syntax, one element per parameter.
  params:
    var executable : ExecutableConstruct #:
      The executable containing the params.
    var preamble : vec<str> #:
      Where to write any parameter-related preamble code.
    var decl : bool = false #:
      If true, format for declaration not definition.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      result = []
      kind = executable.attrval('kind')
      if kind == 'static':
        /# No receiver.
        pass
      else:
        rec = self.receiverStr(executable)
        assert rec is not None
        result.append(rec)

      params = executable.parsedParams()
      pdata = params['data']
      if pdata:
        for param in pdata:
          part = param['name']
          if 'default' in param:
            default = self.formatExpr(
              param['default'], param['type'], executable)
            defval = self.pseudovars().get(default, default)
            /# print '%s : %s = %s [%s]' % (param['name'], param['type'].raw(), param['default'], defval)
            part += '=' + defval
          result.append(part)
      if 'varvec' in params:
        result.append('*%s' % params['varvec']['name'])
      if 'varmap' in params:
        result.append('**%s' % params['varmap']['name'])

      return '(%s)' % ', '.join(result)
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      result = []
      rec = self.receiverStr(executable)

      variadics = []
      params = executable.parsedParams()
      pdata = params['data']
      if pdata:
        for param in pdata:
          part = param['name']
          if 'default' in param:
            default = self.formatExpr(
              param['default'], param['type'], executable)
            defval = self.pseudovars().get(default, default)
            /# As of ES2015, default parameters exist in javascript.
            /#   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters
            part += '=' + defval
          result.append(part)
      if 'varvec' in params:
        variadics.append(params['varvec'])
      if 'varmap' in params:
        variadics.append(params['varmap'])
      if variadics:
        result.append('varargs')
        /# http://usejsdoc.org/tags-param.html#multiple-types-and-repeatable-parameters
      return '(%s)' % ', '.join(result)
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      result = []
      rec = self.receiverStr(executable)
      myclass = executable.myclass()

      mutability = executable.attrval('mutability')
      presence = executable.attrval('presence')

      variadics = []
      params = executable.parsedParams()
      pdata = params['data']
      if pdata:
        for param in pdata:
          basetype = self.typeToBase(param['type'], class_construct=myclass)
          part = basetype + ' ' + param['name']
          if 'default' in param:
            if decl:
              /# In C++, default args can be added to declaration or
              /# definition but not both.  Since the default args are part of
              /# the public interface, we assign them in decl not defn.
              print param
              default = self.formatExpr(
                param['default'], param['type'], executable)
              defval = self.pseudovars().get(default, default)
              part += ' = ' + defval
          result.append(part)
      if 'varvec' in params:
        variadics.append(params['varvec'])
      if 'varmap' in params:
        variadics.append(params['varmap'])
      if variadics:
        /# http://en.cppreference.com/w/cpp/language/variadic_arguments
        result.append('...')

      result = '(%s)' % ', '.join(result)
      if mutability == 'const':
        result += ' const'
      if presence == 'abstract':
        result += ' = 0'

      return result
    test:
      test.defineClassAndMethods('cc')
      method = test.method2
      method.myclass().namespaceIs(test.namespace)
      preamble = []
      print 'Fix OoplCpp.formatParams'
      return
      test.iseq(
        '(const std::string* a, int32_t b = 1, bool c = false)',
        test.baselang.formatParams(method, preamble, decl=True))
      test.iseq(
        '(const std::string* a, int32_t b, bool c)',
        test.baselang.formatParams(method, preamble))
      test.iseqvec([], preamble)
    end receiver OoplCpp;

  end behavior formatParams;

  behavior formatParentSpec : str #:
    Obtain baselang syntax for how to define parents of a class.

    SideEffect:
      May register additional dependencies in class_construct via
      addDependency().

    Returns:
     0) the baselang syntax for defining the parents
     1) a list of triples containing 0 or more imports to include.
        Each element specifies (metafqn, kind, target) where kind is one of
        'cls' or 'std' or 'lib'.
  params:
    var class_construct : ClassConstruct;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      parentclasses = class_construct.parentclasses()
      parentdata = parentclasses[0]
      metafqn = parentdata['metafqn']
      basefqn = parentdata['fqn']
      parentspec = basefqn or metafqn
      return parentspec
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      parentclasses = class_construct.parentclasses()
      parentdata = parentclasses[0]
      metafqn = parentdata['metafqn']
      basefqn = parentdata['fqn']
      parentspec = basefqn or metafqn

      /# TODO(wmh): If two different classes with the same name but differing
      /# namespaces are required within a class, we will not be able to
      /# produce the same shortname for both and the following assumption will
      /# be invalidated.  I'd prefer to use the long names always, but that
      /# is posing closure errors (missing require 'metax.root.ObjectMetaRoot',
      /# even though the require is not missing).
      parent_name = parentspec.split('.')[-1]

      /# Closure prefers that if we have introduced a short name for a class via
      /# 'goog.require', that we use the short name over the fully-qualified
      /# name. However, Meta often prefers to do the opposite because:
      /#  - some baselangs require fully qualified names (e.g. Perl)
      /#  - shortnames can be ambiguous if two different classes with the
      /#    same basename but differing namespaces are required within
      /#    the same class
      /#
      /# For example, closure prefers:
      /#    const Bar = goog.require('nm.sp2.Bar');
      /#    class Foo extends Bar { ... }
      /#                      ^^^
      /# But Meta often produces:
      /#    const Bar = goog.require('nm.sp2.Bar');
      /#    class Foo extends nm.sp2.Bar { ... }
      /#                      ^^^^^^^^^^
      /# This can generate a closure error of the form:
      /#   metax/root/ObjectMeta.js:10: ERROR - Reference to fully qualified
      /#   import name 'metax.root.ObjectMetaRoot'. Please use the short name
      /#   'ObjectMetaRoot' instead.
      /#
      /# Disabling this should never introduce any errors ... not sure why
      /# closure is even making a fuss about it.
      if '.' in parent_name:
        raise Error('Should never get here')
        /# class_construct.suppress()['JSC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME'] = (
        /#   'Using fqn parent %s' % parent_name)

      /# Form the javascript syntax needed to declare class_construct to be
      /# a child of parent_name.
      parent_spec = ' extends ' + parent_name

      return parent_spec
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      parent_classes = class_construct.parentclasses()
      if parent_classes:
        parent_data = parent_classes[0]
        metafqn = parent_data['metafqn']
        basefqn = parent_data['fqn']

        /# Form the C++ syntax needed to declare class_construct to be
        /# a child of parent_name.
        if not basefqn:
          parent_spec = ''
        else:
          /# TODO(wmh): Generalize ... not always public inheritance.
          parent_spec = ' : public ' + basefqn

      else:
        parent_spec = ''
      return parent_spec
    test:
      test.defineClassAndMethods('cc')
      klass = test.klass
      test.iseq({}, klass.deps())
      test.iseq(
        ' : public metax::root::Object',
        test.baselang.formatParentSpec(klass))
    end receiver OoplCpp;

  end behavior formatParentSpec;

  behavior initializerName : str #:
    The name of the initializer for a given class.

    In most baselangs, this is the name of the class. Specific baselangs
    can override this default implementation (e.g. python).
  params:
    var klass : ClassConstruct;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      return '__init__'
    test:
      test.defineClassAndMethods('py')
      test.iseq('__init__', test.baselang.initializerName(test.klass))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if self.config('use_es2015'):
        /# In javascript using ES2015 class definitions, the initializer is
        /# always 'constructor.  See
        /# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
        result = 'constructor'
      else:
        /# Old-style javascript is different than most other languages, in that
        /# the class is defined (not just initialized) by a function with the
        /# same name as the class. The new class syntax of ES2015 is much
        /# cleaner, but this code path is supported in case we want to use
        /# non-class syntax.
        result = klass.id()
      return result
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      return klass.id()
    test:
    end receiver OoplCpp;

  end behavior initializerName;

  behavior metaMethodBody : vec<str> #:
    Returns the list of lines in baselang syntax used to implement the
    special 'meta' method in every user-level class to return the
    singleton instance of the metaclass.
  params:
    var metainst : str #:
      The name of the baselang variable containing the metaclass instance.
    var metaclass : ClassConstruct #:
      The metaclass construct. May be null, in which case there is no
      metaclass ... appropriate code should be returned for that situation.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if metaclass:
        meta_body = []
        meta_body.append('result = self.__class__')
        /# TODO(wmh): The following code use to do the following:
        /#   assert result is <class>
        /#   assert result is Meta<class>
        /# However, this breaks in situations where a class does not generate
        /# an implicit 'meta' method (e.g. classes that do not generate a
        /# meta class).  So we have changed the code to:
        /#   assert issubclass(result, <class>)
        /#   assert issubclass(result, Meta<class>)
        /# Look into whether this needs further cleanup/removal/reversion.

        meta_body.append('assert issubclass(result, %s)' % metaclass.underclass().id())
        underclass = metaclass.underclass()
        if not underclass.isTestCase():
          /# CODETANGLE(metainst_for_testclass): We do not currently generate
          /#   MetaFooTest = FooTest
          /# for testcase classes because it causes every method defined on
          /# the test class to be executed twice.
          meta_body.append('assert issubclass(result, %s)' % metainst)
        meta_body.append('return result')
      else:
        meta_body = ['return None']
      return meta_body
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if metaclass:
        meta_body = ['return %s;' % metainst]
      else:
        meta_body = ['return null;']
      return meta_body
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if metaclass:
        meta_body = ['return %s;' % metainst]
      else:
        meta_body = ['return nullptr;']
      return meta_body
    test:
      test.defineClassAndMethods('cc')
      test.iseqvec(
        ['return MetaCard;'],
        test.baselang.metaMethodBody('MetaCard', test.metaclass))
    end receiver OoplCpp;

  end behavior metaMethodBody;

  behavior parseBazelLog : any #:
    Perform baselang-specific parsing of a bazel test log file.
  params:
    var logdata : str #:
      The entire content of the logfile.
    var tdata : map #:
      Where to write info.  The following keys must be provided:
        status2: str
          One of 'FATAL' or ...
        count: int
          Number of tests ran
        time2: str
          Amount of time taken to run all tests (num plus time unit)
        methods: dict
          maps class.method to map:
            stdout: str
              the stdout of the test method
            stderr: str
              the stderr of the test method
            us: int
              microseconds taken for this method test
            ok: bool
              True if test passed, false if it failed.
    var debug : bool = false #:
      If true, enable debugging output.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if debug:
        dsep('OoplPython.parseBazelLog Input', delim='@')
        print logdata
        print tdata
        dsep('OoplPython.parseBazelLog Input', delim='@', end=True)
      methods = tdata['methods']

      /# Parse the test.log file.  Contains following structure
      /#   exec ${PAGER:-/usr/bin/less} "$0" || exit 1
      /#   -----------------------------------------------------------------------------
      /#   <one_char_per_test>
      /#   <errors>
      /#   ----------------------------------------------------------------------
      /#   <summary>
      /#
      /#   <status>
      /#   <stdout>
      /#
      /# where
      /#   <one_char_per_test> is '.' or 'E' or ?
      /#   <errors> starts with a line of '======'
      /#   <summary> is of form "Ran 2 tests in 0.001s"
      /#   <status> is of form "FAILED (errors=1)" or "OK"
      /#   <stdout> is the stdout from the test
      /#     - when using Meta infrastructure, setUp() prints out the name
      /#       of the class and method followed by '...'
      /#     - the code executed by the test may add arbitrary output
      /#     - the Meta infrastructure, in tearDown(), prints out the
      /#       time taken in microseconds and ERROR or FAIL if error occurred.
      summary_re = re.compile(
        r'\nRan (?P<count>\d+) tests? in (?P<time>\S+)')
      status_re = re.compile(
        r'\n(?P<status>FAILED|OK)(?: \((?P<counts>\S+)\))?\s*')
      sum = summary_re.search(logdata)
      stat = status_re.search(logdata)
      if not sum or not stat:
        print
        print 'summary: %s' % sum
        print 'status : %s' % stat
        print logdata
        print 'ERROR: Failed to find expected match(es)'
        tdata['status2'] = 'FATAL'
        return

      statdata = stat.groupdict()
      sumdata = sum.groupdict()
      /# print '#' * 70; print target; print statdata; print sumdata

      tdata['count'] = int(sumdata['count'])
      tdata['time2'] = sumdata['time']
      tdata['status2'] = statdata['status']

      /# Obtain error text
      /#  - everything before the start of the sum match if ============ exists
      eqidx = logdata.find('\n=======================')
      if eqidx == -1:
        errors = ''
      else:
        errors = logdata[eqidx:sum.start(0)]
      /#print errors

      /# Now parse the error text
      /#  - after splitting, edata will contain 3K+1 elements where K is the
      /#    number of errors
      /#  - index 0 is text before the first error
      /#     - stdout from code outside test method invocations (useful for
      /#       debugging).
      /#  - within the 3-tuple:
      /#     - index 0 is the name of the method
      /#     - index 1 is the name of the class
      /#     - index 2 is the error text
      ere = re.compile(r'\nERROR: test_(\S+)\s+\(\S+\.(\S+)\)\n')
      edata = ere.split(errors)
      n = len(edata)
      assert (n-1) % 3 == 0
      preout = edata[0].strip()
      if False and preout:
        print '-' * 70
        print preout
        print '-' * 70
        pprint.pprint(edata)

      i = 1
      while i < n:
        method_name = edata[i]
        class_name = edata[i+1]
        assert class_name.endswith('Test')
        class_name = class_name[:-4]
        cmname = class_name + '.' + method_name
        stderr = edata[i+2]
        methods.setdefault(cmname, {})['stderr'] = stderr
        i += 3

      /# Parse the stdout
      /#  - everything after the end of the stat match.
      /#  - consists of
      /#     <class>.<method>     ...<stdout> <time> <status>
      /#    where
      /#      <class> is the name of the class being tested (not test class)
      /#      <method> is the name of the method being tested (not test method)
      /#      <stdout> is whatever was written to stdout when test was run.
      /#               (may contain newlines)
      /#      <time> is how long the test took (<num> ' us')
      /#      <status> is optional and is either ERROR or FAILED
      stdout = logdata[stat.end(0)-1:]  # -1 so we start on a newline (ore below relies on it)
      if stdout[0] != '\n':
        print '#' * 70
        print logdata
        print '-' * 70
        print stdout
        print '#' * 70
        return

      ore = re.compile(
        r'\n(?P<cmname>[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+)\s+\.\.\.')
      tre = re.compile(r' *(?P<us>\d+) us\s+')
      olines = ore.split(stdout)
      n = len(olines)
      assert (n-1) % 2 == 0
      /# There are 2K+1 elements in olines (first element is text before
      /# first method (ignored)). Within each pair of elements thereafter,
      /# first is class.method, second is output (including time at end)
      i = 1
      while i < n:
        cmname = olines[i]
        stdout = olines[i+1]
        tm = tre.search(stdout)
        mdata = methods.setdefault(cmname, {})
        if not tm:
          raise Error('Failed to parse microseconds from "%s"' % stdout)
        mdata['us'] = int(tm.group('us'))
        /# We remove the time data from stdout
        stdout = stdout[:tm.start(0)]
        mdata['stdout'] = stdout
        i += 2
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      methods = tdata['methods']

      if debug:
        dsep('OoplJavascript.parseBazelLog Input', delim='@')
        print logdata
        print tdata
        dsep('OoplJavascript.parseBazelLog Input', delim='@', end=True)

      msre = re.compile(r'^(\d{2}):(\d{2}):(\d{2})\.(\d{3})$')

      def StrToMs(val):
        /# Convert a string in form HH:MM:SS.mmm into milliseconds.
        m = msre.match(val)
        if not m: raise Error('Invalid ms "%s"' % val)
        seconds = int(m.group(1)) * 3600 + int(m.group(2)) * 60 + int(m.group(3))
        ms = seconds * 1000 + int(m.group(4))
        return ms

      class_start_re = re.compile(
        r'\n-> (?P<time>\S+) : Starting tests: (?P<fqn>\S+)\n')
      class_end_re = re.compile(
        '\n-> (?P<time>\S+) : (?P<runcount>\d+) of (?P<count>\d+) tests run in (?P<duration>\S+)\.\n')
      method_start_re = re.compile(
        r'^-> (?P<time>\S+) : Running test: (?P<method>\S+)')

      tdata['status2'] = '???'

      ms = class_start_re.search(logdata)
      me = class_end_re.search(logdata)
      if ms and me:
        fqn = ms.group('fqn')
        parts = fqn.split('.')
        class_name = ClassConstruct.UntestifyName(parts[-1])
        namespace_name = '.'.join(parts[:-1])

        tdata['subcount'] = int(me.group('runcount'))
        tdata['count'] = int(me.group('count'))
        tdata['time2'] = me.group('duration')

        methdata = logdata[ms.end(0):me.start(0)]
        if methdata.strip():
          end_re = None
          method = None
          stdout = None

          if debug:
            print methdata
            print '=' * 70

          for line in methdata.split('\n'):
            m = method_start_re.match(line)
            if m:
              test_method_name = m.group('method')
              method_name = ExecutableConstruct.UntestifyName(test_method_name)
              end_re = re.compile(
                '^-> (?P<time>\S+) : %s : (?P<status>\S+)' % test_method_name)
              cmname = class_name + '.' + method_name
              stdout = []

              if debug:
                print 'Found test method: %s' % str(m.groupdict())

              mdata = methods.setdefault(cmname, {})
              mdata['start'] = m.group('time')
            elif end_re is None:
              print '**** IGNORING %s' % line
            else:
              /# We should always find a method_start before we need end_re.
              m = end_re.match(line)
              if m:
                /# Found end of method.
                mdata['stdout'] = '\n'.join(stdout)
                /# TODO(wmh): Where is stderr written??? Remember that this
                /# isn't necessarily actually stderr, but rather any error
                /# output produced while running the test.
                /# NOTE(wmh): Only add 'stderr' if there are actual errors.
                mdata['end'] = m.group('time')
                mdata['us'] = (StrToMs(mdata['end']) - StrToMs(mdata['start'])) * 1000
                if debug:
                  print 'Found end of method: %s' % str(mdata)
                end_re = None
                stdout = None
              else:
                assert line.startswith('-> ')
                stdout.append(line[3:])

          if stdout:
            print '***** ERROR! Have left-over stdout'
            print '\n'.join(stdout)

          if debug:
            print '@' * 70

      else:
        print 'ERROR: Failed to find class tests!'

      /#import pprint; pprint.pprint(tdata)
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if debug:
        dsep('OoplCpp.parseBazelLog Input', delim='@')
        print logdata
        print tdata
        dsep('OoplCpp.parseBazelLog Input', delim='@', end=True)
      methods = tdata['methods']

      /# Parse the test.log file. You can see the output interactively with:
      /#   % cd ./tests/cc/gtest/src
      /#   % blaze test --test_output=all :PersonTest
      /#
      /# Contains following structure
      /#   exec ${PAGER:-/usr/bin/less} "$0" || exit 1
      /#   -----------------------------------------------------------------------------
      /#   <env_initializer_output>
      /#   [==========] Running <M> tests from <N> test case.
      /#   [----------] Global test environment set-up.
      /#   <env_setup_output>
      /#   [----------] <M> tests from FrenchDeckTest
      /#   <setupcase_output>
      /#   [ RUN      ] <class>Test.test_<method>
      /#   <initializer_output>
      /#   <setup_output>
      /#   <output>
      /#   <teardown_output>
      /#   <finalizer_output>
      /#   [       OK ] <class>Test.test_<method> (<ms> ms)
      /#   [ RUN      ] <class>Test.test_<method2>
      /#   <*_output2>
      /#   ...
      /#   [  FAILED  ] <class>Test.test_<method2> (<ms2> ms)
      /#   [ RUN      ] <class>Test.test_<method3>
      /#   <*_output3>
      /#   ...
      /#   [       OK ] <class>Test.test_<method3> (<ms3> ms)
      /#   ...
      /#   <teardowncase_output>
      /#   [----------] <M> tests from <class>Test (<class_ms> ms total)
      /#
      /#   [----------] Global test environment tear-down
      /#   <env_teardown_output>
      /#   [==========] 3 tests from 1 test case ran. (1 ms total)
      /#   [  PASSED  ] 2 tests.
      /#   [  FAILED  ] 1 test, listed below:
      /#   [  FAILED  ] FrenchDeckTest.test_asStr
      /#
      /#    1 FAILED TEST
      /#   <env_finalizer_output>
      /#
      /# where
      /#   <env_initializer_output>
      /#     output in the initializer of the global Environment subclass
      /#     (usually not provided unless we make it a namespace-wide option).
      /#   <env_setup_output>
      /#     output from Environment::SetUp()
      /#   <setupcase_output>
      /#     output from <class>Test::SetUpTestCase()
      /#   <initializer_output>
      /#     output from <class>Test::<class>Test
      /#   <setup_output>
      /#     output from <class>Test::SetUp()
      /#   <output>
      /#     output from <class>Test::test_<method>
      /#   <teardown_output>
      /#     output from <class>Test::TearDown()
      /#   <finalizer_output>
      /#     output from <class>Test::~<class>Test
      /#   <teardowncase_output>
      /#     output from <class>Test::TearDownTestCase()
      /#   <env_teardown_output>
      /#     output from Environment::TearDown()
      /#   <env_finalizer_output>
      /#     output from Environment::~Environment()

      def StrToMicroSeconds(tstr):
        assert tstr.endswith(' ms')
        return int(tstr[:-3]) * 1000

      /# The following is a collection of regexps that should match lines in
      /# logdata. Any line not matching one of these is output associated with
      /# the section identified by the current index.
      /#
      /# Index 7 is special in that we can transition either to index 8 or
      /# index 5 (this cycle allows us to parse multiple test methods).
      regexps = [
        re.compile(r'^exec.*PAGER.*exit'),
        re.compile(r'^---{50,}$'),
        re.compile(
          r'\[==========\] Running (?P<count>\d+) tests from 1 test case\.$'),
        re.compile(
          r'\[----------\] Global test environment set-up\.$'),
        re.compile(
          r'\[----------\] (?P<count>\d+) tests from (?P<class>\S+)Test$'),

        /# This starts the parsing of a test method
        re.compile(
          r'\[ RUN      \] (?P<class>\S+)Test\.test_(?P<method>\S+)$'),

        /# This ends the parsing of a test method.
        re.compile(
          r'\[\s*(?P<mstatus>OK|FAILED)\s*\] '
          r'(?P<class>\S+)Test\.test_(?P<method>\S+) \((?P<mtime>\d+\s*\S+)\)'),

        /# This is the special regexp ... if we are looking for this one,
        /# we need to also check for index 5 (if index 5 matches, we loop
        /# back, processing another test).
        re.compile(
          r'\[----------\] (?P<count>\d+) tests from (?P<class>\S+)Test '
          r'\((?P<time2>\d+ \S+) total\)$'),

        re.compile(
          r'\[----------\] Global test environment tear-down'),
        re.compile(
          r'\[==========\] (?P<count>\d+) tests from 1 test case ran.*'),
        re.compile(r'\[  PASSED  \] (?P<passed>\d+) tests\.'),
        re.compile(r'\[  FAILED  \] (?P<failed>\d+) test, listed below:'),
      ]

      outputs = {}
      matches = {}
      order = []
      index = 0

      for line in logdata.split('\n'):
        if index >= len(regexps):
          outputs.setdefault(index, []).append(line)
        else:
          m = regexps[index].match(line)
          if m:
            /# We have found a new regexp. We advance the regexp index. Any
            /# line that doesn't match against the next regexp is added to
            /# outputs[index-1] (with index 7 being special).
            if debug:
              print 'Found index %d: %s for %s' % (index, str(m.groupdict()), line)
            matches[index] = m.groupdict()
            index += 1
          else:
            /# For every index except 7, the only transition is to index+1.
            /# However, at index 7, we can transition to either 8 or 5, so
            /# the code below checks for the transition to 5.  This means
            /# we are finished parsing one test method and are parsing
            /# another (instead of finishing the parsing of methods).
            if index == 7:
              m = regexps[5].match(line)
              if m:
                /# We are current on the line after the line matching index 6.
                /# There are only two possible matches:
                /#  1) it matches index 7, which ends the method-specific part
                /#     of parsing
                /#  2) it matches index 5, the start of another unittest.
                /#
                /# We are in situation #2 ... it matches index 5. This means
                /# we've just finished processing a test method, with the
                /# (merged) stdout and stderr available in outputs[5] and
                /# some additional info available in matches[5] and matches[6]
                order.append((matches[5], matches[6], outputs[5]))
                matches[5] = m.groupdict()
                outputs[5] = []
                index = 6
              else:
                outputs.setdefault(index - 1, []).append(line)
            else:
              /# The current line did not match next (or prev) regexp, so
              /# it belongs to the output for index-1.
              outputs.setdefault(index - 1, []).append(line)
              if index == 8:
                /# We've matched index 7, so we've parsed the final test method.
                order.append((matches[5], matches[6], outputs[5]))

      /# Now we parse 'order' into 'methods'
      for start_dict, end_dict, stderr in order:
        assert start_dict['class'] == end_dict['class']
        assert start_dict['method'] == end_dict['method']
        cmname = '%s.%s' % (start_dict['class'], start_dict['method'])
        ok = end_dict['mstatus'] == 'OK'
        methods[cmname] = {
          /# It appears that C++ log files to not make any distinction between
          /# stdout and stderr (unfortunate!). We put everything in stderr.
          'stdout': None,
          'stderr': stderr,
          'us': StrToMicroSeconds(end_dict['mtime']),
          'ok': ok
        }

      /# Establish overall status2
      if 11 in matches:
        assert matches[11]['failed'] > 0
        status = 'FAILED'
      else:
        status = 'OK'
      tdata['status2'] = status

      /# Establish count of number of tests.
      count = matches[7]['count']
      assert count == matches[4]['count']
      tdata['count2'] = int(count)

      /# Establish time taken for all tests.
      tdata['time2'] = matches[7]['time2']

      if debug:
        for i in sorted(outputs):
          print i
          for line in outputs[i]:
            print '  ' + line
        pprint.pprint(matches)
        pprint.pprint(order)

    test:
      logdata = (
        >|"""exec ${PAGER:-/usr/bin/less} "$0" || exit 1
        >|-----------------------------------------------------------------------------
        >|[==========] Running 3 tests from 1 test case.
        >|[----------] Global test environment set-up.
        >|[----------] 3 tests from FrenchDeckTest
        >|[ RUN      ] FrenchDeckTest.test_FrenchDeck
        >|Fix C++ teardown
        >|[       OK ] FrenchDeckTest.test_FrenchDeck (0 ms)
        >|[ RUN      ] FrenchDeckTest.test_asStr
        >|unknown file: Failure
        >|C++ exception with description "TestCase.iseq() not yet implemented" thrown in the test body.
        >|Fix C++ teardown
        >|[  FAILED  ] FrenchDeckTest.test_asStr (1 ms)
        >|[ RUN      ] FrenchDeckTest.test_meta
        >|Fix C++ teardown
        >|[       OK ] FrenchDeckTest.test_meta (0 ms)
        >|[----------] 3 tests from FrenchDeckTest (1 ms total)
        >|
        >|[----------] Global test environment tear-down
        >|[==========] 3 tests from 1 test case ran. (1 ms total)
        >|[  PASSED  ] 2 tests.
        >|[  FAILED  ] 1 test, listed below:
        >|[  FAILED  ] FrenchDeckTest.test_asStr
        >|
        >| 1 FAILED TEST
        >|""")
      tdata = {
        'methods': {},
        /# 'log': logdata, 'logpath': '?', 'dir': '?', 'namespace': '?', 'class': '?'
      }
      baselang, _, _, _ = test.cachedInfo('cc')
      baselang.parseBazelLog(logdata, tdata, debug=False)

      test.iseq(
        {'count2': 3,
         'status2': 'FAILED',
         'time2': '1 ms',
         'methods': {
           'FrenchDeck.FrenchDeck': {
             'ok': True,
             'stderr': ['Fix C++ teardown'],
             'stdout': None,
             'us': 0,
           },
           'FrenchDeck.asStr': {
             'ok': False,
             'stderr': ['unknown file: Failure',
             'C++ exception with description "TestCase.iseq() not yet implemented" thrown in the test body.',
             'Fix C++ teardown'],
             'stdout': None,
             'us': 1000,
           },
           'FrenchDeck.meta': {
             'ok': True,
             'stderr': ['Fix C++ teardown'],
             'stdout': None,
             'us': 0,
           },
         },
        }, tdata)
    end receiver OoplCpp;

  end behavior parseBazelLog;

  behavior receiverStr : str #:
    Obtain the baselang-specific receiver variable
  params:
    var method : ExecutableConstruct #:
      The executable for which a receiver is desired.
    var location : str = null #:
      The location feature value of the method. If null, obtained from
      method.
    var style : str = 'base' #:
      One of 'base', 'meta' or 'auto'
        base:
          Use the baselang-defined receiver variable. Note that python and
          perl do not have a lang-defined variable name, but by convention
          the receiver is 'self' in both languages (and 'cls' for class
          methods).
        meta:
          Use the meta-defined receiver variable ('self' for instance,
          'meta' for metaclass, 'test' for testclass)
        auto:
          Establish the meta-level receiver, then look for that variable
          in the user-provided body of the method.  If found, use that
          variable, else use the 'base' variable.
    var myclass : ClassConstruct = null #:
      The class of the method.  If null, uses method.myclass().
    var sep : bool = false #:
      If true, append the separator character. For style 'base', this
      is baselang-dependent, but for style 'meta' it is always '.'.
    var deref : bool = false #:
      If true, return the version of the base receiver that can respond
        to '.'. For example, for C++, returns '(*this)', because
        '(*this).func()' is legal.
  scope:

    receiver BaseLanguageOopl scope:
      if myclass is None:
        myclass = method.myclass()
      if location is None:
        location = method.attrval('location')
      attrkind = method.attrval('kind')
      if style == 'base':
        if attrkind == 'static':
          /# TODO(wmh): Some baselangs will need to use fqn rather than id.
          /# Also, in C++, the separator between the receiver and method is
          /# different for static methods than for instance/meta methods, and
          /# will have to be special-cased in FieldConstruct.expandMeta().
          result = myclass.id()
        elif self.id() in ('python', 'perl'):
          if myclass.isMeta() or attrkind == 'cls':
            result = 'cls'
          else:
            result = 'self'
        else:
          pvar = 'cls' if location == 'meta' else 'self'
          result = self.config(pvar)
      elif style == 'meta':
        if myclass.isTest():
          result = 'test'
        elif myclass.isMeta():
          result = 'meta'
        else:
          kind = method.attrval('kind')
          result = 'meta' if kind == 'cls' else 'self'
      elif style == 'auto':
        meta_result = 'self' if location == 'user' else location
        pvar = 'cls' if location == 'meta' else 'self'
        base_result = self.config(pvar)
        /# TODO(wmh): search method.attrval('scope:') for references to
        /# the variable stored in result. If found, use it, else use the
        /# baselang version.
        raise Error('Not yet supporting receiverStr(base="%s")' % style)
      else:
        raise Error('Invalid style "%s"' % style)

      if sep:
        if style == 'base':
          result += self.config('selfsep')
        else:
          result += '.'
      if deref:
        if style == 'base':
          /# TODO(wmh): Generalize? We could define receiverStr() as
          /# a behavior, with this implementation as the default. C++ would
          /# call super and modify slightly.
          if self.id() == 'cpp':
            result = '(*' + result + ')'
      return result
    test:
      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      oopljs, _, _, _ = test.cachedInfo(basel='javascript')
      ooplcc, _, _, _ = test.cachedInfo(basel='cpp')

      filec = metax.c.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.c.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.c.ClassConstruct.NewFromData(
        'Card', context, parent=namespace.attr('scope:'),
        secondaries=[('scope:', [])])

      /# instance method
      instance_method = metax.c.MethodConstruct.NewFromData(
        'f', context, parent=klass.attr('scope:'))
      instance_method.myclassIs(klass)
      test.iseq('self', ooplpy.receiverStr(instance_method, location='user'))
      test.iseq('self', ooplpy.receiverStr(instance_method))
      test.iseq('self', ooplpy.receiverStr(instance_method, style='meta'))
      test.iseq('this', oopljs.receiverStr(instance_method, location='user'))
      test.iseq('this', oopljs.receiverStr(instance_method))
      test.iseq('self', oopljs.receiverStr(instance_method, style='meta'))
      test.iseq('this', ooplcc.receiverStr(instance_method, location='user'))
      test.iseq('this', ooplcc.receiverStr(instance_method))
      test.iseq('self', ooplcc.receiverStr(instance_method, style='meta'))

      /# meta method
      meta_method =  metax.c.MethodConstruct.NewFromData(
        'F', context, parent=klass.attr('scope:'),
        features=[('location', 'meta')])
      meta_method.myclassIs(klass)
      klass.variantIs('meta')
      test.iseq('cls',  ooplpy.receiverStr(meta_method, location='meta'))
      test.iseq('cls',  ooplpy.receiverStr(meta_method))
      test.iseq('meta', ooplpy.receiverStr(meta_method, style='meta'))
      test.iseq('this', oopljs.receiverStr(meta_method, location='meta'))
      test.iseq('this', oopljs.receiverStr(meta_method))
      test.iseq('meta', oopljs.receiverStr(meta_method, style='meta'))
      test.iseq('this', ooplcc.receiverStr(meta_method, location='meta'))
      test.iseq('this', ooplcc.receiverStr(meta_method))
      test.iseq('meta', ooplcc.receiverStr(meta_method, style='meta'))

      /# test method
      test_method =  metax.c.MethodConstruct.NewFromData(
        'test_f', context, parent=klass.attr('scope:'),
        features=[('location', 'test')])
      test_method.myclassIs(klass)
      klass.variantIs('test')
      test.iseq('self', ooplpy.receiverStr(test_method, location='test'))
      test.iseq('self', ooplpy.receiverStr(test_method))
      test.iseq('test', ooplpy.receiverStr(test_method, style='meta'))
      test.iseq('this', oopljs.receiverStr(test_method, location='test'))
      test.iseq('this', oopljs.receiverStr(test_method))
      test.iseq('test', oopljs.receiverStr(test_method, style='meta'))
      test.iseq('this', ooplcc.receiverStr(test_method, location='test'))
      test.iseq('this', ooplcc.receiverStr(test_method))
      test.iseq('test', ooplcc.receiverStr(test_method, style='meta'))

      /# Testing the 'sep' param
      test.iseq('self.', ooplpy.receiverStr(instance_method, sep=True))
      test.iseq('this.', oopljs.receiverStr(instance_method, sep=True))
      test.iseq('this->', ooplcc.receiverStr(instance_method, sep=True))

      /# Testing the 'deref' param
      test.iseq('self', ooplpy.receiverStr(instance_method, deref=True))
      test.iseq('this', oopljs.receiverStr(instance_method, deref=True))
      test.iseq('(*this)', ooplcc.receiverStr(instance_method, deref=True))
    end receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      result = super(OoplCpp, self).receiverStr(
        method, location=location, style=style, myclass=myclass, sep=sep)
      if deref:
        if style == 'base':
          result = '(*' + result + ')'
      return result
    test:
      /# Noop - tested in BaseLanguageOopl.receiverStr()
      pass
    end receiver OoplCpp;

  end behavior receiverStr;

  behavior repl #:
    Perform a read-execute-print loop for this baselang.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      banner = 'Welcome to Meta'
      locals = {'a': 1}
      code.interact(banner=banner, local=locals)
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# TODO(wmh): Generalize location of phantomjs
      /# TODO(wmh): Need to set things up so that phantomjs loads up the
      /# Meta environment, including any meta files specified.
      subprocess.call(['pjs'])
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      template = """
      >|# include <iostream>
      >|using namespace std;
      >|int main() {
      >|%(body)s
      >|}
      >|"""

      prompt = '>>> '
      execfile = './tmp'
      tmpfile = 'tmp.cc'
      chunks = []

      import os
      while True:
        /# Obtain a new chunk of C++ code to add to the previous chunks.
        /#  - if line is empty or ends with ';' or '}', terminate
        /#  - otherwise keep reading input
        lines = []
        while True:
          /# Read one line
          line = raw_input(prompt)

          /# Check for exit request.
          if line in ('exit', 'quit'):
            return

          /# Check for special print request
          m = re.match('^\s*(?:p|print)\s+(.*)', line)
          if m:
            line = 'cout << %s << endl;' % m.group(1).strip().rstrip(';')

          /# Register line
          lines.append(line)

          /# Determine if we need to ask for another line or end reading.
          if not line or line[-1] in (';', '}'):
            break
        text = '\n'.join(lines)
        chunks.append(text)

        /# Obtain the C++ code to compile.
        code = template % {'body': '\n'.join(chunks)}
        with open(tmpfile, 'w') as fp:
          fp.write(code)

        /# Compile code, and if no compilation errors, run code.
        rc = subprocess.call(['g++', '-o', execfile, tmpfile])
        if rc == 0:
          rc = subprocess.call([execfile])


        if rc == 0:
          /# The code did not produce any compile-time or run-time error, so
          /# we leave it in place.  However, we modify the new chunk so that
          /# any code that prints to cout is commented out.
          /#  - this correctly handles 'p a'
          /#  - this correctly handles 'if (a) { cout << "blah" << endl; }'
          /#  - this incorrectly comments out the cout in
          /#      class A { public: A() { cout << "hello!" << endl; } };
          /#    but we provide an escape-hatch by not commenting out std::cout
          /#      class A { public: A() { std::cout << "hello!" << endl; } };
          chunks.pop()
          qtext = re.sub(r'(^[:])(cout[ <][^;]+;)', r'\1/* \2 */', text)
          chunks.append(qtext)

        else:
          /# The new chunk of C++ code produced a compile or run-time error,
          /# so we remove it from the list of chunks.
          chunks.pop()
    test:
    end receiver OoplCpp;

  end behavior repl;

  behavior superCode : void #:
    Write baselang code to invoke a superclass method.
  params:
    var method : ExecutableConstruct #:
      The method for which super code is desired.
    var output : vec<str> #:
      Where to append lines of baselang code representing the super-call.
    var width : int = 80 #:
      Maximum width that lines can take on.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      recstr = self.receiverStr(method)
      myclass = method.myclass()
      class_name = myclass.id()
      method_name = method.id()
      super_method = 'super(%s, %s).%s' % (class_name, recstr, method_name)
      metafile = method.metafile()

      /# TODO(wmh): Should we do LOOKUP here? If we don't always do it
      /# (except for block-valued attributes) how will the user know when an
      /# attribute is inherited and when it isn't?  On the other hand, if
      /# super doesn't exist explicitly, we could assume the parent is invoked
      /# with the same args as method, providing a convenient short-hand that
      /# is common.
      super_attr, super_args = method.attrpair('super', default=None)
      if super_args:
        param_str, _ = self.compileExpr(
          super_args, metafile, executable=method)
        /# TODO(wmh): This logic should be implemented in compileExpr. Note
        /# that it already has the method in 'executable', so it can obtain
        /# the params and check for multi vars.
        params = method.parsedParams()
        varvec = params.get('varvec', None)
        varmap = params.get('varmap', None)
        if varvec or varmap:
          arglist = re.split(r'\s*,\s*', param_str[1:-1])
          if varvec:
            for i, arg in enumerate(arglist):
              if arg == varvec['name']:
                arglist[i] = '*' + arg
                break
          if varmap:
            for i, arg in enumerate(arglist):
              if arg == varmap['name']:
                arglist[i] = '**' + arg
                break
          param_str = '(%s)' % (', '.join(arglist))
      else:
        param_str = '()'

      if len(super_method) + len(param_str) < width:
        output.append(super_method + param_str)
      else:
        output.append(super_method + '(')
        output.append('    ' + param_str[1:])
    test:
      test.defineClassAndMethods('py')

      /# An initializer
      out = []
      test.baselang.superCode(test.initializer, out)
      test.iseqvec(['super(Card, self).__init__(a, b=1, c=False)'], out)

      /# A non-iniitalizer method
      out = []
      test.baselang.superCode(test.method2, out)
      test.iseqvec(['super(Card, self).f(a, b=1, c=False)'], out)
    end receiver OoplPython;

    receiver OoplJavascript scope:
      kind = method.attrval('kind', default=metax.c.LOOKUP)
      recstr = self.receiverStr(method)
      myclass = method.myclass()
      class_name = myclass.id()
      method_name = method.id()

      use_es2015_classes = self.config('use_es2015')

      args = []

      if use_es2015_classes:
        super_method = 'super'
      else:
        super_method = '%s.base' % myclass.fqn()
        args.append(recstr)

      if kind == 'initializer':
        if not use_es2015_classes:
          args.append("'constructor'")
      else:
        if use_es2015_classes:
          super_method += '.' + method.id()
        else:
          args.append("'%s'" % method.id())

      /# TODO(wmh): Should we do LOOKUP here? If we don't always do it
      /# (except for block-valued attributes) how will the user know when an
      /# attribute is inherited and when it isn't?  On the other hand, if
      /# super doesn't exist explicitly, we could assume the parent is invoked
      /# with the same args as method, providing a convenient short-hand that
      /# is common.
      metafile = method.metafile()
      super_attr, super_args = method.attrpair('super', default=None)
      if super_args:
        for sarg in super_args.value():
          sstr, _ = self.compileExpr(sarg, metafile, executable=method)
          args.append(sstr)
      output.append(super_method + '(' + ', '.join(args) + ');')


    test:
      oopljs, _, context, _ = test.cachedInfo(basel='javascript')

      filec = metax.c.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.c.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.c.ClassConstruct.NewFromData(
        'Card', context, namespace.attr('scope:'), secondaries=[('scope:', [])])
      kscope = klass.attr('scope:')
      exprp = metax.c.ExprParser(test.metafileFor('(a, b=1, c=false)\n'))
      expr = exprp.parse()

      /# An initializer
      initializer = metax.c.MethodConstruct.NewFromData(
        '__init__', context, parent=kscope,
        features=[('kind', 'initializer')],
        secondaries=[('super', expr)])
      initializer.myclassIs(klass)
      out = []
      oopljs.superCode(initializer, out)
      test.iseqvec(["super(a, b=1, c=false);"], out)

      /# A non-iniitalizer method
      method = metax.c.MethodConstruct.NewFromData(
        'f', context, parent=kscope, secondaries=[('super', expr)])
      method.myclassIs(klass)
      out = []
      oopljs.superCode(method, out)
      test.iseqvec(["super.f(a, b=1, c=false);"], out)
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      kind = method.attrval('kind')

      if kind == 'initializer':
        /# The superCode() method is for generating code WITHIN a code block
        /# for invoking a superclass method. Invoking a parent constructor
        /# in C++ happens in the initlist, NOT within the code block, so we
        /# write nothing to output for initializers here ... handled in
        /# OoplCpp.augmentVarset().
        pass
      else:
        myclass = method.myclass()
        parent_classes = myclass.parentclasses()
        parent = parent_classes[0]
        pfqn = parent['fqn']
        pparts = pfqn.split('.')

        method_name = method.id()
        metafile = method.metafile()
        super_method = 'this->%s::%s' % (pparts[-1], method_name)

        /# TODO(wmh): Should we do LOOKUP here? If we don't always do it
        /# (except for block-valued attributes) how will the user know when an
        /# attribute is inherited and when it isn't?  On the other hand, if
        /# super doesn't exist explicitly, we could assume the parent is invoked
        /# with the same args as method, providing a convenient short-hand that
        /# is common.
        super_attr, super_args = method.attrpair('super', default=None)

        if super_args:
          param_str, _ = self.compileExpr(
            super_args, metafile, executable=method)
        else:
          param_str = '()'

        if len(super_method) + len(param_str) + 1 < width:
          output.append('%s%s;' % (super_method, param_str))
        else:
          output.append("%s(" % super_method)
          output.append('    ' + param_str[1:] + ';')
    test:
      test.defineClassAndMethods('cc')
      /# An initializer
      out = []
      test.baselang.superCode(test.initializer, out)
      test.iseqvec([], out)

      /# A non-iniitalizer method
      out = []
      test.baselang.superCode(test.method2, out)
      test.iseqvec(['this->metax::root::Object::f(a, b=1, c=false);'], out)
    end receiver OoplCpp;

  end behavior superCode;

  class ConstructConstruct < MetaConstruct #:
    Used to represent Construct constructs.
  scope:

    method kind : str scope:
      return 'Construct'

  end class ConstructConstruct;

  class AttributeConstruct < MetaConstruct #:
    Used to represent Attribute constructs.
  scope:

    method kind : str scope:
      return 'Attribute'

  end class AttributeConstruct;

  class FeatureValueConstruct < MetaConstruct #:
    Used to represent FeatureValue constructs.
  scope:

    method kind : str scope:
      return 'FeatureValue'

  end class FeatureValueConstruct;

  class FileConstruct < MetaConstruct #:
    Used to represent File constructs.
  assocs:
    std assoc time;
  scope:

    method kind : str scope:
      return 'File'

    method path : str #:
      The path to this construct within the metafile.
    scope:
      return ''
    test:
    end method path;

    method expandMeta #:
      Expand all top-level constructs in this file.
    scope:
      D.expand.sinfo(self.id())
      scope, children = self.attrpair('scope:')
      user_children = list(children)
      for child in user_children:
        child.expandMeta()
      D.expand.end()
    end method expandMeta;

    method importMeta #:
      Import additional .meta files identified during expandMeta.
    scope:
      D.imports.sinfo(self.id())

      debug = False

      /# We obtain the set of metafiles that this metafile depends on that
      /# have not already been parsed.
      metapaths = set()
      metafile = self.metafile()
      metac = metafile.compiler()
      existing_classes = metac.classes()
      existing_metafiles = metac.metafiles()
      fs = metac.fs()
      baselang = metac.baselang()
      if debug:
        print 'HERE in FileConstruct.importMeta for %s' % metafile.path()
      for fqn in metafile.classdeps():
        if fqn in existing_classes:
          /# We already have the class parsed, so we do not need to check its
          /# meta file.
          pass
        else:
          class_path = fs.join(metac.repositoryPath(), baselang.classPath(fqn))
          meta_path = metac.basePathToMeta(class_path)

          /# Canonicalize path
          if meta_path is None:
            /# This can happen, for example, when a user specifies 
            /#   cls assoc <class>;
            /# when <class> is not a legal class.
            klass = metac.classes().get(fqn, None)

            /# TODO(wmh): Decide how to enable/disable this.
            if False:
              metafile.warning(
                'Failed to find class %s' % fqn,
                line=klass.primary().line() if klass else -1)
          elif fs.exists(meta_path):
            meta_path = fs.realpath(meta_path)

          /# Register metafile
          if debug:
            print '  %s = %s' % (fqn, meta_path)
          if meta_path in existing_metafiles:
            pass
          elif meta_path:
            metapaths.add(meta_path)

      /# We import all of the dependent metafiles.
      for meta_path in metapaths:
        if debug:
          print '  *** Loading %s' % meta_path
        metafile = metac.getMeta(
          meta_path, expand=True,
          /# I suspect there are times where we will need to perform a
          /# recursive invocation of imports, but am not yet clear whether it
          /# is better to do it depth-first (here) or breadth-first (by
          /# iterating within this method until no more metafiles exist).
          /# Prelminary experiments with setting this to True were causing us
          /# to load the same file multiple times, but that may be fixed
          /# (and if not, can be fixed).
          imports=False,
          /# We definitely don't need to translate or compile these classes.
          translate=False, compile=False)
        if debug:
          print '  *** Loaded %s' % metafile.path()

      /# Establish which metafiles need to be transitively loaded due to
      /# additional unresolved dependencies in the above code.
      /#  - TODO(wmh): what needs to be done here?

      /# Now we have our children perform post-import actions.
      scope, children = self.attrpair('scope:')
      user_children = list(children)
      for child in user_children:
        child.importMeta()

      D.imports.end()
    end method importMeta;

    method translateMeta scope:
      D.translate.sinfo(self.id())
      scope, children = self.attrpair('scope:')
      for child in children:
        child.translateMeta()
      D.translate.end()
    end method translateMeta;

    method compileMeta scope:
      D.compile.sinfo(self.id())
      scope, children = self.attrpair('scope:')
      for child in children:
        child.compileMeta()
      D.compile.end()
    end method compileMeta;

  end class FileConstruct;

  class TemplateConstruct < MetaConstruct #:
    Used to represent Template constructs.
  scope:

    method kind : str scope:
      return 'Template'
    test:
      cons = metax.c.TestxConstruct('testx', None, test.context())
      test.iseq('testx', cons.kind())
    end method kind;

  end class TemplateConstruct;

  abstract
  class OoplConstruct < Construct #:
    Abstract superclass of all constructs within Meta(Oopl)
  scope:

    abstract
    method kind : str #:
      The kind of construct.
    end;

    method expandMeta #:
      Each subclass overrides this method to perform expansion of the construct
      associated with the subclass. The code in these implementations are mostly
      baselang-agnostic, since they deal with the creation of implicit
      Meta-level constructs, moving constructs around, etc. However, some
      special-casing is needed based on esoteria of individual baselangs.

      IMPORTANT ISSUES TO KEEP IN MIND:
       - each construct should be expanded exactly once (not counting situations
         where an expandMeta() method is invoked on a construct and it is
         determined that nothing should be done for the instance in question
         (this can happen, for example, when invoking expandMeta() on
         class-level constructs ... if the location is 'meta' or 'test' the
         construct is moved to a different class and the current invocation
         should NOT do any further expansion (expansion will happen when the
         other class is expanded).
       - each construct is reponsible for invoking expandMeta() on its children
       - if an expandMeta() method creates new sub-constructs, whether or
         not the new construct should have expandMeta() invoked on it depends
         on the following:
          - if the new construct is added to a different class or namespace,
            it should NOT need to be immediately expanded, as it will be
            expanded when that other class/namespace is expanded (as long
            as that other class/namespace hasn't already been expanded).
          - if the new construct is added to the same class, and the new
            construct has an expandMeta() defined, one should in most cases
            invoke expandMeta() on that sub-construct at the time it is created.

       - NamespaceConstruct.expandMeta(), when invoked on a user-defined
         namespace, creates a test namespace, then expands all subconstructs of
         the user-defined namespace (which populates the test namespace with
         various constructs).
          - At the end of this expandMeta(), the test namespace is expanded via
            a call to expandMeta().
          - No construct needs to expand any autogened subconstruct that is
            placed into the test namespace ... it will be expanded when the test
            namespace is expanded.

       - ClassConstruct.expandMeta(), when invoked on a user-defined namespace,
         creates a metaclass then expands all subconstructs of the user-defined
         class (which populates the metaclass with meta-level constructs,
         and populates the test namespace with test-level constructs).
          - At the end of ClassConstruct.expandMeta(), the metaclass is
            expanded via another call to expandMeta()
          - No construct needs to expand any autogened subconstruct that is
            placed into the metaclass ... it will be expanded when the metaclass
            is expanded.
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      /# TODO(wmh): Switch this to be abstract to force children to
      /# define the method.
      print '%s: %sConstruct.expandMeta() should be defined' % (
        self.kindid(), self.kind().capitalize())
    end method expandMeta;

    method translateMeta : vec<BaseFile> #:
      Each subclass overrides this method to perform compilation of
      the construct associated with the subclass. The code in these
      implementations should be baselang-agnostic, but may invoke code
      on the BaseLanguageOopl subclass stored in the compiler to
      perform baselang-specific actions.
    scope:
      /# TODO(wmh): Switch this to be abstract to force children to
      /# define the method.
      print '%s: %sConstruct.translateMeta() should be defined' % (
        self.kindid(), self.kind().capitalize())
    end method translateMeta;

    method myclass : ClassConstruct #:
      Dummy implementation of myclass for use in constructs that appear
      within a class construct but which do not maintain a myclass field.
    scope:
      return None
    test:
    end method myclass;

    method myclassIs #:
      Dummy implementation of myclassIs for use in constructs that appear
      within a class construct but which do not maintain a myclass field.
    params:
      var klass : ClassConstruct;
    scope:
    test:
    end method myclassIs;

  end class OoplConstruct;

  abstract
  class SymbolConstruct < OoplConstruct #:
    Abstract superclass of constructs that maintain a symbol table mapping
    identifiers to sub-constructs accessible at runtime.
  scope:

    field symbols : SymbolTable #:
      The symbols visible from code within the level of this construct.
      For example:
       - namespaces contain the singleton class instances (MetaFoo, MetaBar,
         etc).  They do NOT contain the class names themselves, as not all
         baselangs treat classes as first-class objects.
       - classes contain all method and field names
          - the symboltable of class B should link to the symboltable of
            class A if B is a child of A.
          - if class symbol tables link to parent class symbol tables, does
            that mean that we need to support multiple parents to also support
            'inheriting' from namespaces? We *could* copy parent data into
            symbol tables at time of linking, but this incurs more space
            overhead and makes it more difficult to support dynamic modification
            of classes at runtime within Meta (if symbol tables inherit,
            dynamically adding a field to a class C means it is immediately
            available in subclasses without us having to update symboltables
            other than C).
       - methods contain all params and local vars not within a lexically
         scoped subblock.
       - lexical blocks contain vars introduced within the block

    lifecycle params:
      var uid : str;
      var parent : ComplexBlock;
      var context : Context;
      var precount : int = 0;
    super (uid, parent, context, precount)
    scope:
      /# NOTE: The first arg passed to SymbolTable should be a SymbolTable
      /# instance (for classes, for example, it is the SymbolTable associated
      /# with the parent class). At time of construct creation, we do not
      /# necessarily have such a construct, so the parent field of these symbol
      /# tables must be patched up within *Construct.importMeta() when the
      /# inheritance hierarchy is guaranteed to exist.
      self.symbolsIs(SymbolTable(self, None))
    end;

    method registerSymbol #:
      Add a symbol to this construct's symbol table.
    params:
      var name : str #:
        The symbol name.
      var construct : Construct #:
        The construct associated with the symbol.
    scope:
      table = self.symbols()
      /# print '%s registering symbol %s = %s' % (self.kindfqn(), name, construct.kindfqn())
      table.register(name, construct, source=self)
    test:
      test.defineClassAndMethods('py')
      method = test.method
      test.iseq([], sorted(test.klass.symbols().allSymbols()))
      test.klass.registerSymbol(method.id(), method)
      test.iseq(['show'], sorted(test.klass.symbols().allSymbols()))
    end method registerSymbol;

    method symbolNamed : Construct #:
      Obtain a symbol within this construct by name.
    params:
      var name : &str #:
        The name of the symbol desired.
      var kind : str = null #:
        If not null, and the symbol identified by 'name' is not of kind 'kind'
        print an error to the metafile.
    scope:
      result = self.symbols().find(name)
      if kind and (not result or result.kind() != kind):
        metafile = self.metafile()
        if result:
          metafile.error(
            'Expecting %s to be of kind %s' % (result.kindfqn(), kind),
            line=result.primary().line())
        else:
          metafile.error(
            'Expecting to find %s %s within %s' %
            (kind or '', name, self.kindfqn()),
            line=self.primary().line())
        result = None
      return result
    test:
      test.defineClassAndMethods('py')
      method = test.method
      test.isnull(test.klass.symbolNamed('show'))
      test.klass.registerSymbol(method.id(), method)
      test.issame(method, test.klass.symbolNamed('show'))
    end method symbolNamed;

    method establishType : Type #:
      Given the name of a variable within a particular scope that has a
      symbol table, establish the type of that variable.

      Returns:
        null if the variable does not exist in the symboltable.
    params:
      var varname : str #:
        Name of variable.
    scope:
      result = None
      table = self.symbols()
      construct = table.find(varname)
      if construct:
        try:
          result = construct.effectiveType()
        except AttributeError as e:
          print 'WARNING: Failed to find effective type for %s (%s): %s' % (
            construct.kindfqn(), construct.__class__.__name__, str(e))
          result = None
      return result
    test:
    end method establishType;

  end class SymbolConstruct;

  class NamespaceConstruct < SymbolConstruct #:
    Represents a 'namespace' construct.

    Implementation issues:
     - Each user class has additional implicit classes associatied with it:
        - a meta class
        - a test class
        - a meta class for the test class
        - a test class for the meta class
     - Notes
        - meta classes do not have meta classes
        - test classes do not have test classes
        - If a user class is in nm.sp.Class
           - the associated test class is in nm.sp_test.ClassTest
           - the associated meta class is currently placed in nm.sp.Class__Meta
             (i.e. metaclasses share the same namespace as the user class,
              but test classes do not).
  scope:

    meta
    method TestifyName : str #:
      Convert a namespace name to a testspace name.
    params:
      var name : str #:
        relative or fully qualified name of namespace to make a test version of.
    scope:
      return name + '_test'
    end method TestifyName;

    meta
    method UntestifyName : str #:
      Convert a testspace name to a namespace name.
    params:
      var name : str #:
        Relative or fully qualified name of testspace name.
    scope:
      assert name.endswith('_test')
      return name[:-5]
    end method UntestifyName;

    field namespace : NamespaceConstruct #:
      The parent namespace of this namespace. It is not called parentspace
      or something similar because we need it to match the naming expectations
      of Class.namespace, etc. ... all constructs that can appear within
      a namespace are expected to have a 'namespace' field that represents
      their parent.

    field testspace : NamespaceConstruct #:
      The NamespaceConstruct instance representing the test namespace associated
      with this namespace.
       - if self is a user namespace, testspace is initialized in expandMeta
         to a new namespace
       - if self is a test namespace, testspace is self
       - note that metaclasses and userclasses share the same namespace.

    field userspace : NamespaceConstruct #:
      The NamespaceConstruct instance representing the user namespace associated
      with a test namespace.
       - if self is a user namespace, userspace is self
       - if self is a test namespace, userspace is the namespace from which
         it was generated.

    field types : @map<str,TypeWrapper> #:
      Maps a type string whose base is a relative class to TypeWrapper
      instance.

    lifecycle params:
      var id : str;
      var parent : ComplexBlock;
      var context : Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      /# This was an experiment performed on 2017/12/30 to see if we could
      /# get namespaces expanded out so that nm.sp is two namespaces instead
      /# of one. Ran into a few issues:
      /#  - when we do this work in the constructor, code in parseComplexBlock
      /#    after our rejiggering attempts to invoke registerConstruct()
      /#    with the FileConstruct parent (the one we were trying to remap).
      /#  - constructor terminator code starts failing with
      /#       E43: Parsing namespace cards1 but found terminator for namespace demo.cards1
      /#
      /# I'm going to experiment with an alternative solution in which we do
      /# the expansion in NamespaceConstruct.expandMeta() instead.
      if False:
        self.createImplicitParents(id, parent, context)
    end;

    method createImplicitParents : any #:
      An experiment in creating namespace parents. As of 2017/12/30 it is NOT
      being used.  Left in place in case the explorations about implementing
      in expandMeta() don't work out.
    params:
      var id : str;
      var parent : ComplexBlock;
      var context : Context;
    scope:
      if '.' in id:
        /# We perform some implicit work here to create a hierarchy of
        /# NamespaceConstruct instances.
        parts = id.split('.')
        final_nmsp = parts.pop()

        /# The only time we should find a '.' in a namespace id is when
        /# the normal parsing flow of MetaFile.parseConstruct finds
        /# a namespace in a meta source file with nested id.
        /# In such a situation, its parent should be a FileConstruct.
        filecons = parent.parent()
        assert filecons.kind() == 'File'

        /# We need to verify the existence of N-1 ancestor namespaces if there
        /# are N parts in the 'id'. If any ancestor namespace does not already
        /# exist, it is created, inheriting from an appropriate scope: block.
        /#
        /# As an example, suppose id is nm.sp2.sub, and that nm.sp1 is already
        /# registered (so 'nm' already exists), but neither 'sp2' nor 'sub'
        /# are registered.
        /#  - we first find the pre-existing 'nm' within the passed in parent
        /#    block
        /#  - we obtain the 'scope:' block of 'nm'
        /#  - we look for 'sp2', and since it is not present, we create it,
        /#    specifying the block we just looked in as its parent. A scope:
        /#    block is created as part of the creation of 'sp2'.
        /#  - we obtain the 'scope:' block of 'sp2'
        /#  - we are now at the final namespace 'sub', which was what this
        /#    method was invoked to create.  The super call has currently
        /#    set its id to 'nm.sp2.sub', and its parent to the FileConstruct
        /#    scope:.  We update the id to be 'sub', and the parent to be the
        /#    scope: block on 'sp2'
        parent_construct = filecons
        parent_scope = parent
        print 'scope of filecons path: %s' % parent_scope.path()
        for pid in parts:
          child = parent_scope.cons(pid, default=None)
          if child:
            /# Found a pre-existing ancestor namespace
            assert child.kind() == 'namespace'
            parent_construct = child
          else:
            /# There is no ancestor namespace with given name in its parent,
            /# so we create it.
            parent_construct = NamespaceConstruct.NewFromData(
              pid, context, parent=parent_scope,
              secondaries=[('scope:', [])])
          print 'cons path %s' % parent_construct.path()
          parent_scope = parent_construct.attr('scope:', default=REQUIRED)
          print 'scope path %s' % parent_scope.path()

        /# Now we process the final_nmsp by updating self's id and parent.
        self.idIs(final_nmsp)
        self.parentIs(parent_scope)
        print 'final nmsp path is %s' % self.path()
        print 'HERE with %s vs %s' % (id, self.fqn())
    test:
    end method createImplicitParents;

    method kind : str scope:
      return 'namespace'

    method variant : str #:
      One of 'user' or 'test', indicating which namespace this is.
    scope:
      result = 'user' if self.userspace() is self else 'test'
      return result
    test:
    end method variant;

    method isTest : bool #:
      True if this namespace is a testspace.
    scope:
      return self.variant() == 'test'
    test:
    end method isTest;

    method registerType #:
      Register a type with this namespace for use in making relative
      types absolute.
    params:
      var wtype : TypeWrapper;
    scope:
      key = wtype.wrappedRaw()
      if key in self._types:
        raise InternalError(
          'Reregistering wrapped type %s in %s' % (key, self.id()))
      self._types[key] = wtype
    end method registerType;

    method getType : TypeWrapper #:
      Obtain a previously cached typed
    params:
      var reltypestr : str;
    scope:
      return self._types.get(reltypestr, None)
    end method getType;

    method expandMeta #:
      Expand the namespace:
       - Create test namespace
       - Recurse to children.
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      D.expand.sinfo(self.kindfqn())
      name = self.id()
      fqn = self.fqn()
      parent = self.parent()
      context = self.context()

      if fqn.endswith('_test'):
        /# We are expanding the auto-generated test namespace.
        istest = True
        test_name = None
        testspace = None

      else:
        istest = False
        test_name = name + '_test'

        /# TODO(wmh): Create multiple namespaces, one for each part in
        /# the id. This will be a good transition test for doing something
        /# similar for the user namespace.

        /# Create the test namespace
        secondaries = [
          ('comment:', ['Auto-generated test namespace for %s.' % name]),
          ('scope:', [])
        ]
        testpreports_attr = self.attr('testpreports:', default=None)
        if testpreports_attr:
          secondaries.append(('preports:', testpreports_attr.value()))
        testspace = NamespaceConstruct.NewFromData(
          /# TODO(wmh): Verify that the implicit testspace should share the
          /# same context as the user namespace.
          test_name, context, parent=parent,
          secondaries=secondaries,
          precount=1,
        )
        self.testspaceIs(testspace)
        self.userspaceIs(self)
        testspace.userspaceIs(self)
        testspace.testspaceIs(testspace)
        if output is not None:
          output.append(testspace)

        /# TODO(wmh): If 'name' (aka self.id()) contains dots, we need to
        /# modify the chain of parents
        /#  - find/create NamespaceConstruct instances for each component of
        /#    the id, with proper parent and a new 'scope:' attribute.
        /#  - unregister self from its current parent, register within the
        /#    new parent, and update self.id().

      /# Invoke expandMeta() on child constructs.
      /#  - we make a copy of children so that we do NOT expand the classes
      /#    added to children by calls to child.expandMeta().
      scope, children = self.attrpair('scope:')
      user_children = list(children)
      for child in user_children:
        /# All constructs within namespace should have a namespace field
        /# within which we can cache the namespace.
        child.namespaceIs(self)

        /# Some child classes need to be expanded now, while others should NOT
        /# be expanded now because they will be expanded later (expanding a
        /# class twice can cause problems).
        expand = True

        /# If the child is a class
        /#  - if we are processing a user-level namespace:
        /#      - the class is either a 'user' class, a 'metauser'
        /#        class or a 'testuser' class.
        /#  - if we are processing a test namespace:
        /#      - the class is either an auto-generated test class associated
        /#        with a user class, or is a user-provided test class.
        /#  - It is important to set variant before invoking expandMeta.
        if child.kind() == 'class':
          if istest:
            /# We are in a autogened testspace.
            /#
            /# The testspace is not expanded until after the user namespace has
            /# been expanded, which means all user classes have been expanded
            /# and the various autogenerated classes have been created. Since
            /# ClassConstruct.expandMeta() sets the 'variant' field of the
            /# autogenerated fields, we can use the variant to distinguish
            /# between autogenerated classes and user-specified test classes.
            /#  - autogen test classes will have variant 'test'
            /#  - user-provided test classes will have variant 'testuser'
            testvariant = child.variant()
            if testvariant == 'test':
              /# auto-generated test class associated with user class.
              pass
            elif testvariant == 'metatest':
              /# autogened metaclass for autogened testclass of user class.
              pass
            elif testvariant == 'testuser':
              /# user-provided test class.
              pass
            elif testvariant == 'testmeta':
              /# autogened testclass for autogened metaclass of user class.
              pass
            else:
              child.write()
              raise Error('Unhandled testvariant "%s"' % testvariant)
          else:
            /# We are in the user-provided namespace. The class construct
            /# is one of:
            /#   user:
            /#     a standard user-provided class
            /#   testuser:
            /#     a user-provided class to put in the autogened test namespace
            /#   metauser:
            /#     a user-provided metaclass
            location = child.attrval('location', default=metax.c.LOOKUP)
            variant = 'user'
            if location != 'user':
              variant = location + variant
            child.variantIs(variant)

        /# Expand the child (class, etc.)
        if expand:
          child.expandMeta()

      if testspace:
        /# The testspace variable is defined only if we are in the user
        /# namespace and have finished expanding the user code base.  By
        /# invoking expandMeta() on testspace we ensure that any constructs
        /# added to that namespace are properly expanded next.
        testspace.expandMeta()

        if output is not None:
          output.append(testspace)
      D.expand.end()
    test:
      /# Using a local compiler instead of cached one because we were seeing
      /# errors in this test when all tests were included, but not when it
      /# was run stand-alone (implies some corruption between tests).
      metac = metax.c.Compiler(metal='oopl', basel='python')
      cards1, scope, namespace, path = test.getMetaFile(
        'oopl', 'cards1', compiler=metac)
      namespace.expandMeta()
    end method expandMeta;

    method importMeta scope:
      D.imports.sinfo(self.id())

      /# For namespaces, importMeta is primarily a means to invoke
      /# ClassConstruct.importMeta(), which does more heavy lifting. However,
      /# this method is also where we register each class within the namespace
      /# in the symboltable of the namespace.
      table = self.symbols()
      assert table.construct() is self
      scope, children = self.attrpair('scope:')
      for child in children:
        child.importMeta()

        /# CODETANGLE(highlevel_symbols): For namespaces, what resides in the
        /# symboltable are the names of classes within the namespace, and the
        /# names of other namespaces that have been specified as required.
        /#  - highlevel symbols for classes = class ids (which represent the
        /#    metaclass).
        /#  - baselang symbols for classes = singleton instance of metaclass,
        /#    at least in baselangs without first-class classes).
        /#  - We are currently implementing high-level semantics.
        if child.isClass():
          if not child.isMeta():
            table.register(child.id(), child, source=self)
      D.imports.end()
    end method importMeta;

    method translateMeta : vec<BaseFile> #:
      Namespace compilation code.
       - compile all classes into separate files
       - for languages that are namespace-primary (e.g. Python), create a
         file representing the namespace (aka module)
       - create a BUILD file containing all targets for building the classes
         in the namespace, and for building the namespace itself.
    scope:
      D.translate.sinfo(self.kindfqn())

      fqn = self.id()
      metac = self.compiler()
      baselang = self.baselang()
      metafile = self.metafile()
      scope_sep = Context.TOKENS['scope_sep']
      nameparts = fqn.split(scope_sep)
      nmspbase = nameparts[-1]
      fs = metac.fs()

      /###
      /# Process the scope.  Children include:
      /#   class
      /#   native
      /#   static method (in the future)
      /#   static field (in the future)
      scope, children = self.attrpair('scope:')
      triples = []
      blds = []
      test_classes = []
      namespace_primary = baselang.config('namespace_primary')
      for child in children:
        basefiles = child.translateMeta()
        assert len(basefiles) == 2
        basefile, bld = basefiles
        if child.kind() == 'class':
          triples.append((child, basefile, bld))
          if child.isTestCase():
            test_classes.append(child)
        if bld is not None:
          /# print '%s = %d' % (basefile.subpath(), len(basefile.contents()))
          assert bld.subpath().endswith('.bld'), bld.subpath()
          blds.append(bld)

      /# Perform baselang-specific namespace processing.
      /#  - instantiate the template representing a namespace in the baselang.
      /#  - most languages do not have syntax for defining a namespace in
      /#    aggregate, but python does.
      /#  - if a baselang doesn't have a namespace-specific syntax, it should
      /#    simply not define a Template in the 'namespace' construct.
      basel = baselang.id()
      if basel == 'python':
        basefiles = self.compilePython(kind='merge', triples=triples)
        bld = basefiles[-1]
        assert bld.subpath().endswith('.bld'), bld.subpath()
        blds.append(bld)

      /# Create the BUILD file
      bfqn = fqn + scope_sep + 'BUILD'
      buildpath = metac.basePath(bfqn)
      contents = baselang.buildPreambleText()
      for bld in blds:
        contents += bld.contents()
      if self.isTest() and not baselang.config('namespace_primary'):
        /# For baselangs that are NOT namespace_primary, the leaf-level
        /# namespace target ('//nm/sp_test:sp_test') is implemented as a
        /# test_suite that invokes each of the per-class test targets.
        /# On the other hand, in namespace_primary languages we do something
        /# different (see the NamespaceConstruct.compilePython.__init__.bld()
        /# method).
        build = {
          'name': nmspbase,
          'tests': [':%s' % k.id() for k in test_classes]}
        contents += '\n' + baselang.formatBuildRule('test_suite', build) + '\n'

      buildfile = BaseFile(buildpath, contents, metafile=metafile)
      metafile.registerFile(buildfile)

      /# TODO(wmh): Now that namespaces are nested within namespaces, determine
      /# whether this should be returning something meaningful!
      return [None, None]

      D.translate.end()
    test:
      print 'FIX NamespaceConstruct.translatemeta'
      return
      cards1, scope, namespace, path = test.getMetaFile(
        'oopl', 'cards1', debuglevel=0)
      namespace.expandMeta()
      namespace.translateMeta()
      metac = namespace.compiler()
      test.isfalse(namespace.metafile().hasErrors(show=True))
      fs = metac.fs()
      /# fs.summarize()
      test.iseqvec(
        ['oopl/python/demo/__init__.py',
         'oopl/python/demo/cards1/.Card.py',
         'oopl/python/demo/cards1/.CardMeta.py',
         'oopl/python/demo/cards1/.Pack.py',
         'oopl/python/demo/cards1/.PackMeta.py',
         'oopl/python/demo/cards1/.Pile.py',
         'oopl/python/demo/cards1/.PileMeta.py',
         'oopl/python/demo/cards1/.__init__.bld',
         'oopl/python/demo/cards1/BUILD',
         'oopl/python/demo/cards1/__init__.py'
        ],
        sorted(fs.filemap()))
    end method translateMeta;

    method compilePython : vec<BaseFile> #:
      Compile this namespace into python. Creates __init__.py

      Returns:
       0) basefile : BaseFile
         The __init__.py file
       1) bldfile : BaseFile
         The .__init__.bld file
    params:
      var kind : str = 'merge' #:
        Legal values are:
          merge: merge all class files into __init__.py
          import: import all class files into __init__.py
      var triples : vec<tuple<ClassConstruct,BaseFile,BaseFile>> = null #:
        Each element is a triple containing a class construct, the
        BaseFile containing the class code, and a BaseFile containing
        the .bld fragment.
    scope:
      fqn = self.id()
      metac = self.compiler()
      baselang = self.baselang()
      metafile = self.metafile()
      variant = self.variant()
      scope_sep = Context.TOKENS['scope_sep']
      nameparts = fqn.split(scope_sep)
      nmspbase = nameparts[-1]
      fs = metac.fs()
      /# TODO(wmh): How to establish the actual width?
      width = 80 - 0
      basesuffix = baselang.suffix()
      fqn += scope_sep + '__init__'

      /# comments : vec<str>
      /#   Documentation for the namespace.
      comment_attr, comment = self.attrpair('comment:', default=None)
      comment = baselang.formatComment(comment, width=width)

      /# preports : vec<str>
      /#   This is arbitrary baselang code that should appear before anything
      /#   else in the namespace.  Used to modify path, perform special actions
      /#   like modifying encoding type, etc.
      preports_attr = self.attr('preports:', default=None)
      preports = baselang.simpleToBase(preports_attr)

      /# prelines: vec<str>
      /#   The total set of lines added before classes in the merged
      /#   namespace.
      prelines = ['# -*- coding: utf-8 -*-'] + comment + preports

      /# classes : vec<str>
      /#   The baselang code for importing the classes.
      scope = self.attr('scope:')
      if kind == 'merge':
        mapfile = MapFile(
          metac.basePath(fqn, prefix='.', suffix=basesuffix + '.map'),
          fs.realpath(fs.abspath(metafile.path())),
          [])
        all_lines, targets = self._mergeClassesPython(
          triples, mapfile, prelines)
      elif kind == 'import':
        all_lines, targets = self._importClassesPython(triples)
      else:
        raise Error(
          'NamespaceConstruct.compilePython: Invalid kind "%s"' % kind)

      /# IMPORTANT: We are currently NOT using the Template constructs
      /# in the namespace construct for python.  They should either
      /# be removed, or we should move to a mechanism whereby we do use
      /# them.  The difficulty is in getting the line numbers from the
      /# mapfile initialized by _mergeClassesPython() to reflect reality,
      /# but it would certainly be possible with a bit of effort.
      if self.isTest():
        all_lines.extend([
          '',
          '',
          "if __name__ == '__main__':",
          "  metax.test.main()"
        ])

      else:
        /# Experimenting with the introduction of a 'Meta()' method in each
        /# user namespace.

        /# CODETANGLE(implicit_objectmeta)
        all_lines.append('')
        all_lines.append('')
        all_lines.append('def Meta():')
        all_lines.append('  return metax.root.MetaObject')

      basefile = BaseFile(
        metac.basePath(fqn, suffix=basesuffix),
        '\n'.join(all_lines) + '\n', metafile=metafile, mapfile=mapfile)
      metafile.registerFile(basefile)

      /# Create the .__init__.bld file:
      bldpath = metac.basePath(fqn, prefix='.', suffix='.bld')
      istest = self.isTest()
      if False:
        /# Useful during debugging.
        print bldpath
        print '  Targets:'
        for target in targets:
          print '    ' + target

      rule, build_data = baselang.createBuildFragment(
        self, targets, test=istest,
        name=nmspbase, src='__init__.py')
      if istest:
        /# Bazel expects a py_test with name 'cards_test' to have its source
        /# in 'cards_test.py', but in our case it is in '__init__.py'. We
        /# can fix this by adding a 'main' target.
        build_data['main'] = '__init__.py'
      bldfile = None
      if rule is not None:
        fragment = baselang.formatBuildRule(rule, build_data)
        bldfile = BaseFile(bldpath, '\n' + fragment + '\n', metafile=metafile)
        metafile.registerFile(bldfile)

      /# Ensure that all package directories have a __init__.py file.
      pqn = ''
      for base in nameparts[:-1]:
        if pqn: pqn += scope_sep
        pqn += base
        subpath = fs.join(metac.basePath(pqn), '__init__.py')
        initpath, _ = fs.subfilePath(subpath)
        if not fs.exists(initpath):
          initfile = BaseFile(subpath, '', metafile=metafile)
          metafile.registerFile(initfile)

      return basefile, bldfile
    test:
    end method compilePython;

    method _mergeClassesPython : tuple<vec<str>,vec<str>> #:
      Generate the lines in a namespace file by merging all class files.

      Returns:
        0. The list of lines in the namespace file
        1. The list of build targets needed by the namespace.
    params:
      var triples : vec<tuple<ClassConstruct,BaseFile,BaseFile>> #:
        Each element is a triple containing a class construct, the
        BaseFile containing the class code, and a BaseFile containing
        the .bld fragment.
      var mapfile : MapFile #:
        The merged mapfile across all base files.
      var prelines : vec<str> #:
        The list of lines appearing before imports in the namespace
        (e.g. comment, preports, etc.)
    scope:
      debug = 0

      /# TODO(wmh): Move elsewhere
      impre = re.compile(
        r'import\s+(?P<import>\S+)(?:\s*#\s*target=(?P<target>\S+))?')

      /# TODO(wmh): Make these less fragile. Any changes to the 'End Imports'
      /# or 'Start Harness' lines in templates will raise an Error.
      end_start = '##########  End Imports  ##########\n'
      start_end = '########## Start Harness ##########\n'

      fqn = self.id()

      /# chunks contains (offset, lines) pairs
      chunks = []

      /# imports : vec<str>
      /#  - Accumulates all the import lines from individual classes, to be
      /#    inserted at the top of the namespace file. Preserves order of
      /#    imports (based on first time seen), hence the vec instead of set.
      imports = []
      /#  - Individual import statements may have ' # target=' comments
      /#    specifying associated targets. These are extracted.
      targets = set()
      for klass, basefile, bldfild in triples:
        /# We merge all of the class files into the __init__.py.
        /#  - if we are defining namespace nm.sp, we need to find all
        /#    references to nm.sp.<class> and replace them with <class>
        /#    (alternatively, we can ensure that nm.sp is available within
        /#    nm.sp).
        /#      - IMPORTANT: replacing nm.sp.<class> with <class> is
        /#        non-trivial, as we do NOT want to replace <class> within
        /#        strings, only when it is an actual class reference. Better
        /#        to get 'nm.sp.<class>' working within <class>. Disabling
        /#        replacement for now.
        /#  - the per-class file maps need to be merged and modified into
        /#    .__init__.py.map
        r = re.compile(
          r'([^a-zA-Z0-9_])%s\.([a-zA-Z0-9_]+)' % re.escape(fqn))
        /# DISABLED 2017-12-23 as flawed (replaces occurences in strings,
        /# which breaks metax.root.Object.Resource(..., fqn='...').
        /# contents = r.sub(r'\1\2', basefile.contents().rstrip())
        contents = basefile.contents().rstrip()
        istestcase = klass.isTestCase()

        submapfile = basefile.mapfile()

        /# All python class files are required to have a line containing
        /# end_start.
        start_index = contents.find(end_start)
        if start_index == -1:
          raise Error('Failed to find "%s" in\n%s' % (end_start, contents))
        start_index += len(end_start)
        assert contents[start_index-1] == '\n'
        import_lines = contents[:start_index-1].split('\n')
        start_removed = len(import_lines)
        for line in import_lines:
          /# Parse the import line (into import and target).
          /#  - May need to generalize to support
          /#      'from nm.sp import X as Y'
          /#  - The order in which imports appear is sometimes critically
          /#    important, so we maintain the order (based on when first seen).
          if line and line[0] == '#': continue
          m = impre.match(line)
          if m:
            impline = 'import %s' % m.group('import')
            if impline not in imports:
              imports.append(impline)
            target = m.group('target')
            if target:
              targets.add(target)
          else:
            raise Error('Not currently supporting imports of form "%s"' % line)

        if debug > 3:
          print '#' * 80
          print 'Removed from start'
          sys.stdout.write(contents[:start_index])
          print '-' * 80

        /# All python test class files are required to have a line containing
        /# start_end.
        if istestcase:
          /# The class in question is a test class, so we require it to have
          /# the end_start and start_end lines.
          end_index = contents.rfind(start_end)
          if end_index == -1:
            raise Error('Failed to find "%s" in\n%s' % (start_end, contents))
          assert contents[end_index] == '#', (
            'Expecting index %d of contents to be "#" not "%s"' %
            (end_index, contents[end_index-5:end_index+5]))
          end_removed = contents[end_index:].count('\n')
          if debug > 3:
            print '#' * 80
            print 'Removed from end'
            print contents[end_index:]
            print '=' * 80
          /# By decrementing end_index to position ourselves on the newline,
          /# we ensure that when we split the resulting content into lines,
          /# we do not introduce a spurious newline at the end.
          end_index -= 1
          assert contents[end_index] == '\n'
        else:
          end_index = len(contents)
          end_removed = 0

        lines = contents[start_index:end_index].split('\n')
        chunks.append((start_removed, lines, submapfile))

        if debug > 2:
          print '#' * 80
          print contents
        if debug > 1:
          print '-' * 80
        if debug:
          fs = self.compiler().fs()
          print '%-25s: removed %d start lines and %d end lines leaving %d lines' % (
            fs.basename(basefile.subpath()), start_removed, end_removed, len(lines))
        if debug > 1:
          submapfile.serialize()

      /# We add some special importation code to ensure that one can access all
      /# classes within the namespace fully-qualified (by default, python does
      /# not add 'sp' to 'nm' until after 'nm.sp' has been parsed).
      all_lines = prelines + sorted(imports)
      try:
        my_index = all_lines.index('import ' + fqn)
        /# We need to add some lines of code after myindex to ensure the module
        /# is available fully qualified. It is important that this special
        /# code occur before we import any namespaces within this namespace,
        /# so that they too have access to the fully qualified namespace (so
        /# we cannot insert the special code at the end of all_lines).
        new_lines = []
        parent_nmsp, base_nmsp = fqn.rsplit('.', 1)
        new_lines.append(
          "if not getattr(%s, '%s', None):" % (parent_nmsp, base_nmsp))
        if 'import sys' not in new_lines:
          new_lines.append('  import sys')
        new_lines.append('  %s = sys.modules[__name__]' % fqn)
        n = len(all_lines)
        my_index += 1
        all_lines = all_lines[:my_index] + new_lines + all_lines[my_index:]
        assert len(all_lines) == n + len(new_lines)
      except ValueError:
        pass

      /# Now obtain the merged collection of lines, and associated mapfile.
      /#  - starts with the sorted list of imports
      /#  - we add the (stripped) lines for each class in sequence. The
      /#    final mapfile adds the contents of the associated submapfile with
      /#    the following adjustments to baseline nums in the submapfile
      /#     - subtract 'removed' lines
      /#     - add current length of 'all_lines'
      for removed, lines, submapfile in chunks:
        mapfile.addSubFile(submapfile, len(all_lines) - removed)
        all_lines.extend(lines)

      parts = fqn.split('.')
      mytarget = '//%s:%s' % (fqn.replace('.', '/'), parts[-1])
      targets.discard(mytarget)

      return (all_lines, sorted(targets))
    test:
    end method _mergeClassesPython;

    method _importClassesPython : tuple<vec<str>,vec<str>> #:
      Generate the lines in a namespace file by importing class files.

      Returns:
        0. The list of lines in the namespace file
        1. The list of build targets needed by the namespace.
    params:
      var triples : vec<tuple<ClassConstruct,BaseFile,BaseFile>> = null #:
        Each element is a triple containing a class construct, the
        BaseFile containing the class code, and a BaseFile containing
        the .bld fragment.
    scope:
      classes = []
      targets = []
      for klass, basefile, bldfild in triples:
        /# We are to import each class file into __init__.py
        /#  - this is currently problematic. Suppose we have classes A and B
        /#    and nm/sp/__init__.py contains
        /#      from .A import *
        /#      from .B import *
        /#    then the following:
        /#      import nm.sp.A
        /#    will yield the *module* nm.sp.A (the class is at nm.sp.A.A).
        /#    Need to learn more about how to import symbols, the use
        /#    of __all_, relative vs absolute imports, etc.
        classes.append('from .%s import *' % klass.id())
        targets.append(':' + klass.id())
      return (classes, targets)
    test:
    end method _importClassesPython;

    method compileMeta scope:
      D.compile.sinfo(self.id())

      /# TODO(wmh): Implement this.
      /# - In python
      /#   - create .pyc file to detect syntax errors
      /#   - can we create optimized .par file?
      /#   - do we generate implicit binaries or invoke 'bazel build' on
      /#     py_binary build targets?
      /# - In Javascript
      /#   - Invoke 'bazel build' on js_closure_binary targets
      /# - In C++
      /#   - Invoke 'bazel build' on cc_binary targets
      scope, children = self.attrpair('scope:')
      for child in children:
        child.compileMeta()
      D.compile.end()
    end method compileMeta;

  end class NamespaceConstruct;

  abstract
  class ClassicConstruct < SymbolConstruct #:
    Abstract parent of all constructs that appear within a class.

    Includes field, method, lifecycle, behavior, entry and class.

    Note that there are various constructs that can appear within the 'scope:'
    of a class that are NOT subclasses of ClassicConstruct, including remark,
    category and native (they are more general, and do not need a 'myclass'
    field).
  scope:

    field myclass : ClassConstruct #:
      The class this construct belongs to.

    postx
    method changeParent #:
      Move myself out of my current parent into the new parent.
    params:
      var new_parent : ComplexBlock #:
        The parent to move this construct into.
      var position : str = null #:
        The name of some construct in the new parent preceeded by '+'
        (insert after) or '-' (insert before).  If the position is '+' or
        null, insert at end.  If the position is '-', insert at beginning.
    super (new_parent, position=position)
    scope:
      oldklass = self.myclass()
      klass = new_parent.parent().ancestor('class', proper=False)
      self.myclassIs(klass)
      /# print '**** NOTE: Changed parent of %s which changes class from %s to %s' % (self.fqn(), oldklass.fqn() if oldklass else None, klass.fqn())
    end method changeParent;

    method updateClass : tuple<ClassConstruct,bool> #:
      Decide if this construct needs to be moved to an auto-generated class,
      and if so, move it.

      SideEffects:
        The myclass. field is updated.

      Returns:
        0. The class of the construct after the move (may or may not change).
        1. True if the construct was moved to a different class, false if not.
    scope:
      myclass = self.ancestor('class')
      metafile = myclass.metafile()
      assert myclass is not None
      variant = myclass.variant()
      moved = False
      autogen = myclass.autogenInfo()

      if variant in ('user', 'testuser'):
        /# This is the only variant within which we pay attention to the
        /# 'location' feature attribute:
        /#   - fields with location 'test' are moved to the test class
        /#   - fields with location 'meta' are moved to the meta class.
        /# TODO(wmh): For other variants, if the location is explicitly
        /# provided and different from the default, report a warning/error?
        location = self.attrval('location')

        if location == 'user':
          /# Everything is where it should be
          pass

        elif location == 'test':
          /# Move this construct to the test class
          testclass = myclass.testclass()
          moved = True
          if autogen['test']:
            assert testclass is not None
            testscope = testclass.attr('scope:')
            self.changeParent(testscope)
            myclass = self.myclass()
            assert myclass is testclass
          else:
            assert testclass is None
            metafile.error(
              'Cannot specify test %s when test class is disabled' %
              self.kindfqn(),
              line=self.primary().line())

        elif location == 'meta':
          /# Move this field to the meta class
          metaclass = myclass.metaclass()
          moved = True
          if autogen['meta']:
            assert metaclass is not None
            metascope = metaclass.attr('scope:')
            self.changeParent(metascope)
            myclass = self.myclass()
            assert myclass is metaclass
          else:
            assert metaclass is None
            metafile.error(
              'Cannot specify meta %s when meta class is disabled' %
              self.kindfqn(),
              line=self.primary().line())

        self.myclassIs(myclass)

      else:
        /# If this construct is already in a non-user class, the myclass
        /# field should already be initialized.
        /#  - TODO(wmh): Verify this is always true (and if not, fix it,
        /#    either here or upstream).
        /#  - NOTE(wmh): As of 2017/12/04 the above hypothesis is proved
        /#    incorrect ... classes with location 'test' have variant 'testuser'
        /#    and myclass is not initialized.
        /# print 'HERE with %s and %s and %s' % (self.fqn(), self.myclass(), myclass.fqn())
        assert self.myclass() is myclass

      return myclass, moved
    test:
    end method updateClass;

  end class ClassicConstruct;

  class ClassConstruct < ClassicConstruct #:
    Represents a 'class' construct.

    The userclass, testclass and metaclass fields are set in expandMeta:

                                            class
                   -----------------------------------------------------------
       variant     user  under       test            meta
       -------     ----  -----       ----            ----
       user        Name  null        NameTest        Name__Meta
       test        Name  Name        null            NameTest__Meta
       testmeta    Name  Name__Meta  null            null
       testuser    null  null        null            null
       meta        Name  Name        Name__MetaTest  null
       metatest    Name  NameTest    null            null
       metauser    null  null        null            null

     TODO(wmh): We should probably support test classes on metauser classes
     (e.g. create a testclass for metauser classes).
  scope:

    meta
    method TestifyName : str #:
      Convert a class name to a testclass name.
    params:
      var name : str #:
        relative or fully qualified name of class to make a Test version of.
    scope:
      return name + 'Test'
    end method TestifyName;

    meta
    method UntestifyName : str #:
      Convert a testclass name to a userlass name.
    params:
      var name : str #:
        relative or fully qualified name of testclass name.
    scope:
      assert name.endswith('Test')
      return name[:-4]
    end method UntestifyName;

    meta
    method IsTestName : bool #:
      Check if a name is a testclass name
    params:
      var name : str;
    scope:
      return name.endswith('Test')
    end method;

    meta
    method MetaifyName : str #:
      Convert a class name to a metaclass name.
    params:
      var name : str #:
        relative or fully qualified name of class to make a Meta version of.
    scope:
      return name + 'Meta'
    end method MetaifyName;

    meta
    method MetaInstifyName : str #:
      Convert a class name to a metaclass instance name.
      TODO(wmh): Can we make this an instance method, or is it used in 
      situations where an instance isn't avialable?
    params:
      var name : str #:
        relative or fully qualified name of class to make a Meta version of.
    scope:
      parts = name.split('.')
      parts[-1] = 'Meta' + parts[-1]
      return '.'.join(parts)
    end method MetaInstifyName;

    meta
    method UnmetaifyName : str #:
      Convert a metaclass name to a userclass name.
    params:
      var name : str #:
        relative or fully qualified name of metaclass to obtain userclass for
    scope:
      assert name.endswith('Meta')
      return name[:-4]
    end method UnmetaifyName;

    meta
    method UnmetainstifyName : str #:
      Convert a metaclass instance name to a userclass name.
    params:
      var name : str #:
        relative or fully qualified name of metaclass to obtain userclass for
    scope:
      parts = name.split('.')
      assert parts[-1].startswith('Meta')
      parts[-1] = parts[-1][4:]
      return '.'.join(parts)
    end method UnmetainstifyName;

    meta
    method IsMetaName : bool #:
      Check if a name is a metaclass name
    params:
      var name : str;
    scope:
      return name.endswith('Meta')
    end method;

    meta
    method IsMetaInstName : bool #:
      Check if a name is a metaclass name
    params:
      var name : str;
    scope:
      parts = name.split('.')
      return parts[-1].startswith('Meta')
    end method;

    meta
    method CanonicalizeClassName : str #:
      Canonicalize a class name, handling various special syntaxes.
       - Return null if name is 'void'
       - Fully qualified relative names unless prefixed with '^'

      Returns:
        Fully qualified class name (in meta syntax, not baselang syntax).
    params:
      var name : str #:
        The meta-level class name.
      var namespace : NamespaceConstruct = null #:
        The namespace within which the class type resides.
    scope:
      if name[0] == Context.TOKENS['explicit_class_indicator']:
        /# A class that starts with '^' is a verbatim request from user.
        fqn = name[1:]
      elif name == 'void':
        fqn = None
      else:
        if '.' not in name:
          /# We have a relative class name ... prepend the namespace.
          if namespace is None:
            raise Error('No namespace provided: cannot qualify "%s"' % name)
          fqn = namespace.id() + Context.TOKENS['scope_sep'] + name
        else:
          fqn = name
      return fqn
    test:
      _, _, context, _ = self.cachedInfo()
      CanonicalizeClassName = metax.c.ClassConstruct.CanonicalizeClassName
      test.iseq('object', CanonicalizeClassName('^object'))
      test.iseq(
        'demo.cards1.Card', CanonicalizeClassName('demo.cards1.Card'))
      namespace = metax.c.NamespaceConstruct.NewFromData(
        'demo.cards1', context)
      test.iseq(
        'demo.cards1.Card',
        CanonicalizeClassName('Card', namespace=namespace))
      test.raises(metax.c.Error, CanonicalizeClassName, 'Card')
    end method CanonicalizeClassName;

    field fields : @vec<FieldConstruct> #:
      The list of field constructs in this class. Maintains order in which
      fields are defined. Use self.symbols() to obtain fields by name.

    field packed : vec<FieldConstruct> #:
      The list of fields that are marked packed.

    field namespace : NamespaceConstruct #:
      The namespace this class belongs to.

    field parentclasses : vec<map> #:
      A parsed version of the 'parent' (or 'parents:') attribute.
      Each element is for a different parent (currently focusing on single
      parents, but will want to extend in the future).  The element contains:
        raw: str
          The raw parent string as found in the meta source code.
        fqn: str
          The fully qualified name of the parent class in baselang syntax
        metafqn: str
          The fully qualified name of the parent class in meta syntax
        external: bool
          True if the parent class is NOT defined within Meta. Somewhat
          redundant relative to 'class' except that this can be determined
          earlier in parsing than the class can be.
        class: ClassConstruct
          The ClassConstruct instance representing the parent. Is null for
          all classes until ClassConstruct.importMeta() is invoked, and is
          always null for a parent not defined in Meta.

    field childclasses : @map<str,ClassConstruct> #:
      Maps class ids to ClassConstruct, for those classes that inherit
      directly from this class.

    field underclass : ClassConstruct #:
      The ClassConstruct that this class is based upon.

    field testclass : ClassConstruct #:
      The auto-generated test class associated with this class. This is set
      for user classes and for auto-generated metaclasses of userclasses,
      and is null for all other variants.

    field metaclass : ClassConstruct #:
      The auto-generated meta class associated with this class. This is set
      for user classes and auto-generated test classes of userclasses, and is
      null for all other variants.

    field userclass : ClassConstruct #:
      The user class.
      See class comment for details on what value this takes on.

    field variant : str #:
      Indicates the class variant.  Legal values are:
        user: the user defined class
        test: the implicitly generated test class associated with a user class
        meta: the implicitly generated meta class associated with a user class
        metatest: the implicit metaclass of an implicit test class for a user class
        testmeta: the implicit testclass of an implicit meta class for a user class
        testuser: a user-provided test class
        metauser: a user-provided meta class
        testmetauser: an implicit metaclass for a user-provided test class
        metatestuser: an implicit testclass for a user-provided meta class
        null: not yet initialized

    field resources : @map #:
      Maps resource names to absolute paths to resource, for resources
      defined in the 'associations' attribute of this class.

    field deps : @map #:
      The dependencies of this class.  Maps fully-qualified name to map
      containing:
        kind: str
          One of 'std', 'cls', 'lib', etc.
        target: str
          The bazel target to use for the dependency.
        fqn: str
           The fully qualified name of the dependency
        reason: str
           Why the dependency exists.

    field initializer : MethodConstruct #:
      The initializer associated with this ClassConstruct.

    field clinit : MethodConstruct #:
      The method initializing the static fields of this class.  Often null.

    field extralines : @map<str,vec<str>> #:
      Maps <position> to placement to list of strings, where <position> is one
      of 'pre' or 'post', <placement> is one of 'defn' or 'decl', and the list
      represents baselang text to appear before (post) or after (pre) this
      class. The most common keys are post/defn, because native constructs in
      namespace scope appearing after a class are by default associated with the
      class above them (post) and refer to class definition (defn). For
      languages like C++ that have both a header file and source file, 'defn'
      refers to .cc and 'decl' refers to 'h'.

    field suppress : @map #:
      Maps suppress commands to strings explaining why the error is being
      suppressed.

    method kind : str scope:
      return 'class'

    method __repr__ : str scope:
      return '<%s>' % self.kindfqn()

    method showDebug : any #:
      Write out some state of this class useful during debugging.
    scope:
      fp = sys.stdout
      fp.write('%s: %s\n' % (self.kindfqn(), self.variant()))
      for ckind, construct in (
        ('underclass', self.underclass()),
        ('testclass', self.testclass()),
        ('metaclass', self.metaclass()),
        ('userclass', self.userclass()),
        ('initializer', self.initializer()),
      ):
        fp.write('  %-12s: %s\n' % (ckind, construct.kindfqn() if construct else 'null'))
      fields = self.fields()
      if fields:
        fp.write('  fields:\n')
        for field in fields:
          fp.write('    %s\n' % field.kindfqn())

    test:
    end method showDebug;

    method isTest : bool #:
      True if this class is a test class.
    scope:
      return self.variant() in ('test', 'testmeta', 'testuser')
    test:
    end method isTest;

    method isTestCase : bool #:
      True if this class inherits from metax.test.TestCase.

      TODO(wmh): I suspect this method is being used for two mutually exclusive
      purposes and it needs to be cleaned up.
       1. Does this class inherit from metax.test.TestCase.
           - this includes autogenerated test classes and namespace specific
             testcase classes
       2. Is this class one that will be instantiated in the testsuite.
          - this includes autogenerated test classes but does NOT include
            namespace specific testcase classes.
    scope:
      /# There are two different kinds of classes in the test namespace:
      /# those that are to be instantiated as part of the test harness, and
      /# those that are service classes used indirectly (not directly) by
      /# the test harness.
      /#
      /# Note that the distinction is NOT as simple as "does the class inherit
      /# from metax.test.TestCase", because namespace-specific TestCase classes
      /# inherit from this class but are NOT classes to be tested (instead,
      /# they are superclasses of classes to be tested).
      result = False
      name = self.id()
      underclass = self.underclass()
      if underclass:
        username = underclass.id()
        if name == ClassConstruct.TestifyName(username):
          result = True
      return result
    test:
    end method isTestCase;

    method isMeta : bool #:
      True if this class is a meta class.
    scope:
      return self.variant() in ('meta', 'metatest', 'metauser', 'metatestuser')
    test:
    end method isMeta;

    method addDependency #:
      Add a dependency on this class.
    params:
      var fqn : str #:
        The fully-qualified name of the dependency.
      var kind : str #:
        One of 'std', 'cls', 'lib', etc.
      var reason : str #:
        Why the dependency exists.
      var target : str = '<auto>' #:
        The bazel target associated with the dependency. If it is null,
        no target is generated.  If it is '<auto>', the standard target
        associated with fqn is used.
    scope:
      if target == '<auto>':
        if kind == 'std':
          target = None
        else:
          target = self.baselang().nameToBuildTarget(fqn, lib=kind=='lib')

      deps = self.deps()
      if fqn in deps:
        info = deps[fqn]
        if info['kind'] != kind:
          print '**** WARNING: for %s dep %s has kind %s vs %s' % (
            self.kindfqn(), fqn, kind, info['kind'])
        if info['target'] != target:
          print '**** WARNING: for %s dep %s has target %s vs %s' % (
            self.kindfqn(), fqn, target, info['target'])
      else:
        deps[fqn] = {
          'fqn': fqn, 'kind': kind, 'target': target, 'reason': reason}
        metafile = self.metafile()
        if target:
          metafile.registerDependentClass(fqn)
          /# print 'Adding %s as dependency of %s' % (fqn, metafile.path())
        else:
          /# print 'NOT adding %s as dependency of %s' % (fqn, metafile.path())
          pass
    test:
    end method addDependency;

    method showDependencies #:
      Print out the dependencies of this class.
    params:
      var fp : ostream = out #:
        Where to write output.
    scope:
      deps = self.deps()
      fp.write('%s dependencies\n' % self.kindfqn())
      for fqn in sorted(deps):
        info = deps[fqn]
        fp.write('  %-40s : %-10s = %-40s [%s]\n' % (
          fqn, info['kind'], info['target'], info['reason']))
    test:
    end method showDependencies;

    method validate #:
      Perform consistency checks on this construct to ensure that the
      various fields are internally consistent.

      IMPORTANT: This method is not meant to be used in production code,
      but rather is meant to be inserted during debugging. It can be
      expensive to execute.
    scope:
      meta = self.__class__

      /# The variant should be determined by the values of userclass,
      /# underclass, testclass and metaclass.
      userclass = self.userclass()
      underclass = self.underclass()
      testclass = self.testclass()
      metaclass = self.metaclass()
      variant = self.variant()
      autogen = self.autogenInfo()

      if testclass is not None:
        assert meta.IsTestName(testclass.id())
      if metaclass is not None:
        assert meta.IsMetaName(metaclass.id()), '%s does not have proper Meta name' % metaclass.id()

      if variant == 'user':
        assert userclass is self
        assert underclass is None
        if autogen['test']:
          assert testclass is not None
          assert testclass.userclass() is self
        else:
          assert testclass is None

        if autogen['meta']:
          assert metaclass is not None
        else:
          assert metaclass is None

      elif variant == 'test':
        assert userclass is not None
        assert userclass.testclass() is self
        assert underclass is userclass
        assert testclass is None
        if Compiler.IMPL['metatestclass']:
          assert metaclass is not None
          assert metaclass.underclass() is self
        else:
          assert metaclass is None

      elif variant == 'testmeta':
        assert userclass is not None
        assert userclass.metaclass() is underclass
        assert testclass is None
        assert metaclass is None

      elif variant == 'testuser':
        assert userclass is None
        /# TODO(wmh): These may need updating
        assert underclass is None
        assert testclass is None
        assert metaclass is not None

      elif variant == 'meta':
        assert userclass is not None
        assert userclass.metaclass() is self
        assert underclass is userclass
        assert metaclass is None
        assert testclass is not None
        if Compiler.IMPL['testmetaclass']:
          assert testclass.underclass() is self
        else:
          assert testclass.underclass() is self.underclass()

      elif variant == 'metatest':
        assert userclass is not None
        assert userclass.testclass() is underclass
        assert testclass is None
        assert metaclass is None

      elif variant == 'metauser':
        assert userclass is None
        /# TODO(wmh): These may need updating
        assert underclass is None
        assert testclass is None
        assert metaclass is None

    test:
    end method validate;

    method testClassInfo : tuple<NamespaceConstruct,ComplexBlock,str,str> #:
      Obtain test class information.

      Returns:
       0) NamespaecConstruct
         The namespace within which the test class is to be added
       1) ComplexBlock
         The scope within the namespace within which the test class is to be added.
       2) str
         The (relative) name of the test class
       3) str
         The name of the parent of the test class (relative or absolute).
    scope:
      namespace = self.namespace()
      userblock = namespace.attr('scope:')
      testspace = namespace.testspace()
      testblock = testspace.attr('scope:') if testspace else None
      testparent = self.attrval('testparent', default=metax.c.LOOKUP)
      if testparent == '<special>':
        /# If there is a TestCase class defined within testblock, we use
        /# that as the parent, else we use metax.test.TestCase
        testcase_in_test = testblock.cons('TestCase', default=None) if testblock else None
        testcase_in_user = userblock.cons('TestCase', default=None)
        if (
          testcase_in_test or
          (testcase_in_user and testcase_in_user.attrval('location') == 'test')
        ):
          testparent = 'TestCase'
        else:
          testparent = 'metax.test.TestCase'
        /# print '**** HERE!!! %s = %s' % (self.kindfqn(), testparent)
      testname = ClassConstruct.TestifyName(self.id())
      assert testspace is not None
      return (testspace, testblock, testname, testparent)
    end method testClassInfo;

    method metaClassInfo : tuple<NamespaceConstruct,ComplexBlock,str,str> #:
      Obtain the meta namespace and metaclass name.

      Returns:
       0) NamespaceConstruct
         The namespace within which the meta class is to be added
       1) ComplexBlock
         The scope within the namespace within which the meta class is to be added.
       2) str
         The (relative) name of the meta class
       3) str
         The name of the parent of the meta class (relative or absolute).
    scope:
      metaspace = self.namespace()
      metablock = metaspace.rawattr('scope:') if metaspace else None
      metaparent = self.attrval('metaparent', default=metax.c.LOOKUP)

      if metaparent == '<special>':
        /# We did not find an explicit metaparent, so we compute it dynamically:
        /#  - if the parent of the userclass is meta-defined, that parent
        /#    has an auto-generated metaclass and the parent of this class
        /#    should be that class.
        /#  - if the parent of the userclass is not meta-defined, we use
        /#    metax.root.ObjectMetaRoot
        /#     - this assumes the non-meta parent does not have a metaclass
        /#       of its own (if it does, the user will need to provide
        /#       that nonmeta metaclass explicitly via metaparent)
        /#     - TODO(wmh): Rewrite root.meta as root.meta2, and use namespace
        /#       metaxy.root (we cannot use 'meta' because we are using
        /#       that as the receiver variable of metaclass methods).
        parentdata = self.parentclasses()[0]
        if parentdata.get('external', False):
          /# nonmeta class
          /#metaparent = ClassConstruct.MetaifyName('metax.root.ObjectMetaRoot')
          metaparent = 'metax.root.ObjectMetaRoot'
        else:
          /# TODO(wmh): Update this to use parentdata['class'] when we've
          /# implemented importMeta().
          metaparent = ClassConstruct.MetaifyName(parentdata['metafqn'])
        /# print '******* HERE with %s and %s and %s' % (self.fqn(), metaparent, parentdata)
      else:
        /# print '**** FOR %s found explicit metaparent %s' % (self.kindfqn(), metaparent)
        pass

      /# TODO(wmh): Delete following when we are using root.meta2
      /# if metaparent == 'metax.root.Object__Meta':
      /#   metaparent = 'metax.root.ObjectMetaClass'

      metaname = ClassConstruct.MetaifyName(self.id())
      assert metaspace is not None

      return (metaspace, metablock, metaname, metaparent)
    end method metaClassInfo;

    method autogenInfo : map #:
      Establish which autogenerated classes should and should not be produced.
    scope:
      /# TODO(wmh): Extend to support testmeta and metatest
      result = {'test': True, 'meta': True}
      autogen = self.attrval('autogen')
      if autogen != 'std':
        if 'notest' in autogen:
          result['test'] = False
        if 'nometa' in autogen:
          result['meta'] = False

      /# Some additional logic:
      /# - classes inheriting from Error are considered implicitly nometa
      /#   and notest if they have no scope: or only 0-1 constructs in scope:
      if self.isErrorClass():
        scope, lines = self.attrpair('scope:', default=None)
        if scope is None or len(lines) < 2:
          result['test'] = False
          result['meta'] = False

      return result
    test:
    end method autogenInfo;

    method suppressInfo : tuple<vec<str>,vec<str>> #:
      Parses the suppress() map to identifies two sets of suppression
      lists, local and global.  The local list is suitable for inclusion
      in (for example, using javascript, @fileoverview @suppress), while
      the global list is suitable for inclusion in a BUILD target rule
      (for example, using javascript, in the 'suppress' attribute of a
      closure_js_library target).
    scope:
      suppress = self.suppress() or {}
      local_list = []
      global_list = []
      for key in sorted(suppress):
        if key == key.upper():
          global_list.append(key)
        else:
          local_list.append(key)
      return (local_list, global_list)
    test:
    end method suppressInfo;

    method isErrorClass : bool #:
      True if this class inherits from metax.root.Error.
    scope:
      /# TODO(wmh): Need a 'is subclass of' mechanism in Meta. In the interim,
      /# this is heuristic in nature.
      result = False
      if self.id().endswith('Error'):
        result = True
      else:
        pcs = self.parentclasses()
        if pcs:
          if pcs[0]['id'].endswith('Error'):
            result = True
      return result
    test:
    end method isErrorClass;

    method typeOfSelf : Type #:
      Return the meta Type of 'self' for this class (or 'this' if dothis True)
    params:
      var dothis : bool = false #:
        If True, type 'this' instead of 'self'.  The hope is that we can make
        'self' be &<class>, and keep 'this' as '#*<class>' but languages may
        be inconsistent in their treatment of the type of receiver objects ...
        we'll see.
      var isconst : bool = false #:
        If True, return the version of the type in which the object is const.
    scope:
      if dothis:
        tstr = '#*%s%s' % ('#' if isconst else '', self.fqn())
      else:
        tstr = '&%s%s' % ('#' if isconst else '', self.fqn())
      result = Type.Instance(tstr)
      return result
    end method typeOfSelf;

    method initParentClasses : vec #:
      Establish the parent classes of this class.
    scope:
      /# TODO(wmh): Why not add this as a lazy: block of parentclasses?

      parentclasses = []
      /# parents_attr, parents = self.attrpair('parents:', default=None)
      parents_attr = None
      if parents_attr is None:
        namespace = self.namespace()
        metafile = self.metafile()
        parent_attr, parent = self.attrpair('parent', default=metax.c.LOOKUP)
        fqn, metafqn = self.baselang().formatClassType(
          metafile, parent, namespace)

        /# fqn will be None if parent is 'void'
        if fqn:
          parts = metafqn.split('.')
          pdata = {
            'raw': parent,
            'fqn': fqn,
            'id': parts[-1],
            'metafqn': metafqn,
            'class': None}
          if parent[0] == Context.TOKENS['explicit_class_indicator']:
            pdata['external'] = True
          parentclasses.append(pdata)
        else:
          /# For the special case of 'no parent', we have the choice of
          /#  1) adding a pdata in which 'fqn' is 'void'
          /#  2) returning an empty vector.
          /# Both require special casing, but #2 is more accurate, so that's
          /# what we do.
          pass
      else:
        /# TODO(wmh): Support multiple inheritance.
        pass
      self.parentclassesIs(parentclasses)
    test:
    end method initParentClasses;

    new
    method ancestors : vec<ClassConstruct> #:
      Obtain the ancestors of this class (does NOT include self).
      TODO(wmh): Need to support ancestors that are outside Meta.
       - create a special ExternalClassConstruct subclass of ClassConstruct?
    scope:
      result = []
      klass = self
      while klass is not None:
        parentclasses = klass.parentclasses()
        if parentclasses:
          parent_info = parentclasses[0]
          klass = parent_info['class']
          if klass is None:
            raise Error('Should never reach here')
          else:
            result.append(klass)
        else:
          klass = None
      result.reverse()
      return result
    test:
    end method ancestors;

    method parentclass : ClassConstruct #:
      Obtain a parent class by index in superclass list.

      NOTE: Until ClassConstruct.importMeta() is invoked on this class,
      this method will return null.
    params:
      var index : int = 0 #:
        The index in self.parentclasses() of desired parent.
    scope:
      parentclasses = self.parentclasses()
      if index < len(parentclasses):
        result = parentclasses[index]['class']
      else:
        /# TODO(wmh): Raise exception?
        result = None
      return result
    test:
    end method parentclass;

    method idfqn : str #:
      Return id or fqn depending on whether this class is in same nmsp as parent.

      WARNING: Should only be invoked after ClassConstruct.importMeta() has
      been invoked!
    scope:
      parent = self.parentclass()
      pspace = parent.namespace() if parent else None
      if pspace and pspace.fqn() == self.namespace().fqn():
        result = self.id()
      else:
        result = self.fqn()
      return result
    test:
    end method idfqn;

    method expandMeta : vec<Construct> #:
      Expansion depends on variant
       - user:
          - create test class, meta class, test metaclass and meta testclass.
             - test class: nm.sp_test.ClassTest
             - meta class: nm.sp.Class__Meta
             - test class for metaclass: nm.sp.Class__MetaTest
             - meta class for testclass: nm.sp_test.ClassTest__Meta
          - expand children
       - meta or test or metatest or testmeta or metauser:
          - expand children
       - testuser:
          - if we are currently in the user namespace
             - move the class into the test namespace
             - DO NOT expand children, do not create initializer, etc.
          - else (we are in the testspace)
            - expand children
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      D.expand.sinfo('%s variant %s' % (self.kindfqn(), self.variant()))

      name = self.id()
      fqn = self.fqn()
      variant = self.variant()
      baselang = self.baselang()
      basel = baselang.id()
      metafile = self.metafile()
      metac = metafile.compiler()
      context = self.context()
      namespace = self.namespace()
      incnmsp = namespace.fqn() == 'metax.c'

      /# We first parse the parent specification into self.parentclasses().
      /#  - TODO(wmh): Support 'parents:' in addition to 'parent' (along
      /#    with 'testparents:' and 'metaparents:')
      /#  - It is important that we initialized parentclasses() before
      /#    moving on to variant-specific functionality because some of
      /#    that code needs to call metaClassInfo() which relies on
      /#    parentclasses() being initialized.
      /#  - This is somewhat problematic because it means that user-provided
      /#    test classes will execute this code twice (once when expanding the
      /#    class within the user namespace, and again when it is expanded
      /#    in the test namespace).
      self.initParentClasses()

      newclasses = []
      metaclass = None
      proceed = None

      scope, children = self.attrpair('scope:', default=None)
      span = self.attrval('span')
      presence = self.attrval('presence')
      autogen = self.autogenInfo()

      if not scope and span != 'specific' and presence != 'abstract':
        if self.isErrorClass():
          /# It is common for error classes to not need a scope. We create
          /# a dummy empty scope.
          /# TODO(wmh): There are probably other examples of classes not
          /# needing scopes ... do we want to generalize, or is this the only
          /# case that is commonly without a scope?
          children = []
          scope = ComplexBlock(
            self, 'scope:', children, line=self.primary().line())
          self.registerAttribute(scope)
          /# TODO(wmh): By inserting this scope, canonicalization will produce
          /# the scope unless we somehow mark it as implicit and avoid
          /# printing implicit attributes during canonicalization.
          proceed = True
        else:
          metafile.error('The concrete general %s has no scope' % self.kindfqn())
          proceed = False

      if not scope and span == 'specific':
        /# This class is only defined for baselangs that provide a scope, and
        /# no scope is present, so we remove the class entirely.
        /#  - TODO(wmh): Is complete removal the right approach? Or should we
        /#    introduce a 'disabled' field in class constructs instead?
        self.parent().unregisterConstruct(self)
        proceed = False

      elif variant is None:
        raise Error('ClassConstruct.expandMeta: invoked before variant set')

      elif variant == 'user':
        /# We are in the user-provided class.
        /# userclass = self.userclass()
        /# testclass = self.testclass()
        /# metaclass = self.metaclass()

        /# We disallow user-level classes from starting or ending with
        /# 'Meta' because:
        /#   - <Class>Meta represents the metaclass of <Class>
        /#   - Meta<Class> represents the singleton instance of <Class>Meta
        /#   - we don't want to introduce conflicts between user-defined
        /#     classes starting/ending with 'Meta' and the above symbols.
        /# CODE TANGLE: meta-disallowed
        if name.endswith('Meta') and not incnmsp:
          metafile.error(
            'User-level class "%s" cannot end with "Meta"' % name,
            line=self.primary().line())
        if name.startswith('Meta') and not incnmsp:
          metafile.error(
            'User-level class "%s" cannot start with "Meta"' % name,
            line=self.primary().line())

        testspace, testblock, testname, testparent = self.testClassInfo()
        if autogen['test']:
          /# Create the auto-generated test class
          /#  - we also explicitly create an initializer, as we need to pass in
          /#    a special name parameter.
          /#  - TODO(wmh): verify there isn't a race-condition here if
          /#    the special TestCase class is defined with location 'test' in
          /#    user code. Does it need to appear BEFORE the classes it is
          /#    meant to affect?
          testclass = ClassConstruct.NewFromData(
            /# TODO(wmh): Verify that test class should share same context as
            /# user class.
            testname, context, parent=testblock,
            features=[('location', 'test')],
            secondaries=[
              ('parent', testparent),
              /# TODO(wmh): Test classes can have metaclasses ... what should
              /# the metaparent of the testclass be?
              /# ('metaparent', '?'),
              ('assocs:', []),
              ('comment:', ['Auto-generated test class for ' + fqn]),
              ('scope:', [])
            ],
            precount=1)

          /# Create the auto-generated metaclass for the auto-generated testclass
          if Compiler.IMPL['metatestclass']:
            metatestname = ClassConstruct.MetaifyName(testname)
            metatestblock = testblock
            metatestparent = ClassConstruct.MetaifyName(testparent)
            metatestparent2 = ClassConstruct.MetaifyName('metax.test.TestCase')
            /# print 'For %s\n  %s\n  %s' % (self.kindfqn(), metatestparent, metatestparent2)
            metatestclass = ClassConstruct.NewFromData(
              /# TODO(wmh): Verify that metatest class should share same context as
              /# user class.
              metatestname, context, parent=metatestblock,
              features=[('location', 'meta')],
              secondaries=[
                ('parent', metatestparent),
                ('comment:',
                 ['Auto-generated meta class for auto-generated test class ' + testclass.fqn()]),
                ('scope:', []),
              ],
              position='-' + testname,
              precount=1)
          else:
            metatestclass = None
        else:
          testclass = None
          metatestclass = None

        /# Create the auto-generated meta class
        if autogen['meta']:
          metaclass = self.generateMetaClass()
          metaname = metaclass.id()

          if not Compiler.IMPL['testmetaclass']:
            /# There is very little benefit to creating an auto-generated test
            /# class associated with the auto-generated meta-class of a user
            /# class. Rather, methods defined on metaclasses can have their test
            /# methods defined on the auto-generated test class of the user
            /# class. This makes things conceptually simpler without loss of
            /# generality.
            testmetaclass = None
          else:
            /# Create the auto-generated testclass for the auto-generated metaclass
            testmetaname = ClassConstruct.TestifyName(metaname)
            testmetablock = testblock
            testmetaparent = testparent
            testmetaclass = ClassConstruct.NewFromData(
              /# TODO(wmh): Verify that test class should share same context as
              /# user class.
              testmetaname, context, parent=testmetablock,
              features=[('location', 'test')],
              secondaries=[
                ('parent', testmetaparent),
                ('comment:',
                 ['Auto-generated test class for auto-generated meta class %s.' %
                  metaclass.fqn()]),
                ('scope:', []),
              ],
              precount=1)
        else:
          metaclass = None
          testmetaclass = None

        /# Move/copy assoc constructs to test/meta classes.
        assocs_attr, assocs = self.attrpair('associations:', default=None)
        if assocs_attr:
          test_assocs = testclass.attr('associations:') if testclass else None
          meta_assocs = metaclass.attr('associations:') if metaclass else None
          /# NOTE(wmh): Important to iterate over list(assocs) because we may
          /# modify 'assocs' by moving constructs to test_assocs or meta_assocs.
          for dep in list(assocs):
            /# Each dep is either 'assoc' or 'resource'. Both constructs
            /# have a 'location' field that indicates where the construct
            /# belongs. The 'assoc' location is special in that 'usertest'
            /# is also meaningful.
            /# TODO(wmh): implement this as a multi-valued feature value
            /# instead).
            akind = dep.kind()
            if akind == 'remark': continue
            aloc = dep.attrval('location')

            if aloc == 'user':
              /# Things are fine just as they are.
              pass
            elif aloc == 'test':
              if test_assocs:
                dep.changeParent(test_assocs)
              else:
                metafile.error(
                  'Cannot specify location test for construct %s when '
                  'testclass disabled' % kind,
                  line=dep.primary().line())
            elif aloc == 'meta':
              if meta_assocs:
                dep.changeParent(meta_assocs)
              else:
                metafile.error(
                  'Cannot specify location meta for construct %s when '
                  'metaclass disabled' % kind,
                  line=dep.primary().line())
            elif aloc == 'usertest':
              if akind == 'resource':
                metafile.error(
                  'resource constructs do not support location %s' % aloc,
                  line=dep.primary().line())
              else:
                /# This is a special case ... we need the construct to stay
                /# in the user class but also appear in the test class. We
                /# clone and register.
                if test_assocs:
                  testdep = dep.clone(test_assocs)
                  /# TODO(wmh): Consider deleting the 'location' attribute
                  /# from testdep, but it is actually fine as-is (not used
                  /# in translateMeta()) and may serve a useful purpose.
                  test_assocs.registerConstruct(testdep)
                else:
                  metafile.error(
                    'Cannot specify location usertest for construct %s when '
                    'testclass disabled' % kind,
                    line=dep.primary().line())

            else:
              raise InternalError('Invalid assocs child kind %s' % kind)

        /# Initialize class fields of user class
        self.userclassIs(self)
        self.underclassIs(None)
        self.testclassIs(testclass)
        self.metaclassIs(metaclass)

        /# Initialize class fields of test class
        if testclass:
          testclass.variantIs('test')
          testclass.userclassIs(self)
          testclass.underclassIs(self)
          testclass.testclassIs(None)
          testclass.metaclassIs(metatestclass)
          testclass.namespaceIs(testspace)
          /#newclasses.append(testclass)

        /# Initialize class fields of meta class
        if metaclass:
          metaclass.variantIs('meta')
          metaclass.userclassIs(self)
          metaclass.underclassIs(self)
          if Compiler.IMPL['testmetaclass']:
            metaclass.testclassIs(testmetaclass)
          else:
            /# We are not generating test clases for metaclasses of userclasses,
            /# and are instead adding test methods for meta-methods to the
            /# testclass of the userclass.
            metaclass.testclassIs(testclass)
          metaclass.metaclassIs(None)
          metaclass.namespaceIs(namespace)
          newclasses.append(metaclass)

        /# Initialize class fields of metatest class
        if metatestclass:
          metatestclass.variantIs('metatest')
          metatestclass.userclassIs(self)
          metatestclass.underclassIs(testclass)
          metatestclass.testclassIs(None)
          metatestclass.metaclassIs(None)
          metatestclass.namespaceIs(testspace)
          /#newclasses.append(metatestclass)

        /# Initialize class fields of testmeta class
        if testmetaclass:
          testmetaclass.variantIs('testmeta')
          testmetaclass.userclassIs(self)
          testmetaclass.underclassIs(metaclass)
          testmetaclass.testclassIs(None)
          testmetaclass.metaclassIs(None)
          testmetaclass.namespaceIs(testspace)
          /#newclasses.append(testmetaclass)

        if autogen['meta']:
          self.generateImplicitMeta()

        /# We not recurse if there isn't any scope.
        proceed = True if scope else False

      elif variant == 'testuser':
        /# We are in a user-provided test class
        /#  - the class is moved into the test scope.
        /#  - no further class-level expansion is needed (but child
        /#    constructs need expanding).
        /#  - the location is 'test', and stays as test even when we move
        /#    to the test namespace (used to determine what the receiver
        /#    should be).
        if namespace.variant() == 'user':
          /# We are expanding the user-provided test class within the
          /# user namespace.  Move to the testspace and do NOT do any
          /# further expansion of the class (it will be done when the
          /# testspace is expanded).
          testspace = namespace.testspace()
          testblock = testspace.attr('scope:')
          /# If an explicit user-provided test class named 'TestCase' exists
          /# in a namespace, then all implicitly generated test classes in
          /# the namespace will inherit from this class. In order for this
          /# to work, the TestCase class needs to appear at the top of the
          /# testspace.
          position = '-' if self.id() == 'TestCase' else None
          self.changeParent(testblock, position=position)
          proceed = False
        else:
          /# We are expanding the user-provided test class now that it has
          /# been moved to the testspace ... full expansion is needed.
          proceed = True

          /# We need to generate a metaclass for the user-provide testclass.
          /# - note that this is NOT guarded by Compiler.IMPL['metatestclass']
          /#   because this is an explicit test class, not an implicit one,
          /#   and we always support meta fields/methods on explicit test
          /#   classes because such classes are often providing a test version
          /#   of a user-class, and should have all the same functionality as
          /#   those user-classes.
          metatestclass = self.generateMetaClass()
          metatestclass.variantIs('metatestuser')
          metatestclass.namespaceIs(namespace)
          metatestclass.initParentClasses()
          self.metaclassIs(metatestclass)
          newclasses.append(metatestclass)

      elif variant == 'metatestuser':
        /# The auto-generated meta class of a user-defined test class.
        proceed = True

      elif variant == 'metauser':
        /# We are in a user-provided meta class
        /#  - this looks exactly like a normal class except that the receiver
        /#    is 'meta'
        /#  - stays in same namespace
        proceed = True

      elif variant in ('test', 'meta', 'testmeta', 'metatest'):
        /# A class with any of these variants does not require any class-level
        /# expansion (they were expanded when the underlying user
        /# class was encountered)

        if variant == 'test':
          self.generateImplicitMeta()

        proceed = True

      else:
        raise Error('Unknown class variant ' + variant)

      if proceed is None:
        raise InternalError('Failed to initialize proceed')

      elif proceed:
        /# Invoke expandMeta() on child constructs.
        /#  - we make a copy of children so that we do NOT expand the implicit
        /#    children added to children by calls to child.expandMeta().
        if children is None:
          children = []
        for child in list(children):
          child.myclassIs(self)
          child.expandMeta()

        if output is not None:
          output.extend(newclasses)

        context = self.context()
        initializer = self.initializer()

        if initializer:
          if basel == 'javascript':
            use_es2015_classes = baselang.config('use_es2015', False)
            if not use_es2015_classes:
              /# In Javascript, if one is defining classes by explict function
              /# definition, the initializer needs to be the first construct
              /# generated.  However, if ES2015 classes are used, it does not
              /# need to be first.
              for i, child in enumerate(list(children)):
                if child is initializer:
                  if i != 0:
                    children.pop(i)
                    children.insert(0, initializer)
                  break
        else:
          /# If there is no explicit initializer, we define one.
          /#  - In javascript, required if not using ES2015 classes, since
          /#    the initializer function is what actually defines the clas..
          /#  - useful in other languages because we often need to insert
          /#    implicit field initialization code.
          /#     - we can optimize unnecessary initializers out of the code
          /#       in translateMeta().
          /#  - the metafile line number is set to -1 because there is no
          /#    actual meta code associated with this implicit initializer.
          initname = baselang.initializerName(self)
          secondaries = []

          /# TODO(wmh): Need a cleaner way of determining whether a test class
          /# does NOT inherit from metax.test.TestCase.
          if variant == 'user' or (variant == 'testuser' and self.id() != 'TestCase'):
            /# We need to ensure that we accept the same args as the parent, and
            /# pass those args up via super(). For meta and test classes the
            /# param list is not user-provided (so we don't provide params
            /# for them here either), but for user classes we must pass args
            /# up to parent.
            /#
            /# An implementation that works for all baselangs relies on Meta
            /# implicitly compiling all .meta files needed in order to have
            /# a complete transitive understanding of the inheritance hierarchy
            /# dictated by the source .meta files.  That will give us
            /# ClassConstruct instances for every ancestor, and allow us to
            /# establish the exact signature of the initializer.
            /#
            /# As a stop-gap implementation that will work only for Python,
            /# we add some *arg,**kwds delegation.
            /#
            /# TODO(wmh): Get this working in all baselangs.  Note that the
            /# alternative is to require that a lifecycle construct (and
            /# associated scope:) always be explicitly defined in user classes,
            /# and leave it up to the user to properly delegate up the
            /# stack.
            if basel == 'python':
              params = metax.c.ExecutableConstruct.CreateParams(
                [
                  {'var': 'args',
                   'features': [('multiplicity', 'multi')],
                   'secondaries': [(':', Type.Instance('vec'))]},
                  {'var': 'kwds',
                   'features': [('multiplicity', 'multi')],
                   'secondaries': [(':', Type.Instance('map'))]},
                ],
                context)
              secondaries.append(('params:', params))
              super_expr = ExprParser.StrExpr('(args, kwds)')
              secondaries.append(('super', super_expr))
            else:
              print '***** FIX ME FIX ME!'

          secondaries.append(('scope:', [], -1))
          initializer = MethodConstruct.NewFromData(
            initname, context, parent=scope,
            features=[('kind', 'initializer')],
            secondaries=secondaries,
            primary_line=-1,
            position='-')

          /#print 'WARNING: created implicit %s (%s)' % (initializer.fqn(), self.isTest())
          /# initializer.write()
          self.registerInitializer(initializer)

          /# In situations where we have classes like:
          /#    class Error < metax.root.Error;
          /#    class InternalError < Error;
          /# note that the termcode for both of the above is 1. After inserting
          /# the implicit initializer, it is not very readable to terminate with
          /# just a semicolon, so we upgrade the termcode. Similarly, we insert
          /# an empty line before such constructs in the interests of readability.
          if self.termcode() == 1:
            self.termcodeIs(3)
          if self.precount() == 0:
            self.precountIs(1)

        if self.isTest():
          /# There are two different kinds of classes that can appear within a
          /# testspace, those that inherit from metax.test.TestCase and those
          /# that do not. For the former, the initializer of such classes should
          /# never have an explicit params: or 'super' specified, and an
          /# implicit params: containing a single 'var meta__name : &str' is to
          /# be added (and passed up via an auto-inserted 'super (meta__name)'.
          /# However, the latter kind of class can have an initializer with
          /# arbitrary signature and is not modified by this code. The difficult
          /# part here is in answering the question of whether the class
          /# inherits from metax.test.TestCase or not. For now, we use a
          /# crude and limiting heuristic ... if the class name has 'TestCase'
          /# anywhere in it, or ends in 'Test', we assume it inherits from
          /# metax.test.TestCase, otherwise it does not.
          /#
          /# TODO(wmh): When we get fully parsing of the inheritance hierarchy
          /# implemented, we can replace this heuristic with a real subclass
          /# test.
          if 'TestCase' in name or ClassConstruct.IsTestName(name):
            /# We assume this class inherits from metax.test.TestCase and thus
            /# needs a special params
            params = initializer.attr('params:', default=None)
            if params is not None:
              metafile.error(
                'testclass initializer %s (assumed to inherit from metax.test.TestCase) should not specify params:' %
                initializer.fqn())
            else:
              /# We add an explicit 'super' and 'params:' attributes.
              fauxfile = metax.c.MetaFile(
                '/faux/faux.meta', metac, text='(meta__name)\n')
              super_expr = ExprParser(fauxfile).parse()
              super = ExprAttribute(initializer, 'super', super_expr)
              /# Create a 'params:' attribute.
              params = ExecutableConstruct.CreateParams(
                [{'var': 'meta__name',
                  'secondaries': [
                    /# TODO(wmh): In order to get unittesting in C++ working
                    /# with gtest, I needed to make the meta__name arg be
                    /# optional because the TEST_F macro relies on there
                    /# being a constructor that takes no arguments. This
                    /# means that the name of the test method is NOT being
                    /# passed (at least not via the constructor). We can fix
                    /# this by introducing a TEST_M macro that invokes the
                    /# constructor with the method name (after which we could
                    /# remove the default value below).
                    (':', Type.Instance('&str')), ('=', Expr('str', '""', '""'))]},
                    /# TODO(wmh): In Meta, we need a baselang-independent
                    /# mechanism for initializing a variable to the empty
                    /# value of its type (e.g. "" for string, [] for vec,
                    /# {} for map, etc.). Consider introducing the
                    /# meta-level pseudovar 'empty'. Then we could do:
                    /#   method f : int params:
                    /#     var s : str = empty;
                    /#     var v : vec = empty;
                    /#     var m : map = empty;
                ],
                context)
              initializer.registerAttribute(
                super, position='+' + initializer.primary().key())
              initializer.registerAttribute(params, position='-super')
        else:
          /# The class does NOT inherit from metax.test.TestCase and its
          /# initializer has whatever signature the user specified.
          pass

        if self.isMeta():
          /# For metaclasses, regardless of whether an initializer was
          /# explicitly provided or not, there should never be an explicit
          /# params: attribute. Instead, this code implicitly defines a
          /# 'params:' attribute of a pre-determined signature, and an associatd
          /# 'super' attribute to call up the inheritance chain. The only meta
          /# class that does NOT get this implicit treatment is
          /# metax.root.ObjectMetaRoot, which is the special parent of all
          /# meta-defined metaclasses.  If a user defines a metaclass with
          /# a parent that is not a subclass of metax.root.ObjectMetaRoot,
          /# it is their responsibility to have the parent initializer accept
          /# the same signature.

          params = initializer.attr('params:', default=None)
          if self.fqn() == 'metax.root.ObjectMetaRoot':
            /# This is the sole exception to implicit params: ... we leave
            /# the class exactly as-is.
            pass
          elif params is not None:
            print '#' * 70
            print 'HERE with %s = %s' % (self.kindfqn(), self.variant())
            initializer.write()
            print '#' * 70
            metafile.error(
              'metaclass initializer %s should not specify params:' %
              initializer.fqn(),
              line=initializer.primary().line())
          else:
            /# Currently, metaclass initializers in all baselangs must have
            /# the same signature:
            /#   var name : &str #:
            /#     The name of the class being created
            /#   var bases : &vec<class> #:
            /#     The parent classes of the class
            /#   var symbols : &map #:
            /#     The symbols available within the class.
            /# This signature may need to evolve as more baselangs are added
            /# and we see how the metaclass support in those baselangs
            /# interact with the mandates of Meta.
            /#
            /# All metaclasses should inherit from metax.root.ObjectMetaRoot,
            /# which expects the above params, so we invoke super().

            /# Create a 'params:' attribute
            params = ExecutableConstruct.CreateParams(
              [
                {'var': 'name',
                 'secondaries': [(':', Type.Instance('&str'))]},
                {'var': 'bases',
                 'secondaries': [(':', Type.Instance('&vec<class>'))]},
                {'var': 'symbols',
                 'secondaries': [(':', Type.Instance('&map'))]},
              ],
              context)

            /# Create a 'super' attribute
            if True:
              /# Explicit creation
              super_expr = Expr(
                'plist', '(name, bases, symbols)', 
                [
                  Expr('var', 'name', 'name'),
                  Expr('var', 'bases', 'bases'),
                  Expr('var', 'symbols', 'symbols')
                ]
              )
            else:
              /# Indirect and slow creation
              fauxfile = metax.c.MetaFile(
                '/faux/faux.meta', metac,
                text='(name, bases, symbols)\n')
              super_expr = ExprParser(fauxfile).parse()
            super = ExprAttribute(initializer, 'super', super_expr)

            iscope = initializer.attr('scope:', default=None)
            if iscope:
              initializer.registerAttribute(super, position='-scope:')
              initializer.registerAttribute(params, position='-super')
            else:
              metafile.error('Missing scope', line=initializer.primary().line())

        if True:
          /# TODO(wmh): Disable this when we go production!
          self.validate()
          D.expand.info(
            'Validated %s (%s)' % (self.kindfqn(), self.variant()), level=2)

        /# Register this class with the compiler.
        metac.registerClass(self)

        /# Compute dependencies for this class!
        self.registerDependencies()

        /# Sub-expansions
        /#  - if we are processing a user class, the code above creates four
        /#    autogened classes (metaclass, testclass, metatestclass and
        /#    testmetaclass).
        /#  - The first of these (metaclass) resides in the same namespace as
        /#    the user class, and needs to be explicitly expanded.
        /#  - The rest of the autogened classes reside in the testspace associated
        /#    with the namespace that the user class belongs to, so we do NOT
        /#    need to expand them here (they will be expanded when the testspace
        /#    is expanded at the end of NamespaceConstruct.expandMeta().
        for cls in newclasses:
          cls.expandMeta()

      D.expand.end()
    test:
      cards1, scope, namespace, path = test.getMetaFile(
        'oopl', 'cards1', debuglevel=0)
      output = []
      namespace.expandMeta(output=output)
      test.iseq(2, len(output))
      test.isfalse(cards1.hasErrors(show=True))
    end method expandMeta;

    method importMeta #:
      Link this class with all of its ancestor classes, now that all dependent
      metafiles have been transitively parsed, expanded and imported.
    scope:
      D.imports.sinfo(self.id())

      metafile = self.metafile()
      metac = metafile.compiler()

      /# Establish the ClassConstruct instances of parents
      /#  - initialize self.parentclasses[i]['class']
      /#  - add entry to parent_construct.childclasses() for self
      /#  - patch up the parent() field in self.symbols() table.
      parentclasses = self.parentclasses() or []
      for index, parent_info in enumerate(parentclasses):
        fqn = parent_info['metafqn']
        parent_class = metac.classes().get(fqn, None)
        if parent_class is None:
          /# This can mean various things:
          /#  - the parent class was not defined within Meta
          /#  - the parent class is incorrectly specified by the user
          /#  - there is a bug in Meta
          if not parent_info.get('external', False):
            /# print 'PARENT INFO: %s' % str(parent_info)
            metafile.warning(
              'Failed to import parent %s for %s' % (fqn, self.fqn()),
              line=self.primary().line())
          else:
            /# The parent is defined in the baselang, not in Meta. We create
            /# an ExternalClassConstruct instance to represent it.
            parent_class = ExternalClassConstruct(
              /# Passing null context poses problems, so passing self's
              /# context even though it isn't entirely accurate.
              parent_info['id'], None, self.context(), precount=0)
            parent_info['class'] = parent_class
            parent_class.childclasses()[self.id()] = self
        else:
          /# We have successfully identified a ClassConstruct for the parent.
          parent_info['class'] = parent_class
          parent_class.childclasses()[self.id()] = self
          if index == 0:
            /# For now, there is only one parent symbol table, but we should
            /# probably allow SymbolTable to have arbitrary numbers of parents.
            symbols = self.symbols()
            assert symbols.parent() is None
            symbols.parentIs(parent_class.symbols())
          
      /# We now recurse down to constructs within the class so that they can
      /# update any state that relies on full resolution of the class
      /# inheritance change.
      scope, children = self.attrpair('scope:')
      for child in children:
        child.importMeta()

      D.imports.end()
    end method importMeta;

    method translateMeta : vec<BaseFile> #:
      Baselang-independent class compilation code.

      Notes:

       - There are three separate ClassConstruct instances associated with
         every user-specified class: 1) the user class, 2) a test class,
         3) a meta class. Each of these is compiled separately.

       - A class with name nm.sp.Ex has the following associated files:

          1a. class definition
                <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$defn
              where $defn is the baselang-specific suffix for definitions.

          1b. line map for class definition
                <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.$defn.map
              defining the mapping from line numbers in source .meta file and
              line numbers in
                <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$defn.

          2a. class declaration
                <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$decl
              where $defn is the baselang-specific suffix for declarations.
              Most languages, $decl == $defn, but in languages likes C++
              they differ.

          2b. line map for class declaration
                <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.$decl.map
              defining the mapping from line numbers in source .meta file and
              line numbers in
                <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$decl.

          3.  build fragment for class
                <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.bld
              containing a bazel ${basel}_library rule defining how
              to compile the class and listing all deps (other Bazel targets),
              and all data (aka resources).

      Actions:

       - identify all dependencies that need importing (assocs plus implicit
         dependencies like parent classes, baselang std library, etc.)
          - produce baselang specific import syntax for these dependencies

       - create the BUILD fragment representing the class
         (in <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.bld)

       - compile all class-level constructs to obtain the contents of the class,
         writing baselang text to BaseStream instances and populating the
         ClassConstruct instance with relevant data identified during child
         processing (symbol tables, etc.)

       - initialize a VarSet and instantiate the baselang class Template to
         create <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$defn (and,
         where needed,
         <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$decl). The same
         VarSet should be used to instantiate all source files associated with
         the class, and all baselangs use the same variable names in their
         templates.

      Returns:
        The list of BaseFile instances created. This is normally null, since
        most constructs do not produce files.  However, claseses and namespaces
        do.
    scope:
      D.translate.sinfo(self.kindfqn())

      metac = self.compiler()
      context = self.context()
      baselang = self.baselang()
      basel = baselang.id()
      metafile = self.metafile()
      consinfo = context.consinfo('class')
      namespace = self.namespace()
      fs = metac.fs()
      decl_is_separate = baselang.id() == 'cpp'
      variant = self.variant()
      suppress = self.suppress()

      /# TODO(wmh): How to establish the actual width?
      width = 80 - 0

      /###
      /# Process the scope. Subconstructs include:
      /#   field
      /#   method/initializer/finalizer/lifecycle/function
      /#   native
      /#   category
      extralines = self.extralines()
      streams = metafile.streams()
      streams.initStreams('decl', 'defn')
      scope, children = self.attrpair('scope:')
      for construct in children:
        construct.translateMeta()
      decl_segments = streams.stream('decl')
      defn_segments = streams.stream('defn')

      /# parentspec: str
      /#   the baselang syntax needed to define all parents (extends/implements)
      parentspec = baselang.formatParentSpec(self)

      /# Now process dependencies into targets and imports
      imports, targets = baselang.formatDependencies(self)

      /# preclass: vec<str>
      /#   baselang code associated with a class definition but appearing
      /#   before the class.
      preclass = []
      prelines = extralines.get('pre', {}).get('defn', None)
      if prelines:
        preclass.extend(prelines)

      /# postclass: vec<str>
      /#   baselang code associated with a class definition but appearing
      /#   after the class.
      postclass = []

      /# preamble: vec<str>
      /#   Lines of text within class scope before user-provided scope.
      preamble = []

      /# postamble: vec<str>
      /#   Lines of text within class scope after user-provided scope.
      postamble = []

      /# comment: vec<str>
      /#   potentially multi-line string  representing documentation
      /#   associated with the class as a whole.
      /#
      /#   Note that formatClassComment() also modifies suppress, providing a
      /#   way for 'Meta:suppress <label>' syntax within a class or method
      /#   comment block to be added to a @fileoverview, method or BUILD target.
      /#
      /#   Note that by passing in a default value, we do not need to deal
      /#   with inserting a 'pass' in an empty class in Python.
      comment_attr = self.attr('comment:', default=None)
      comment = baselang.formatClassComment(
        comment_attr, suppress=suppress, default=['Undocumented.'])

      /# Create the VarSet of variables.
      varset = VarSet()
      varset.addVar('imports', imports)
      varset.addVar('preclass', preclass)
      varset.addVar('preamble', preamble)
      varset.addVar('fqcn', self.fqn())
      varset.addVar('namespace', namespace.id())
      varset.addVar('class', self.id(), attribute=self.primary())
      varset.addVar('parentspec', parentspec)
      varset.addVar('comment', comment, attribute=comment_attr)
      varset.addVar('scope', defn_segments, attribute=scope)
      varset.addVar('postamble', postamble)
      varset.addVar('postclass', postclass)
      /# varset.show()

      /# TODO(wmh): Is there a better way of providing baselang-specific
      /# augmentation of varsets?  By putting the code in BaseLanguage, we
      /# hide the code away from user modification.
      /#  - what we really want is multi-dispatch on construct and baselang
      /#  - could define augmentPythonVarset, augmentJavascriptVarset, etc.
      /#    in each construct class?
      baselang.augmentVarset(self, varset)

      /# Add any extra lines to postclass from native constructs found
      /# after the class associated with the class.
      postlines = extralines.get('post', {}).get('defn', None)
      if postlines:
        postclass.extend(postlines)

      /# Instantiate the template using the varset
      has_decl = False
      istestcase = self.isTestCase()
      basesuffix = baselang.suffix()
      template_name = baselang.id()
      if istestcase: template_name += '_test'
      if baselang.config('definition_separate'):
        /# For baselangs with two files per class, we print out the
        /# definition using the same flow as in other baselangs, and
        /# handle the declaration file specially.
        template_name += '_defn'
        has_decl = True

      /# Create the defn base file and associated mapfile
      template = consinfo.templateNamed(template_name)
      segment = BaseSegment(self.primary())
      fqn = self.fqn()
      segment.instantiate(template, varset, self.kind(), fqn)

      mapfile = MapFile(
        metac.basePath(fqn, prefix='.', suffix=basesuffix + '.map'),
        fs.realpath(fs.abspath(metafile.path())), [])
      contents = []
      segment.flattenLines(contents, mapfile, strip_special=True)
      basesubpath = baselang.classSubPath(self)
      basefile = BaseFile(
        basesubpath, '\n'.join(contents) + '\n',
        metafile=metafile, mapfile=mapfile)
      metafile.registerFile(basefile)

      /# If the baselang separates definition from declaration, do declaration.
      if has_decl:
        template_name = template_name.replace('_defn', '_decl')
        template = consinfo.templateNamed(template_name)
        segment = BaseSegment(self.primary())
        fqn = self.fqn()
        declsuffix = baselang.suffix(location='decl')

        varset.setValue('scope', decl_segments)

        segment.instantiate(template, varset, self.kind(), fqn)
        mapfile = MapFile(
          metac.basePath(fqn, prefix='.', suffix=declsuffix + '.map'),
          fs.realpath(fs.abspath(metafile.path())), [])
        contents = []
        segment.flattenLines(contents, mapfile, strip_special=True)
        basesubpath = baselang.classSubPath(self, location='decl')
        basefile = BaseFile(
          basesubpath, '\n'.join(contents) + '\n',
          metafile=metafile, mapfile=mapfile)
        metafile.registerFile(basefile)

      /# Create the .bld BUILD fragment
      /#  - until we can find a way to implement python namespaces in terms
      /#    of per-class files, we do NOT create .bld files for each class
      /#    in python
      bldfile = None
      if basel != 'python':
        bldpath = metac.basePath(fqn, prefix='.', suffix='.bld')
        if False:
          /# Useful during debugging.
          print bldpath
          self.showDependencies()
          print '  Targets:'
          for target in targets:
            print '    ' + target
        rule, build_data = baselang.createBuildFragment(
          self, sorted(targets), test=istestcase)
        if rule is not None:
          fragment = baselang.formatBuildRule(rule, build_data)
          bldfile = BaseFile(bldpath, '\n' + fragment + '\n', metafile=metafile)
          metafile.registerFile(bldfile)

      D.translate.end()
      return [basefile, bldfile]
    test:
      /# Due to the amount of dependency between various methods (expandMeta()
      /# before translateMeta(), expandMeta() of namespace before expandMeta()
      /# of class before expandMeta() of method, etc.), there is no clean way
      /# to invoke translateMeta() on just a class instance ... we need to
      /# expand and translate an entire namespace. This is tested in
      /# NamespaceConstruct.expandMeta(), so we don't repeat it here.
      pass
    end method translateMeta;

    method compileMeta scope:
      D.compile.sinfo(self.id())
      /# TODO(wmh): Implement this.
      /# - In python
      /#   - Handle per-class Entry points (but since Python is namespace-centric),
      /#     it may be handle in NamespaceConstruct.compileMeta() instead.
      /# - In Javascript
      /#   - Handle per-class Entry points.
      /# - In C++
      /#   - Handle per-class Entry points.
      scope, children = self.attrpair('scope:')
      for child in children:
        child.compileMeta()
      D.compile.end()
    end method compileMeta;

    method registerDependencies #:
      Populate the 'deps' field by adding explicit and implicit dependencies to
      this class.
    scope:
      baselang = self.baselang()
      basel = baselang.id()
      metaclass = self.metaclass()
      namespace = self.namespace()
      assocs = self.attrval('associations:', default=metax.c.EMPTY)
      istest = self.isTest()

      /# Parent imports
      parent_classes = self.parentclasses()
      if parent_classes:
        parentdata = parent_classes[0]
        if not parentdata.get('external', False):
          pfqn = parentdata['metafqn']
          self.addDependency(pfqn, 'cls', 'parent')

      /# Explicit imports
      for dep in assocs:
        /# dep can be either 'assoc' or 'resource'
        akind = dep.kind()
        if akind == 'resource':
          self.registerResource(dep)
        elif akind == 'assoc':
          /# assoc
          aid = dep.id()
          aloc = dep.attrval('location', default=metax.c.LOOKUP)
          akind = dep.attrval('kind', default=metax.c.LOOKUP)

          if istest and 'test' not in aloc:
            continue
          elif 'user' not in aloc:
            continue

          if akind == 'std':
            fqn = aid
          else:
            fqn = ClassConstruct.CanonicalizeClassName(
              aid, namespace=namespace)

          atarget = dep.attrval('target', default=None)
          if atarget is None:
            /# TODO(wmh): If akind is 'std' we could set atarget to null, but we
            /# would need to still register the dependency. Currently, we handle
            /# setting target to null in Oopl*.formatDependency instead.
            atarget = baselang.nameToBuildTarget(fqn)
          else:
            atarget = atarget.asStr(unquote=True)
          if atarget:
            self.addDependency(fqn, akind, 'in assocs')

      /# Implicit imports
      if metaclass is not None:
        /# This is a user-defined user-level class.  Each such class defines
        /# a 'meta' method that returns the singleton instance of the
        /# metaclass describing the class.
        mfqn = metaclass.fqn()
        if basel == 'javascript':
          /# TODO(wmh): Clean up the special-casing in javascript ... the current
          /# implementation is too messy!
          /#  - the nm.sp.FooMeta module exports both nm.sp.FooMeta and nm.sp.MetaFoo
          /#  - if one wants to import either nm.sp.FooMeta or nm.sp.MetaFoo,
          /#    special code must be generated in OoplJavascript.formatDependency.
          /#  - when importing nm.sp.MetaFoo, one uses assoc kind 'cls' even
          /#    though MetaFoo is an instance of FooMeta, not a class.
          metaclass_instname = ClassConstruct.MetaInstifyName(self.id())
          mifqn = '.'.join(mfqn.split('.')[:-1] + [metaclass_instname])
          self.addDependency(
            mifqn, 'cls', 'implicit import in ClassConstruct.translateMeta()')
        else:
          self.addDependency(
            mfqn, 'cls', 'implicit import in ClassConstruct.translateMeta()')

        /# Every class depends on metax.root.ObjectMeta.
        self.addDependency(
          /# CODETANGLE(implicit_objectmeta)
          'metax.root.ObjectMeta', 'cls', 'every class depends on ObjectMeta')

      /# If this class is a test class, we always import:
      /#  - the class it tests.
      /#  - metax.test (for metax.test.main()) ... in python
      if self.isTest():
        underclass = self.underclass()
        if underclass:
          /# All implicit test classes will have underclass set, but
          /# explicit user-provided test classes will not.
          ufqn = underclass.fqn()
          self.addDependency(
            ufqn, 'cls', 'implicit import in ClassConstruct.translateMeta()')

          if basel == 'javascript':
            tsfqn = 'goog.testing.testSuite'
            self.addDependency(
              tsfqn, 'cls', 'implicit import in ClassConstruct.translateMeta()',
              target=None)

          /# In python, the metax.test module is needed because metax.test.main()
          /# is invoked to start the test suite.
          if basel == 'python':
            self.addDependency(
              'metax.test', 'lib', 
              'implicit import of metax.test so metax.test.main() is available',
              target=None)
        else:
          /# Means we have an explicit user-provided test class.
          pass
    test:
    end method registerDependencies;

    method generateMetaClass : ClassConstruct #:
      Create a metaclass associated with this class.

      May be applied to user-level or test-level classes.
    scope:
      name = self.id()
      fqn = self.fqn()
      context = self.context()
      metaspace, metablock, metaname, metaparent = self.metaClassInfo()
      metaclass = ClassConstruct.NewFromData(
        /# TODO(wmh): Verify that meta class should share same context as
        /# user class.
        metaname, context, parent=metablock,
        features=[('location', 'meta')],
        secondaries=[
          ('parent', metaparent),
          /# We are not expanding the resulting class, so we don't bother
          /# ('testparent', testmetaparent),
          ('assocs:', []),
          ('comment:', ['Auto-generated meta class for %s.' % fqn]),
          ('scope:', []),
        ],
        position='-' + name,
        precount=1)
      return metaclass
    test:
    end method generateMetaClass;

    method generateImplicitMeta : MethodConstruct #:
      Generate a 'meta' method for this class.
    scope:
      result = None
      /# TODO(wmh): Once confident that the generation of this method is
      /# working properly in all baselangs, some optimizations can be
      /# performed:
      /#  - the method does NOT need to be defined in every python class ...
      /#    we can simply define it in metax.root.Object as:
      /#      def meta(self):
      /#        return self.__class__
      /#    (assuming we continue to set the __metaclass__ of every class
      /#    in Python ... if we do not, we will need to continue to define
      /#    meta() in each class).
      name = self.id()
      fqn = self.fqn()
      scope = self.attr('scope:', default=None)
      baselang = self.baselang()
      context = self.context()
      metaclass = self.metaclass()
      if metaclass is None:
        /# TODO(wmh): Determine when this is an error, and when this is working
        /# as intended!
        if Compiler.IMPL['metatestclass']:
          raise InternalError(
            'Must initialize metaclass of %s before invoking '
            'generateImplicitMeta().' % fqn)
        else:
          /# Do not generate a 'meta' method.
          scope = None

      if scope:
        /# We do not create a 'meta' method if there is no explicit scope:
        /# in the class.  This deals with the common case of someting like
        /#   class Error < metax.root.Error;
        /# and also situations where no metaclass exists for the class.
        /#
        /# However, this may pose problems in other situations ... we can
        /# reconsider how to handle this if it is an issue. Added because
        /# NewFromData() was failing when parent=None and position!=null.

        /# Define an implicit method named 'meta' that returns the
        /# singleton instance of the metaclass defining this class.
        /#  - if metaclasses have been disabled, the method should return null.
        /# TODO(wmh): When statement-level constructs exist, define this
        /# method in Meta<*>:
        metaclass_instname = ClassConstruct.MetaInstifyName(name)
        test_body = ["%s noop" % Context.TOKENS['remark']]
        if baselang.id() == 'python':
          test_body.append('pass')
        meta_body = baselang.metaMethodBody(metaclass_instname, metaclass)

        /# We need to establish whether the 'meta' method is defined on an
        /# ancestor or not. Once we have full hierarchy info we can establish
        /# this directly, but for now the following heuristic:
        /#  - if fqn is metax.root.Object, inheritance new
        /#  - if fqn is metax.root.ObjectMetaRoot, inheritance new
        /#  - if fqn is metax.test.TestCase, inheritance new
        /#  - if class does not inherit from any of the above, inheritance new
        /#  - otherwise inheritance override
        if fqn in (
          'metax.root.Object',
          'metax.root.ObjectMetaRoot',
          'metax.test.TestCase'
        ):
          inheritance = 'new'
        else:
          inheritance = 'override'
        features = [
          ('inheritance', inheritance),
          ('autogen', 'notest'),
        ]
        secondaries = [
          /# We use * instead of & because we want to support the conditional
          /# inclusion of metaclasses.
          ('returns', Type.Instance('*metax.root.ObjectMetaRoot')),
          ('scope:', meta_body),
          ('test:', test_body)
        ]

        result = MethodConstruct.NewFromData(
          'meta', context, parent=scope, precount=1,
          features=features, secondaries=secondaries,
          primary_line=-1, position='+')

      return result
    test:
    end method generateImplicitMeta;

    method registerResource #:
      Register a resource.
    params:
      var resource : Construct #:
        The reource construct to register.
    scope:
      metafile = self.metafile()
      metac = self.compiler()
      fs = metac.fs()
      baselang = metac.baselang()

      /# Establish the path storing the resource.
      path_attr, subpath_expr = resource.attrpair('path', default=metax.c.LOOKUP)
      subpath = fs.expandvars(subpath_expr.asStr(unquote=True))

      src_path = fs.join(fs.dirname(metafile.path()), subpath)
      if not fs.exists(src_path):
        metafile.error(
          '%s does not exist' % src_path, line=resource.primary().line())
      else:
        klass = resource.ancestor('class')
        assert klass is self

        /# Create a filename that encodes the class name and the resource name.
        resname = resource.id()
        class_name = klass.id()
        /# CODETANGLE(resource_dir): See metax.root.Object.Resource.
        filename = '%s_%s' % (class_name, resname)

        /# Establish the path within the generated python code hierarchy from
        /# which we will symlink to the src path. It has to be in the same
        /# hierarchy as the generated code for bazel to be happy.
        namespace = self.namespace()
        dest_dir = fs.join(
          /# CODETANGLE(resource_dir)
          metac.repositoryPath(), metac.basePath(namespace.fqn()), 'resources')
        dest_base = fs.basename(dest_dir)
        dest_path = fs.join(dest_dir, filename)

        if not fs.exists(dest_dir):
          fs.makedirs(dest_dir, 0755)
        target = fs.join(dest_base, filename)

        /# print 'src_path %s' % src_path
        /# print 'dest_path %s' % dest_path
        /# print 'target %s' % target

        /# Create the symlink from src_path to dest_path.
        if not fs.lexists(dest_path):
          print 'NOTE: Linking %s to %s' % (src_path, dest_path)
          fs.symlink(src_path, dest_path)
        else:
          /# The file already exists ... verify it is a symlink and points where
          /# it should.
          if fs.islink(dest_path):
            curr_src_path = fs.readlink(dest_path)
            if curr_src_path != src_path:
              /# It does not point where it should. For now, we report an error and tell
              /# the user how to fix the problem (by removing the incorrect symlink). We
              /# may want to automatically do this in the future (but we want to avoid
              /# deleting an important file while doing
              metafile.error(
                'Resource %s is stored in\n'
                '  %s\nwhich currently links to\n'
                '  %s\ninstead of\n'
                '  %s\nRemove\n'
                '  %s\n'
                'and reinvoke metac to proceed.' %
                (resname, dest_path, curr_src_path, src_path, dest_path),
                line=resource.primary().line())
          else:
            metafile.warning(
              'Resource %s is stored in\n'
              '  %s\n'
              'which is currently a non-symlink when it should be a symlink to\n'
              '  %s\n'
              'You can remove\n'
              '  %s\n'
              'and reinvoke metac to clean up.' %
              (resname, dest_path, src_path, dest_path),
              line=resource.primary().line())

        /# Store a mapping from resource name to target for use in
        /# createBuildFragment().
        self.resources()[resname] = target
    end method registerResource;

    method registerInitializer #:
      Register an initializer with this class.
    params:
      var initializer : MethodConstruct;
    scope:
      /# TODO(wmh): it is very possible that the MethodConstruct instance
      /# will never be properly GCed because of all the circular links.
      /# Implement __del__ on Construct, and/or start using weakptrs in
      /# some places.  Relevant because we are tromping any pre-existing
      /# initializer and hoping the old instance gets GCed ... it may not!
      current = self.initializer()
      if current:
        current.myclassIs(None)
      self.initializerIs(initializer)

      if initializer:
        initcls = initializer.myclass()
        if initcls and initcls is not self:
          raise Error(
            '%s already has initializer %s and now %s' %
            (self.fqn(), initcls.kindfqn(), initializer.kindfqn()))
        initializer.myclassIs(self)
    test:
    end method registerInitializer;

    method registerStaticInitializer #:
      Register a static initializer with this clas.
    params:
      var initializer : MethodConstruct #:
        The method defining the static initializer.
        TODO(wmh): Not all baselangs implement static initializers via
        methods (e.g. Java). This will need to be generalized.
    scope:
      self.clinitIs(initializer)
    test:
    end method registerStaticInitializer;

    meta
    method CreateAssocs : ComplexBlock #:
      Create a 'associations:' attribute given assoc info.
    params:
      var assoclist : vec<map> #:
        Each element is a map containing:
          id: str
          features : vec<tuple<str,str>>
          secondaries : vec<tuple<str,any>>
          termcode : int
      var context : Context;
    scope:
      assocs = ComplexBlock(None, 'associations:', [])
      for assocdata in assoclist:
        assoc = AssocConstruct.NewFromData(
          assocdata['id'], context, parent=assocs,
          features=assocdata.get('features', None),
          secondaries=assocdata.get('secondaries', None),
          termcode=assocdata.get('termcode', 1))
      return assocs
    test:
      _, schema, context, compiler = test.cachedInfo()

      assocs = metax.c.ClassConstruct.CreateAssocs([], context)
      test.iseq('associations:', assocs.key())
      test.iseq([], assocs.value())

      assocs = metax.c.ClassConstruct.CreateAssocs(
        [
          {'id': 'sys', 'features': [('kind', 'std')]},
          {'id': 'code', 'features': [('kind', 'std'), ('location', 'test')]},
          {'id': 'nm.sp.Class',
           'features': [('kind', 'cls')],
           'secondaries': [
             ('target',
              metax.c.Expr(
                'str', '"//faux@nm.sp:Class"', '"//faux@nm.sp:Class"'))]},
        ],
        context)
      test.iseq('associations:', assocs.key())
      test.iseq(
        ['std assoc sys;\n',
         'std test assoc code;\n',
         'cls assoc nm.sp.Class target "//faux@nm.sp:Class";\n'],
        [assoc.asStr() for assoc in assocs.value()])
    end method CreateAssocs;

  end class ClassConstruct;

  class ExternalClassConstruct < ClassConstruct #:
    A class defined external to Meta, in baselang-space.

    There are admittedly a massive number of unused fields declared and
    initialized by inheriting from ClassConstruct, but there will presumably be
    a relatively small number of classes, never mind non-meta classes, so I'm
    assuming it won't be an issue. Enterprise scale may need a different
    solution (eg. ClassInterface above ClassConstruct and
    ExternalClassConstruct)
  scope:

    lifecycle params:
      var id : str;
      var parent : ClassConstruct;
      var context : Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.variantIs('baselang')
      /# TODO(wmh): We could do baselang introspection (for those languages
      /# supporting it) to initialize fields like parentclasses(), deps(),
      /# testclass(), namespace(), fields(), etc.  For now, we do not do so.
      self.parentclassesIs([])
    end;

    method parentclass : ClassConstruct #:
      Obtain a parent class by index in superclass list.

      NOTE: Until ClassConstruct.importMeta() is invoked on this class,
      this method will return null.
    params:
      var index : int = 0 #:
        The index in self.parentclasses() of desired parent.
    scope:
      /# TODO(wmh): We could use baselang introspection to obtain the
      /# actual parent class of this baselang class, and dynamically
      /# create a new ExternalClassConstruct.
      return None
    test:
    end method parentclass;

  end class ExternalClassConstruct;

  class CategoryConstruct < OoplConstruct #:
    Represents a 'category' construct.

    TODO(wmh): Decide whether this class should inherit from ClassicConstruct
    or just provide the same interface
     - note that duck typing won't work if we implement Meta in Meta<C++>
     - the concern here is that category constructs could be legal at other
       levels (namespace, method, etc.) and having CategoryConstruct be a
       subclass of ClassicConstruct is misleading and wasteful in those
       situations (although ClassicConstruct defines few fields currently,
       I expect its state to grow significantly).

    TODO(wmh): Decide whether this construct is even worth the complexities it
    imposes.
     - need to ensure uniqueness of all symbols defined transitively down
       all nested categories (pretty easy to do by registering every
       non-category child of a category with the namespace/class/method the
       category is residing in).
  scope:

    method kind : str scope:
      return 'category'

    method expandMeta #:
      Expand the field
       - produce accessor methods (getter, setter, reffer, etc.)
         in appropriate class depending on level.
       - leave the field construct in the user class no matter what
         (translateMeta can decide whether to ignore or not on a per-baselang
         basis).
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      D.expand.sinfo(self.kindfqn())

      /# We want the effect to be the same as if the category construct
      /# wasn't present, while still maintaining the grouping provided
      /# by categories.
      /#  - construct ids must be unique across entire nested category
      /#    hierarchy

      /# TODO(wmh): Note that we cannot just move the child constructs up
      /# to the top-level, as this will lose the grouping provided by category.
      /# But we do need to maintain uniqueness, so each class (and any other
      /# consstruct that supports categories) should maintain a 'symbol_closure'
      /# field for aggregating constructs across the category hierarchy.

      scope = self.attrval('scope:', default=None)
      if scope:
        for child in scope:
          child.expandMeta(output=output)

      D.expand.end()
    end method expandMeta;

    method translateMeta : vec<BaseFile> #:
      Field compilation code.
       - generate
       - for languages that are namespace-primary (e.g. Python), create a
         file representing the namespace (aka module)
       - create a BUILD file containing all targets for building the classes
         in the namespace, and for building the namespace itself.
    scope:
      D.translate.sinfo(self.kindfqn())

      scope = self.attrval('scope:', default=None)
      if scope:
        for child in scope:
          child.translateMeta(output=output)

      D.translate.end()
    test:
    end method translateMeta;

  end class CategoryConstruct;

  class RemarkConstruct < OoplConstruct #:
    Represents a 'remark' construct.

    TODO(wmh): Decide whether this class should inherit from ClassicConstruct
    or just provide the same interface.
     - note that duck typing won't work if we implement Meta in Meta<C++>
     - the concern here is that remark constructs are legal elsewhere than
       just class scope.
  scope:

    method kind : str scope:
      return 'remark'

    method expandMeta #:
      Expand the remark (nothing to do).
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      D.expand.sinfo(self.kindfqn())
      /# No expansion needed.
      D.expand.end()
    end method expandMeta;

    method translateMeta : vec<BaseFile> #:
      Translate.  Write baselang comment.
    scope:
      D.translate.sinfo(self.kindfqn())

      /# TODO(wmh): Write a baselang comment here!

      D.translate.end()
    test:
    end method translateMeta;

  end class RemarkConstruct;

  class CommandConstruct < ClassicConstruct #:
    Represents a 'command' construct.

    TODO(wmh): Decide whether this class should inherit from ClassicConstruct
    or just provide the same interface.
     - note that duck typing won't work if we implement Meta in Meta<C++>
     - the concern here is that command constructs are legal elsewhere than
       just class scope.
  scope:

    method kind : str scope:
      return 'command'

    method expandMeta #:
      Expand the entry.

      Create a meta method on the class within which the entry is found
      representing the code to execute for this entry point. This involves
      compiling all 'flag', 'block' and 'command' subconstructs within
      the entry 'scope' into a collection of lines that represent the
      body of the to-be-added meta method.
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      D.expand.sinfo(self.kindfqn())

      metafile = self.metafile()
      streams = metafile.streams()
      klass = self.ancestor('class')
      metaclass = klass.metaclass()
      metaclass_scope = metaclass.attr('scope:', default=metax.c.REQUIRED)
      userclass = metaclass.underclass()
      assert userclass is not None
      class_scope = userclass.attr('scope:', default=metax.c.REQUIRED)

      context = metaclass.context()
      metafile = self.metafile()
      baselang = self.baselang()
      rem = baselang.config('rem')
      /# For the top-level command within a class, we pass the comment of the
      /# command on as the comment of the method.
      comment_lines = self.attrval('comment:', default=None)
      if comment_lines is None:
        comment_lines = [
          'Auto-generated entry point for %s' % klass.fqn()]
      command_scope = self.attrval('scope:', default=metax.c.REQUIRED)

      special_default_command = '__default__'

      def VarName(names, start=1, end=None):
        if end is None:
          end = len(names)
        result = '_'.join(names[start:end])
        if result:
          result += '_'
        result += 'command'
        return result

      /# Establish the level of command construct.
      clist = []
      cnames = []
      cmd = self
      while cmd.kind() == 'command':
        clist.insert(0, cmd)
        cnames.insert(0, cmd.id())
        cmd = cmd.parentConstruct()
      level = len(clist) - 1
      toplevel = level == 0
      indent = '  ' * level
      sub_var = 'meta__names[%d]' % (level + 1)

      command_fullname = VarName(cnames)
      if toplevel:
        parent_fullname = None
      else:
        parent_fullname = VarName(cnames, end=-1)

      if toplevel:
        streams.initStreams('command_init', 'command_body')
        /# TODO(wmh): Determine why the following produces a problem in
        /# importMeta() when we specify ('metax.cli', 'lib', ...). This yields
        /# class path .../metax/.cli.py (instead of metax/cli/__init__.py) and
        /# thus a null meta path. Note that it is not strictly sufficient
        /# to import metax.cli.Command ... also need Flag and Arg and Values.
        /# Works fine for Python, but may not for other baselangs.
        metaclass.addDependency(
          'metax.cli.Command', 'cls', 'needed for entry point')

      command_init = streams.stream('command_init')
      command_body = streams.stream('command_body')

      /# print '*** For %s found %s lines in body before start' % (self.kindfqn(), len(command_body))

      /# We need to add code to command_init to create a new
      /# metax.cli.Command instance.
      self.generatePython(command_fullname, parent_fullname, command_init)

      /# Now parse the scope
      subcmds = []
      args = []
      default_encountered = False
      for child in command_scope:
        kind = child.kind()

        if kind == 'flag':
          /# Generate flag code in command_init.
          child.generatePython(command_fullname, command_init)

        elif kind == 'command':
          if len(subcmds) == 0:
            /# This is the first subcommand ... insert an initial block that
            /# never gets executed (avoids special case code latter).
            command_body.append('')
            command_body.append('%sif False:' % indent)
            command_body.append('%s  pass' % indent)
          elif default_encountered:
            /# We previously encountered the special default command, which
            /# must occur after all other commands, so the current one is
            /# in error.
            /# TODO(wmh): Use a less hacky mechanism here.
            metafile.error(
              'The special %s command must occur last' %
              special_default_command, line=child.primary().line())
            break

          subcmds.append(child)
          command_body.append('')
          if child.id() == special_default_command:
            command_body.append('%selse:' % indent)
            default_encountered = True
          else:
            command_body.append(
              "%selif %s == '%s':" % (indent, sub_var, child.id()))
          /# We encode within the baselang output stream some information about
          /# where within the .meta file the upcoming code block resides.
          cscope = child.attr('scope:', default=metax.c.REQUIRED)
          command_body.append(
            '%s  %s ^METAFILE^ %s' % (indent, rem, metafile.path()))
          command_body.append(
            '%s  %s ^METALINE^ %s:command %d' %
            (indent, rem, child.fqn(), cscope.line()))
          /# We recursively expand the child command construct, which will write
          /# lines into the command_body and command_init streams.
          child.expandMeta()

        elif kind == 'block':
          clines = child.attrval('comment:', default=None)
          if clines is None:
            /# If there are multiple named blocks defined in this 'command'
            /# without comments, they will all share the command-level
            /# comment.  Not really a problem.
            /# TODO(wmh): As a side question, should we enforce only one
            /# block for leaf commands?
            clines = self.attrval('comment:', default=None)
            if clines is None:
              clines = []

          blines = child.attrval('scope:', default=metax.c.REQUIRED)
          block_kind = child.attrval('kind')

          if block_kind == 'named':
            /# We create a method to implement this block.

            if self.id() == special_default_command:
              metafile.error(
                'The default command cannot be named',
                line=block.primary().line())
            else:
              /# Establish the method name
              if Context.IsAutoId(child.id()):
                methname = command_fullname
              else:
                methname = block.id()

              /# Generate the method call locally.
              command_body.append('%sself.%s()' % (indent, methname))

              /# Create the method that does the actual work.
              /#  - note that although the toplevel Entry method is
              /#    a meta method (and thus defined on the meta class),
              /#    named blocks are generated as instance methods on
              /#    the underlying user class.
              method = MethodConstruct.NewFromData(
                methname, context, parent=class_scope,
                features=[],
                secondaries=[
                  ('#:', clines or None),
                  ('scope:', blines),
                ],
                primary_line=child.primary().line())

          else:
            /# We write the contents of the block into command_body.
            /# TODO(wmh): Should use BlockConstruct.translateMeta() if possible!
            /# TODO(wmh): Is there a way to force a new lexical scope in
            /# python3 within a method, so that a variable defined inside
            /# the lexical scope does not affect its value outside that scope?
            for line in clines:
              /# TODO(wmh): Generalize to all baselangs.
              command_body.append(indent + rem + ' ' + line)
            for line in blines:
              command_body.append(indent + line)

        else:
          raise Error(
            'Unexpected child %s of %s' % (child.kindid(), construct.kindfqn()))

      if subcmds:
        if default_encountered:
          /# A default command was encountered, so a final 'else has been
          /# generated.
          pass
        else:
          /# There were subcommands, so we close the if ... elif ... block
          /# with an error if command is unknown.
          command_body.append('')
          command_body.append('%selse:' % indent)
          command_body.append(
            indent + "  print 'ERROR: Unrecognized command \"%s\"' % " + sub_var )


      if not subcmds or toplevel:
        /# There were no subcommands (or, alternatively, this is the top-level
        /# command. In either case, we want to add a 'catch-all' arg.
        /#  - for non-toplevel commands, if there were any 'arg' constructs
        /#    specified within this command, they are assumed to constitute all
        /#    desired args.
        /#  - as a convenience, if no args are specified, we defined a
        /#    multi-valued 'rest' arg that consumes all subsequent args.
        /#  - TODO(wmh): Consider removing this special arg when we have args
        /#    working properly as constructs ... abide by exactly what the
        /#    user wants. May still need it for toplevel though.
        command_init.append('%s.newArg(' % command_fullname)
        command_init.append("  'rest', multi=True, summary='Leftover args.')")

      if toplevel:
        /# Insert code into the method to instantiate a Command instance based
        /# on command-line args.
        command_init.append('')
        command_init.append('# Parse the command line args')
        command_init.append(
          'selected_command = %s.instantiate(args, start=True)' %
          command_fullname)
        command_init.append('if selected_command is None:')
        command_init.append('  return')
        command_init.append('meta__names = selected_command.names()')
        command_init.append('cli = selected_command.asValues()')

        /# We create the entry method.
        method_name = 'Entry'
        body = command_init + command_body
        params = ExecutableConstruct.CreateParams(
          [{'var': 'args',
            'secondaries': [
              (':', Type.Instance('&vec<str>')),
              ('#:', ['The list of command line args (including executable)']),
            ]},
           {'var': 'parent',
            'secondaries': [
              (':', Type.Instance('metax.root.Command')),
              ('#:', ['A parent command. Usually null.']),
              ('=', Expr('var', 'null', 'null')),
            ]},
           {'var': 'kwds', 'features': [('multiplicity', 'multi')],
            'secondaries': [
              (':', Type.Instance('map')),
              ('#:', ['Catchall arg for special-casing.']),
            ]},
          ],
          context)
        entry_method = MethodConstruct.NewFromData(
          method_name, context, parent=metaclass_scope,
          /# We do not bother setting location because we are creating the method
          /# within the metaclass (location is only relevant during expansion and
          /# we are skipping that step by defining in metaclass directly).
          secondaries=[
            (':', Type.Instance('int')),
            ('#:', comment_lines),
            ('params:', params),
            ('scope:', body),
          ])
        entry_method.myclassIs(klass)

      D.expand.end()
    end method expandMeta;

    method translateMeta : vec<BaseFile> #:
      Translate.  Write baselang comment.
    scope:
      D.translate.sinfo(self.kindfqn())

      /# This is currently a noop, as we form a 'method' in expandMeta and
      /# rely on MethodConstruct.translateMeta() to do its thing.

      D.translate.end()
    test:
    end method translateMeta;

    method generatePython #:
      Generate python code that will create a metax.cli.Command
      instances representing this command construct.
    params:
      var command_var : str #:
        The name of the variable storing a metax.cli.Command instance
        that is to contain the Flag instance.
      var parent_var : str #:
        The name of the parent.  Is null if this is the top-level construct.
        Note that top-level construct does not necessarily mean top-level
        Command instance (depends on value of 'parent' in the generated code).
      var output : &vec<str> #:
        Where to write output.
    scope:
      indent = ''
      toplevel = parent_var is None

      aliases = self.attrval('aliases', default=None)

      if toplevel:
        /# We are at top-level, so we need to create a Command directly.
        creation_cmd = 'metax.cli.Command'
      else:
        /# We are not at top-level, so we can create a subcommand using
        /# newCommand() on the parent.
        creation_cmd = '%s.newCommand' % parent_var

      summary, desc = self.splitComment()
      output.append("%s%s = %s(" % (indent, command_var, creation_cmd))
      output.append("%s  '%s'," % (indent, self.id()))
      if toplevel:
        output.append('%s  parent=parent,' % indent)
      if aliases:
        /# the 'aliases' attribute of 'command' is of type 'str' so it is
        /# an Expr with kind 'str'.
        aval = aliases.asStr(unquote=True)
        output.append("%s  aliases='%s'," % (indent, aval))
      output.append(
        "%s  summary='%s'," % (indent, summary.replace("'", "\\'")))
      lines = desc.split('\n')
      if len(lines) == 0:
        output.append("%s  desc='')" % indent)
      elif len(lines) == 1:
        output.append(
          "%s  desc='%s')" %
          (indent, desc.replace('\n', '\\n').replace("'", "\\'")))
      else:
        output.append("%s  desc=(" % indent)
        last = lines.pop()
        for line in lines:
          output.append("%s    '%s\\n'" % (indent, line.replace("'", "\\'")))
        output.append("%s    '%s'))" % (indent, last))
    end method generatePython;

  end class CommandConstruct;

  class FlagConstruct < OoplConstruct #:
    Represents a 'flag' construct.

    TODO(wmh): Decide whether this class should inherit from ClassicConstruct
    or just provide the same interface.
     - note that duck typing won't work if we implement Meta in Meta<C++>
     - the concern here is that flag constructs are legal elsewhere than
       just class scope.
  scope:

    method kind : str scope:
      return 'flag'

    method expandMeta #:
      Expand the flag (nothing to do).
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      D.expand.sinfo(self.kindfqn())
      /# I don't believe we ever use this, right?
      raise Error('Should never get here')
      D.expand.end()
    end method expandMeta;

    method translateMeta : vec<BaseFile> #:
      Translate.  Write baselang comment.
    scope:
      D.translate.sinfo(self.kindfqn())
      /# I don't believe we ever use this, right?
      raise Error('Should never get here')
      D.translate.end()
    test:
    end method translateMeta;

    method generatePython #:
      Generate python code that will create a metax.cli.Flag
      instances representing this flag construct.
    params:
      var command_var : str #:
        The name of the variable storing a metax.cli.Command instance
        that is to contain the Flag instance.
      var output : &vec<str> #:
        Where to write output.
    scope:
      indent = ''
      metac = self.compiler()
      baselang = metac.baselang()
      aliases = self.attrval('aliases', default=None)
      type = self.attrval('type', default=None) or Type.Instance('str')
      default = self.attrval('default', default=None)
      baselang_default = baselang.formatExpr(default, type, self)
      /#if default is None:
      /#  default = baselang.defaultValue(type)
      summary, desc = self.splitComment()

      /# Establish if this is a flag or arg.
      /#  - TODO(wmh): When aliases for primary constructs are working,
      /#    we can distinguish between flag and arg by the construct kind.
      /#  - For now, if the id starts with 'arg_', it is an arg and we
      /#    strip the prefix.
      name = self.id()
      isarg = False
      if name.startswith('arg_'):
        name = name[4:]
        isarg = True

      /# Clean up type issues
      typestr = type.raw()
      if typestr.startswith('vec<'):
        typestr = typestr.replace('vec<', 'list<')

      /# Generate the code.
      output.append(
        "%s%s.new%s(" % (indent, command_var, 'Arg' if isarg else 'Flag'))
      /# baselang_default = baselang.metabaseValue(default)
      output.append(
        "%s  '%s', mytype='%s', default=%s," % (
          indent, name, typestr, baselang_default))
      if aliases:
        aval = aliases.asStr(unquote=True)
        output.append("%s  aliases='%s'," % (indent, aval))
      if summary:
        output.append(
          "%s  summary='%s'," % (indent, summary.replace("'", "\\'")))
      if desc:
        output.append(
          "%s  desc='%s'," %
          (indent, desc.replace('\n', '\\n').replace("'", "\\'")))
      if isarg and typestr.startswith('list<'):
        output.append("%s  multi=True," % indent)
      output.append("%s)" % indent)
    test:
    end method generatePython;

  end class FlagConstruct;

  class BlockConstruct < SymbolConstruct #:
    Represents a 'block' construct.

    TODO(wmh): Decide whether this class should inherit from ClassicConstruct
    or just provide the same interface.
     - note that duck typing won't work if we implement Meta in Meta<C++>
     - the concern here is that block constructs are legal elsewhere than
       just class scope.
  scope:

    method kind : str scope:
      return 'block'

    method expandMeta #:
      Expand the block (nothing to do).
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      D.expand.sinfo(self.kindfqn())
      print 'HERE in %s.expandMeta()' % self.kindfqn()
      D.expand.end()
    end method expandMeta;

    method translateMeta : vec<BaseFile> #:
      Translate.  Write baselang comment.
    scope:
      D.translate.sinfo(self.kindfqn())
      /# I don't believe we ever use this, right?
      print 'HERE in %s.translateMeta()' % self.kindfqn()
      D.translate.end()
    test:
    end method translateMeta;

  end class BlockConstruct;

  class FieldConstruct < ClassicConstruct #:
    Represents a 'field' construct.
  scope:

    field rawfield : str #:
      The rawfield name for this field.  This is usually some minor variant
      of self.id(), but for packed fields it will be completely different.

    field packed : tuple<int,int> #:
      Will be null if the field is not packed, otherwise the first integer
      is the lowest bit position in rawfield of this field, and the second
      integer is the number of bits used by the field.

    method kind : str scope:
      return 'field'

    method expandMeta #:
      Expand the field
       - produce accessor methods (getter, setter, reffer, etc.)
         in appropriate class depending on level.
       - leave the field construct in the user class no matter what
         (translateMeta can decide whether to ignore or not on a per-baselang
         basis).
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      D.expand.sinfo(self.kindfqn())

      myclass, moved = self.updateClass()
      /# D.expand.info('moved = %s' % moved)

      if moved:
        /# We only expand fields if we haven't moved the field to a different
        /# class (if we have moved it, it will be expanded later when that
        /# class is expanded).
        D.expand.info('moved (no further expansion)', level=2)
      else:
        name = self.id()
        fqn = self.fqn()
        clsname = myclass.id()
        fqcn = myclass.fqn()
        baselang = self.baselang()
        metafile = self.metafile()
        context = self.context()
        namespace = myclass.namespace()
        nmspfunc = lambda: namespace

        /# We establish the receiver to use for accessors
        /#  - use the receiver dictated by the baselang so that we don't
        /#    incur inefficiencies introducing a variable unlikely to be used
        /#    by the user
        /#  - HOWEVER, when user defines accessors in field scope:, they
        /#    need to know which variable to use to reference the receiver.
        /#    We need to either be consistent, document inconsistencies, or
        /#    auto-insert receiver variables as needed.
        /#  - Note that some baselangs do not have a specific receiver variable
        /#    (e.g. Python and Perl), in which case we use the meta-level
        /#    receiver variable.
        location = 'test' if myclass.isTest() else ('meta' if myclass.isMeta() else 'user')
        receiver_code = baselang.receiverStr(
          self, style='base', location=location, myclass=myclass)

        /# print 'FieldConstruct.expandMeta: %s' % fqn

        kind = self.attrval('kind')
        scope, accessors = self.attrpair('scope:', default=None)
        pack = self.attrval('pack')
        tmpvis = self.attrval('visibility')
        typeattr, type = self.attrpair('type', default=metax.c.LOOKUP)
        select = self.attrval('select')
        if type is None:
          metafile.error('Must provide a type', line=self.primary().line())
          return
        isconst = type.isBaseConst()

        /# Register this field with the class.
        myclass.fields().append(self)

        /# Establish the rawfield of this field
        if pack == 'packed':
          raise Error('Not yet handling packed fields')
        tokens = Context.TOKENS
        /# CODETANGLE(fieldinit):
        if tmpvis == 'tmppublic':
          rawfield = name
        else:
          rawfield = tokens['field_prefix'] + name + tokens['field_suffix']
        self.rawfieldIs(rawfield)
        stmtend = baselang.config('stmtend')

        /# Establish the default accessor code.
        /#  - also establishes the legal set of accessor ids.
        field_code = '%s%s%s' % (
          receiver_code, baselang.config('selfsep'), rawfield)
        bodymap = {}
        bodymap['get'] = ['return %s%s' % (field_code, stmtend)]
        bodymap['set'] = [
          '%s = value%s' % (field_code, stmtend),
          /# See ../../README.md section 'Accessors' for discussion of setter
          /# return values.  Currently having setters return void.
          /# 'return %s%s' % (receiver_code, stmtend)
        ]
        bodymap['ref'] = ['return %s%s' % (field_code, stmtend)]

        /# Determine if there are any explicit accessors.
        lazylines = None
        if scope:
          for accessor in accessors:
            acc = accessor.id()
            if acc not in bodymap:
              metafile.error(
                'Invalid accessor %s' % acc, attribute=accessor.primary())
            else:
              acclines = accessor.attrval('scope:', default=None)
              lazy_attr, lazylines = accessor.attrpair('lazy:', default=None)
              if acclines is not None:
                if lazylines is not None:
                  metafile.error(
                    'accessor %s should specify only scope or lazy, not both' %
                    accessor.id(), line=lazy_attr.line())
                bodymap[acc] = acclines
              elif lazylines is not None:
                /# We process the lazylines after we've created a getter method
                /# below.
                pass

        /# Establish which accessors to generate
        /#  - TODO(wmh): Improve on this by making the 'select' attribute
        /#    a multi-valued field.
        genacc = {}
        if select == 'raw':
          /# By definition of 'raw', there are no accessors for raw fields.
          genacc['get'] = False
          genacc['set'] = False
          genacc['ref'] = False
        else:
          /# We generate accessors. However, if the field has const type,
          /# we don't generate a setter or reffer.
          genacc['get'] = True
          genacc['set'] = not isconst
          genacc['ref'] = not isconst

        /# The line number in the metafile at which the field is defined. It
        /# is used for:
        /#  - indicating the (faux) metafile line number of the accessor method
        /#  - indicating the (faux) metafile line number of the accessor scope
        primary_line = self.primary().line()
        dest_scope = self.parent()

        /# Getter
        if genacc['get']:
          features = [('optimization', 'inline')]
          if kind != 'instance':
            features.append(('kind', kind))
          getname = name + ':get'
          getter_return = baselang.accessorType(
            type, 'get', namespace_function=nmspfunc)
          getter = MethodConstruct.NewFromData(
            getname, context,
            features=features + [('mutability', 'const')],
            secondaries=[
              (':', getter_return),
              ('scope:', bodymap['get'], primary_line),
            ],
            primary_line=primary_line)
          getter.myclassIs(myclass)
          D.expand.info('Created getter ' + getter.fqn(), level=2)

          if lazylines:
            /# The getter (and reffer?) have lazy lines, so we need to
            /# generate some additional code to replace getter scope:.
            newlines = []
            /# TODO(wmh): Compile a var construct to assign an value to
            /# a result var?
            resvar = '__meta_result'
            recstr = baselang.receiverStr(getter, sep=True)
            rawvar = '%s%s' % (recstr, rawfield)
            newlines.append('%s = %s' % (resvar, rawvar))

            /# TODO(wmh): Make this a baselang method.
            if baselang.id() == 'python':
              if type.isValue():
                newlines.append('if not %s:' % resvar)
              else:
                newlines.append('if %s is None:' % resvar)
              for i in range(0, len(lazylines)-1):
                newlines.append('  ' + lazylines[i])
              resval = lazylines[-1][3:]
              newlines.append('  %s = %s' % (resvar, resval))
              newlines.append('  %s = %s' % (rawvar, resvar))
              /# TODO(wmh): This can easily be obtained for all baselangs
              /# by compiling a 'return' construct.  See the getter code
              /# in Compiler._expandField() for an example.
              newlines.append('return ' + resvar)
              gscope = getter.attrval('scope:')
              del gscope[:]
              gscope.extend(newlines)
        else:
          getter = None

        /# Define the setter
        /#  - See ../../README.md section 'Accessors' for a discussion about
        /#    setter return types. Setters return void.
        /#  - We don't define a setter if the field is const.
        if genacc['set']:
          setret = 'void'
          setname = name + 'Is:set'
          setter = MethodConstruct.NewFromData(
            setname, context,
            features=features,
            secondaries=[
              (':', Type.Instance(setret)),
              ('scope:', bodymap['set'], primary_line),
            ],
            primary_line=primary_line)
          params = ExecutableConstruct.CreateParams(
            [
              {'var': 'value',
               'secondaries': [
                 ('type', baselang.accessorType(
                   type, 'setarg', namespace_function=nmspfunc))]},
            ], context)
          setter.registerAttribute(params, position='-scope:')
          setter.myclassIs(myclass)
          D.expand.info('Created setter ' + setter.fqn(), level=2)
        else:
          setter = None

        /# Define the reffer
        /#  - we don't define a reffer if the field is const.
        if genacc['ref']:
          refname = name + 'Ref:ref'
          reffer = MethodConstruct.NewFromData(
            refname, context,
            features=features,
            secondaries=[
              ('returns', baselang.accessorType(
                type, 'ref', namespace_function=nmspfunc)),
              ('scope:', bodymap['ref'], primary_line),
            ],
            primary_line=primary_line)
          reffer.myclassIs(myclass)
          D.expand.info('Created reffer ' + reffer.fqn(), level=2)
        else:
          reffer = None

        /# We insert all accessor methods after the field construct.
        /#  - by inserting reffer, then setter, then getter, we end up
        /#    putting them in the order getter, setter, reffer.
        /#  - we also register the accessors in the symbol table of
        /#    myclass.
        position = '+' + name
        if reffer:
          dest_scope.registerConstruct(reffer, position=position)
          myclass.registerSymbol(reffer.id(), reffer)
        if setter:
          dest_scope.registerConstruct(setter, position=position)
          myclass.registerSymbol(setter.id(), setter)
        if getter:
          dest_scope.registerConstruct(getter, position=position)
          myclass.registerSymbol(getter.id(), getter)

        /# QUESTION: Do we register rawfield or field?
        /#  - From a practical perspective, it is cleaner to register rawfield,
        /#    as that would allow us to register the getter with the :get suffix
        /#    (but doing so means we have to map user-provided field names to
        /#    raw names when resolving -> provide references).
        /#  - From a conceptual perspective, it depends on whether symbols in
        /#    the symbol-table represent what is actually visible to the
        /#    baselang, or whether the symboltable stores conceptual symbols
        /#    that get mapped down to baselang representations later.
        /#   
        /#  - Symbols are conceptual names:
        /#    + implementing -> provide semantics is easy
        /#    + in namespace, conceptual symbols would be classnames (baselang
        /#      symbols would require us using the MetaFoo singleton instance,
        /#      at least in languages without first-class classes). Being able
        /#      to refer to classes instead of metaclasses is intuitive, and
        /#      makes it viable for us to define the auto-generator for 
        /#        /mem/<metafile>/<namespace>/<class>/<method>
        /#      to be "show the symbol table of the current construct", which
        /#      is pretty convenient.
        /#    + we get to use a high-level receiver string instead of the
        /#      receiver varying from baselang to baselang (admittedly though,
        /#      there is still the 'self'/'meta'/'test' ambiguity).
        /#    - fields use field id not rawfield, at getter needs to be suffixed with :get
        /#    - we need to define a means of mapping high-level symbols to
        /#      baselang level.
        /#    - The most intuitive "conceptual" name for a field is its id.
        /#      The most intuitive "conceptual" name for a getter is its id.
        /#      There is an inherent conflict here that is resolved if we use
        /#      the rawname for fields.
        /#  - Symbols are baselang names:
        /#    + no need to perform high-level-to-baselang mapping of symbols,
        /#      since the symbols are already in baseang syntax.
        /#
        /#  - The current implementation is to have the symbol table store
        /#    conceptual names.  We can revisit if we find problems with this.
        /# CODETANGLE(highlevel_symbols):
        myclass.registerSymbol(name, self)

      D.expand.end()
    test:
    end method expandMeta;

    method translateMeta : vec<BaseFile> #:
      Field compilation code.
       - for languages (like Python and javascript) that define fields in
         initializers, there is nothing to do in FieldConstruct.translateMeta(),
         since it is all handled in the initializer, which has been populated in
         FieldConstruct.expandMeta.
       - for languages (like C++ and Java) for which there is an explicit syntax
         for defining fields, we generate appropriate code here.
    scope:
      D.translate.sinfo(self.kindfqn())

      baselang = self.baselang()
      metafile = self.metafile()
      streams = metafile.streams()

      /# TODO(wmh): Perform as much work here as possible before calling
      /# baselang.formatBaseField().  In particular, check if the field is
      /# optional, packed, etc.
      select_attr, select = self.attrpair('select', default=metax.c.LOOKUP)
      status_attr, status = self.attrpair('status', default=metax.c.LOOKUP)
      location_attr, location = self.attrpair('location', default=metax.c.LOOKUP)
      kind_attr, kind = self.attrpair('kind', default=metax.c.LOOKUP)
      pack_attr, pack = self.attrpair('pack', default=metax.c.LOOKUP)
      inheritance_attr, inheritance = self.attrpair(
        'inheritance', default=metax.c.LOOKUP)
      type_attr, type = self.attrpair('type', default=metax.c.LOOKUP)
      /# TODO(wmh): Should we LOOKUP default?
      default_attr, default = self.attrpair('default', default=None)
      comment_attr, comlines = self.attrpair('comment:', default=None)

      rem = baselang.config('rem') + ' '
      clines = []
      clines.append('')
      clines.append('%sfield %s : %s' % (rem, self.id(), type))
      if comlines:
        k = len(comlines) - 1
        while k > 0 and not comlines[k].strip():
          k -= 1
        for i in range(0, k+1):
          clines.append(rem + '  ' + comlines[i])

      /# In most languages, the field definition occurs in the merged defn/decl
      /# stream, but in languages with separated decl/defn (at least in C++),
      /# the field definition is written into the declaration stream.
      /# TODO(wmh): Define a method on BaseLanguageOopl for determining which
      /# stream to write field declarations to?
      sname = 'defn'
      if baselang.config('definition_separate'):
        sname = 'decl'
      streams.addLines(sname, clines)

      lines = baselang.formatFieldDefinition(self)
      if lines:
        /# TODO(wmh): Do we need to create a BaseSegment so we have line
        /# numbering?
        streams.addLines(sname, lines)

      D.translate.end()
    test:
    end method translateMeta;

  end class FieldConstruct;

  class AccessorConstruct < OoplConstruct #:
    Used to represent Accessor constructs.
  scope:

    method kind : str scope:
      return 'accessor'

  end class AccessorConstruct;

  abstract
  class ExecutableConstruct < ClassicConstruct #:
    Abstract construct above constructs that have
    executable code.
  scope:

    meta
    method TestifyName : str #:
      Obtain the test method naem corresponding to a user method.
    params:
      var name : str;
    scope:
      /# CODETANGLE(methtest)
      return 'test_' + name
    end method TestifyName;

    meta
    method IsTestName : bool #:
      Check if a name is a test.
    params:
      var name : str;
    scope:
      /# CODETANGLE(methtest)
      return name.startswith('test_')
    end method;

    meta
    method UntestifyName : str #:
      Obtain the user method name corresponding to a test method name.
    params:
      var name : str;
    scope:
      assert name.startswith('test_')
      return name[5:]
    end method UntestifyName;

    field returntype : Type #:
      The return type of this Executable. Represents a cached version of
      the 'returns' or 'returns:' attributes.
      TODO(wmh): This is not yet implemented!!!

    field params : *map #:
      A parsed representation of the 'params:' attribute.  Contains:
        attr: Attribute
          The params attribute
        data: vec<map>
          name: str
          type: Type
          default: any (optional)
          provides: str (optional)
          comment: vec<str>
        fields: map
          maps (high-level) field names to parameter names, for all fields
          that are to be initialized directly from a parameter (i.e. via
          the 'provides' syntax).
        varvec: map
          name: str
            The name of the catch-all vec-based param
          comment: vec<str>
        varmap: map
          name: str
            The name of the catch-all map-based param
          comment: vec<str>

    method expandMeta #:
      Expand the executable
       - if level is meta, move method to metaclass
       - if level is test, move method to testclass
       - currently, we do NOT recurse to children, as the children in scope: are
         either lines (simple block) or statement level constructs that do not
         need expansion.
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      D.expand.sinfo('%s (%s)' % (self.kindfqn(), self))

      myclass, moved = self.updateClass()
      /# D.expand.info('moved = %s' % moved)

      if moved:
        /# We only expand methods if we haven't moved the method to a different
        /# class (if we have moved it, it will be expanded later when that
        /# class is expanded).
        D.expand.info('moved (no further expansion)', level=2)

        /# TODO(wmh): In Python, due to some unfortunate ways that metaclasses
        /# interact with @classmethod, we need to provide a @classmethod
        /# implementation of meta methods within the userclass, which means
        /# we need to create some wrapper method.
        /#  - How to establish whether the current method is a meta method
        /#    within user scope?
        /#  - Do we have the @classmethod method defined on the userclass
        /#    call the meta method, or vice-versa?
        /#  - How do we handle class variables vs meta variables?
        pass

      else:
        metafile = self.metafile()
        context = self.context()
        fqn = self.fqn()
        variant = myclass.variant()
        baselang = self.baselang()

        kind = self.attrval('kind')
        span = self.attrval('span')
        scope = self.attrval('scope:', default=None)
        autogen = self.attrval('autogen')

        if span == 'specific' and scope is None:
          /# This method does not apply to the current baselang, so we remove
          /# it entirely.
          self.parent().unregisterConstruct(self)

        else:
          /# If this is an initializer, record it with the class.
          if kind == 'initializer':
            myclass.registerInitializer(self)

          /# Establish the receiver variable to use.
          rec = baselang.receiverStr(self, style='meta')

          /# We register this executable as a symbol within its class.
          /#  - TODO(wmh): Think more carefully about how symbols should be
          /#    handles for meta and test classes.
          if variant == 'user':
            myclass.registerSymbol(self.id(), self)

          /# TODO(wmh): In python, due to some unfortunate ways that metaclasses
          /# interact with @classmethod, we need to provide a @classmethod
          /# implementation of meta methods within the userclass (it delegates to
          /# the implementation in the metaclass).
          /#  - How do we establish if this is a meta-method within a user
          /#    class? (

          /# We expand 'test:' and 'tests:' blocks in methods within classes of
          /# the following variants:
          /#   user
          /#   meta
          /#   metauser ???
          /# We do NOT expand test blocks in
          /#   test      (test classes do not have tests)
          /#   testmeta  (test classes do not have tests)
          /#   metatest  (meta classes of test classes do not have tests)
          /#   testuser  (test classes do not have tests)

          testclass = myclass.testclass()
          if variant in ('user', 'meta') and testclass and autogen != 'notest':
            /# Define one (or more) test methods within the test class associated
            /# with the class this method is defined within.
            testscope = testclass.attr('scope:')
            testattr, testlines = self.attrpair('test:', default=None)
            testsattr, testxes = self.attrpair('tests:', default=None)

            /# The code below creates one or more entries in testdata based on
            /# data in testattr and testsattr.
            /#  - if neither a test: nor tests: block is found, we create one
            /#    test method printing "test not yet implemented".
            /#  - if test: and tests: are both defined, it is an error
            /#  - if test: is defined, create one test method
            /#  - if tests: is defined, create one test method for each testx
            /#    construct in tests:
            /#  - each element of testdata contains:
            /#      name : str
            /#        The name of the test method
            /#      features : vec<tuple<str,str>>
            /#        The key/value features in order
            /#      secondaries : vec<tuple<str,str>>
            /#        The key/value secondary attributes (except scope:)
            /#      scope : vec<str> or vec<Construct>
            /#        The value to assign to the scope: of the test method.
            /#  - some general observations about feature and secondary attributes
            /#    of test methods:
            /#     - feature attributes are almost always:
            /#        - level instance
            /#        - location user
            /#        - visibility public
            /#        - presence concrete
            /#        - mutability mutable
            /#        - extensibility extendable
            /#        - dispatch autodispatch
            /#        - inheritance new
            /#       (which are the default values for all of these feature attrs,
            /#        so feature attributes are rarely needed).
            /#     - secondary attributes are almost always:
            /#        - no params
            /#        - return type void
            /#        - no tests
            /#        - no super
            /#        - no comment
            /#        - no config
            /#      (e.g. no secondaries are needed)
            testdata = []
            testbase = ExecutableConstruct.TestifyName(self.id())
            /# TODO(wmh): Generalize to all baselangs
            if testbase == 'test___init__':
              testbase = ExecutableConstruct.TestifyName(myclass.id())

            voidtype = Type.Instance('void')

            if variant == 'meta' or kind == 'initializer':
              /# For meta classes and initializer, we do not produce a warning
              /# message.
              missing_message = None
            else:
              /# TODO(wmh): disabling temporarily
              missing_message = None
              /# missing_message = '%s does not yet have a unittest' % fqn

            if testattr and testsattr:
              metafile.error(
                'Cannot define both test: and tests:', attribute=testsattr)

            elif testattr:
              /# We have a single test, which is usually a simple block (but
              /# may be a complex block of <*>ed).
              if testattr.isComplexBlock():
                /# testlines is a misnomer ... it is really a list of Construct,
                /# not lines.
                metafile.error(
                  'Not yet handling complex test: blocks', attribute=testattr)
              else:
                /# Simple block of lines.
                if len(testlines) == 0:
                  testlines = baselang.emptyBlockCode(
                    None, message=missing_message)
                  
                testdata.append({
                  'name': testbase,
                  'features': [],
                  'secondaries': [],
                  'scope': testlines,
                  'line': testattr.line(),
                })

            elif testsattr:
              /# We have one or more testx constructs.
              for testx in testxes:
                testname = testbase + '_' + testx.id()
                metafile.info(
                  'Not yet handling testx constructs',
                  line=testx.primary().line())
                /# TODO(wmh): Fix this! Add methods with name 'testname'

            else:
              /# Neither 'test:' nor 'tests:' was defined.
              /#  - we add an empty test block for non-abstract methods.
              presence = self.attrval('presence', default=metax.c.LOOKUP)
              if presence == 'concrete':
                testdata.append({
                  'name': testbase,
                  'features': [],
                  'secondaries': [],
                  'scope': baselang.emptyBlockCode(
                    None, message=missing_message),
                })

            for testinfo in testdata:
              secondaries = testinfo['secondaries']
              assert 'scope:' not in [p[0] for p in secondaries]
              tscope = testinfo['scope']
              assert tscope is not None
              secondaries.append(('scope:', tscope, testinfo.get('line', -1)))
              unittest = MethodConstruct.NewFromData(
                testinfo['name'], context, parent=testscope,
                features=testinfo['features'],
                secondaries=secondaries,
                /# Add at end of test scope. Since we are processing methods
                /# in order, the test methods will have the same order.
                position=None)
              unittest.myclassIs(testclass)

      D.expand.end()
    test:
    end method expandMeta;

    method translateMeta : vec<BaseFile> #:
      Executable compilation code.
       - format the signature
       - format the comment
       - insert auto-generated preamble (initialize fields, super calls, typechecking)
       - insert user-provided code (or implicit stub)
       - insert postamble
    scope:
      D.translate.sinfo(self.kindfqn())

      attrkind = self.attrval('kind')
      presence = self.attrval('presence')
      optimization = self.attrval('optimization')
      returntype = self.attrval('returns')

      /# modifiers : vec<str>
      /#   The modifiers to add before the class
      modifiers = []

      /# scope_lines : vec<str>
      /#   The lines making up the executable body.
      /# preamble : vec<str>
      /#   The lines of baselang text to insert within scope before user code.
      /# postamble : vec<str>
      /#   The lines of baselang text to insert within scope after user code.
      scope_attr, scope_lines, preamble, postamble, comment, params_str = (
        self.methodInfo())

      /# postmethod : vec<str>
      /#   The lines of baselang text to insert after scope.
      postmethod = []

      if scope_lines is None:
        /# This method is not to be generated.
        pass

      else:
        myclass = self.myclass()
        baselang = self.baselang()
        metafile = self.metafile()
        rem = baselang.config('rem')
        comment_attr = attribute=self.attr('comment:', default=None)

        /# Establish the baselang-level name of the method.
        if attrkind == 'initializer':
          execname = baselang.initializerName(self)
        else:
          /# We currently have some hackery in place around getter method ids,
          /# which are the same as the underlying field. To avoid having the
          /# field and getter conflict, we add a special ':get' to the getter
          /# in FieldConstruct.expandMeta() and a special clause in
          /# ExprParser.ID_RE.  We remove it here.
          /#
          /# To make it less hacky, the following code is sufficiently general
          /# to convert <name>:get to <name>, <name>Is:set to <name>Is, and
          /# <name>Ref:ref to <name>Ref. In particular, it strips off a suffix
          /# of the form ':(get|set|ref)$'.
          execname = self.id()
          m = ExprParser.ID_RE.match(execname)
          if m and m.group(3):
            /# print '***** HERE with %s' % execname
            execname = (m.group(1) or '') + m.group(2)

        /# Establish baselang syntax for method return type.
        return_str = baselang.typeToBase(returntype, class_construct=myclass)

        /# Create the VarSet of variables.
        varset = VarSet()
        varset.addVar('modifiers', modifiers)
        varset.addVar('method', execname, attribute=self.primary())
        varset.addVar('fqn', myclass.fqn())
        varset.addVar('class_base', myclass.id())
        varset.addVar('params', params_str)
        varset.addVar('returns', return_str)
        varset.addVar('comment', comment, comment_attr)
        varset.addVar('preamble', preamble)
        varset.addVar('scope', scope_lines, attribute=scope_attr)
        varset.addVar('postamble', postamble)
        varset.addVar('postmethod', postmethod)

        if ExecutableConstruct.IsTestName(execname):
          varset.addVar(
            'method_base', ExecutableConstruct.UntestifyName(execname))

        /# Allow baselangs to modify the varset
        /#  - they may modify 'preamble'
        baselang.augmentVarset(self, varset)
        if preamble:
          /# This must be the last line in the preamble in order for
          /# base-to-meta line numbers to be correct!
          preamble.append('%s User-provided code follows.' % rem)

        /# This should be empty if the scope is NOT being inlined.
        /# Currently the code only supports inlining for definition_separate
        /# baselangs.
        inline = ''
        has_decl = False
        has_defn = True
        if baselang.config('definition_separate'):
          /# For baselangs with two files per class, we print out the
          /# declaration using the same flow as in other baselangs, and handle
          /# the definition file specially.
          has_decl = True
          if presence == 'abstract':
            has_defn = False

          if scope_lines:
            /# If this is an accessor being defined, we want to inline the code.
            /# If it is a single line, we do so more concisely than we otherwise
            /# would.
            if optimization == 'inline' and len(scope_lines) == 1:
              if rem not in scope_lines[0]:
                /# Until we can test whether this method is an accessor or not,
                /# we must avoid lines with comments if we want to put the
                /# text on a single line ending with '}'.
                inline = ' { %s }' % scope_lines[0]
            else:
              /# TODO(wmh): Allow any number of lines!
              pass

        template_name = baselang.establishTemplateName(self, defn=True)
        /# print 'Here with %s = %s' % (self.kindfqn(), template_name)

        streams = metafile.streams()
        consinfo = self.context().consinfo(self.kind())

        /# The normal action is to write the method to 'defn'
        /#  - the only time we do not do this is if the baselang has a
        /#    separation between decl and defn and the method is inlined
        /#    (in which case we put it only in decl, not in defn). Note
        /#    that this logic is C++-centric, but the distinction
        /#    between defn and decl is probbably C++ specific too.
        if has_defn and (not has_decl or not inline):
          template = consinfo.templateNamed(template_name)
          segment = BaseSegment(None)
          segment.instantiate(template, varset, self.kind(), self.fqn())
          streams.addSegment('defn', segment)

        if has_decl:
          /# This baselang has different syntax for declaring a method and
          /# defining it (in separate files). We've already written the
          /# definition to the 'defn' stream, and now we write the declaration
          /# to the 'decl' stream.
          template_name = baselang.establishTemplateName(self, defn=False)
          template = consinfo.templateNamed(template_name)
          segment = BaseSegment(None)

          /#varset.addVar('inline', inline, attribute=scope)
          if not inline:
            inline = ';'
          varset.addVar('inline', inline)

          dummy = []
          params_str = baselang.formatParams(self, dummy, decl=True)
          varset.setValue('params', params_str)

          segment.instantiate(template, varset, self.kind(), self.fqn())
          streams.addSegment('decl', segment)

      D.translate.end()
    test:
    end method translateMeta;

    private
    method methodInfo
    returns tuple<ComplexBlock,vec<str>,vec<str>,vec<str>,vec<str>,str> #:
      Obtain various aspects of the method:

      Returns:
       0) scope_attr: ComplexBlock
            The scope block. This may be null (but does not imply anything
            by itself ... see 'scope' below for null-ness).
       1) scope: vec<str>
            The baselang lines in the user-provided scope. If this is None,
            we are NOT to generate anything for the executable (and all other
            return values are ignored).
       2) preamble: vec<str>
            The baselang lines in the scope before user content.
       3) postamble: vec<str>
            The baselang lines in the scope after user content.
       4) comment: vec<str>
            The baselang comment associated with the method.
       5) params: str
            The baselang syntax for declaring params.
    scope:

      if self.kind() != 'method':
        /# lifecycle and behavior should be expanded away, no?
        print '%s in %s' % (self.kindfqn(), self.parentConstruct().kindfqn())
        print '@' * 70
        self.write()
        print '@' * 70
        raise Error('Expecting only methods not %s' % self.kindfqn())

      metac = self.compiler()
      myclass = self.myclass()
      metafile = self.metafile()
      baselang = self.baselang()
      /# TODO(wmh): How to establish the actual width?
      width = 80 - 0
      scope_lines = None

      scope_attr, _ = self.attrpair('scope:', default=None)
      if scope_attr is None:
        scope_lines = []
        span = self.attrval('span')
        presence = self.attrval('presence')
        /# No 'scope:' is present.

        if span == 'specific':
          /# We do not expect a scope, and are to NOT generate a method.
          scope_lines = None

        elif presence == 'abstract':
          /# This is handled when emptyBlockCode() is invoked below.
          pass

        elif (
          /# It is common for test classes to not have initializers and to
          /# instead have 'setup' blocks.
          self.myclass().variant() == 'user'
          /# If --implicit_scopes is specified, we are to generate a dummy
          /# scope block rather than report a warning.
          and not metac.cli().implicit_scopes
        ):
          metafile.warning(
            '%s is general but missing scope<%s>' %
            (self.fqn(), baselang.suffix()[1:]),
            line=self.primary().line())
      elif scope_attr.isSimpleBlock():
        /# We strip empty lines in case the user has added spurious emptiness.
        /# This is needed because BaseFile() expects final content to never
        /# have blank lines at the end, and raises an exception if found.
        scope_lines = baselang.simpleToBase(
          scope_attr, strip_empty=True, replace_receiver=True)
      else:
        /# TODO(wmh): Compile the meta-level statement constructs.
        scope_lines = []

      if scope_lines is None:
        /# We've established that we should not generate this method.
        params = None
        comment = None
        preamble = None
        postamble = None
      else:
        preamble = []
        postamble = []
        attrkind = self.attrval('kind')
        inheritance = self.attrval('inheritance')

        /# Handle inheritance (prex and postx).
        if attrkind == 'initializer':
          /# Various special functionality is generated in initializers:
          /#  - invocation of parent initializers (default postx semantics)
          /#  - implicit initialization of fields not explicitly initialized
          /#    in scope_lines.

          /# TODO(wmh): Currently, we are assuming that iniitalizers always
          /# have inheritance 'postx', but we probably want to generalize
          /# this.
          /# TODO(wmh): IMPORTANT: In oopl/schema.meta, the 'lifecycle'
          /# construct has defined 'Attribute inheritance = postx', but
          /# the '= postx' does not appear to be overriding the '= new'
          /# defined up in _executable_.
          if inheritance == 'superx':
            /# This is a request to NOT generate the super code ... it is
            /# up to the user to perform the call themselves.
            pass
          else:
            baselang.superCode(self, preamble)
            /# We do NOT invoke baselang.initCode() here because we need to do
            /# formatParams() first, as it may add code to 'preamble' to define
            /# a new receiver variable (one that is used in initCode()).
        else:
          if inheritance == 'postx':
            baselang.superCode(self, preamble)
          elif inheritance == 'prex':
            baselang.superCode(self, postamble)

          if len(scope_lines) == 0:
            scope_lines = baselang.emptyBlockCode(self)

        /# Obtain params and comment.
        params = baselang.formatParams(self, preamble)
        comment = baselang.formatMethodComment(self, width=width)

        /# Now add implicit field initialization code to the preamble.
        if attrkind == 'initializer':
          baselang.initCode(self, preamble)

          /# Initializers are candidates for being optimzied away. If the
          /# following are all true, we do not need to define the initializer:
          /#  - scope_lines is empty
          /#  - postamble is empty
          /#  - preamble is empty or contains only a super() call.
          if (
            False and
            not scope_lines
            and not postamble
            and (
              not preamble
              /# TODO(wmh): Testing for 'super(' is baselang specific. Generalize
              /# this code.
              or (len(preamble) == 1 and preamble[0].startswith('super('))
            )
          ):
            msg = '%s has been optimized away' % self.kindfqn()
            /#print 'NOTE: ' + msg
            metafile.info(msg, line=self.primary().line())

            /# Setting scope_lines to None means "do not generate method".
            scope_lines = None
            /# Remove the initializer from the class.
            /#  - TODO(wmh): Is there any reason to keep the initializer
            /#    construct around?  We could use a different field to
            /#    indicate that it has been optimized out, rather than
            /#    killing it.
            myclass.registerInitializer(None)

      return scope_attr, scope_lines, preamble, postamble, comment, params
    end method methodInfo;

    method isTestCase : bool #:
      True if this method is defined within a class that is a test case
      and looks like a test method.
    scope:
      return (
        self.myclass().isTestCase()
        and ExecutableConstruct.IsTestName(self.id()))
    test:
    end method isTestCase;

    meta
    method CreateParams : ComplexBlock #:
      Create a 'params:' attribute given var info.
    params:
      var varlist : vec<map> #:
        Each element is a map containing:
          var: str
          features : vec<tuple<str,str>>
          secondaries : vec<tuple<str,any>>
          termcode : int
      var context : Context;
    scope:
      params = ComplexBlock(None, 'params:', [])
      for vardata in varlist:
        var = VarConstruct.NewFromData(
          vardata['var'], context, parent=params,
          features=vardata.get('features', None),
          secondaries=vardata.get('secondaries', None),
          termcode=vardata.get('termcode', 1))
      return params
    test:
      Type = metax.c.Type

      _, schema, context, compiler = test.cachedInfo()

      params = metax.c.ExecutableConstruct.CreateParams([], context)
      test.iseq('params:', params.key())
      test.iseq([], params.value())

      params = metax.c.ExecutableConstruct.CreateParams(
        [
          {'var': 'name',
           'secondaries': [('type', Type.Instance('int'))]},
          {'var': 'age',
           'secondaries': [
             (':', Type.Instance('int')),
             ('=', metax.c.Expr('int', '77', 77))]},
          {'var': 'rest', 'features': [('multiplicity', 'multi')],
           'secondaries': [(':', Type.Instance('vec'))]},
        ],
        context)
      test.iseq('params:', params.key())
      test.iseq(
        ['var name type int;\n',
         'var age : int = 77;\n',
         'multi var rest : vec;\n'],
        [v.asStr() for v in params.value()])
    end method CreateParams;

    method parsedParams : map #:
      Parse the 'params:' attribute.

      Returns:
        See the 'params' field for details.
    params:
      var force : bool = false #:
        If true, recompute params even if already pre-computed.
    scope:
      result = self.params()
      if result is None or force:
        metafile = self.metafile()
        params = self.attr('params:', default=None)
        data = []
        fields = {}
        result = {'attr': params, 'data': data}
        if params:
          for var in params.value():
            name = var.id()
            provides_attr, provides = var.attrpair(
              'provides', default=metax.c.LOOKUP)
            /# If 'provides' is given, should not specify 'type', 'multiplicity'
            /# or 'comment:' (but can specify 'default')
            missing = None if provides else metax.c.LOOKUP
            typeattr, type = var.attrpair('type', default=missing)
            multattr, multiplicity = var.attrpair(
              'multiplicity', default=missing)
            comattr, comlines = var.attrpair('comment:', default=None)
            default = var.attrval('default', default=metax.c.LOOKUP)

            if provides:
              myclass = self.myclass()
              field = myclass.symbolNamed(provides)
              if not field:
                metafile.error(
                  'Failed to find field %s in %s' %
                  (provides, myclass.kindfqn()),
                  line=provides_attr.line())
              elif field.kind() != 'field':
                metafile.error(
                  'Expecting %s to be of kind field not %s' %
                  (field.kindfqn(), field.kind()),
                  line=provides_attr.line())
              else:
                if typeattr:
                  metafile.error(
                    'Cannot specify both provides and type',
                    line=typeattr.line())
                if comattr:
                  /# TODO(wmh): Look into whether there is any utility in
                  /# allow such a comment. For example, explaining what
                  /# the default value associated witht the 'provides' means
                  /# (something that doesn't make sense to put in the field
                  /# comment in all cases).
                  metafile.warning(
                    'Not currently using var comment (using field comment instead)',
                    line=comattr.line())
                if multattr:
                  metafile.error(
                    'Cannot specify both provides and multiplicity',
                    line=multattr.line())
                /# We obtain type and comment from the field.
                typeattr, type = field.attrpair('type', default=missing)
                comattr, comlines = field.attrpair('comment:', default=None)

                /# We record a mapping from field to param name for use in
                /# BaseLanguageOopl.initCode()
                fields[provides] = name

            if multiplicity == 'multi':
              traw = type.raw()
              if traw.startswith('vec'):
                varvec = {'name': name}
                if comlines:
                  varvec['comment'] = comlines
                result['varvec'] = varvec
              elif traw.startswith('map'):
                varmap = {'name': name}
                if comlines:
                  varmap['comment'] = comlines
                result['varmap'] = varmap
              else:
                metafile.error(
                  'Invalid type %s for multi var %s' % (traw, name),
                  line=typeattr.line())
            else:
              item = {'name': name, 'type': type}
              if provides:
                item['provides'] = provides
              /# CODETANGLE(special_expr): TODO(wmh): Decide whether <special>
              /# is indicated by an Expr with value() None, or by an Expr that
              /# is None. Depending on which is decided, default below is either
              /# never None, or never '<special>'.
              if default is not None and default != '<special>':
                item['default'] = default
              if comlines:
                item['comment'] = comlines
              data.append(item)
        if fields:
          result['fields'] = fields
        self.paramsIs(result)
      return result
    test:
    end method parsedParams;

  end class ExecutableConstruct;

  class MethodConstruct < ExecutableConstruct #:
    Represents a 'method' construct.

    - parse:
       - nothing
    - expand:
       - not currently invoked
    - import:
       - 
  scope:

    field supermethod : MethodConstruct #:
      The method being overridden in an ancestor by this definition. Will be
      null if no ancestor defines the method (it will also always be null before
      importMeta() has been invoked on this instance).

    method kind : str scope:
      return 'method'

    method importMeta #:
      Look up the inheritance chain for a method with the same name.
       - allows us to enforce 'new'/'override' semantics
       - allows us to implement 'super var' semantics in parameters by being
         able to identify the types of params from their parent equivalents
    scope:
      name = self.id()
      D.imports.sinfo(name)

      myclass = self.myclass()
      parentclass = myclass.parentclass()
      if parentclass is not None:
        psymbols = parentclass.symbols()
        super_method = psymbols.find(name)
        if super_method:
          self.supermethodIs(super_method)
          attrkind = self.attrval('kind')
          if attrkind == 'initializer':
            /# Knowing the parent initializer will be useful for many purposes.
            pass
          else:
            /# TODO(wmh): methods from behaviors are not showing up as being
            /# overridden.
            if name != 'meta':
              /# print '  In %s found parent definition %s' % (self.kindfqn(), super_method.kindfqn())
              pass

      /# Now initialize the symbol table of the method.
      /#  - for methods with simple blocks, we only have access to the params
      /#  - for methods with complex blocks, we have all vars specified at
      /#    top-level within the method as well.
      table = self.symbols()
      params = self.attrval('params:', default=None) or []
      for i, pvar in enumerate(params):
        table.register(pvar.id(), pvar, source=self, note='From param #%d' % (i+1))

      scope = self.attr('scope:', default=None)
      if scope:
        if scope.isComplexBlock():
          /# TODO(wmh): Do we add all top-level 'var' constructs now? A variable
          /# cannot be used until declared in most baselangs, so pre-populating
          /# the symbol table is problematic unless we add an 'inactive' field
          /# that allows us to indicate when a symbol is and is not active.
          pass
        else:
          /# TODO(wmh): We could do some heuristic analysis of the baselang
          /# source code fairly easily. Or, if we have access to a
          /# statement-level parser for each baselang, we can identify all
          /# variable declarations.
          pass
      
      D.imports.end()
    end method importMeta;

  end class MethodConstruct;

  class LifecycleConstruct < ExecutableConstruct #:
    Represents a 'lifecycle' construct.
  scope:

    method kind : str scope:
      return 'lifecycle'

    method expandMeta #:
      Expand the lifecycle
       - move to testclass or metaclass if location indicates such
       - create initializer method based on params, scope and most other attrs.
       - create finalizer method based on 'finalize:'
       - create baselang-specific setup/teardown methods based on 'setup:'
         and teardown: (and location).
          - if location is 'user', setup and teardown to not make sense except
            in the very special case of defining metax.test.TestCase
          - if location is 'meta', setup and teardown do not make sense
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      /# Move to testclass or metaclass if appropriate
      myclass, moved = self.updateClass()

      D.expand.sinfo(
        '%s in %s variant %s location %s moved %s metaclass %s' %
        (self.kindfqn(), myclass.kindfqn(), myclass.variant(),
         self.attrval('location'), moved, myclass.metaclass()))
      /# if False and myclass.id() == 'TestCase':
      /#   myclass.showDebug()

      if moved:
        /# We only expand lifecycles if we haven't moved the lifecycle to a
        /# different class (if we have moved it, it will be expanded later when
        /# that class is expanded).
        D.expand.info('moved (no further expansion)', level=2)
      else:
        /# A 'lifecycle' construct is a generalization of an initializer, and
        /# can thus be found in every class.
        /#  - when used within a test class that inherits from
        /#    metax.test.TestCase, the 'setup:' and 'teardown:' block attributes
        /#    correspond to the baselang-specific and location-secific setUp and
        /#    tearDown methods.
        /#  - the setup*/teardown* attributes do not make sense for user-defined
        /#    classes (at normal or meta level, even if they are service test
        /#    classes)
        /#  - the setup/teardown attributes do make sense (and are common) for
        /#    lifecycles with location 'test' (either explicitly within a class
        /#    'scope:', or implicitly by appearing in the 'tests' block of a
        /#    user-level class). They are also common in lifecycles appearing in
        /#    user-defined test classes (i.e. classes with location 'test' in
        /#    namespace 'scope:' or appearing in the 'tests:' block of a
        /#    namespace), but only if the test class inherits from
        /#    metax.test.TestCase, not if it is a service test class that
        /#    doesn't inherit from metax.test.TestCase.
        /#  - setup is invoked before each test method is executed, teardown is
        /#    invoked after each test method is executed.
        /#  - setupcase is invoked once before any of the test methods within a
        /#    testcase are invoked, and teardowncase is invoked once after all
        /#    of the testmethods within a testcase have been invoked.
        /#
        /# Some reminder notes about Meta and unittests (and how lifecycles
        /# interact)
        /#  - Most baselangs that support xUnit testing will have a root
        /#    TestCase class with setup-each, teardown-each, setup-once and
        /#    teardown-once methods (exactly names depend on baselang) and a
        /#    constructor that accepts a string representing the name of the
        /#    method to test.
        /#  - Meta defines meta.testing.TestCase which inherits from this
        /#    baselang-specific root TestClass, and whose initializer has a
        /#    method-name arg passed to the parent.
        /#  - For user-defined class <C>, we implicitly create <C>Test which is
        /#    a subclass of meta.testing.TestCase, whose initializer accepts a
        /#    method name that is passed to its parent.
        variant = myclass.variant()
        baselang = self.baselang()
        metafile = myclass.metafile()

        /# Create an initializer method.
        /#  - initializer name is determined by baselang.initializerName()
        /#  - insert just before the lifecycle construct.
        /#  - the test method(s) should use the name of the class, NOT the
        /#    baselang-specific initname (this allows us to ensure that
        /#    the initializer unittest can be accessed by a baselang-independent
        /#    name.
        initname = baselang.initializerName(myclass)
        position = '-' + self.id()
        context = self.context()
        scope = myclass.attr('scope:')
        features = []
        for fkey in (
          'presence', 'visibility', 'mutability', 'extensibility', 'dispatch',
          /# The location attribute of the generated initializer method will
          /# not be used, but we include it for readability purposes. May
          /# want to consider introducing a 'ignore' value to 'location' that
          /# we can set it to instead of taking the value from the lifecycle.
          'location',
          /# The inheritance feature attribute defaults to 'postx' for
          /# lifecycle constructs, and the code currently assumes this value
          /# always.  However, it is often useful to allow initialization of
          /# values before invoking the parent.  Supporting this in C++
          /# and Java will result in some inefficiency, but should be possible.
          /# There are also times where we want to be able to disable calls
          /# to the parent constructor in python (e.g. when we are inheriting
          /# from an old-school class), in which case superx is useful.
          'inheritance',
        ):
          fval = self.attrval(fkey, default=None)
          if fval is not None:
            features.append((fkey, fval))
        features.append(('kind', 'initializer'))
        primary_line = self.primary().line()
        initializer = MethodConstruct.NewFromData(
          initname, context, parent=scope,
          features=features,
          primary_line=primary_line,
          position=position)
        /# Now move all the secondary attributes from the lifecycle to the
        /# initializer.
        for skey in (
          'returns', 'returns:', 'comment:', 'params:', 'super',
          'pres:', 'posts:', 'scope:', 'test:', 'tests:',
        ):
          secondary = self.attr(skey, default=None)
          if secondary is not None:
            secondary.changeParent(initializer)
        myclass.registerInitializer(initializer)
        /# Now expand the newly created initializer (to move the test attribute,
        /# etc.)
        initializer.expandMeta()

        /# TODO(wmh): Create a finalizer method if there is a 'finalize'
        /# attribute in this lifecycle.


        /# Handle the 'clinit' block.
        clinit_attr, clinit_lines = self.attrpair('clinit:', default=None)
        if clinit_attr is not None:
          /# TODO(wmh): Generalize to all baselangs
          if baselang.id() == 'python':
            /# We create a Meta__Initialize() method.
            clinit = MethodConstruct.NewFromData(
              'Meta__Initialize', context, parent=scope,
              features=[('kind', 'static')],
              secondaries=[('scope:', clinit_lines)],
              primary_line=clinit_attr.line(),
              position='+' + initname)
            myclass.registerStaticInitializer(clinit)
          else:
            metafile.error(
              'Not yet supporting clinit: for baselang %s' % baselang.id(),
              line=clinit_attr.line())

        /# Create baselang-specific setup/teardown methods depending on
        /# which of 'setup', 'setupcase', 'teardown' and 'teardowncase' exists
        /# as attributes on this lifecycle.
        for attr in ('setup', 'setupcase', 'teardown', 'teardowncase'):
          block = self.attr(attr + ':', default=None)
          if block:
            if (
              (variant == 'testuser') or
              (variant == 'test') or
              (variant == 'user' and myclass.id() == 'TestCase')
            ):
              tinfo = baselang.config(attr)
              tname = tinfo['name']
              tlevel = tinfo.get('level', 'instance')
              tkind = None
              if tlevel == 'static':
                tkind = 'static'
                features.append(('kind', 'static'))
              elif tlevel == 'meta':
                tkind = 'cls'
              features = []
              if tkind:
                features.append(('kind', tkind))
              if tkind != 'static':
                features.append(
                  ('inheritance', 'prex' if 'teardown' in attr else 'postx'))

              tmethod = MethodConstruct.NewFromData(
                tname, context, parent=scope,
                features=features,
                secondaries=[('scope:', block.value())],
                primary_line=block.line())
              tmethod.myclassIs(myclass)
              tmethod.expandMeta()
            else:
              metafile.warning(
                'Attribute "%s" does not apply to %s %s' %
                (attr, variant, myclass.kindfqn()))
      D.expand.end()
    end method expandMeta;

    method translateMeta #:
      A lifecycle is expanded into various methods. Nothing needs doing
      for the lifecycle construct itself except in special circumstances
      (e.g. Javascript).
    scope:
      /# print 'LifecycleConstruct.translateMeta: Doing nothing for %s' % self.fqn()
      pass
    end method translateMeta;

  end class LifecycleConstruct;

  class BehaviorConstruct < ExecutableConstruct #:
    Represents a 'behavior' construct.
  assocs:
    std assoc collections;
    std assoc copy;
  scope:

    field namespace : NamespaceConstruct #:
      The namespace this class belongs to.

    method kind : str scope:
      return 'behavior'

    method expandMeta #:
      Expand the behavior
       - create method constructs in each receiver class
       - create test method constructs in each receiver test class
    params:
      var output : vec<Construct> = null #:
        Where to write constructs created during expansion.  Does NOT
        include transitively created constructs. If null, do not accumulate.
    scope:
      /# Expand the behavior into a collection of methods defined on
      /# classes identified by the 'receiver' constructs within the behaviors
      /# scope.
      name = self.id()
      baselang = self.baselang()
      context = self.context()
      comment_lines = self.attrval('comment:', default=None)
      params_attr, params = self.attrpair('params:', default=None)
      parent_block = self.parent()

      if False:
        print '#' * 70
        print self.kindfqn()
        self.write()

      fkey_order = (
        'visibility', 'span', 'level', 'nature', 'mutability', 'kind',
        'dispatch')
      default_feature_map = {}
      for fkey in fkey_order:
        fattr, fval = self.attrpair(fkey, default=None)
        if fval is not None:
          default_feature_map[fkey] = fval

      scope, receivers = self.attrpair('scope:', default=None)
      for receiver in receivers:

        clsname = receiver.id()

        feature_map = copy.copy(default_feature_map)
        presence = receiver.attrval('presence', default=None)
        if presence is not None:
          feature_map['presence'] = presence

        /# scope may be null if receiver is abstract
        receiver_scope, receiver_lines = receiver.attrpair(
          'scope:', default=None)
        if receiver_scope is None:
          receiver_lines = baselang.emptyBlockCode(receiver)
          receiver_linenum = receiver.primary().line()
        else:
          receiver_linenum = receiver_scope.line()

        /# test can definitely be null.
        receiver_test, test_lines = receiver.attrpair(
          'test:', default=None)

        /# Find the class_construct matching 'clsname'
        /#  - TODO(wmh): This needs to be generalized to support classes
        /#    in a different namespace than the behavior.
        /#  - Easily accomplished because we have access to the entire
        /#    hierarchy by fqn.
        receiver_class = parent_block.cons(clsname, default=None)
        if receiver_class is None:
          print 'ERROR: Failed to find %s.%s' % (namespace.id(), clsname)
        else:
          /# feature attributes
          features = []
          for k in fkey_order:
            if k in feature_map:
              features.append((k, feature_map[k]))
          /# secondary attributes
          secondaries = []
          if comment_lines:
            secondaries.append(('#:', comment_lines))
          if params_attr:
            /# Note that we cannot just move 'params:' because there can be
            /# multiple receivers, each needing the params: attribute.
            params_copy = params_attr.clone(None)
            secondaries.append(('params:', params_copy))
          secondaries.append(('scope:', receiver_lines, receiver_linenum))
          class_scope = receiver_class.attr('scope:', default=REQUIRED)
          /# method creation
          method = MethodConstruct.NewFromData(
            name, context, parent=class_scope, features=features,
            secondaries=secondaries, primary_line=receiver.primary().line())
          method.myclassIs(receiver_class)
          assert method.primary().line() == receiver.primary().line()

          /# Create a test method if a 'test' attribute exists
          if receiver_test:
            receiver_test_class = receiver_class.testclass()
            if receiver_test_class is None:
              print (
                'WARN: Compiler._expandNamespaceScope on %s: Failed to find '
                '%s in %s test block' %
                (self.kindfqn(),
                 clsname + 'Test', test_block.parent().kindfqn()))
            else:
              class_test_scope = receiver_test_class.attr(
                'scope:', default=REQUIRED)
              test_secondaries = [
                ('scope:', test_lines, receiver_test.line())
              ]
              test_method = MethodConstruct.NewFromData(
                'test_' + name, context, parent=class_test_scope,
                secondaries=test_secondaries,
                primary_line=receiver.primary().line())
    end method expandMeta;

    override
    method translateMeta #:
      Expand the behavior
       - create method constructs in each receiver class
       - create test method constructs in each receiver test class
    scope:
      /# TODO(wmh): We need to disable this method because BehaviorConstruct is
      /# currently inheriting from ExecutableConstruct. Although conceptually it
      /# is executable, implementation-wise it is not, so we should change its
      /# parent to OoplConstruct.
      return (None, None)
    end method translateMeta;

  end class BehaviorConstruct;

  class ReceiverConstruct < OoplConstruct #:
    Represents a 'receiver' construct.
  scope:

    method kind : str scope:
      return 'receiver'

  end class ReceiverConstruct;

  class NativeConstruct < OoplConstruct #:
    Represents a 'native' construct.
  scope:

    field namespace : NamespaceConstruct #:
      Every construct that can appear in a namespace must have a
      namespace field.  Not really needed for Native.

    method kind : str scope:
      return 'native'

    method expandMeta #:
      For native blocks within namespace scope, the native construct
      is attached to the preceeding class construct
    scope:
      parent_construct = self.parentConstruct()
      if parent_construct.kind() == 'namespace':
        /# native blocks within namespace scope are added to either the
        /# 'pre' or 'post' key of the 'extralines' field of the nearest
        /# 'class' construct in a particular direction.
        baselang = self.baselang()
        rem = baselang.config('rem')
        comment_attr, commlines = self.attrpair('comment:', None)
        scope_attr, scope = self.attrpair('scope:', default=None)

        /# These feature attributes help us determine which class construct to
        /# find (the 'position' feature is either 'pre' or 'post', indicating
        /# whether we are looking for the class below or above this native
        /# construct), which class variant is desired (the 'location' feature
        /# is 'user', 'test' or 'meta'), and which file variant is desired
        /# (the 'placement' feature is 'defn' or 'decl').
        position = self.attrval('position')
        placement = self.attrval('placement')

        parent = self.parent()
        block = parent.value()
        index = block.index(self)
        class_construct = None
        metafile = self.metafile()

        if scope is None:
          /# This native block does not apply to the baselang in question.
          direction = None

        elif position == 'pre':
          /# This native block is associated with the class BELOW it, and
          /# is written into that class' premap field.
          direction = 'below'
          n = len(block)
          while index < n-1:
            index += 1
            cons = block[index]
            if cons.kind() == 'class':
              class_construct = cons
              break
        elif position == 'post':
          /# This native block is associated with the class ABOVE it, and
          /# is written into that class' postmap field.
          direction = 'above'
          while index > 0:
            index -= 1
            cons = block[index]
            if cons.kind() == 'class':
              class_construct = cons
              break
        else:
          raise InternalError('Invalid position "%s"' % position)

        if direction is None:
          pass
        elif not class_construct:
          metafile.error(
            'Failed to find a class %s %s' % (direction, self.fqn()),
            line=self.primary().line())
        else:
          /# Now we check the 'location' attribute to see if the code is
          /# to be put in the test class or meta class instead.
          target_class = None
          locattr, location = self.attrpair('location', default=LOOKUP)
          /# TODO(wmh): Fix this issue with attrpair ... if we need to LOOKUP,
          /# then locattr will by definition not have a proper line number
          /# in the meta source file.  We should fall back to some default
          /# (the primary attribute line number, for example).

          if location == 'user':
            /# We are good as-is
            target_class = class_construct
          elif location == 'test':
            /# The test class may be disabled or otherwise missing.
            testclass = class_construct.testclass()
            if testclass is None:
              metafile.error(
                'native block requests placement in non-existent test class',
                line=self.primary().line())
            else:
              target_class = testclass
          elif location == 'meta':
            /# The meta class may be disabled or otherwise missing.
            metaclass = class_construct.metaclass()
            if metaclass is None:
              metafile.error(
                'native block requests placement in non-existent meta class',
                line=self.primary().line())
            else:
              target_class = metaclass
          else:
            metafile.error(
              'Unknown location %s' % location, line=self.primary().line())

          /# Write the native lines to the appropriate location.
          if target_class:
            lines = []
            if comment_attr or scope:
              lines.append('')
            baselang.simpleToBase(comment_attr, output=lines, comment=True)
            baselang.simpleToBase(scope_attr, output=lines)
            segment = BaseSegment(scope_attr, chunks=lines)
            extralines = target_class.extralines().setdefault(position, {}).setdefault(placement, [])
            extralines.append(segment)
    end method expandMeta;

    method translateMeta : vec<BaseFile> #:
      Verbatim dump.
    scope:
      parent_construct = self.parentConstruct()
      if parent_construct.kind() == 'class':
        metafile = self.metafile()
        baselang = self.baselang()
        streams = metafile.streams()
        scope = self.attr('scope:', default=None)
        if scope:
          precount = self.precount()
          /# We adjust metaline down by precound so that an error on line
          /# precount corresponds to scope.line() ... e.g. the blank lines
          /# inserted should not break line mapping.
          metaline = scope.line() - precount
          lines = []
          for i in range(0, precount):
            lines.append('')
          baselang.simpleToBase(scope, output=lines)
          segment = BaseSegment(scope, metaline=metaline, chunks=lines)
          streams.addSegment('defn', segment)

      return (None, None)
    end method translateMeta;

  end class NativeConstruct;

  class AssocConstruct < OoplConstruct #:
    Represents a 'assoc' construct.
  scope:

    method kind : str scope:
      return 'assoc'

  end class AssocConstruct;

  class TestxConstruct < OoplConstruct #:
    Represents a 'testx' construct.
  scope:

    method kind : str scope:
      return 'testx'
    test:
      cons = metax.c.TestxConstruct('testx', None, test.context())
      test.iseq('testx', cons.kind())
    end;

  end class TestxConstruct;

  class ResourceConstruct < OoplConstruct #:
    Represents a 'resource' construct.
  scope:

    method kind : str scope:
      return 'resource'

  end class ResourceConstruct;

  abstract
  class StatementConstruct < OoplConstruct #:
    Abstract construct above constructs that can
    appear within executable code.
  scope:
  end class StatementConstruct;

  class VarConstruct < StatementConstruct #:
    Represents a 'var' construct.
  scope:

    field implicitType : Type #:
      The implicit type of this var based on, for example, the type of the
      value specified in a default attribute.  May be (and usually is) null.

    method kind : str scope:
      return 'var'
    test:
      varcons = metax.c.VarConstruct('age', None, test.context())
      test.iseq('var', varcons.kind())
    end;

    method effectiveType : Type #:
      The type of this var.
    scope:
      result = self.attrval('type')
      if result.isAny():
        implicit = self.implicitType()
        if implicit:
          result = implicit
      return result
    end method effectiveType;

  end class VarConstruct;

  class LoopConstruct < StatementConstruct #:
    Represents a 'loop' construct.
  scope:
    method kind : str scope:
      return 'loop'
  end class LoopConstruct;

  behavior isNamespace : bool #:
    Test if a construct is a namespace
  scope:
    receiver Construct scope:
      return False
    receiver NamespaceConstruct scope:
      return True
  end behavior isNamespace;

  behavior isClass : bool #:
    Test if a construct is a class.
  scope:
    receiver Construct scope:
      return False
    receiver ClassConstruct scope:
      return True
  end behavior isClass;

  behavior isMethod : bool #:
    Test if a construct is a method
  scope:
    receiver Construct scope:
      return False
    receiver MethodConstruct scope:
      return True
  end behavior isMethod;

  class MetaFile #:
    A metafile (with functionality for parsing, as well as final state).
  assocs:
    std assoc math;
    usertest std assoc pprint;
    std assoc time;
  scope:

    meta lifecycle scope:
      /# AttrTypeMap maps conceptual attribute value type strings to
      /# three-tuples containing
      /#    <subclass, exception_class, function>
      /# The value establishes the subclass of Attribute to use for representing
      /# attribute values of the key type. If the value is a tuple, the second
      /# element is the exception raised if a particular value is invalid,
      /# and the third element is a function accepting an input value that
      /# returns a canonicalized value.
      cls.AttrTypeMap = {
        'feature': (FeatureAttribute, None, None),

        /# Word-based
        'id': (IdAttribute, None, None),
        'xid': (IdAttribute, None, None),
        'word': (WordAttribute, None, None),
        'num': (NumAttribute, ValueError, None),
        'enum': (EnumAttribute, TypeError, None),

        /# Specialty
        'str': (ExprAttribute, None, None),
        'expr': (ExprAttribute, None, None),
        'type': (TypeAttribute, InvalidType, None),

        /# Block-valued
        'simple': (SimpleBlock, None, None),
        'complex': (ComplexBlock, None, None),
        'simplex': (SimpleBlock, None, None),

        /# List-valued
        /#'word-list': (WordListAttribute, None, None),
        /#'id-list': (IdListAttribute, None, None),
      }

      /# Maps attrtype strings to functions accepting attribute key, type and
      /# value. Returns true if the value type checks relative to the type, and
      /# False if not.
      cls.AttrTypeCheck = {
        'id': lambda akey, atype, aval: ExprParser.ID_RE.match(aval),
        'xid': lambda akey, atype, aval: ExprParser.XID_RE.match(aval),
        'num': lambda akey, atype, aval: ExprParser.NUM_RE.match(aval),
        'enum': lambda akey, atype, aval: ExprParser.ENUM_RE.match(aval),
      }

      def Err():
        raise InvalidAttributeType(
          'No sensible default exists for this value type')

      cls.AttrValueEmpty = {
        /# should never see 'feature', since feature Attribute instances should
        /# never have default <empty>
        'feature': Err,

        'id': lambda: '',  # not legal, must disable typechecking in createNewAttribute
        'xid': lambda: '', # not legal, must disable typechecking in createNewAttribute
        'word': lambda: '',
        'num': lambda: 0,
        'enum': lambda: tuple(),

        'str': lambda: Expr('str', '""', '""'),
        'expr': Err,       # is there a meaningful empty expr?
        'type': Err,       # is there a meaningful empty type?

        'complex': lambda: tuple(),
        'simplex': lambda: tuple(),
        'simple': lambda: tuple(),

        'word-list': lambda: tuple(),
        'id-list': lambda: tuple(),
      }

      cls.TERM_RE = re.compile(
        r'((?P<end>end)(?:\s+(?P<kind>\S+)(?:\s+(?P<id>\S+))?)?)?;')
    end lifecycle;

    field path : str #:
      The path to the .meta file being parsed.

    field abbrev : str #:
      A temporary abbrev set by the Compiler to concisely but uniquely
      identify the metafile amongst all metafiles currently parsed in memory.

    field construct : FileConstruct #:
      The FileConstruct instance storing the parsed representation of the
      MetaFile.  Initialized by parseMeta()

    field compiler : Compiler #:
      The compiler instance specifying which metalang and baselang are active,
      as well as various other user-level config options.

    field debuglevel : int #:
      Controls how much debugging diagnostic output is produced.

    field debuglast : int #:
      The line number during the most recent call to self.debug()

    field lnum : int #:
      The current line within the file (0 is first line).

    field index : int #:
      The current position within self.text().

    field logmap : map #:
      Provides level-specific lists of logging lines.

    field text : str #:
      The contents of the .meta file being parsed, as a multi-line string
      ending with a newline.

    field lines : vec<Line> #:
      The .meta file as a collection of Line instances.

    field files : @set<str> #:
      The set of files written as part of compiling this metafile.
      TODO(wmh): Remove in favor of basefiles.

    field basefiles : @set<str> #:
      The set of BaseFile instances associated with compiling this metafile.
      TODO(wmh): This should be able to subsume files() above.

    field context : Context #:
      The context within which the current construct is being parsed.
      When parsing a construct, a next Context is created if a 'config'
      secondary block is encountered.

    field constructs : @map<str,set<Construct>> #:
      Every construct that is created during parsing is added to this
      dict.  Keys are construct kinds, values are lists of Construct.

    field streams : BaseStreams #:
      The collection of streams one can write to when compiling this metafile.

    field classdeps : set<str> #:
      The fully-qualified names of classes depended on within this metafile.
      Used to determine which .meta files need to be imported during importMeta.

    field stats : @map #:
      Maintains status on various things:
        parse: float
          seconds taken to parse
        expand: float
          seconds taken to expand
        translate: float
          seconds taken to translate
        compile: float
          seconds taken to compile

    field state : str #:
      Indicates the current state of the metafile. One of:
        parsing: currentingly being parsed
        parsed: finished parsing, have not yet expanded
        expanding: currently expanding
        expanded: finished expanding, have not yet translated
        translating: currently translating
        translated: finished translating, have not yet compiled
        compiling: currently compiling
        compiled: finished compiling
        complete: all actions have been accomplished.

    lifecycle params:
      var path -> path;
      var compiler -> compiler;
      var debuglevel -> debuglevel = 0;
      var text : str = null #:
        If present, path is not read (and thus does not need to exist).
        Instead, the contents of the metafile are assumed to be fully
        specified by this param.  Useful in unittests.
    scope:
      self.logmapIs({'order': []})
      if text is None:
        with open(path, 'r') as fp:
          text = fp.read()
      if not text or text[-1] != '\n':
        text += '\n'
      lines = Line.FromText(text)
      streams = BaseStreams()

      /# TODO(wmh): field files of type @set is not properly initializing a set.
      self.filesIs(set())
      self.basefilesIs(set())
      self.classdepsIs(set())

      self.linesIs(lines)
      self.textIs(text)
      self.streamsIs(streams)
    end lifecycle;

    method set #:
      Set current index and line.
    params:
      var index : int = -1 #:
        If negative, it is a request to compute the index based on line number.
      var lnum : int = -1 #:
        If negative, it is a request to compute line number based on index. This
        is expensive and should not be used in production paths.
      var adj : int = 0 #:
        An adjustment to add to the index. Useful when index is -1 and lnum is
        not (which sets index to first live char of the line, and adj allows
        one to advance within the line).
    scope:
      lines = self._lines
      if index < 0:
        if lnum < 0:
          raise Error('Must provide one of index or lnum')
        line = lines[lnum]
        index = line.start() + line.indent()
      elif lnum < 0:
        self.warning(
          'WARNING: MetaFile.set() is expensive when index given without lnum.\n'
          'Consider explicitly providing lnum')
        /# TODO(wmh): We could use binary search, but frankly we should never
        /# use this code ... we should always have the lnum available to pass
        /# in explicitly.
        lnum = 0
        try:
          while lines[lnum].end() < index:
            lnum += 1
        except IndexError:
          /# EOF.
          lnum = -1
      index += adj
      /#if index > lines[lnum].end():
      /#  raise Error('Cannot adj past end of line %d (%d)' % (lnum, adj))
      self.indexIs(index)
      self.lnumIs(lnum)
    test:
      mf = test.metafile
      test.iseq((0, 0, 0), (mf.index(), mf.lnum(), mf.column()))
      mf.set(index=5, lnum=0)
      test.iseq((5, 0, 5), (mf.index(), mf.lnum(), mf.column()))
      mf.set(index=30, lnum=1)
      test.iseq((30, 1, 4), (mf.index(), mf.lnum(), mf.column()))
    end method set;

    method current : tuple<str,int,int,Line> #:
      Obtain the text and current index, lineno, column and Line.
    scope:
      lnum = self._lnum
      line = self.line()
      index = self._index
      col = index - line.start()
      return (self._text, index, lnum, col, line)
    test:
      test.iseq(
        ('MetaLanguage Test config:\nend MetaLanguage Test;\n', 0, 0, 0, test.metafile.line()),
        test.metafile.current())
    end method current;

    method line : Line #:
      The specified Line.
    params:
      var lnum : int = -1 #:
        If negative, use self._lnum instead.
    scope:
      lines = self._lines
      if lnum < 0:
        lnum = self._lnum
      return lines[lnum] if lnum < len(lines) else None
    test:
      test.iseq('MetaLanguage Test config:', test.metafile.line().line())
    end method line;

    method column : int #:
      Obtain the current column
    params:
      var line : Line = null #:
        The current Line. Not necessary, as it can be obtained from
        self._lines[self._lnum], but provided as an optimization for
        situations where the caller has the line. It is important the
        correct Line is passed in, or the result will be incorrect.
    scope:
      try:
        if line is None:
          line = self._lines[self._lnum]
        result = self._index - line.start()
      except IndexError:
        /# EOF
        result = -1
      return result
    test:
      metafile, context = test.schemaParser(
        'MetaLanguage Test config:\nend MetaLanguage;\n')
      test.iseq(0, metafile.column())
      metafile.indexIs(7)
      test.iseq(7, metafile.column())
      metafile.set(30, 1)
      test.iseq(4, metafile.column())
    end method column;

    method log #:
      Log a message
    params:
      var message : str;
      var kind : str = 'I';
      var line : int = -1;
      var col : int = -1;
      var attr : Attribute = null;
    scope:
      if attr:
        line = attr.line()
        col = attr.col()
      elif line < 0:
        line = self._lnum
        col = self.column()
      elif col < 0:
        col = self.column()
      entry = {'message': message, 'line': line, 'col': col, 'kind': kind}
      /# TODO(wmh): We really don't need to store the entry in both a
      /# kind-specific list and in the 'order' list ... we could just
      /# increment a counter instead.
      kind_log = self._logmap.setdefault(kind, [])
      kind_log.append(entry)
      order = self._logmap['order']
      order.append(entry)
      return entry
    test:
      mf = test.metafile
      mf.log('Testing')
      test.iseq(
        {'I': [{'message': 'Testing', 'line': 0, 'kind': 'I', 'col': 0}],
         'order': [{'message': 'Testing', 'line': 0, 'kind': 'I', 'col': 0}]},
        mf._logmap)
      mf.log('An error', kind='E', line=30, col=16)
      test.iseq(
        {'I': [{'message': 'Testing', 'line': 0, 'kind': 'I', 'col': 0}],
         'E': [{'message': 'An error', 'line': 30, 'kind': 'E', 'col': 16}],
        'order': [
          {'message': 'Testing', 'line': 0, 'kind': 'I', 'col': 0},
          {'message': 'An error', 'line': 30, 'kind': 'E', 'col': 16}]
        },
        mf._logmap)
    end method log;

    method debug #:
      Write a debug message.
    params:
      var message : str;
      var line : int = -1;
      var col : int = -1;
      var width : int = 60;
    scope:
      if self._debuglevel:
        entry = self.log(message, kind='D', line=line, col=col)
        num = entry['line']
        lastnum = self._debuglast
        self._debuglast = num
        lines = self._lines
        if self._debuglevel > 1:
          lineobj = lines[num] if num <= len(lines) else None
          msg = message[:width-1] + '$' if len(message) > width else message
          linetext = (
            (lineobj.line() if lineobj else '<eof>') if num != lastnum
            else '        \"')
          sys.stdout.write('%4d:%3d: %s |%s\n' % (
            entry['line'] + 1, entry['col'], msg.ljust(width), linetext))
        else:
          sys.stdout.write('%4d: %s\n' % (
            entry['line'], message))
    test:
      mf = test.metafile
      test.iseq(0, mf._debuglevel)
      mf.debug('a problem', line=14, col=30, width=30)
      test.iseq({'order': []}, mf._logmap)

      test.captureStdout()

      mf._debuglevel = 1
      mf.debug('another problem', line=14, col=30, width=30)
      test.iseq(
        {'order': [
           {'message': 'another problem', 'line': 14, 'kind': 'D', 'col': 30}],
         'D': [{'message': 'another problem', 'line': 14, 'kind': 'D', 'col': 30}],
        },
        mf._logmap)

      mf._debuglevel = 2
      mf.debug('a third problem', line=50, col=2, width=30)
      test.iseq(
        {'order': [
          {'message': 'another problem', 'line': 14, 'kind': 'D', 'col': 30},
          {'message': 'a third problem', 'line': 50, 'kind': 'D', 'col': 2}],
         'D': [
           {'message': 'another problem', 'line': 14, 'kind': 'D', 'col': 30},
           {'message': 'a third problem', 'line': 50, 'kind': 'D', 'col': 2}],
        },
        mf._logmap)

      out = test.getStdout()
      test.iseqtext(
        '  14: another problem\n'
        '  51:  2: a third problem                |<eof>\n',
        out)
    end method debug;

    method info params:
      var message : str;
      var line : int = -1;
      var col : int = -1;
      var attr : Attribute = null;
    scope:
      return self.log(message, kind='I', line=line, col=col, attr=attr)
    test:
      mf = test.metafile
      mf.info('hello')
      mf.info('goodbye', line=15, col=30)
      construct = test.basics()
      attr = metax.c.FeatureAttribute(
        construct, 'kind', 'instance', line=50, col=10)
      mf.info('done', attr=attr)
      test.iseq(
        {'I': [
          {'message': 'hello', 'line': 0, 'kind': 'I', 'col': 0},
          {'message': 'goodbye', 'line': 15, 'kind': 'I', 'col': 30},
          {'message': 'done', 'line': 50, 'kind': 'I', 'col': 10}],
         'order': [
           {'message': 'hello', 'line': 0, 'kind': 'I', 'col': 0},
           {'message': 'goodbye', 'line': 15, 'kind': 'I', 'col': 30},
           {'message': 'done', 'line': 50, 'kind': 'I', 'col': 10}],
       },
       mf._logmap)
    end method;

    method warning params:
      var message : str;
      var line : int = -1;
      var col : int = -1;
      var attr : Attribute = null;
    scope:
      return self.log(message, kind='W', line=line, col=col, attr=attr)
    test:
      test.basics()
      mf = test.metafile
      mf.warning('hello')
      mf.warning('goodbye', line=15, col=30)
      attr = metax.c.FeatureAttribute(
        test.construct, 'kind', 'instance', line=50, col=10)
      mf.warning('done', attr=attr)
      test.iseq(
        {'W': [
          {'message': 'hello', 'line': 0, 'kind': 'W', 'col': 0},
          {'message': 'goodbye', 'line': 15, 'kind': 'W', 'col': 30},
          {'message': 'done', 'line': 50, 'kind': 'W', 'col': 10}],
         'order': [
           {'message': 'hello', 'line': 0, 'kind': 'W', 'col': 0},
           {'message': 'goodbye', 'line': 15, 'kind': 'W', 'col': 30},
           {'message': 'done', 'line': 50, 'kind': 'W', 'col': 10}],
       },
       mf._logmap)
    end method warning;

    method error params:
      var message : str;
      var line : int = -1;
      var col : int = -1;
      var attr : Attribute = null;
    scope:
      return self.log(message, kind='E', line=line, col=col, attr=attr)
    test:
      mf = test.metafile
      mf.error('hello')
      mf.error('goodbye', line=15, col=30)
      construct = test.basics()
      attr = metax.c.FeatureAttribute(
        construct, 'kind', 'instance', line=50, col=10)
      mf.error('done', attr=attr)
      test.iseq(
        {'E': [
          {'message': 'hello', 'line': 0, 'kind': 'E', 'col': 0},
          {'message': 'goodbye', 'line': 15, 'kind': 'E', 'col': 30},
          {'message': 'done', 'line': 50, 'kind': 'E', 'col': 10}],
         'order': [
           {'message': 'hello', 'line': 0, 'kind': 'E', 'col': 0},
           {'message': 'goodbye', 'line': 15, 'kind': 'E', 'col': 30},
           {'message': 'done', 'line': 50, 'kind': 'E', 'col': 10}],
       },
       mf._logmap)
    end method error;

    method fatal params:
      var message : str;
      var line : int = -1;
      var col : int = -1;
      var attr : Attribute = null;
    scope:
      self.log(message, kind='F', line=line, col=col)
      self.die(log=True)
    test:
      mf = test.metafile
      construct = test.basics()
      attr = metax.c.FeatureAttribute(
        construct, 'kind', 'instance', line=50, col=10)

      test.captureStdout()

      test.raises(metax.root.Error, mf.fatal, 'hello')
      test.iseq(
        {'order': [{'message': 'hello', 'line': 0, 'kind': 'F', 'col': 0}], 'F': [{'message': 'hello', 'line': 0, 'kind': 'F', 'col': 0}]},
        mf._logmap)

      test.raises(metax.root.Error, mf.fatal, 'goodbye', line=15, col=30)
      test.iseq(
        {'order': [{'message': 'hello', 'line': 0, 'kind': 'F', 'col': 0}, {'message': 'goodbye', 'line': 15, 'kind': 'F', 'col': 30}], 'F': [{'message': 'hello', 'line': 0, 'kind': 'F', 'col': 0}, {'message': 'goodbye', 'line': 15, 'kind': 'F', 'col': 30}]},
        mf._logmap)

      test.raises(metax.root.Error, mf.fatal, 'done', attr=attr)
      test.iseq(
        {'order': [{'message': 'hello', 'line': 0, 'kind': 'F', 'col': 0}, {'message': 'goodbye', 'line': 15, 'kind': 'F', 'col': 30}, {'message': 'done', 'line': 0, 'kind': 'F', 'col': 0}], 'F': [{'message': 'hello', 'line': 0, 'kind': 'F', 'col': 0}, {'message': 'goodbye', 'line': 15, 'kind': 'F', 'col': 30}, {'message': 'done', 'line': 0, 'kind': 'F', 'col': 0}]},
        mf._logmap)

      out = test.getStdout()
      test.iseqtext(
        '\n'
        'fauxpath:\n'
        'F1: hello\n'
        '\n'
        'fauxpath:\n'
        'F1: hello\n'
        'F16: goodbye\n'
        '\n'
        'fauxpath:\n'
        'F1: hello\n'
        'F16: goodbye\n'
        'F1: done\n',
        out)
    end method fatal;

    method die params:
      var log : bool = true;
    scope:
      if log:
        self.printLog()
      raise metax.root.Error('Dying')
    test:
      mf = test.metafile
      test.raises(metax.root.Error, mf.die, log=False)
    end method die;

    method warnings : vec<str> scope:
      return self._logmap.get('W', [])
    test:
      test.iseq([], test.metafile.warnings())
    end method warnings;

    method errors : vec<str> scope:
      return self._logmap.get('E', [])
    test:
      test.iseq([], test.metafile.errors())
    end method errors;

    method hasErrors : bool #:
      Determine if the parse has encountered errors.

      Returns:
        True if any errors exist, False if no errors exist.
    params:
      var show : bool = false #:
        If True (default), print out all log entries if errors exist.
      var category : str = 'E';
    scope:
      if self._logmap.get(category):
        result = True
        if show:
          self.printLog(exclude_kinds=['I'])
      else:
        result = False
      return result
    test:
      mf = test.metafile
      test.isfalse(mf.hasErrors())
      mf.error('testing')
      test.istrue(mf.hasErrors())

      test.captureStdout()
      mf.hasErrors(show=True)
      out = test.getStdout()
      test.iseqtext(
        '\n'
        'fauxpath:\n'
        'E1: testing\n',
        out)
    end method hasErrors;

    method numErrors : int scope:
      return len(self.errors())
    test:
      mf = test.metafile
      test.iseq(0, mf.numErrors())
      mf.error('testing')
      test.iseq(1, mf.numErrors())
    end method numErrors;

    method clearLog scope:
      self._logmap = {'order': []}
    test:
      test.metafile.clearLog()
    end method clearLog;

    method printLog params:
      var indent : str = '';
      var exclude_kinds : vec<str> = null #:
        If present, the kinds to exclude from printing.
    scope:
      fs = self.compiler().fs()
      basefile = fs.basename(self._path)
      numwidth = int(math.ceil(math.log(len(self._lines), 10)))
      print
      print '%s%s:' % (indent, self._path)
      for entry in self._logmap['order']:
        lnum = entry['line']
        kind = entry['kind']
        if exclude_kinds and kind in exclude_kinds: continue
        linestr = '' if lnum < 0 else str(lnum+1)
        print '%s%s%s: %s' % (
          indent, kind, linestr.rjust(numwidth), entry['message'])
    test:
      mf = test.metafile

      test.captureStdout()
      mf.printLog()
      out = test.getStdout()
      test.iseqtext('\nfauxpath:\n', out)

      mf.info('info')
      mf.warning('warning')
      mf.error('error')
      test.captureStdout()
      mf.printLog()
      out = test.getStdout()
      test.iseqtext(
        '\n'
        'fauxpath:\n'
        'I1: info\n'
        'W1: warning\n'
        'E1: error\n',
        out)
    end method printLog;

    method find : any #:
      Obtain a Construct or Attribute descendent node
    params:
      var spec : str #:
        Format is:
          <term> ::- <id> ['@' <attr> ]
          <spec> ::- <term> | <spec> '/' <term>
      var fp : ostream = null #:
        If non-null, where to write failure information.
    scope:
      if spec[0] == '/':
        spec = spec[1:]
      scope = self.construct().rawattr('scope:')
      result = scope.child(spec)
      return result
    test:
      cards1, scope, namespace, path = test.getMetaFile(
        'oopl', 'cards1', debuglevel=0)
      test.iseq('namespace demo.cards1', cards1.find('demo.cards1').kindid())
      test.iseq('class Card', cards1.find('demo.cards1/Card').kindid())
    end method find;

    method registerDependentClass #:
      Record the fact that this metafile depends on a given class.
    params:
      var fqcn : str #:
        The fully qualified name of the class depended upon.
    scope:
      self.classdeps().add(fqcn)
      /# print 'Now have %d deps in %s' % (len(self.classdeps()), id(self))
    test:
    end method registerDependentClass;

    method registerConstructInMetaFile #:
      Add this construct to a global list.

      Certain constructs need to be globally accessible, not just discoverable
      within a particular namespace:
       - we need to maintain a mapping from fully qualified class name to
         ClassConstruct instance, so that we can do type inference.
       - we need to maintain a mapping from namespace to Namespace to
         implement node traversal.
          - this is necessitated by the fact that ides of namespaces are xids
            (meaning they can have dots).  If they were only ids, and we
            created sub namespace instances for each part of 'nm.sp.sub',
            we could traverse the path hierarchy by splitting a fully
            qualified construct id on dots.
          - more concretely, suppose we have
              wmh.game.catan.Hex.edge
            to find this construct from a FileConstruct instance, we would
            like to split on dots and traverse the child hierarchy. But
            that currently won't work ... we need to know to split it into
              ['wmh.game.catan', 'Hex', 'edge']
          - By providing a mapping from namespace id to NamespaceConstruct,
            we can implement traversal below that level.
            TODO(wmh): Clean this all up!!!
    params:
      var construct : Construct;
    scope:
      /#if construct.kind() in ('namespace', 'class', 'method', 'field'):
      /#  print 'Registering %s in context %s path %s' % (
      /#    construct.path(), id(self.context()), self.filename())
      kind = construct.kind()
      conset = self.constructs().setdefault(kind, set())
      if construct in conset:
        if FLAGS.lintfull:
          print 'WARNING: Re-registering %s in MetaFile %s' % (
            construct.path(), self.filename())
      else:
        conset.add(construct)
    test:
    end method registerConstructInMetaFile;

    method unregisterConstructInMetaFile #:
      Remove a construct from a metafile.
    params:
      var construct : Construct;
    scope:
      conset = self.constructs().setdefault(construct.kind(), set())
      if construct not in conset:
        print 'WARNING: Request to unregister non-registered construct %s within %s' % (
          construct.path(), self.filename())
      else:
        conset.remove(construct)
    test:
    end method unregisterConstructInMetaFile;

    meta
    method CreateNewAttribute : Attribute #:
      Create an instance of some subclass of Attribute based on info.
    params:
      var parent : Construct #:
        The construct within which this attribute is being created.
        This is null if a primary attribute is being created, and non-null
        if a secondary attribute is being created.
      var consinfo : ConsInfo #:
        The construct info describing all attributes in a construct.
      var litkey : str #:
        The literal key appearing in the source.
      var key : str = null #:
        The canonical key. This is usually not needed, as it can be established
        from litkey. However, litkey is the empty string in situations where
        the attribute key is not explicitly specified.
      var value : any = null #:
        The value of the attribute. This is often null when initially
        creating Attribute instances.
      var line : int = -1 #:
        The line in which the attribute appears (indexed from 0).
      var col : int = -1 #:
        The column within the line at which the attribute starts (indexed from 0).
      var typecheck : bool = true #:
        Perform typechecking if true.
      var metafile : MetaFile = null #:
        Where to write errors.  If not provided, an Error is raised instead.
      var secondary : boolean = false #:
        Only relevant if parent is null ... if true, treat as secondary even
        when parent is null.
    scope:
      /# TODO(wmh): This check can be removed when the code has been updated to
      /# always having a parent.
      assert parent is None or isinstance(parent, Construct)

      result = None
      error = None
      thekey = key or litkey
      if thekey is None:
        raise Error('Must provide one of "litkey" or "key"')

      /# Establish the attribute info.
      if parent or secondary:
        /# Secondary attribute
        info = consinfo.secondaries().get(thekey, None)
      else:
        /# Primary attribute
        info = consinfo.primary().get(thekey, None)
      if not info:
        consinfo.show()
        print 'KEY: %s' % str(thekey)
        raise Error(
          'Invalid attribute key %s for construct %s' %
          (thekey, consinfo.name()))

      /# Establish canonical key and type
      if key is None:
        key = info['cankey']
      else:
        if key != info['cankey']:
          print '****** HERE with key=%s cankey=%s' % (key, info['cankey'])
        assert key == info['cankey']
      type = info['type']

      /# Perform type checking.
      if typecheck:
        type_checker = cls.AttrTypeCheck.get(type, None)
        if type_checker and value is not None:
          if not type_checker(key, type, value):
            err = (
              'The attribute key "%s" of type "%s" cannot have value "%s"' %
              (key, type, value))
            if metafile:
              metafile.error(err)
            else:
              raise Error(err)

      /# Create the Attribute
      typeinfo = cls.AttrTypeMap.get(type, None)
      if typeinfo:
        attr_class, exc_class, value_converter = typeinfo
        if exc_class is None: exc_class = UnusedException
        if value_converter and value is not None:
          value = value_converter(value)
        try:
          result = attr_class(
            parent, key, value, litkey=litkey, line=line, col=col)
        except exc_class as e:
          err = 'Invalid value "%s" for %s' % (value, key)
          if parent:
            err += ' in ' + parent.kindid()
          if metafile:
            metafile.error(err)
          else:
            raise Error(err)
          result = None
      else:
        error = (
          "Unknown attribute type '%s' for key '%s' of construct '%s'" %
          (type, key, consinfo.name()))
        /# TODO(wmh): Define a special Exception subclass that can contain as
        /# one of its fields any other exception, so that we can store the
        /# offending issue.
        raise Error(error)

      return result
    test:
      mf, context = test.schemaParser('\n')
      attr = metax.c.MetaFile.CreateNewAttribute(
        self.construct, context.consinfo('Attribute'), '=',
        value='blah', line=10, col=20, metafile=mf)
      test.iseq('= blah', attr.asStr())
    end method CreateNewAttribute;

    method show #:
      Print out the content of this metafile.
    params:
      var fp : ostream = out #:
        Where to write to.
    scope:
      sep = '#' * 80 + '\n'
      fp.write(sep)
      lines = self.lines()
      rawlines = self.text().rstrip().split('\n')
      assert len(lines) == len(rawlines), '%d lines vs %d rawlines' % (len(lines), len(rawlines))
      n = len(lines)
      rawstart = 0
      fp.write('lnum:index:in:line\n')
      for i in range(0, n):
        rawline = rawlines[i]
        rawlen = len(rawline) + 1
        line = lines[i]
        start = line.start()
        assert start == rawstart
        fp.write(
          '%4d:%5d:%2d:%s\n' % (i, line.start(), line.indent(), line.line()))
        rawstart += rawlen
      fp.write(sep)
    test:
      fp = test.newStr()
      test.metafile.show(fp=fp)
      test.iseqtext(
        '################################################################################\n'
        'lnum:index:in:line\n'
        '   0:    0: 0:MetaLanguage Test config:\n'
        '   1:   26: 0:end MetaLanguage Test;\n'
        '################################################################################\n',
        fp.getvalue())
    end method show;

    method parseSimpleBlock #:
      Given a parser at start-of-block, parse to end of block adding to self.
    params:
      var block : SimpleBlock #:
        The block to parse into.
      var indent : int #:
        The minimum indent of lines in the block.
    scope:
      context = self.context()
      value = block.value()

      /# Parse lines until we encounter one whose indent is less than indent.
      lines = self._lines
      lnum = self._lnum
      n = len(lines)
      line = lines[lnum]
      index = line.start()
      try:
        while line.empty() or line.indent() >= indent:
          /# We strip the indent off the line added to value, and do NOT add
          /# a newline at the end of the line added. If per-char parsing of
          /# these lines becomes necessary, it can be useful to add a newline
          /# so that we can check for newline instead of having to guard for
          /# end-of-line, in which case we will add a newline (which will
          /# necessitate a few changes in the code, in particular in
          /# SimpleBlock.writeValueLines()).
          value.append(line.line(index + indent))
          lnum += 1
          line = lines[lnum]
          index = line.start()
      except IndexError:
        /# We've encountered eof.
        pass

      /# Update line and index
      /#  - the line is one more than the last line in the simple block.
      /#  - the index is positioned at the first non-space character on the
      /#    new line.
      self.lnumIs(lnum)
      self.indexIs(line.start() + line.indent())
    test:
      text = (
        'MetaLanguage Test comment:\n'
        '  This is a test\n'
        '\n'
        '  to verify simple block parsing.\n'
        'end MetaLanguage;\n'
      )
      metafile, context = test.schemaParser(text)
      block = metax.c.SimpleBlock(self.construct, 'comment:', [], None)
      metafile.set(21, 1)
      metafile.parseSimpleBlock(block, 2)
      test.iseqvec(
        ['This is a test', '', 'to verify simple block parsing.'],
        block.value())
    end method parseSimpleBlock;

    method parseComplexBlock #:
      Given a parser at start-of-block, parse to end of block adding to self.
    params:
      var block : ComplexBlock #:
        The block to parse into.
      var indent : int #:
        The indentation at which the construct must occur.
      var legals : vec<str> = null #:
        The kinds of constructs that can legally appear in this block. If null,
        no constraints placed on constructs.
    scope:
      context = self.context()
      blockdent = context.token('blockdent')
      value = block.value()

      /# Establish the ConsGroup associated with the legal constructs that can
      /# appear within this block.
      consgroup = context.legalInfo(legals)

      /# Parse constructs until we reach the end of the block.
      while True:
        construct = self.parseConstruct(block, indent, consgroup)
        if not construct:
          /# No more constructs in this block.
          break
        
        termcode = construct.termcode()
        if termcode == TERM_UNINIT:
          /# We have encountered an error during parsing.
          /#  - skip forward to end of current block.
          self.skipToIndent(indent - blockdent)
          break

        block.registerConstruct(construct)
    test:
      text = (
        'MetaLanguage Test config:\n'
        '  Construct A;\n'
        '  Construct B;\n'
        '  Construct C;\n'
        'end MetaLanguage;\n'
      )
      schema, context, metafile = test.newTestSchema(text)
      block = metax.c.ComplexBlock(schema, 'config:', [], schema)
      metafile.set(22, 1)
      metafile.parseComplexBlock(block, 2)
      fp = test.newStr()
      block.writeValueLines(fp=fp)
      test.iseqtext(
        '\n'
        '  Construct A;\n'
        '  Construct B;\n'
        '  Construct C;\n',
        fp.getvalue())
    end method parseComplexBlock;

    method parseConstruct : Construct #:
      Parse a Construct at the current parser position.

      SideEffects:
       - advances the parser position to the line that terminates the parsed
         construct (this is either a line containing an explicit construct
         terminator, or a line
         parsed construct, at the first non-space character.

      Returns:
        The parsed construct, or null if EOF has been reached or an
        error occurred during parsing.
    params:
      var parent : ComplexBlock #:
        The parent of the to-be-parsed construct.
      var indent : int #:
        The indentation at which the construct must occur.
      var consgroup : ConsGroup #:
        The list of legal construct kinds in the current block.
    scope:
      result = None
      context = self.context()
      /#consgroup = context.legalInfo(legals)
      primaries = consgroup.primaries()

      /# Skip past empty lines
      line, index, matches, precount = self.skipEmptyLines(indent=indent)
      if not matches:
        /# The first token is NOT found at column 'indent', which means either
        /# we've encountered an implicit construct termination or an error.
        if line.indent() < indent:
          /# Implicit termination.
          parent.postcountIs(precount)
        else:
          /# Probably an error. We advance past all lines at indent 'indent'
          self.skipToIndent(indent-1)

        return None

      /# Check for eof
      if not line: return None

      /# If we are at the end of the complex block, then precount refers to
      /# the number of lines after the last construct.  We update the parent
      /# postcount each time this method is invoked.
      parent.postcountIs(precount)

      /# Consume feature attribute keys and values until we reach a token
      /# that is in 'consgroup' (a token identifying a construct kind that is
      /# legal in this context).
      text = self.text()
      feature_tuples = []
      consinfo = None
      /# the position within text of the start of the primary key
      lnum = self.lnum()
      start = index
      while True:
        atuple = self.peekFeatureOrPrimaryToken(start, consgroup)
        token_data = atuple[3]
        if token_data == 'primary_key':
          break
        elif token_data == 'error':
          /# We have encountered an error ... we were unable to find
          /# a feature value or primary token.  For now, we skip forward
          /# to the end of the block containing the construct being parsed.
          self.error('Unrecognized feature/primary token', line=line.num()-1)
          self.skipToIndent(indent-1)
          return None
        else:
          word, attrkey, attrsel, form, index, _, fnum, fcol = atuple
          self.debug('%s "%s"' % (form, word), line=fnum, col=fcol)
          feature_tuples.append(atuple)
          index = atuple[4]
          if text[index] == '\n':
            line, index, matches = self.nextLine(indent=indent)
            if not matches:
              self.skipToIndent(indent-1)
              return None
          start = index

      /# The only way we reach this point is by finding a construct primary
      /# key.
      word, pkey, psel, _, index, consinfo, primary_lnum, primary_col = atuple
      self.debug(
        'kind "%s"' % consinfo.name(),
        line=primary_lnum, col=primary_col)

      /# We have identified a primary.
      /#  - It is useful to have the construct registered in the parent as
      /#    soon as possible (e.g. not waiting until all attributes have
      /#    been parsed).
      /#  - Since a construct is registered with its parent block by id
      /#    (aka primary attribute value), it is important that we obtain the
      /#    id before creating the construct.
      /#  - Note that some primary attributes have optional (auto-assigned)
      /#    values, and in some situations it can appear that a primary
      /#    has an explicit value when in fact that value should be given
      /#    to a replacer attribute).
      primary_litkey = word
      /# Data about the primary key.
      primary_data = consinfo.primary()[primary_litkey]
      valopt = primary_data['valopt']
      replacer = primary_data.get('replacer', None)
      /# Keys represent all legal secondary key tokens
      secondaries = consinfo.secondaries()
      /# The value of an implicit-key secondary
      replacer_value = None

      /#print 'HERE with litkey %s valopt %s' % (primary_litkey, valopt)

      /# When this block is finished, we will have:
      /#  - identified the primary_value
      /#  - identified the index within text of one char past the end of the
      /#    primary value.
      /#  - detected need for autoassigned id.
      /#  - handled replacer semantics
      /#  - returned from method on error
      primary_value_start = index
      if text[index] == '\n':
        /# We have a situation where the value associated with the primary
        /# key is not on the same line as the key. For now at least, we
        /# require values to start on same line as key, so either this value
        /# is optional or we have an error.
        if valopt:
          primary_value = context.autoId()
        else:
          col = index - line.start()
          self.error('Missing primary id', line=self.lnum(), col=col)
          /# TODO(wmh): We are skipping the entire collection of lines with
          /# indent >= indent, which is maybe more aggresive than we need.
          self.skipToIndent(indent-1)
          return None
      else:
        word, _, next_index = self.peekWord(index)
        if valopt:
          if replacer:
            /# word is probably the value of the secondary attribute 'replacer'.
            /#  - TODO(wmh): we need to create the replacer Attribute!
            primary_value = context.autoId()
            replacer_value = word
            raise Error('Not yet implementing replacers')
          elif word in secondaries:
            /# word is a secondary key, so we autoassign a primary value
            /#  - we avoid updating index, so that the secondary attribute
            /#    code below will properly handle the secondary key we've
            /#    found.  We could do a bit of optimization on this...
            primary_value = context.autoId()
          else:
            /# word is the primary_value
            primary_value = word
            index = next_index
        else:
          /# word must be the primary value.
          primary_value = word
          index = next_index

      self.debug(
        '  id "%s"' % primary_value,
        line=self.lnum(), col=primary_value_start - line.start())

      /# Update position ... past primary value and whitespace, all on same line
      /# as started this method (so we don't need to update the line).
      self.indexIs(index)

      /# Create the primary construct
      primary = self.__class__.CreateNewAttribute(
        None, consinfo, primary_litkey,
        value=primary_value, line=primary_lnum, col=primary_col, metafile=self)

      /# Establish the class to use to implement this construct instance.
      /#  - The ConsInfo instances properly identify the class of all
      /#    constructs except BaseLanguage, which are treated specially
      /#    (for metalang <X> and baselang <Y>, the class is <X><Y>).
      /#  - TODO(wmh): It is unfortunate that we need to test if the current
      /#    construct is BaseLanguage in this (very frequently invoked) method.
      /#    Can we find a way to avoid having ot make that check?  Maybe we
      /#    parse all of them into BaseLanguageConstruct instances initially,
      /#    and then patch up with downcasts later?
      /#  - TODO(wmh): Merge BaseLanguageConstruct and BaseLanguage into
      /#    a single class.
      construct_class = consinfo._construct_class
      if consinfo.name() == 'BaseLanguage':
        /# Each BaseLanguage construct is implemented by its own class.
        /# For metalang <X> and baselang <Y>, the class is <X><Y>.
        parent_construct = parent.parent()
        metal = parent_construct.id().capitalize()
        basel = primary.value().capitalize()
        class_name = metal + basel
        metax_module = sys.modules['metax']
        metax_c_module = metax_module.c
        construct_class = getattr(metax_c_module, class_name, None)
        /# print 'MetaFile.parseSecondaryAttribute: metalang %s baselang %s = %s [%s]' % (
        /#   metal, basel, class_name, construct_class)

      /# Create the construct
      if construct_class:
        /# All kind-specific construct_classes use the same signature as
        /# Construct.
        construct = construct_class(primary.value(), parent, context)
      else:
        /# There is no kind-specific construct class registered for this
        /# construct, so we use a GenericConstruct, which passes in the
        /# kind explicitly.
        construct = GenericConstruct(
          primary.value(), parent, context, primary.key())

      /# We update the construct
      construct.precountIs(precount)
      primary.parentIs(construct)

      /# Parse all of the feature keys/values into FeatureAttributes.
      /#  - the list of feature keys and feature values in feature_tuples are
      /#    valid for *some* construct in the meta language, but it is
      /#    entirely possible they will not be valid for the construct that
      /#    has been identified ... any unrecognized keys/values are reported
      /#    as errors.
      featvals = consinfo.featvals()
      featkeys = consinfo.features()
      i = 0
      n = len(feature_tuples)
      while i < n:
        token, featkv, fsel, form, index, data, feat_lnum, feat_col = feature_tuples[i]
        featinfo = {
          'parent': construct, 'value': None,
          'line': feat_lnum, 'col': feat_col
        }
        if form == 'feature_key':
          /# We have an explicit feature key ... next index must be a value
          /# for this feature key.
          featkey = featkv
          finfo = featkeys[featkey]
          featinfo['litkey'] = featkey
          featinfo['key'] = finfo['cankey']
          i += 1
          if i < n:
            _, featval, featsel, form, index, data, _, _ = feature_tuples[i]
            if form != 'feature_value':
              self.error(
                'Expecting feature value for feature key %s but found unknown %s' %
                (featkey, featval), line=self.lnum())
            else:
              /# We know featval is a legal feature value (or we wouldn't have
              /# gotten here ... right?), but we don't know for sure that it
              /# is a feature value for featkey
              valkey = featvals[featval]
              assert valkey is not None
              if valkey != featkey:
                self.error(
                  'Expecting feature value for feature key %s but found value %s for key %s' %
                  (featkey, featval, valkey))
              else:
                featinfo['value'] = featval

              /# If there was a selector specified on the feature key, we verify
              /# that the selector matches current baselang. If not, we ignore
              /# the feature attribute/key pair entirely.
              if fsel:
                baselang = construct.baselang()
                suffix = baselang.suffix()
                if '.' + fsel != suffix:
                  print '***** IGNORING %s = %s for %s (specific to %s)' % (
                    featkey, featval, suffix, fsel)
                  featinfo = None

          else:
            self.error(
              'Missing feature value for feature key %s' % featkey,
              line=self.lnum())
        elif form == 'feature_value':
          /# We have an implicit feature key dicated by featval
          featval = featkv
          if featval not in featvals:
            self.error(
              "Invalid feature value '%s' for %s" % (featval, construct.kind()))
            featinfo = None
          else:
            featkey = featvals[featval]
            featinfo['litkey'] = ''
            featinfo['key'] = featkey
            featinfo['value'] = featval
        elif form == 'error':
          self.debug('Fix me!')
          self.error('Invalid token "%s"' % token)
          featinfo = None
        else:
          raise Error('Here with form %s' % form)

        /# Create the FeatureAttribute
        if featinfo:
          feature = FeatureAttribute(**featinfo)
          construct.registerAttribute(feature)

        /# Advance to next feature key/value.
        i += 1

      /# Register the primary with the construct
      construct.registerAttribute(primary)
      construct.termcodeIs(TERM_UNINIT)

      /# Now parse secondary attributes.
      while True:
        line = self.line()
        if line is None or line.indent() < indent:
          /# Implicit termination
          construct.termcodeIs(0)
          break

        /# Check if we are currently at end-of-line, and advance if so.
        index = self.index()
        if text[index] == '\n':
          line, index, matches = self.nextLine(indent=indent)
          if not matches:
            /# The new line has a different indent than needed in order for
            /# it to be another attribute, so we must have an implicit
            /# construct termination.
            construct.termcodeIs(0)
            break

        attribute, errtok = self.parseSecondaryAttribute(
          construct, consinfo, indent)
        if not attribute:
          /# There are two possible reasons for attribute to be null:
          /#  1. end-of-construct (explicit or implicit)
          /#  2. syntax error
          /# These are handled below.
          break

      /# Handle termination issues
      termcode = construct.termcode()
      index = self.index()
      if termcode != TERM_UNINIT:
        /# The construct has been successfully parsed.
        self.debug('  termcode %d' % termcode)
        /# We expect the construct to be at end-of-line, except when an
        /# implicit termination was identified.
        if termcode == 0:
          /# An implicit termination was identified, and the current index
          /# is where we are to start parsing the next entity.
          pass
        else:
          if text[index] == '\n':
            /# This is what we normally expect at end of construct.
            self.nextLine()
          else:
            /# When does this happen?
            print text[index:index+30]
            raise Error('How to handle this?')
      else:
        /# We have an error, and no recovery has yet been performed.
        self.debug(
          '  parse error on %s' % errtok,
          line=self.lnum(), col=index - line.start())
        construct = None

      /# Return the construct
      return construct
    tests:
      testx basics scope:
        text = (
          'MetaLanguage Test config:\n'
          '  Construct A config:\n'
          '    Attribute default : word = <empty> aliases <=>;\n'
          '    kind primary noval Attribute Attribute : id = <required>;\n'
          '\n'
          '    kind secondary showkey\n'
          '    Attribute type : word = <empty> aliases <:> #:\n'
          '      A comment\n'
          '    config:\n'
          '      FeatureValue f;\n'
          '      FeatureValue g #:\n'
          '        some comment\n'
          '      FeatureValue h;\n'
          '    end Attribute type;\n'
          '  end Construct;\n'
          'end;\n'
        )
        metafile, context = test.schemaParser(text)
        scope = metax.c.ComplexBlock(
          self.construct, 'scope:', [], None, line=0, col=0)

        /# Parse the simplest construct possible ('FeatureValue f;')
        metafile.set(lnum=9)
        featval = metafile.parseConstruct(
          scope, 6, context.legalInfo(['FeatureValue']))
        test.iseq('FeatureValueConstruct', featval.__class__.__name__)
        test.iseq('FeatureValue', featval.kind())
        test.iseq('f', featval.id())
        test.iseq(1, featval.termcode())
        test.iseqvec(['FeatureValue f'], [a.asStr() for a in featval.order()])

        /# Now a more complex construct with simple secondary keys.
        metafile.set(lnum=2)
        attrdef = metafile.parseConstruct(
          scope, 4, context.legalInfo(['Attribute']))
        test.iseq('AttributeConstruct', attrdef.__class__.__name__)
        test.iseq('Attribute', attrdef.kind())
        test.iseq('default', attrdef.id())
        test.iseq(1, attrdef.termcode())
        test.iseqvec(
          ['Attribute default', ': word', '= <empty>', "aliases <=>"],
          [a.asStr() for a in attrdef.order()])

        /# Now a construct with some feature attributes.
        metafile.set(lnum=3)
        attrprim = metafile.parseConstruct(
          scope, 4, context.legalInfo(['Attribute']))
        test.iseq('AttributeConstruct', attrprim.__class__.__name__)
        test.iseq('Attribute', attrprim.kind())
        test.iseq('Attribute', attrprim.id())
        test.iseqvec(
          ['kind primary', 'noval', 'Attribute Attribute', ': id', '= <required>'],
          [a.asStr() for a in attrprim.order()])

        /# Verify that an attempt to parse a construct at a given indent
        /# when on a line at a different indent yields null.
        metafile.set(lnum=13)
        test.isnull(
          metafile.parseConstruct(
            scope, 6, context.legalInfo(['FeatureValue'])))
        test.isnull(
          metafile.parseConstruct(scope, 2, context.legalInfo(['Construct'])))

        /# Now a construct with feature attributes and block-valued secondaries
        /# (both simple and complex).
        metafile.set(lnum=5)
        /#metafile.debuglevelIs(4)
        /#metafile.show()
        attrtype = metafile.parseConstruct(
          scope, 4, context.legalInfo(['Attribute']))
        /#metafile.printLog()
        fp = test.newStr()
        attrtype.write(fp=fp)
        out = fp.getvalue()
        test.iseqtext(
          'kind secondary showkey\n'
          'Attribute type : word = <empty> aliases <:> #:\n'
          '  A comment\n'
          'config:\n'
          '  FeatureValue f;\n'
          '  FeatureValue g #:\n'
          '    some comment\n'
          '  FeatureValue h;\n'
          'end Attribute type;\n',
          out)

        /# Now an edge-case that was at one point causing an infiite loop
        text = (
          'MetaLanguage Meta\n'
          'comment:\n'
          '  Here with notes\n'
          'config:\n'
          'end MetaLanguage;\n'
        )
        metafile, context = test.schemaParser(text)
        scope = metax.c.ComplexBlock(
          test.construct, 'scope:', [], None, line=0, col=0)
        schema = metafile.parseConstruct(
          scope, 0, context.legalInfo(['MetaLanguage']))
        fp = test.newStr()
        schema.write(fp=fp)
        test.iseqtext(
          'MetaLanguage Meta\n'
          'comment:\n'
          '  Here with notes\n'
          'config:\n'
          'end MetaLanguage;\n',
          fp.getvalue())

      testx optionals scope:
        /# Verify that optional primary values work.
        text = (
          'lifecycle params:\n'
          '  var a : int;\n'
          'scope:\n'
          'end;\n')

        _, schema, context, compiler = test.cachedInfo()
        metafile = metax.c.MetaFile('fauxpath', compiler, text=text)
        metafile.contextIs(context)
        scope = metax.c.ComplexBlock(None, 'scope:', [], line=0, col=0)

        lifecycle = metafile.parseConstruct(
          scope, 0, context.legalInfo(['lifecycle']))
        test.isfalse(metafile.hasErrors(show=True))
        fp = test.newStr()
        lifecycle.write(fp=fp)
        test.iseqtext(
          'lifecycle Meta__1__ params:\n'
          '  var a : int;\n'
          'scope:\n'
          'end;\n',
          fp.getvalue())
    end method parseConstruct;

    method parseSecondaryAttribute : tuple<Attribute,str> #:
      Parse a secondary attribute, supporting optional keys and values.

      The caller is responsible for ensuring this method is only invoked in
      situations where a secondary attribute or explicit/implicit
      end-of-construct is expected.  This method should not be invoked with
      the current position on whitespace (caller responsibility to advance
      past newlines, etc.)

      SideEffects:
       - self.index() is set to the position after the value (after skipping
         spaces but not newlines, except for block-values, which consume
         newlines up to a line with less indent than needed for the block
         value).
       - construct.termcode() must be TERM_UNINIT when this method is invoked,
         and is changed to 0 or greater if a terminator is found (in which
         case null is returned)

      Returns:
       0) attribute : The parsed attribute or null if:
           - an implicit or explicit end-of-construct is seen
           - if an error is encountered
       1) error_token : str or null
           - null if attribute found, the token at current index if error.
    params:
      var construct : Construct #:
        The construct for which an attribute is being parsed.
      var consinfo : ConsInfo #:
        The construct info needed to parse secondary attributes.
      var indent : int #:
        The indent at which secondary attributes that start a new line are
        required to be indented at.
    scope:
      debug = False
      assert construct.termcode() == TERM_UNINIT
      index = self.index()
      lnum = self.lnum()
      line = self.line()
      key_col = index - line.start()
      text = self.text()
      context = construct.context()

      /# Obtain the secondary key (or terminator)
      litkey, key, basel, secondary, value_start, termcode = self.peekSecondaryToken(
        construct, index, context, consinfo)

      /# Check for special-case end-of-parsing
      if line.indent() != indent:
        /# TODO(wmh): Suppose line.indent() is 5. This is currently printing
        /#   E18: Expecting indent 4 not 5.
        /#   E18: Expecting indent 2 not 5.
        /#   E18: Expecting indent 0 not 5.
        /# when it should only print
        /#   E18: Expecting indent 4 not 5.
        self.error('Expecting indent %d not %d' % (indent, line.indent()))
        return (None, litkey)

      elif termcode != TERM_UNINIT:
        /# If we've found an end-of-construct, set it and return.
        construct.termcodeIs(termcode)
        self.indexIs(value_start)
        return (None, litkey)

      elif secondary is None:
        /# The current token does not match a secondary attribute of
        /# 'construct' and is either an implicit termination or a syntax
        /# error. We heuristically determine which by the following logic:
        /#  - if the parsed token is NOT the first one on the current line,
        /#    this cannot be an implicit termination and is an error.
        /#  - if the parsed token is the first on the current line
        /#     - if it is indented less than 'indent', it is definitely
        /#       an implicit end-of-construct indicator
        /#     - if it is indented equal to 'indent', it may be an implicit
        /#       termination or a syntax error:
        /#         - if the token ends in ':', it cannot represent the
        /#           start of a new construct (cannot be a feature key,
        /#           feature value or primary key) and cannot be a terminator,
        /#           so it must be an incorrectly specified secondary token.
        /#         - otherwise we assume it is an implicit termination and
        /#           detect the syntax error in parseConstruct.
        ldent = line.indent()
        if index == line.start() + ldent:
          if ldent < indent:
            /# Definite implicit construct termination
            construct.termcodeIs(0)
          elif ldent == indent:
            if litkey[-1] == ':':
              /# This cannot possibly be a feature key, feature value or
              /# primary key, so it isn't the start of a new construct. Must
              /# be an typoed secondary key.
              self.error(
                'Unknown secondary token "%s"' % litkey, line=lnum, col=key_col)
              /# The most likely situation is that an attribute key has been
              /# mistyped.
              /#  - TODO(wmh): A common instance of this error is when a user
              /#    specifies a superclass of a class using ':' instead of '<'.
              /#    By skipping to indent-1, we consume the entire namespace,
              /#    and thus only print one error when many classes could be
              /#    having the same problem.
              /#  - Can we find a way of skipping to next construct instead of
              /#    all the way to end of scope?
              self.skipToIndent(indent-1)
              construct.termcodeIs(TERM_UNINIT)
            else:
              /# May or may not be implicit construct termination but we assume
              /# it is an implicit termination and detect errors later.
              construct.termcodeIs(0)
          else:
            /# We have a first-token indented more than indent, which should not
            /# be possibly if our logic is correct.
            raise InternalError('Indent %d > %d' % (ldent, indent))
        else:
          /# Definitely an error.
          self.error(
            'Unknown secondary token "%s"' % litkey, line=lnum, col=key_col)
          /# The most likely situation is that an attribute key has been
          /# mistyped.
          self.skipToIndent(indent-1)
          construct.termcodeIs(TERM_UNINIT)
        return (None, litkey)

      /# Some important values
      type = secondary['type']
      if type == 'simplex':
        /# A block marked as simplex is complex if the attribute selector is
        /# '*', and simple otherwise.
        type = 'complex' if basel == '*' else 'simple'
        /# print 'SET type simplex to %s for %s %s' % (type, construct.kindfqn(), basel)

      self.debug('  akey "%s" (%s : %s) [%s] %d' % (litkey, key, type, basel, value_start))

      /# Create the attribute
      /#  - we do this before we parse the value, so that we can register
      /#    the attribute with its construct before the value gets parsed
      /#    (the value can represent almost the entire file, and it is
      /#    useful to have a lexical chain established during parsing for
      /#    debugging purposes).
      attribute = MetaFile.CreateNewAttribute(
        construct, consinfo, litkey, key=key, value=None,
        line=lnum, col=key_col, metafile=self)
      if basel is not None:
        attribute.baselIs(basel)

      /# Register the attribute with the construct
      /#  - we do not need the value to properly register anything other
      /#    than the primary attribute.
      construct.registerAttribute(attribute)

      /# Parse the value based on the attribute value type and current char.
      /#  - the type will never be 'feature' here.
      /#  - MUST initialize next_index to be the index one past the end of
      /#    the parsed value.
      valdone = False
      val_col = value_start - line.start()
      c = text[value_start]
      if type in ('id', 'xid', 'word', 'num', 'enum'):
        /# Parse a word and validate against type.
        value, adj, next_index = self.peekWord(value_start)
        type_checker = MetaFile.AttrTypeCheck.get(type, None)
        if type_checker and not type_checker(key, type, value):
          /# We expected a value of type 'type' but 'value' does not match.
          self.error(
            'Expecting %s value of type %s not %s' %
            (key, type, value), line=lnum, col=val_col)
          /# TODO(wmh): Do we do anything to recover?
          value = None

      elif type == 'str':
        eprs = ExprParser(self, row=self.lnum(), col=val_col)
        value = eprs.parse()
        if value:
          next_index = line.start() + eprs.col()
        else:
          /# TODO(wmh): What is the proper thing to do when we are expecting
          /# a literal string and don't find one?  For now, consume a single
          /# word (throwing it away) so that the parser can make progress.
          token, _, next_index = self.peekWord(value_start)
          self.error(
            'Expecting %s value to be a literal string, not %s' %
            (key, token))

      elif type == 'expr':
        /# Obtain an Expr instance.
        eprs = ExprParser(self, row=self.lnum(), col=val_col)
        value = eprs.parse()
        if value:
          self.lnumIs(eprs.row())
          line = self.line()
          next_index = line.start() + eprs.col()
        else:
          /# TODO(wmh): What is the proper way to recover from an error in which
          /# we expect an expression and don't find one? For now, we skip
          /# whatever the expression managed to parse (if nothing, we skip one
          /# word).
          if eprs.row() == self.lnum() and eprs.col() == self.column():
            /# No progress was made, so we skip a word
            value, _, next_index = self.peekWord(value_start)
            self.error(
              'Expecting %s value to be an expression, not %s' %
              (key, value))
          else:
            /# We managed to parse something before encountering an error.
            line = self.line(lnum=eprs.row())
            index = line.start() + eprs.col()
            fragment = line.line(start=index)
            self.error(
              'Expecting %s value to be an expression, but failed in "%s"' %
              (key, fragment))
            /# Skipping the next word or skipping to the next line may introduce
            /# more errors (especially if we end up skipping a block-valued
            /# attribute key). So we ...
            value, _, next_index = self.peekWord(value_start)
            /#raise Error('Fix Me!')

      elif type == 'type':
        /# Obtain an Type instance
        /# TODO(wmh): For now, we are requiring types to be encoded in a single
        /# word, but we need to generalize this to allow whitespace in
        /# the template portion of the type.
        word, adj, next_index = self.peekWord(value_start)
        namespace_function = lambda: construct.ancestor('namespace')

        if False:
          nmsp = namespace_function()
          assert isinstance(nmsp, NamespaceConstruct), (
            'For type "%s" at %d:%d of %s, namespace_function yields %s = %s' %
            (word, self.lnum(), self.column(), self.path(), nmsp, nmsp.kindid()))
        /# if namespace_function() is None: raise Error('Failed to resolve namespace in %s' % construct.fqn())

        value = Type.Instance(
          word, allow_invalid=True, cons=construct.kind(),
          namespace_function=namespace_function)

      elif type == 'simple' or type == 'simplex':
        /# Parse an indented list of strings
        context = construct.context()
        blockdent = context.token('blockdent')
        /# Initialize the attribute value, which was set to null during creation.
        attribute.valueIs([])
        /# We verify there is no extra text after the scope indicator.
        /#  - TODO(wmh): In the future, we may want to consider allowing such
        /#    extra text to support one-line blocks ala Python.
        /#  - this does not HAVE to be an error (could be a warning), since
        /#    it doesn't affect the correctness of parsing subsequent
        /#    lines
        /#  - a block can be empty.
        /#  - we may want to deal with empty lines at the end of a simple
        /#    block, especially if the block ends due to encountering a
        /#    line indented less than indent (which indicates an implicit
        /#    construct termination).
        fragment = line.line(start=value_start)
        if fragment:
          self.error(
            'Found spurious text after scope indicator: "%s"' % fragment,
            line=self.lnum(), col=value_start)

        /# Advance to next line and start parsing.
        self.nextLine()
        self.parseSimpleBlock(attribute, indent + blockdent)
        value = attribute.value()
        /# The value of attribute and self.index() have already been properly
        /# set. We indicate this with valdone
        valdone = True

      elif type == 'complex':
        /# Parse an indented list of constructs
        /#  - the 'secondaries' dict contains 'children', which is the list
        /#    of legal construct ids within the complex block.
        context = construct.context()
        blockdent = context.token('blockdent')
        line, index, _ = self.nextLine()
        attribute.valueIs([])
        legals = secondary.get('children', None)
        self.parseComplexBlock(attribute, indent + blockdent, legals=legals)
        value = attribute.value()
        /# The value of attribute and self.index() have already been properly
        /# set. We indicate this with valdone
        valdone = True

      else:
        raise InternalError(
          'Unknown type "%s" in MetaFile.parseSecondaryAttribute' %
          type)

      /# Print out the attr value if debugging.
      vcol = value_start - line.start()
      if attribute.isSimpleBlock():
        self.debug('   val [%d elements]' % len(value), line=lnum, col=vcol)
      elif attribute.isComplexBlock():
        /# Since there will be a whole bunch of sub-constructs parsed
        /# between the debug entry for the attribute key and the attribute
        /# value, it is more confusing than not to print anything here.
        pass
      else:
        self.debug('   val "%s"' % value, line=lnum, col=vcol)

      /# Assign the attribute value.
      if not valdone:
        /# Skip past spaces.
        while text[next_index] == ' ': next_index += 1
        self.indexIs(next_index)
        attribute.valueIs(value)

      /# It is important that we properly set stoken() if attribute is None
      assert attribute is not None
      return (attribute, None)
    tests:
      testx t1 scope:
        text = (
          'MetaLanguage Test config:\n'
          '  Construct A config:\n'
          '    Attribute type : word = <empty> aliases <:> #:\n'
          '      A comment\n'
          '    config:\n'
          '      FeatureValue f;\n'
          '      FeatureValue g #:\n'
          '        some comment\n'
          '      FeatureValue h;\n'
          '    end Attribute type;\n'
          'File f path "/this/is/a/test space.txt";\n'
        )
        badtext = (
          'MetaLanguage Test config:\n'
          '  Construct A config:\n'
          '    Attribute type : word = <empty> aliases >:< #: extra text\n'
          '      A comment\n'
          '    config:\n'
          '      FeatureValue f;\n'
          '      FeatureValue g #:\n'
          '        some comment\n'
          '      FeatureValue h;\n'
          '    end Attribute type;\n'
          'File f path "/this/is/a/test space.txt";\n'
        )
        schema, context, metafile = test.newTestSchema(text)
        badfile, badctx = test.schemaParser(badtext)
        scope = metax.c.ComplexBlock(
          self.construct, 'scope:', [], None, line=0, col=0)
        file = metax.c.FileConstruct('f', None, context)
        attr = metax.c.AttributeConstruct('type', None, context)
        badattr = metax.c.AttributeConstruct('type', None, context)

        /# Test parsing a secondary attribute of type 'word'
        metafile.set(lnum=2, adj=15)
        test.iseq(':', metafile.line().line(start=metafile.index())[0])
        attrinfo = context.consmap()['Attribute']
        test.iseq('word', attrinfo.secondaries()[':']['type'])
        type, _ = metafile.parseSecondaryAttribute(attr, attrinfo, 4)
        test.iseq('WordAttribute', type.__class__.__name__)
        test.iseq('type', type.key())
        test.iseq(':', type.litkey())
        test.iseq(74, metafile.index())

        /# Test parsing a secondary attribute of type 'enum'
        metafile.set(lnum=2, adj=32)
        test.iseq('aliases', metafile.line().line(start=metafile.index())[0:7])
        test.iseq('enum', attrinfo.secondaries()['aliases']['type'])
        aliases, _ = metafile.parseSecondaryAttribute(attr, attrinfo, 4)
        test.iseq('WordAttribute', type.__class__.__name__)
        test.iseq('aliases', aliases.key())
        test.iseq([':'], aliases.value())
        test.iseq(96, metafile.index())
        test.isfalse(metafile.hasErrors(show=True))
        /# Same test, but with a non-enum value.
        badfile.set(lnum=2, adj=32)
        aliases2, _ = badfile.parseSecondaryAttribute(badattr, attrinfo, 4)
        test.iseq(1, badfile.numErrors())

        /# Test parsing a secondary attribute of type 'simple'
        metafile.set(lnum=2, adj=44)
        test.iseq('#:', metafile.line().line(start=metafile.index())[0:2])
        test.iseq('simple', attrinfo.secondaries()['#:']['type'])
        comment, _ = metafile.parseSecondaryAttribute(attr, attrinfo, 4)
        test.isfalse(metafile.hasErrors(show=True))
        /# Same test, but with extra text after the scope indicator.
        badfile.set(lnum=2, adj=44)
        test.iseq('#: extra text', badfile.line().line(start=badfile.index())[0:13])
        comment2, _ = badfile.parseSecondaryAttribute(
          metax.c.AttributeConstruct('type', None, badctx), attrinfo, 4)
        test.iseq(2, badfile.numErrors())

        /# Test parsing a secondary attribute of type 'complex'
        metafile.set(lnum=4)
        test.iseq('config:', metafile.line().line(start=metafile.index())[0:7])
        test.iseq('complex', attrinfo.secondaries()['config:']['type'])
        config, _ = metafile.parseSecondaryAttribute(
          metax.c.AttributeConstruct('type', None, context),
          attrinfo, 4)
        /#test.isfalse(metafile.hasErrors(show=True))
        metafile.hasErrors(show=True)

        /# Test parsing an error that was causing an infinite loop.
        /#   - note that 'children<Attribute>' should be 'children <Attribute>',
        /#     and we expect Meta to report a syntax error here, not go into
        /#     an infinite loop.
        metafile, context = test.schemaParser(
          'Attribute config : complex = <empty> children<Attribute> #:\n'
          'end;\n'
        )
        attr = metax.c.AttributeConstruct('type', None, context)
        attrinfo = context.consmap()['Attribute']
        metafile.set(lnum=0, index=17)
        typeattr, _ = metafile.parseSecondaryAttribute(attr, attrinfo, 0)
        test.iseq('type', typeattr.key())
        test.iseq(27, metafile.index())
        defattr, _ = metafile.parseSecondaryAttribute(attr, attrinfo, 0)
        test.iseq('default', defattr.key())
        test.iseq(37, metafile.index())
        chattr, _ = metafile.parseSecondaryAttribute(attr, attrinfo, 0)
        test.isnull(chattr)
        test.iseq(-1, attr.termcode())
        test.iseq(
          [
            {'message': 'Unknown secondary token "children<Attribute>"', 'line': 0, 'kind': 'E', 'col': 37},
          ],
          metafile._logmap['order'])

        /# TODO(wmh): The collection of attribute types used by Meta(Meta)
        /# is quite sparse.  Parse the Meta(Oopl) schema and use it to
        /# perform a comprehensive testing of all attribute types (with both
        /# legal and illegal values).

      testx t2 scope:
        text = (
          'namespace nm.sp scope:\n'
          '  class Card scope:\n'
          '    method f params:\n'
          '      var a : int;\n'
          '    scope<cc>:\n'
          '      cout << "hello" << endl;\n'
          '    scope<py>:\n'
          '      print "hello"\n'
          '    end;\n'
          '  end;\n'
          'end;\n'
        )
        metafile = test.parserFor('Oopl', text, debuglevel=0)
        /#metafile.show()
        metafile.set(index=87, lnum=4)
        context = metafile.context()
        construct = metax.c.MethodConstruct.NewFromData(
          'f', context, termcode=TERM_UNINIT)
        metax.c.Debug = True

        /# Parse the scope<cc>:
        /#  - should NOT add a 'scope:' key, because cc isn't current baselang.
        attribute, error = metafile.parseSecondaryAttribute(
          construct, context.consinfo('method'), 4)
        test.isnull(error)
        test.iseqvec(
          ['method', 'scope:.cc'],
          sorted(construct._attributes))

        /# Parse the scope<py>:
        /#  - this SHOULD add a 'scope:' key because py is current baselang.
        attribute2, error2 = metafile.parseSecondaryAttribute(
          construct, context.consinfo('method'), 4)
        test.isnull(error)
        test.iseqvec(
          ['method', 'scope:', 'scope:.cc', 'scope:.py'],
          sorted(construct._attributes))
        test.issame(attribute2, construct.attr('scope:'))
    end method parseSecondaryAttribute;

    method parseEnd : tuple<int,int> #:
      Check if the current position is the start of a end-of-construct.

      Returns:
       0) termcode : int
         The termcode. Returns TERM_UNINIT if no terminator was found
       1) index : int
         The index within self.text() after the terminator and skipped spaces.
    params:
      var construct : Construct #:
        The construct being parsed.
      var index : int = -1 #:
        The current position within the current line.  Usually not specified,
        in which case self.index() is used.
    scope:
      self.validate(index=index)

      text = self._text
      if index < 0:
        index = self._index
      line = self.line()
      snippet = text[index:line.end()]
      m = MetaFile.TERM_RE.match(snippet)
      if m:
        termcode = 0x1  # semicolon definitely present.
        index += m.end(0)
        if m.group('end'):
          termcode |= 0x2
        kind = m.group('kind')
        if kind:
          termcode |= 0x4
          if kind != construct.kind():
            self.error(
              'Parsing %s but found terminator for %s' %
              (construct.kind(), kind))
        id = m.group('id')
        if id:
          termcode |= 0x8
          if id != construct.id():
            self.error(
              'Parsing %s %s but found terminator for %s %s' %
              (construct.kind(), construct.id(), kind, id))
      else:
        termcode = TERM_UNINIT
        index = line.start()
      return (termcode, index)
    test:
      text = 'MetaLanguage Test config:\nend MetaLanguage;\n'
      construct, context, metafile = test.newTestSchema(text)
      metafile.nextLine()
      test.iseq((7, 43), metafile.parseEnd(construct))
      construct.termcodeIs(7)
      test.iseq('end MetaLanguage;', construct.termstr())

      metafile, context = test.schemaParser(';\n')
      test.iseq((1, 1), metafile.parseEnd(construct))

      metafile, context = test.schemaParser('end;\n')
      test.iseq((3, 4), metafile.parseEnd(construct))

      metafile, context = test.schemaParser('end MetaLanguage;\n')
      test.iseq((7, 17), metafile.parseEnd(construct))

      metafile, context = test.schemaParser('end MetaLanguage Test;\n')
      test.iseq((15, 22), metafile.parseEnd(construct))
      test.iseq([], metafile.errors())

      metafile, context = test.schemaParser('end Construct;\n')
      test.iseq((7, 14), metafile.parseEnd(construct))
      test.iseq(
        [{'message': 'Parsing MetaLanguage but found terminator for Construct',
         'line': 0, 'kind': 'E', 'col': 0}],
        metafile.errors())

      metafile, context = test.schemaParser('end MetaLanguage Bork;\n')
      test.iseq((15, 22), metafile.parseEnd(construct))
      test.iseq(
        [{'message': 'Parsing MetaLanguage Test but found terminator for MetaLanguage Bork',
         'line': 0, 'kind': 'E', 'col': 0}],
        metafile.errors())
    end method parseEnd;

    method parseWord : tuple<str,int> #:
      Obtain next token and advance position beyond it.

      Returns:
       [0] word : str
         The parsed word
       [1] adj : int
         An integer which, when added to the current column, gives the
         column of the next non-space token within the current line.
       [2] index : int
         The absolute index of the next non-space token within self.text().
    params:
      var start : int;
    scope:
      /# peekWord never advances beyond the current line.
      result = self.peekWord(start)
      self._index = result[2]
      return result
    test:
      text = 'MetaLanguage Test config:\nend MetaLanguage;\n'
      metafile, context = test.schemaParser(text)
      test.iseq(('MetaLanguage', 13, 13), metafile.parseWord(0))
      test.iseq(13, metafile.column())
      test.iseq(('Test', 5, 18), metafile.parseWord(13))
      test.iseq(18, metafile.column())
      test.iseq(('config:', 7, 25), metafile.parseWord(18))
      test.iseq(25, metafile.column())
    end method parseWord;

    method peekWord : tuple<str,int,int> #:
      Obtain next word without advancing position.

      NOTE: This method does NOT skip initial whitespace and raises an exception
      if text[start] is a space or newline. It does however skip past whitespace
      after the word.

      Returns:
       [0] word : str
         The parsed word
       [1] adj : int
         An integer which, when added to the current column, gives the
         column of the next non-space token within the current line.
       [2] index : int
         The absolute index of the next non-space token within self.text().
    params:
      var start : int;
    scope:
      text = self._text
      term = self.context().token('term')
      c = text[start]
      assert c != ' ' and c != '\n'
      index = start
      /# Consume the word up to next space or newline
      while True:
        c = text[index]
        if c== ' ' or c == '\n' or c == term: break
        index += 1
      word = text[start:index]
      /# Skip trailing spaces (but not newlines!)
      while text[index] == ' ': index += 1
      return (word, index - start, index)
    test:
      text = 'MetaLanguage Test config:\nend MetaLanguage;\n'
      metafile, context = test.schemaParser(text)
      test.iseq(('MetaLanguage', 13, 13), metafile.peekWord(0))
      test.iseq(('Test', 5, 18), metafile.peekWord(13))
      test.iseq(('config:', 7, 25), metafile.peekWord(18))

      assert text[25] == '\n'
      test.raises(AssertionError, metafile.peekWord, 25)

      assert text[12] == ' '
      test.raises(AssertionError, metafile.peekWord, 12)
    end method peekWord;

    method peekFeatureOrPrimaryToken : tuple<str,str,int,any,int,int> #:
      Obtain next feature value, feature key or primary key token.

      Caller must ensure that the current character is not whitespace (this
      means not at a newline, and nowhere on an empty line) and this method
      should only be invoked in situations where a feature key, feature value or
      primary key is expected.

      Returns:
       [0] word : str
         The parsed token
       [1] form : str
         One of 'feature_value', 'feature_key', 'primary_key', or 'error'
       [2] index : int
         The absolute index of the next non-space token within self.text().
       [3] data : any
         A form-specific value (ConsInfo for primary_key, ...). If it has
         the value 'error', an error has arisen.
       [4] lnum : int
         The line number the token appears on (from 0)
       [5] col : int
         The column the token starts at (from 0)
    params:
      var start : int #:
        The index within text to start looking for a new token.
      var consgroup : ConsGroup #:
        The set of legal feature and primary tokens at the current position.
    scope:
      text = self._text
      index = start
      /# Pre: text[index] != ' ' and text[index] != '\n'

      /# Consume word
      langle = -1
      rangle = -1
      while True:
        c = text[index]
        /# TODO(wmh): Replace ';' with token('term')
        if c == ' ' or c == '\n' or c == ';': break
        elif c == '<':
          langle = index
        elif c == '>':
          rangle = index
        index += 1
      token = text[start:index]

      /# Extract out selector if present.
      if langle > -1 and rangle == index - 1:
        selector = text[langle+1:rangle]
        attrkv = text[start:langle]
      else:
        selector = None
        attrkv = token

      /# Skip whitespace
      while text[index] == ' ': index += 1

      /# Establish if the attrkv is a primary, feature or error.
      consinfo = consgroup._primaries.get(attrkv, None)
      if consinfo:
        form = 'primary_key'
        data = consinfo
      else:
        finfo = consgroup._features.get(attrkv, None)
        if finfo:
          /# 0='key' or 'value', 1=canfeatkey, 2=kinds
          form = 'feature_key' if finfo[0] == 'key' else 'feature_value'
          data = finfo
        else:
          form = 'error'
          data = None

      lnum = self._lnum
      line = self._lines[lnum]
      return (token, attrkv, selector, form, index, data, lnum, start - line.start())
    test:
      text = (
        'MetaLanguage Test config:\n'
        '  Construct Cons config:\n'
        '    kind secondary Attribute Attr : word;\n'
        '    kind<py> secondary Attribute Attr2 : word;\n'
        'end MetaLanguage;\n'
      )
      metafile, context = test.schemaParser(text)

      /# Parse the MetaLanguage primary token
      test.iseq(
        ('MetaLanguage', 'MetaLanguage', None, 'primary_key', 13, context.consmap()['MetaLanguage'], 0, 0),
        metafile.peekFeatureOrPrimaryToken(0, context.legalInfo(['MetaLanguage'])))

      /# Parse the Construct primary token
      metafile.lnumIs(1)
      test.iseq(
        ('Construct', 'Construct', None, 'primary_key', 38, context.consmap()['Construct'], 1, 2),
        metafile.peekFeatureOrPrimaryToken(28, context.legalInfo(['Construct'])))

      /# Parse the Attribute 'kind' feature key
      metafile.lnumIs(2)
      test.iseq(
        ('kind', 'kind', None, 'feature_key', 60, ('key', 'kind', ['Attribute']), 2, 4),
        metafile.peekFeatureOrPrimaryToken(55, context.legalInfo(['Attribute'])))

      /# Parse the Attribute 'kind<py>' feature key.
      metafile.lnumIs(3)
      test.iseq(
        ('kind<py>', 'kind', 'py', 'feature_key', 106, ('key', 'kind', ['Attribute']), 3, 4),
        metafile.peekFeatureOrPrimaryToken(97, context.legalInfo(['Attribute'])))

      /# Parse the Attribute 'secondary' feature value of feature 'kind'
      metafile.lnumIs(2)
      test.iseq(
        ('secondary', 'secondary', None, 'feature_value', 70, ('value', 'kind', ['Attribute']), 2, 9),
        metafile.peekFeatureOrPrimaryToken(60, context.legalInfo(['Attribute'])))

      /# Parse the Attribute primary token
      metafile.lnumIs(2)
      test.iseq(
        ('Attribute', 'Attribute', None, 'primary_key', 80, context.consmap()['Attribute'], 2, 19),
        metafile.peekFeatureOrPrimaryToken(70, context.legalInfo(['Attribute'])))

      /# Parse a feature/primary token when one does not exist.
      metafile.lnumIs(0)
      test.iseq(
        ('Test', 'Test', None, 'error', 18, None, 0, 13),
        metafile.peekFeatureOrPrimaryToken(13, context.legalInfo(['MetaLanguage'])))
    end method peekFeatureOrPrimaryToken;

    method peekSecondaryToken : tuple<str,str,str,map,int> #:
      Obtain a secondary key at given position (or explicit end-of-construct).

      Caller must ensure that the current character is not whitespace (this
      means not at a newline, and nowhere on an empty line) and this method
      should only be invoked in situations where a secondary key (or construct
      terminator) is expected.

      Returns:
       0) token : str
         The secondary token or null if no secondary
       1) key : str
         The canonical secondary token (or null)
       2) basel : str
         The baselang selector (null for no selector, '*' for Meta* else baselang suffix)
       3) info : map
         The information related to the secondary, or null if no secondary
       4) index : int
         The index after the token (and after spaces have been skipped).
         If termcode is not TERM_UNINIT, this is the index after the terminator
         (spaces skipped but not newlines).
       5) termcode : int
           TERM_UNINIT if a secondary token is identified, else an
           integer identifying an implicit (0) or explict (>0) termination.
    params:
      var construct : Construct #:
        The construct instance being parsed.
      var start : int #:
        The position at which the secondary key (explicit or implicit) starts.
      var context : Context #:
        The current context.
      var consinfo : ConsInfo #:
        The construct info being parsed.
    scope:
      text = self._text
      index = start
      term = context.token('term')
      secondaries = consinfo.secondaries()
      /# Pre: text[index] != ' ' and text[index] != '\n'
      cankey = None
      basel = None

      c = text[index]
      autokey = consinfo.autokeys().get(c, None)

      /#print '**** HERE with c="%s"' % c

      if c == term:
        /# We have an explicit termination
        (token, info, termcode) = (None, None, 1)
        index += 1

      elif autokey:
        /# We have a value that is implicitly identifying the attribute key.
        /#  - setting litkey to the empty string is how we inform Meta that
        /#    the key was implicit.
        token = ''  # litkey being empty is special semantics to indicate implicitness
        info = secondaries.get(autokey, None)
        if info is None:
          self.error('Failed to find autokey "%s" for "%s"' % (autokey, c))
        cankey = info['cankey']
        /# Advance past the autokey char.
        index += 1
        termcode = TERM_UNINIT

      else:
        /# The next word is either a secondary token, a terminator token, or an
        /# error.
        left = -1
        right = -1
        while True:
          c = text[index]
          if c == ' ' or c == '\n' or c == term: break
          if c == '<' and left == -1:
            left = index
          elif c == '>':
            right = index
          index += 1
        token = text[start:index]

        /# There is a distinction between:
        /#   token:
        /#     the user-provided secondary key token,
        /#   basetoken:
        /#     the token without baselang selector (but including ':' suffix)
        /#   coretoken:
        /#     the token without baselang selector or ':' suffix.
        if left != -1 and right != -1 and right >= index-2:
          /# We have a selector. Note that the current implementation precludes
          /# using '<>' as an operator unless we add special-case code to detect
          /# that.
          basel = text[left+1:right]
          metalang = self.compiler().metalang()
          if metalang and metalang.isValidBase(basel):
            coretoken = text[start:left]
            basetoken = coretoken + (':' if token[-1] == ':' else '')
          else:
            /# This is not a valid selector, so we treat the whole word as
            /# the token.
            basetoken = token
            coretoken = token[:-1] if token[-1] == ':' else token
        else:
          basetoken = token
          coretoken = token[:-1] if token[-1] == ':' else token

        /# print 'token=%s basetoken=%s coretoken=%s' % (token, basetoken, coretoken)

        termend = context.token('end')
        if token == termend + term:
          token, info, termcode = (None, None, 3)
        elif token == termend:
          token, info = (None, None)
          termcode, index = self.parseEnd(construct, index=start)
        else:
          /# The current token doesn't match any terminator ... it may or may
          /# not be a secondary.
          termcode = TERM_UNINIT
          info = secondaries.get(basetoken, None)
          if info:
            cankey = info['cankey']

      /#if basel and cankey:
      /#  if cankey[-1] == ':':
      /#    cankey = cankey[:-1] + '<' + basel + '>:'
      /#  else:
      /#    cankey += '<' + basel + '>'

      /# Skip whitespace
      while text[index] == ' ': index += 1

      result = (token, cankey, basel, info, index, termcode)
      return result
    test:
      Construct = metax.c.Construct

      def Chk(expected, value):
        info = value[3]
        if info is not None:
          /# We need to remove the 'attribute' element so that we can compare
          /# against a literal dict ... this requires some hoops (we cannot
          /# just delete 'attribute' from the passed in value because the
          /# same object can be passed in on different calls, with 'attirbute'
          /# existing then not existing.
          test.isinst(info, dict)
          test.contains('attribute', value[3])
          test.contains('empty', value[3])
          infocopy = copy.copy(info)
          attr = infocopy.pop('attribute')
          empty = infocopy.pop('empty')
          value = (value[0], value[1], value[2], infocopy, value[4], value[5])
        test.iseq(expected, value)

      text = (
        'MetaLanguage Test config:\n'
        '  Construct Cons config:\n'
        '    kind secondary Attribute Attr : word;\n'
        '  end Construct Cons;\n'
        'end MetaLanguage;\n'
        'File a.meta scope:\n'
        'end;\n'
      )
      schema, context, metafile = test.newTestSchema(text)
      cons = metax.c.ConstructConstruct('Cons', None, context)
      attr = metax.c.AttributeConstruct('Attr', None, context)

      /# Parse the 'config:' attribute of 'MetaLanguage'
      Chk(
        ('config:', 'config:', None,
         {'valopt': False, 'cankey': 'config:', 'default': '<empty>',
          'keyopt': False, 'type': 'complex', 'autokey': None,
          'children': ['Construct', 'BaseLanguage']},
          25, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(
          schema, 18, context, context.consmap()['MetaLanguage']))

      /# Parse the 'type' attribute of 'Attribute' (litkey ':')
      Chk(
        (':', 'type', None,
         {'valopt': False, 'cankey': 'type', 'default': '<empty>',
          'keyopt': False, 'type': 'word', 'autokey': None
          },
         87, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(
          attr, 85, context, context.consmap()['Attribute']))

      /# Parse the ';' at the end of the Attribute.
      metafile.lnumIs(2)
      Chk(
        (None, None, None, None, 92, 1),
        metafile.peekSecondaryToken(
          attr, 91, context, context.consmap()['Attribute']))

      /# Parse the 'end Construct Cons;' at the end of the Construct.
      metafile.lnumIs(3)
      Chk(
        (None, None, None, None, 114, 15),
        metafile.peekSecondaryToken(
          cons, 95, context, context.consmap()['Construct']))

      /# Parse the 'end MetaLanguage;' at the end of the MetaLanguage.
      metafile.lnumIs(4)
      Chk(
        (None, None, None, None, 132, 7),
        metafile.peekSecondaryToken(
          schema, 115, context, context.consmap()['MetaLanguage']))

      /# TODO(wmh): Meta(Meta) does not have any autokey attributes, so we
      /# need Meta(Oopl) to properly test that aspect of peekSecondaryToken().
      /# However, we can fake things up by hacking autokeys.
      /#  - we indicate that if Meta sees '/' when expecting a secondary key,
      /#    it should interpret this as an implicit 'default' secondary
      /#    (which of course doesn't make sense to actually do ... just a test).
      attrinfo = context.consmap()['Attribute']
      attrinfo.autokeys()['/'] = 'default'
      metafile, context = test.schemaParser('Attribute Attr /blah;\n')
      attr = metax.c.AttributeConstruct('Attr', None, context)
      Chk(
        ('', 'default', None,
         {'valopt': False, 'cankey': 'default', 'default': '<empty>', 'keyopt': False, 'type': 'word', 'autokey': None},
         16, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, 15, context, attrinfo))

      /###
      /# Now perform tests on selector parsing.
      text = (
        'type<meta> type<*> type\n'
        'comment<meta>: comment<*>: comment:\n'
        ':<meta> :<*> :\n'
        ':<meta>: :<*>: ::\n'
      )
      metafile, context = test.schemaParser(text)
      attr = metax.c.AttributeConstruct('Attr', None, context)
      attrinfo = context.consmap()['Attribute']

      /# First line, variants on 'type' (non-block valued)
      metafile.lnumIs(0)
      Chk(
        ('type<meta>', 'type', 'meta',
         {'valopt': False, 'cankey': 'type', 'default': '<empty>',
          'keyopt': False, 'type': 'word', 'autokey': None}, 11, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, 0, context, attrinfo))
      Chk(
        ('type<*>', 'type', '*',
         {'valopt': False, 'cankey': 'type', 'default': '<empty>',
          'keyopt': False, 'type': 'word', 'autokey': None}, 19, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, 11, context, attrinfo))
      Chk(
        ('type', 'type', None,
         {'valopt': False, 'cankey': 'type', 'default': '<empty>',
          'keyopt': False, 'type': 'word', 'autokey': None}, 23, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, 19, context, attrinfo))

      /# Second line, variants on 'comment' (block-valued)
      metafile.set(lnum=1)
      index = 24
      test.iseq(index, metafile.index())
      Chk(
        ('comment<meta>:', 'comment:', 'meta',
         {'valopt': False, 'cankey': 'comment:', 'default': '<empty>',
          'keyopt': False, 'type': 'simple', 'autokey': None}, index + 15, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, index, context, attrinfo))
      Chk(
        ('comment<*>:', 'comment:', '*',
         {'valopt': False, 'cankey': 'comment:', 'default': '<empty>',
          'keyopt': False, 'type': 'simple', 'autokey': None}, index + 27, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, index + 15, context, attrinfo))
      Chk(
        ('comment:', 'comment:', None,
         {'valopt': False, 'cankey': 'comment:', 'default': '<empty>',
          'keyopt': False, 'type': 'simple', 'autokey': None}, index + 35, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, index + 27, context, attrinfo))

      /# Third line, variants on ':' (alias for 'type')
      metafile.set(lnum=2)
      index = 60
      test.iseq(index, metafile.index())
      Chk(
        (':<meta>', 'type', 'meta',
         {'valopt': False, 'cankey': 'type', 'default': '<empty>',
          'keyopt': False, 'type': 'word', 'autokey': None}, index + 8, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, index, context, attrinfo))
      Chk(
        (':<*>', 'type', '*',
         {'valopt': False, 'cankey': 'type', 'default': '<empty>',
          'keyopt': False, 'type': 'word', 'autokey': None}, index + 13, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, index + 8, context, attrinfo))
      Chk(
        (':', 'type', None,
         {'valopt': False, 'cankey': 'type', 'default': '<empty>',
          'keyopt': False, 'type': 'word', 'autokey': None}, index + 14, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, index + 13, context, attrinfo))

      /# Fourth line, variants on '::' (alias for 'scope')
      /#  - note that '::' isn't defined on 'Attribute', so it fails to
      /#    identify selector info.
      /#  - we switch to MetaLanguage, which defines 'scope:' and '::'.
      metafile.set(lnum=3)
      index = 75
      test.iseq(index, metafile.index())
      Chk(
        (':<meta>:', None, 'meta', None, index + 9, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(attr, index, context, attrinfo))
      schema = metax.c.ConstructConstruct('MetaLanguage', None, context)
      schemainfo = context.consmap()['MetaLanguage']
      Chk(
        (':<meta>:', 'scope:', 'meta',
         {'valopt': False, 'cankey': 'scope:', 'default': '<empty>',
          'keyopt': False, 'type': 'complex', 'autokey': None}, index + 9, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(schema, index, context, schemainfo))
      Chk(
        (':<*>:', 'scope:', '*',
         {'valopt': False, 'cankey': 'scope:', 'default': '<empty>',
          'keyopt': False, 'type': 'complex', 'autokey': None}, index + 15, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(schema, index + 9, context, schemainfo))
      Chk(
        ('::', 'scope:', None,
         {'valopt': False, 'cankey': 'scope:', 'default': '<empty>',
          'keyopt': False, 'type': 'complex', 'autokey': None}, index + 17, metax.c.TERM_UNINIT),
        metafile.peekSecondaryToken(schema, index + 15, context, schemainfo))

    end method peekSecondaryToken;

    method nextLine : tuple<Line,int,bool> #:
      Advance to next line.

      Returns:
        [0] line: Line
          The next Line (or null if EOF has been reached).
        [1] index: int
          The new index within self.text(). Callers should update their
          locally cached concept of index within text based on this. This
          will be -1 if EOF has been reached.
        [2] matches: bool
          A boolean indicator of whether the new line indent matches
          expectations. Always true if the 'indent' param is negative.
    params:
      var indent : int = -1 #:
        If zero or greater, it is a request to confirm that the indent of
        the returned line exactly matches the indent specified.
    scope:
      self._lnum += 1
      line = self.line()
      index = (line._start + line._indent) if line else -1
      self._index = index
      matches = True
      if indent > -1 and indent != line._indent:
        matches = False
        /# We used to log here, but it is probably best to let the caller
        /# decide how to report this.
        /#self.error('Expected token indented %d spaces' % indent)
      return line, index, matches
    test:
      mf, _ = test.schemaParser(
        'MetaLanguage Test config:\n  Construct A config:\n  end;\nend;\n')
      lines = mf.lines()
      test.iseq(0, mf.lnum())

      test.iseq((lines[1], 28, True), mf.nextLine())
      test.iseq(1, mf.lnum())
      test.iseq(2, mf.column())

      test.iseq((lines[2], 50, True), mf.nextLine(indent=2))
      test.iseq(2, mf.lnum())
      test.iseq(2, mf.column())
      test.iseq([], mf.errors())

      test.iseq((lines[3], 55, False), mf.nextLine(indent=2))
      test.iseq(3, mf.lnum())
      test.iseq(0, mf.column())
    end method nextLine;

    method skipEmptyLines : tuple<Line,int,bool,int> #:
      Advance forward past empty lines.

      SideEffects:
        - sets self.col() to first non-space on resulting non-empty line.
        - updates self.lnum()

      Returns:
        [0] line: Line
          The next Line (or null if EOF has been reached).
        [1] index: int
          The new index within self.text(). Callers should update their
          locally cached concept of index within text based on this. This
          will be -1 if EOF has been reached.
        [2] matches: bool
          A boolean indicator of whether the new line indent matches
          expectations. Always true if the 'indent' param is negative.
        [3] precount: int
          The number of empty lines skipped.
    params:
      var indent : int = -1 #:
        If zero or greater, it is a request to confirm that the indent of
        the returned line exactly matches the indent specified.
    scope:
      skipped = 0
      matches = True
      lines = self._lines
      lnum = self._lnum
      n = len(lines)
      while lnum < n and lines[lnum].empty():
        lnum += 1
        skipped += 1
      if lnum < n:
        line = lines[lnum]
        index = line.start() + line.indent()
        if indent > -1 and indent != line.indent():
          matches = False
          /# Used to log here, but probably best to let caller decide how to
          /# report this.
          /# self.error(
          /#  'Expecting token indented %d spaces' % indent, line=self.lnum())
      else:
        line = None
        index = n
      self.set(index=index, lnum=lnum)
      return (line, index, matches, skipped)
    test:
      metafile, _ = test.schemaParser('MetaLanguage Test config:\nend;\n')
      test.iseq((metafile.lines()[0], 0, True, 0), metafile.skipEmptyLines())
      test.iseq(0, metafile.column())
      metafile, _ = test.schemaParser('\n    \nMetaLanguage Test config:\nend;\n')
      test.iseq((metafile.lines()[2], 6, True, 2), metafile.skipEmptyLines())
      test.iseq(0, metafile.column())
      metafile, _ = test.schemaParser( '\n    \n    class Person scope:\n')
      test.iseq((metafile.lines()[2], 10, True, 2), metafile.skipEmptyLines())
      test.iseq(4, metafile.column())
    end method skipEmptyLines;

    method skipToIndent : Line #:
      Advance to the nearest line whose indent is less-equal given indent.
    params:
      var indent : int;
    scope:
      lnum = self.lnum()
      start = lnum
      lines = self.lines()
      n = len(lines)
      while lnum < n and lines[lnum].indent() > indent:
        lnum += 1
      self.lnumIs(lnum)
      result = lines[lnum] if lnum < n else None
      /# self.info('Skipped %d lines' % (lnum - start), line=start)
      return result
    test:
      metafile, _ = test.schemaParser(
        '  a = 1;\n  b = 2;\nMetaLanguage Test config:\nend;\n')
      line = metafile.skipToIndent(0)
      test.iseq('   3: 0:MetaLanguage Test config:', line.asStr())
      test.iseq(2, metafile.lnum())
    end method skipToIndent;

    method validate : bool #:
      Ensure this MetaFile's invariants are true.
    params:
      var index = -1 #:
        The indent to validate (if negative, self.index() is used).
    scope:
      if index < 0:
        index = self.index()
      line = self.line()
      if line.start() > index:
        raise Error(
          'line %d starting %d is > %d current' % (self.lnum(), line.start(), index))
      elif line.end() < index:
        raise Error(
          'line %d ending %d is < %d current' % (self.lnum(), line.end(), index))
      return True
    test:
      /# This is effectively a test method. No test for test methods.
      pass
    end method validate;

    method registerFile #:
      Register a BaseFile.
    params:
      var basefile : BaseFile #:
        The basefile to register.
    scope:
      fs = self.compiler().fs()
      /# Filesystem.addFile() returns null if we are not in disk mode,
      /# otherwise [basepath] or [basepath, mappath]
      paths = fs.addFile(basefile)
      if paths:
        for path in paths:
          self.files().add(path)
        self.basefiles().add(basefile)
    test:
    end method registerFile;

    method writeFiles #:
      Write the files this metafile writes to to a stream.
    params:
      var path : str = null #:
        The path to write to.  If None, write to stdout.
    scope:
      fs = self.fs()
      if path is None:
        fp = sys.stdout
      else:
        fp = fs.open(path, 'w')

      fp.write('%s\n' % self.filename())
      for path in sorted(self.files()):
        assert path == fs.realpath(path)
        fp.write(path + '\n')

      if path is None:
        fs.close(fp)
    end method writeFiles;

    method readFiles : set<str> #:
      Read files previously written with 'writeFiles'.
    params:
      var path : str #:
        The path to read from.
    scope:
      fs = self.fs()
      result = set()
      if fs.exists(path):
        ifp = fs.open(path, 'r')
        srcfilename = ifp.readline().strip()
        if srcfilename != self.path():
          /# This may be ok, but for now raising exception to explore when this
          /# happens.
          raise Error('Found "%s" vs "%s"' % (srcfilename, self.path()))
        for line in ifp:
          result.add(line.strip())
      return result
    end method readFiles;

    method cleanupFiles #:
      Remove any files created last time that were not created this time.
    scope:
      fs = self.fs()
      metac = self.compiler()
      flags = metac.cli()
      metadir = flags.metadir
      if metadir != metax.c.SUFFIX:
        self.warning(
          'Not performing file caching/cleanup for metadir %s' % metadir)
        return

      /# Establish the file containing last times set of files.
      baselang = self.baselang()
      path = self.path()
      pdir, filename = fs.split(path)
      basename, suffix = fs.splitext(filename)
      logfile = fs.join(pdir, '.%s.%s.files' % (basename, baselang.suffix()))
      self.files().add(logfile)

      /# Obtain files written last time and this time.
      old_files = self.readFiles(logfile)
      new_files = self.files()
      del_files = old_files - new_files

      debug = False
      if debug:
        for path in sorted(old_files.union(new_files)):
          nc = 'Y' if path in new_files else ' '
          oc = 'Y' if path in old_files else ' '
          print '%s %s %s' % (nc, oc, path)
        print 'Found %d old files and %d new files and %d obselete files' % (
          len(old_files), len(new_files), len(del_files))

      /# Write the new set of files to disk for next time.
      self.writeFiles(logfile)

      /# Delete any obsolete files
      for path in del_files:
        if fs.exists(path):
          print 'CLEANUP: Removed obsolete %s' % path
          fs.unlink(path)
    end method cleanupFiles;

    method computeFileStats : map #:
      Compute stats on the basefiles generated for this Metafile.

      Returns:
        Lines: int
          Number of lines in this meta file
        Bytes: int
          Number of bytes in this meta file
        files: int
          Number of files generated
        lines: int
          Number of lines across all files
        reallines: int
          Number of non-trivial lines across all files. Note that comments
          are NOT considered trivial and thus contribute to this value.
        bytes: int
    scope:
      basefiles = self.basefiles()
      numlines = 0
      reallines = 0
      bytes = 0

      for basefile in basefiles:
        contents = basefile.contents()
        if contents:
          bytes += len(contents)
          lines = contents.split('\n')
          assert contents and contents[-1] == '\n'
          lines.pop()
          numlines += len(lines)
          /# TODO(wmh): Should the lines in the map file associated with basefile
          /# be added? For now we do not.

          /# TODO(wmh): Implement baselang-specific function for following.
          /#  - trivial lines include
          /#     - blank lines
          /#     - lines consisting solely of construct terminators (non-existent in python)
          /#  - trivial lines do NOT include
          /#     - comments
          baselang = self.compiler().baselang()
          fluffre = re.compile(r'^\s*$')
          for line in lines:
            m = fluffre.match(line)
            if not m:
              reallines += 1

      result = {
        'Lines': len(self.lines()),
        'Bytes': len(self.text()),
        /# TODO(wmh): Add a 'metareal' entry that shows the non-empty line count
        /# of the meta file. This means ignoring empty lines and lines with
        /# construct teminators ... anything else?
        'files': len(basefiles),
        'lines': numlines,
        'reallines': reallines,
        'bytes': bytes,
      }
      return result
    test:
    end method computeFileStats;

    method parseMeta : FileConstruct #:
      Parse the entire contents of this MetaFile instance into a FileConstruct,
      initializing self.construct().
    params:
      var parent_context : Context #:
        The context within which the metafile is to be parsed. The context
        identifies which constructs are legal in the scope.
      var is_schema : bool = false #:
        True if we are parsing a schema file.
    scope:
      /# IMPORTANT: We make a copy of 'context' even though there are no
      /# 'config' changes relative to the passed in 'context'. We do this so
      /# that we can safely set context.metafile() to self without tromping
      /# a previous value.
      self.stateIs('parsing')
      start = time.time()
      context = parent_context.subclone(metafile=self)

      /# We initialized the compiler instance of Context.
      context.compilerIs(self.compiler())

      /# TODO(wmh): The parent of the FileConstruct should be the scope: of
      /# the MetaLanguage of the Metalanguage within which the metafile is defined.
      parent = None

      fs = self.compiler().fs()
      /# print '***** PARSING %s' % fs.realpath(self.path())

      file_construct = FileConstruct(self.path(), parent, context)
      primary = IdAttribute(file_construct, 'File', self.path(), line=0, col=0)
      scope = ComplexBlock(file_construct, 'scope:', [], line=0, col=0)
      file_construct.registerAttribute(primary)
      file_construct.registerAttribute(scope)
      self.contextIs(context)
      metalang = self.compiler().metalang()
      if metalang is None:
        if is_schema:
          /# TODO(wmh): This is a hack to allow the Compiler initializer to
          /# create MetaLanguageConstruct instances by parsing schema files.
          /# The initializer invokes metalangNamed() which invokes parseMeta()
          /# which invokes this method which needs the compiler().metalang()
          /# before one exists (e.g. while the initializer is unfinished).
          /# Find a better way to handle this bootstrapping issue!
          legals = ['MetaLanguage', 'File']
        else:
          raise Error('Attempt to parse MetaFile without metalang')
      else:
        legals = metalang.toplevelConstructKinds()

      self.parseComplexBlock(scope, 0, legals=legals)
      self.constructIs(file_construct)

      self.stats()['parse'] = time.time() - start
      self.stateIs('parsed')
      return file_construct
    test:
      text = (
        'MetaLanguage Test config:\n'
        'end MetaLanguage;\n'
      )
      metafile, context = test.schemaParser(text)
      file = metafile.parseMeta(context)
      fp = test.newStr()
      file.write(fp=fp)
      out = fp.getvalue()
      test.iseqtext(
        'File fauxpath scope:\n'
        '  MetaLanguage Test config:\n'
        '  end MetaLanguage;\n',
        out)
    end method parseMeta;

    method expandMeta #:
      Expand all top-level constructs in this file.
    scope:
      D.expand.sinfo(self.path())

      self.stateIs('expanding')
      start = time.time()
      self.construct().expandMeta()
      self.stats()['expand'] = time.time() - start
      self.stateIs('expanded')

      D.expand.end()
    end method expandMeta;

    method importMeta #:
      Import additional .meta files identified during expandMeta.
    scope:
      D.imports.sinfo(self.path())

      self.stateIs('importing')
      start = time.time()
      self.construct().importMeta()
      self.stats()['import'] = time.time() - start
      self.stateIs('imported')

      D.imports.end()
    test:
    end method importMeta;

    method translateMeta scope:
      D.translate.sinfo(self.path())

      self.stateIs('translating')
      start = time.time()
      self.construct().translateMeta()
      self.stats()['translate'] = time.time() - start
      self.stateIs('translated')

      D.translate.end()
    end method translateMeta;

    method compileMeta scope:
      D.compile.sinfo(self.path())

      self.stateIs('compiling')
      start = time.time()
      self.construct().compileMeta()
      self.stats()['compile'] = time.time() - start
      self.stateIs('compiled')

      D.compile.end()
    end method compileMeta;

    test
    lifecycle setup:
      /# testdata = metax.root.Object.Resource('testdata', fqn='metax.c.Meta')
      _, _, _, compiler = test.cachedInfo(metal='meta')
      text = 'MetaLanguage Test config:\nend MetaLanguage Test;\n'
      self.metafile = metax.c.MetaFile('fauxpath', compiler, text=text)
    end lifecycle;
  end class MetaFile;

  class Compiler #:
    Maintains information about a collection of metafiles and provides
    functionality for parsing, expanding, compiling, analyzing, canonicalizing,
    (etc) those meta files.

    Each Compiler instance is specific to a particular Meta Language. A
    specific BaseLanguage is active at any given time, but can be switched
    during the lifetime of the Compiler instance.

  assocs:
    std assoc collections;
    std assoc copy;
    std assoc cStringIO;
    std assoc datetime;
    std assoc difflib;
    std assoc json;
    std assoc importlib;
    test std assoc metastrap #:
      TODO(wmh): Establish how to specify a bazel target for metastrap.
    std assoc platform;
    std assoc pprint;
    std assoc re;
    std assoc sre_constants;
    std assoc subprocess;
    std assoc sys;
    std assoc time;
    std assoc traceback;

    cls assoc metax.c.shell.Shell;
    cls assoc metax.fs.Filesystem;
    cls assoc metax.cli.Command;
    cls assoc metax.cli.Values;

    resource emacs_template path "../templates/meta-mode-template.el";
    resource oopl_tgz path "../templates/oopl.tgz";
    resource test_repo path "./testdata/repo";
  scope:

    meta
    field CLI : metax.cli.Values #:
      The command-line flags and args (and command)

    meta
    field Current : Compiler #:
      Initialized in the Entry meta-method to the instance created there-in.

    meta
    lifecycle scope:
      cls.MAP_RE = re.compile(
        r'^\s*(?P<baseline>-?\d+)\s+(?P<metaline>-?\d+)\s+(?P<fullid>\S+)')
      cls.BAZEL_STDOUT_RE = re.compile(
        r'(?P<preamble>.*)'
        r'==================== Test output for (?P<target>\S+):\n'
        r'(?P<stderr>.*'
        r'\nRan (?P<tests>\d+) tests? in (?P<time>\S+)\n\n'
        r'(?P<status>\S+) *(?P<extra>\S*)\n'
        r')'
        r'(?P<stdout>.*)'
        r'\n={80}\n'
        r'(?P<rest>.*)'
        ,
        flags=re.DOTALL)

      cls.METADATA = {
        /##############
        /# Meta(Meta) #
        /##############
        'meta': {
          'name': 'Meta',
          'parent': None,
          'toplevel': ['MetaLanguage', 'File'],
          'constructs': {
            'MetaLanguage': MetaLanguageConstruct,
            'BaseLanguage': BaseLanguageConstruct,
            'File': FileConstruct,
            'Construct': ConstructConstruct,
            'Attribute': AttributeConstruct,
            'FeatureValue': FeatureValueConstruct,
            'Template': TemplateConstruct,
          },
          'baselangs': {},
          'basesels': ['meta'],
        },
        /##############
        /# Meta(Oopl) #
        /##############
        'oopl': {
          'name': 'Oopl',
          'parent': 'meta',
          'toplevel': ['namespace'],
          'constructs': {
            'namespace': NamespaceConstruct,
            'class': ClassConstruct,
            'method': MethodConstruct,
            'field': FieldConstruct,
            'accessor': AccessorConstruct,
            'lifecycle': LifecycleConstruct,
            'var': VarConstruct,
            'assoc': AssocConstruct,
            'testx': TestxConstruct,
            'native': NativeConstruct,
            'resource': ResourceConstruct,
            'category': CategoryConstruct,
            'remark': RemarkConstruct,
            'flag': FlagConstruct,
            'command': CommandConstruct,
            'block': BlockConstruct,
            'behavior': BehaviorConstruct,
            'receiver': ReceiverConstruct,
          },
          'baselangs': {
            'python': OoplPython,
            'javascript': OoplJavascript,
            'cpp': OoplCpp,
          },
          'basesels': [],
        },
        /#############
        /# Meta(Fun) #
        /#############
        'fun': {
          'name': 'Fun',
          'parent': 'meta',
          'toplevel': None,  # FIX ME
          'constructs': {},  # FIX ME
          'baselangs': {},   # FIX ME
          'basesels': [],
        },
        /#############
        /# Meta(Doc) #
        /#############
        'doc': {
          'name': 'Doc',
          'parent': 'meta',
          'toplevel': None,  # FIX ME
          'constructs': {},  # FIX ME
          'baselangs': {},   # FIX ME
          'basesels': [],
        },
        /##############
        /# Meta(Draw) #
        /##############
        'draw': {
          'name': 'Draw',
          'parent': 'meta',
          'toplevel': None,  # FIX ME
          'constructs': {},  # FIX ME
          'baselangs': {},   # FIX ME
          'basesels': [],
        },
        /##############
        /# Meta(Plot) #
        /##############
        'plot': {
          'name': 'Plot',
          'parent': 'meta',
          'toplevel': None,  # FIX ME
          'constructs': {},  # FIX ME
          'baselangs': {},   # FIX ME
          'basesels': [],
        },
        /##############
        /# Meta(Test) #
        /##############
        'test': {
          'name': 'Test',
          'parent': 'meta',
          'toplevel': ['test'],  # FIX ME
          'constructs': {},      # FIX ME
          'baselangs': {},       # FIX ME
          'basesels': [],
        }
      }

      cls.HTML_HEAD = (
        >|"""    <style>
        >|    .metafile {
        >|        font-size: 80%;
        >|        margin: 0px 0px 0px 250px;
        >|        width: 100ch;
        >|        background-color: black;
        >|        color: #c5c8c6;
        >|        /* http://crafted-software.blogspot.com/2010/07/css-for-tag-list-of-best-monospaced.html */
        >|        font-family: /* Pragmata,*/ Menlo, 'DejaVu LGC Sans Mono', 'DejaVu Sans Mono', Consolas, 'Everson Mono', 'Lucida Console', 'Andale Mono', 'Nimbus Mono L', 'Liberation Mono', FreeMono, 'Osaka Monospaced', Courier, 'New Courier', monospace;
        >|        border: 1px solid blue;
        >|        float: left;
        >|    }
        >|    .metadex {
        >|        background-color: #c5c8c6;
        >|        color: black;
        >|        position: fixed;
        >|        top: 9px;
        >|        left: 5px;
        >|    }
        >|    code {
        >|      font-family: /* Pragmata,*/ Menlo, 'DejaVu LGC Sans Mono', 'DejaVu Sans Mono', Consolas, 'Everson Mono', 'Lucida Console', 'Andale Mono', 'Nimbus Mono L', 'Liberation Mono', FreeMono, 'Osaka Monospaced', Courier, 'New Courier', monospace;
        >|      white-space: pre;
        >|    }
        >|    /* https://developer.mozilla.org/en-US/docs/Web/CSS/color_value */
        >|    /* /usr/X11/share/X11/rgb.txt */
        >|    .face-primary   { color: purple; }
        >|    .face-primary2  { color: rgb(0, 100, 0); /* darkgreen */ }
        >|    .face-feature   { color: rgb(85, 107, 47);  /* darkolivegreen */ }
        >|    .face-secondary { color: rgb(85, 107, 47);  /* darkolivegreen */ }
        >|    .face-featval   { color: rgb(139, 58, 98); /* hotpink4 */ }
        >|    .face-keyword   { color: rgb(255, 20, 147); /* deep pink */ }
        >|    .face-end       { color: rgb(139, 139, 131); /* ivory4 */ }
        >|    .face-name      { color: rgb(0, 0, 255); /* blue1 */ }
        >|    .face-comment   { color: rgb(0, 139, 139); /* cyan4 */ }
        >|
        >|    .ellipsis { color: black; }
        >|
        >|    /**
        >|     * Each line of code in a .meta program is specified by:
        >|     *   <div>
        >|     *     <span class="linenum">LINENUM</span>
        >|     *     <span class="indentNUM"></span>
        >|     *     <span class="linetext">SOURCE LINE</span>
        >|     *   </div>
        >|     *
        >|     * Notes:
        >|     *  - the linenum span is a fixed width and subdued coloring
        >|     *  - the indentNUM span is used to provide indentation.
        >|     *  - the linetext span contains the meta source line (appropriately marked up).
        >|     *
        >|     * TODO(wmh):
        >|     *  - Establish why we need to move the linetext span one char to the left
        >|     *  - Establish why there is a 1ch spacing between the linenum span and
        >|     *    the indentNUM spans ... it isn't due to margin or padding in either
        >|     *    of the two spans, as far as I can tell. It is actually working in our
        >|     *    favor, but I'd like to understand where it is coming from.
        >|     */
        >|    .linenum  {
        >|        display: inline-block;
        >|        width: 4ex;
        >|        text-align: right;
        >|        margin: 0px;
        >|        color: rgb(179, 179, 171);
        >|        /* border: 1px solid red; */
        >|    }
        >|    .indent0 { display: inline-block; width:  0ch; /* border: 1px solid green; */ }
        >|    .indent1 { display: inline-block; width:  2ch; /* border: 1px solid green; */ }
        >|    .indent2 { display: inline-block; width:  4ch; /* border: 1px solid green; */ }
        >|    .indent3 { display: inline-block; width:  6ch; /* border: 1px solid green; */ }
        >|    .indent4 { display: inline-block; width:  8ch; /* border: 1px solid green; */ }
        >|    .indent5 { display: inline-block; width: 10ch; /* border: 1px solid green; */ }
        >|    .indent6 { display: inline-block; width: 12ch; /* border: 1px solid green; */ }
        >|    .indent7 { display: inline-block; width: 14ch; /* border: 1px solid green; */ }
        >|    .indent8 { display: inline-block; width: 16ch; /* border: 1px solid green; */ }
        >|    .indent9 { display: inline-block; width: 18ch; /* border: 1px solid green; */ }
        >|    .linetext {
        >|        /* border: 1px solid purple; */
        >|        margin: 0em -1ch;
        >|    }
        >|
        >|    /*background color*/
        >|    .hljs {
        >|      display: block;
        >|      overflow-x: auto;
        >|      padding: 0em;
        >|      background: black;
        >|    }
        >|
        >|    /*selection color*/
        >|    .hljs::selection,
        >|    .hljs span::selection {
        >|      background: #373b41;
        >|    }
        >|
        >|    .hljs::-moz-selection,
        >|    .hljs span::-moz-selection {
        >|      background: #373b41;
        >|    }
        >|
        >|    /*foreground color*/
        >|    .hljs {
        >|      color: #c5c8c6;
        >|    }
        >|
        >|    /*color: fg_yellow*/
        >|    .hljs-title,
        >|    .hljs-name {
        >|      color: #f0c674;
        >|    }
        >|
        >|    /*color: fg_comment*/
        >|    .hljs-comment,
        >|    .hljs-meta,
        >|    .hljs-meta .hljs-keyword {
        >|      color: #707880;
        >|    }
        >|
        >|    /*color: fg_red*/
        >|    .hljs-number,
        >|    .hljs-symbol,
        >|    .hljs-literal,
        >|    .hljs-deletion,
        >|    .hljs-link {
        >|     color: #cc6666
        >|    }
        >|
        >|    /*color: fg_green*/
        >|    .hljs-string,
        >|    .hljs-doctag,
        >|    .hljs-addition,
        >|    .hljs-regexp,
        >|    .hljs-selector-attr,
        >|    .hljs-selector-pseudo {
        >|      color: #b5bd68;
        >|    }
        >|
        >|    /*color: fg_purple*/
        >|    .hljs-attribute,
        >|    .hljs-code,
        >|    .hljs-selector-id {
        >|     color: #b294bb;
        >|    }
        >|
        >|    /*color: fg_blue*/
        >|    .hljs-keyword,
        >|    .hljs-selector-tag,
        >|    .hljs-bullet,
        >|    .hljs-tag {
        >|     color: #81a2be;
        >|    }
        >|
        >|    /*color: fg_aqua*/
        >|    .hljs-subst,
        >|    .hljs-variable,
        >|    .hljs-template-tag,
        >|    .hljs-template-variable {
        >|      color: #8abeb7;
        >|    }
        >|
        >|    /*color: fg_orange*/
        >|    .hljs-type,
        >|    .hljs-built_in,
        >|    .hljs-builtin-name,
        >|    .hljs-quote,
        >|    .hljs-section,
        >|    .hljs-selector-class {
        >|      color: #de935f;
        >|    }
        >|
        >|    .hljs-emphasis {
        >|      font-style: italic;
        >|    }
        >|
        >|    .hljs-strong {
        >|      font-weight: bold;
        >|    }
        >|    </style>
        >|
        >|    <script src="http://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.12.0/build/highlight.min.js"></script>
        >|
        >|    <script type="text/javascript">
        >|
        >|      var allids = ${#allids#};
        >|
        >|      function highlightCode() {
        >|        console.log('starting!');
        >|        var baselang_divs = document.getElementsByClassName('baselang');
        >|        for (var i = 0; i < baselang_divs.length; ++i) {
        >|          var div = baselang_divs[i];
        >|          console.log('Highlighting ' + div.id);
        >|          hljs.highlightBlock(div);
        >|        }
        >|        console.log('finished!');
        >|      }
        >|
        >|      function tv(id) {
        >|        // Toggle visibility of node with given id.
        >|        var node = document.getElementById(id);
        >|        if (node) {
        >|          // console.log('Toggling ' + id + ': "' + node.style.display + '"');
        >|          // console.log('Toggling ' + id);
        >|          var display = node.style.display;
        >|          if ((display == 'block') || (display == '')) {
        >|            node.style.display = 'none';
        >|          } else {
        >|            node.style.display = 'block';
        >|          }
        >|        } else {
        >|          console.log('ERROR: Failed to find node with id ' + id);
        >|        }
        >|        var enode = document.getElementById(id + ':e');
        >|        if (enode) {
        >|          // console.log('enode color = ' + enode.style.color);
        >|          var color = enode.style.color;
        >|          enode.style.color = ((color == 'black')||(color=='')) ? 'red' : 'black';
        >|        }
        >|      };
        >|
        >|      function tlist(ids) {
        >|        for (var i = 0; i < ids.length; ++i) { tv(ids[i]); }
        >|      }
        >|
        >|      function sv(id) {
        >|        // Set visibility of node with given id.
        >|        var node = document.getElementById(id);
        >|        if (node) {
        >|          node.style.display = 'block';
        >|        } else {
        >|          console.log('ERROR: Failed to find node with id ' + id);
        >|        }
        >|        var enode = document.getElementById(id + ':e');
        >|        if (enode) {
        >|          enode.style.color = 'black';
        >|        }
        >|      };
        >|
        >|      function slist(ids) {
        >|        for (var i = 0; i < ids.length; ++i) { sv(ids[i]); }
        >|      }
        >|
        >|      function uv(id) {
        >|        // Unset visibility of node with given id.
        >|        var node = document.getElementById(id);
        >|        if (node) {
        >|          node.style.display = 'none';
        >|        } else {
        >|          console.log('ERROR: Failed to find node with id ' + id);
        >|        }
        >|        var enode = document.getElementById(id + ':e');
        >|        if (enode) {
        >|          enode.style.color = 'red';
        >|        }
        >|      };
        >|
        >|      function ulist(ids) {
        >|        for (var i = 0; i < ids.length; ++i) { uv(ids[i]); }
        >|      }
        >|
        >|      window.onload = highlightCode;
        >|    </script>
        >|""")

      /# TODO(wmh): Temporary hack. The per-construct color mapping should
      /# be obtained from the current Context and its ConsInfo instances.
      cls.ConstructColorMap = {
        'class': 'red',  # 255, 0, 0
        'behavior': 'red',
        'method': 'orange',  # 255, 165, 0
        'field': 'orange',
        'lifecycle': 'orange',
      }

      /# Initialized in Initialize(). Replaces all envars with a single
      /# file containing all configuration options.
      cls.CONFIG = None

      /# A collection of constants controlling implementation paths.
      cls.IMPL = {
        /# If true, do create an auto-generated test class for the
        /# auto-generated meta-class of each user-class (and put the test blocks
        /# of meta methods defined within user-classes within this test class).
        /# If false, do NOT create a test class for metaclasses of userclasses,
        /# and put the test blocks of meta methods within the testclass of the
        /# userclass instead.
        'testmetaclass': False,
        /# If true, do create an auto-generated metaclass for the auto-generated
        /# testclass of each userclass. If false, do NOT create such a
        /# metaclass. The latter implies that meta fields and meta methods
        /# are not supported on test classes. In general, static fields/methods
        /# should always suffice for auto-generated test classes, but there
        /# will definitely be places where meta fields/methods will be needed
        /# on explicit test-classes provided by users.
        'metatestclass': False,
      }
    end lifecycle;

    meta
    method Initialize #:
      This method must be invoked before anything else in order to initialize
      class-level state based on command-line flags.
    params:
      var metadata : map = null #:
        Maps metalang id to metalang info.
        TODO(wmh): This arg will be changed/removed when we more fully move
        to defining all metalang info in the associated schema.
    scope:
      if metadata:
        cls.METADATA.update(metadata)

      config, configpath = metax.root.MetaObject.Config()
      cls.CONFIG = config

      /# TODO(wmh): Get this working via Filesystem!
      import os

      errors = []
      if 'bazel' not in config:
        errors.append("Must specify 'bazel' (path to bazel executable)")
      elif not os.path.exists(config['bazel']):
        errors.append('Invalid bazel %s (does not exist)' % config['bazel'])
      if 'src_root' not in config:
        errors.append('Must specify src_root (where Meta is installed)')
      elif not os.path.exists(config['src_root']):
        errors.append('Invalid src_root %s (does not exist)' % config['src_root'])
      if not os.path.exists(config['repository_path']):
        errors.append('Invalid repository_path %s (does not exist)' % config['repository_path'])
      if errors:
        for error in errors:
          print 'ERROR: %s' % error
        print 'Please edit %s and fix the above errors' % configpath
        sys.exit(1)
    end;

    field metalangs : @map<str,MetaLanguageConstruct> #:
      Maps ids/names of metalanguages to MetaLanguage instances.

    field metalang : MetaLanguageConstruct #:
      The meta language that source files are written in. Determines which
      schema file to load, and thus the set of legal constructs.

    field baselang : BaseLanguage #:
      The base language to compile to. For some operations, this is not
      needed, while for others it is.

    field metafiles : @map<str,MetaFile> #:
      Maps both relative and absolute paths to MetaFile instances.

    field metaorder : @vec<MetaFile> #:
      The MetaFile instances in the order they were parsed.

    field classes : @map<ClassConstruct> #:
      Maps fqcn to ClassConstruct, for every class that has had expandMeta
      invoked on it across all MetaFiles in this compiler.
      TODO(wmh): Determine if we should register classes earlier than
      expandMeta.

    field argmap : map #:
      A grouping of args into categories.

    field levels : map #:
      Maps the various compilation dimensions to values
        'off', 'low', 'avg', 'high', 'max'.

    field filesystem : metax.fs.Filesystem #:
      The I/O abstraction object.  All I/O should go thru it.

    field repodir : str #:
      The directory containing the repository.

    field shelldata : map #:
      A collection of key/value pairs used in the implementation of shell-like
      features.  Keys include:
        cwd: str
          A conceptual current working directory, with '/' representing top
          of repo, '/nm' representing a particular top-level namespace,
          '/nm/sp' representing a second-level namespace, etc. Commands like
          'ls' and 'show' provide information across baselangs based on this
          value.

    field metadata : @map #:
      Maps (lower) metalang ids to maps providing information about the
      metalang.
      TODO(wmh): This field can be removed now that MetaLanguageConstruct
      and BaseLanguageConstruct exist ... everything about a metalang is
      specifiable in its schema file (although we need to figure out how
      to map constructs to class in the transitory period during which they
      are defined separately ... at some point we'll be able to put the
      definitions directly into the 'scope:' attribute of the constructs in
      the schema file (allowing users to extend the language by modifying
      the schema) but that is a ways away.

    lifecycle params:
      var metal : str = 'Oopl';
      var basel : str = null;
      var rootdir : str = null #:
        The directory that metadir is relative to. Normally null, in which
        case the current dir is used. This works if current dir contains
        the meta files being parsed. An explicit value can be passed in,
        for example, unit tests.
      var metadir : str = null #:
        The path, relative to rootdir, within which the meta repository resides.
        If this matches metax.c.SUFFIX, it is treated specially in various
        places in the codebase.
      var kind : str = null #:
        The kind of filesystem to use. One of the legal values of the
        metax.c.Filesystem.kind field ('disk', 'memory', 'emulate'). If null,
        established based on value of --inmemory.
      var repodir : str = null #:
        The directory containing the repository. If null, obtained from the
        global config.
    scope:
      cls = self.__class__
      flags = metax.root.MetaObject.CLI()
      if flags:
        optimize_level = flags.optimize_level
        metadir = flags.metadir
        inmemory = flags.inmemory
      else:
        optimize_level = 'high'
        metadir = '.meta2'
        inmemory = False

      levels = {
        'warn': 'max',
        'debug': 'max',
        'optimize': optimize_level if flags else 'off',
        'profile': 'off',
        'inline': 'off',
      }
      self.metalangIs(None)

      /# Save the repodir
      /#  - the repositoryPath() method checks if this is null and if so,
      /#    obtains a value based on METAREP.
      /#  - lazy evaluation done because unittests that rely on it need to
      /#    invoke test.fixenv() first ... most tests do not rely on it, so
      /#    we don't force them all to fixenv.
      self.repodirIs(repodir)

      /# Create the filesystem.
      /#  - TODO(wmh): Add some kind of flag support for turning on 'emulate'.
      /#  - Do we want to replace --inmemory with --iokind?
      if metadir is None:
        metadir = metadir
        if metadir == '.meta':
          metadir = '.meta' + metax.c.NEWSUFFIX
      if kind is None:
        kind = 'memory' if inmemory else 'disk'
      fs = metax.fs.Filesystem(kind=kind, metadir=metadir, rootdir=rootdir)
      self.filesystemIs(fs)

      /# Every compiler needs access to the Meta(Meta) language, so we load it
      /# up first.
      metameta = self.metalangNamed('meta')

      /# Now create the Meta(L) language that this compiler is parsing source
      /# files for (inherits, directly or indirectly, from metameta).
      metalang = self.metalangNamed(metal)
      if not metalang:
        raise metax.root.Error('Unknown MetaLanguage %s' % metal)

      self.metalangIs(metalang)
      self.levelsIs(levels)


      /# The baselang doesn't need to be set upon creation, but will be
      /# needed for actions involving expansion and compilation.
      /#  - if the metalang in question doesn't have baselangs, the basel
      /#    is completely ignored (e.g. Meta(Meta)).
      if basel and metalang.baselangs():
        baselang = metalang.baselangNamed(basel)
        if not baselang:
          raise metax.root.Error(
            'Unknown BaseLanguage %s for %s' % (basel, metal))
        self.baselangIs(baselang)
      else:
        self.baselangIs(None)

      /# Initialize the shelldata.
      self.shelldataIs({
        'cwd': '/',
      })

    end lifecycle;

    method cli : metax.cli.Values #:
      The command-line flags and args.
    scope:
      return metax.root.MetaObject.CLI()
    end method cli;

    method updateCLI #:
      Updates the CLI with a new Command instance.

      This should rarely be needed, as the global CLI instance is meant
      to represent the command-line.  However, for interactive shells, the
      Command is updated each time a new command is entered at the shell
      prompt.

      TODO(wmh): Decide whether the interactive shell should maintain its
      own metax.cli.Values() instance so that the global instance remains
      pinned to the command line values.
    params:
      var command : metax.cli.Command #:
        The newly instantiated Command instance.  This should rarely
    scope:
      self.cli()._command_Is(command)
    test:
    end method updateCLI;

    method registerClass #:
      Register an expanded class with myself.
    params:
      var klass : ClassConstruct;
    scope:
      fqn = klass.fqn()
      classes = self.classes()
      if fqn in classes and classes[fqn] is not klass:
        /#raise Error(
        print 'ERROR: ' + (
          'Attempt to double register class %s (%s vs %s)' %
          (fqn, id(klass), id(classes[fqn])))
      classes[fqn] = klass
    test:
    end method registerClass;

    method fs : metax.c.Filesystem #:
      The filesystem wrapper.
    scope:
      return self.filesystem()
      /# return self.__class__.Filesystem()
    end method fs;

    method metaRoot : str #:
      Obtain the root directory for Meta.
    scope:
      fs = self.fs()
      rootdir = Compiler.CONFIG.get('src_root', None)
      if not rootdir or not fs.exists(rootdir):
        raise Error('Failed to find <<src__root>> %s' % rootdir)
      return rootdir
    test:
      _, _, _, metaoopl = test.cachedInfo()
      test.fixenv()
      rootdir = metaoopl.metaRoot()
      test.iseq(metax.c.Compiler.CONFIG['src_root'], rootdir)
    end method metaRoot;

    method metaPath : str #:
      Obtain a path relative to the meta root.
    params:
      multi var subpaths : vec;
    scope:
      fs = self.fs()
      return fs.join(self.metaRoot(), *subpaths)
    test:
      _, _, _, metaoopl = test.cachedInfo()
      test.fixenv()
      fs = metaoopl.fs()
      rootdir = metax.c.Compiler.CONFIG['src_root']
      test.iseq(
        rootdir + '/oopl/python/meta/test.py',
        metaoopl.metaPath('oopl', 'python', 'meta', 'test.py'))
    end method metaPath;

    method mapPath : str #:
      Obtain the .map variant of given path.
    params:
      var path : str;
    scope:
      fs = self.fs()
      dirname, basename = fs.split(path)
      if basename[0] != '.':
        basename = '.' + basename
      /# We used to return /a/.b.map for /a/b.py or /a/b.cc, but
      /# now we return /a/.b.py.map and /a/.b.cc.map and /a/.b.h.map
      /# so that we have separate map files for b.cc and b.h.
      return fs.join(dirname, basename + '.map')
    test:
      _, _, _, metaoopl = test.cachedInfo()
      test.iseq(
        '/some/rep/a/.b.py.map', metaoopl.mapPath('/some/rep/a/b.py'))
    end method mapPath;

    method repositoryPath #:
      Obtain the path to the meta repository.
    scope:
      result = self.repodir()
      if result is None:
        cls = self.__class__
        fs = self.fs()
        result = Compiler.CONFIG['repository_path']
        self.repodirIs(result)
        /# Disabling until unittests can create fake filesystems.
        /#if not fs.exists(result):
        /#  raise Error('Failed to find meta repository "%s"' % result)
      return result
    test:
      /# TODO(wmh): Get this working.
      _, _, _, metaoopl = test.cachedInfo()
      test.fixenv()
      path = metaoopl.repositoryPath()
      expected = metax.c.Compiler.CONFIG['repository_path']
      test.iseq(expected, path)
    end method repositoryPath;

    method workspaceDirectory : str #:
      The directory containing the baselang-specific WORKSPACE.
      This is the directory from which all unittesting code should be invoked
      (implicitly via bazel, explicitly for raw tests).
    scope:
      return self.fs().join(self.repositoryPath(), self.basePath())
    test:
    end method workspaceDirectory;

    method verifyDirectory : bool #:
      Ensure the initial directory is set up.
    params:
      var fp : ostream = out #:
        Where to write diagnostic information.
      var metadir : str = null #:
        The metadir to verify. If null, obtained from state.
    scope:
      result = True
      if metadir is None:
        flags = self.cli()
        metadir = flags.metadir
      assert '/' not in metadir
      repository_path = self.repositoryPath()
      special_metadir = metax.c.SUFFIX
      fs = self.fs()

      def Print(msg):
        if fp: fp.write(msg + '\n')

      if not fs.exists(repository_path):
        Print(
          'ERROR: %s does not exist ... create as directory' % repository_path)
        result = False

      elif fs.exists(metadir):
        /# The metadir directory exists.
        if metadir == special_metadir:
          /# The metadir directory must be a symlink to the official repository.
          if not fs.islink(metadir):
            Print(
              'ERROR: %s must be a symlink to %s' % (metadir, repository_path))
            result = False
          else:
            link = fs.readlink(metadir)
            if link != repository_path:
              Print(
                'ERROR: %s must be a symlink to %s not %s' %
                (metdir, repository_path, link))
              result = False
        else:
          /# Note the special metadir ... must be a directory.
          if not fs.isdir(metadir):
            Print('ERROR: %s must be a directory' % metadir)
            result = False
      else:
        /# The metadir subdir of the current directory does not exist.
        if metadir == special_metadir:
          /# Create a symlink to the repository.
          Print(
            'NOTE: Created symlink from %s to %s' % (metadir, repository_path))
          fs.symlink(repository_path, metadir)
        else:
          /# Create a directory
          Print('NOTE: Created %s' % metadir)
          fs.mkdir(metadir, mode=0755)

      return result
    end method verifyDirectory;

    method bootstrapContext : Context #:
      Obtain a Context capable of parsing a schema file.

      Creates a Context populated with the ConsInfo instances needed to
      parse a schema file.

      This method should be updated any time src/schema/meta/schema.meta is
      modified.
    scope:
      cls = self.__class__
      context = cls.BootstrapContext()
      context.compilerIs(self)
      return context
    test:
      test.basics()
      bootstrap_context = test.compiler.bootstrapContext()
      test.iseq(7, len(bootstrap_context.consmap()))

      /# We verify the bootstrapContext has all the same Construct/Attribute
      /# definitions as the actual Meta(Meta) schema.
      _, schema, schema_context, _ = test.cachedInfo(metal='meta')
      bfp = test.newStr()
      bootstrap_context.metafileIs(schema_context.metafile())
      bootstrap_context.show(fp=bfp)
      sfp = test.newStr()
      schema_context.show(fp=sfp)
      test.iseqtext(sfp.getvalue(), bfp.getvalue())
    end method bootstrapContext;

    meta
    method BootstrapContext : Context #:
      Obtain a Context capable of parsing a schema file.

      Creates a Context populated with the ConsInfo instances needed to
      parse a schema file.

      This method should be updated any time src/schema/meta/schema.meta is
      modified.
    scope:
      clsmap = {
        'MetaLanguage': MetaLanguageConstruct,
        'Construct': ConstructConstruct,
        'Template': TemplateConstruct,
        'Attribute': AttributeConstruct,
        'FeatureValue': FeatureValueConstruct,
        'File': FileConstruct,
        'BaseLanguage': BaseLanguageConstruct,
      }
      childmap = {
        'File': None,
        'MetaLanguage': ['Construct', 'BaseLanguage'],
        'Construct': ['Attribute', 'Template'],
        'Attribute': ['FeatureValue'],
        'BaseLanguage': None,
      }

      /# Add some attributes to all meta-level constructs:
      /#   primary
      /#   comment:
      /#   config:
      empty = '<empty>'
      consmap = {}
      for cons, construct_class in clsmap.iteritems():
        consinfo = ConsInfo(
          cons,
          'word' if cons in ('Attribute', 'File', 'FeatureValue', 'Template')
          else 'id',
          construct_class)
        consmap[cons] = consinfo
        consinfo.registerSecondary('comment:', 'simple', empty, aliases=['#:'])
        if cons not in ('FeatureValue', 'Template'):
          consinfo.registerSecondary(
            'config:', 'complex', empty, children=childmap[cons])

      /# MetaLanguage
      consmap['MetaLanguage'].registerSecondary('parent', 'xid', empty)
      consmap['MetaLanguage'].registerSecondary('name', 'word', '<required>')
      consmap['MetaLanguage'].registerSecondary('toplevel', 'enum', empty)
      consmap['MetaLanguage'].registerSecondary('color', 'word', empty)
      consmap['MetaLanguage'].registerSecondary(
        'scope:', 'complex', empty, aliases=['::'])

      /# Construct
      consmap['Construct'].registerFeature(
        'presence',
        values={'abstract': None, 'concrete': None},
        default='concrete')
      consmap['Construct'].registerSecondary(
        'parent', 'xid', empty, aliases=['<'])

      /# Template
      consmap['Template'].registerSecondary(
        'scope:', 'simple', empty, aliases=['::'])

      /# Attribute
      consmap['Attribute'].registerFeature(
        'kind',
        values={fk: None for fk in ('undef', 'feature', 'primary', 'secondary')},
        default='undef')
      consmap['Attribute'].registerFeature(
        'key',
        values={fk: None for fk in ('nokey', 'showkey', 'aliaskey')},
        default='showkey')
      consmap['Attribute'].registerFeature(
        'value',
        values={fk: None for fk in ('noval', 'userval', 'showval')},
        default='showval')
      consmap['Attribute'].registerSecondary(
        'default', 'word', empty, aliases=['='])
      consmap['Attribute'].registerSecondary(
        'type', 'word', empty, aliases=[':'])
      consmap['Attribute'].registerSecondary('children', 'enum', empty)
      consmap['Attribute'].registerSecondary('aliases', 'enum', empty)
      consmap['Attribute'].registerSecondary('autokey', 'str', empty)
      consmap['Attribute'].registerSecondary('replacer', 'word', empty)
      consmap['Attribute'].registerSecondary('delim', 'str', empty)

      /# FeatureValue
      consmap['FeatureValue'].registerSecondary('aliases', 'enum', empty)

      /# File
      consmap['File'].registerSecondary(
        'scope:', 'complex', empty, aliases=['::'])

      /# BaseLanguage
      consmap['BaseLanguage'].registerSecondary('name', 'word', '<required>')
      consmap['BaseLanguage'].registerSecondary('suffixes', 'enum', empty)
      consmap['BaseLanguage'].registerSecondary(
        'scope:', 'complex', empty, aliases=['::'])

      context = Context(None, consmap, None, None)
      return context
    test:
      bootstrap_context = metax.c.Compiler.BootstrapContext()
      test.iseq(7, len(bootstrap_context.consmap()))
    end method BootstrapContext;

    method bootstrap : MetaLanguageConstruct #:
      Bootstrap the Meta parsing infrastructure.

      In order to parse a .meta file, we need to have a Context identifying
      the legal constructs available in the meta-language that the .meta file
      is implemeted in.

      In order to obtain a Context containing all legal constructs available in
      a meta language, we need to parse the src/schema/<metalang>/schema.meta
      file (which is defined using constructs from Meta(Meta)). This involves
      a circularity ... we need to parse a file in order to parse that file.

      To bootstrap the process, we can manually define the Construct instances
      described in src/schema/meta/schema.meta, and use those manually defined
      Constructs to reparse src/schema/meta/schema.meta, after which we are
      capable of parsing any schema file, and thus any Meta language.

      This method creates ConsInfo instances to represent the constructs in
      Meta(Meta) ... MetaLanguage, Construct, Attribute, FeatureValue and File ... and
      uses them to parse the src/schema/<metalang>/schema.meta file.
    scope:
      /# Now parse <<src_root>>/src/schema/meta/schema.meta
      context = self.bootstrapContext()
      metapath = metax.root.Object.Resource(
        'metameta', fqn='metax.c.MetaLanguageConstruct')
      metafile = MetaFile(metapath, self)
      /#metafile.debuglevelIs(4)
      file_construct = metafile.parseMeta(context)
      scope = file_construct.rawattr('scope:')
      schema = scope.value()[0]
      return schema
    test:
      _, _, _, metac = test.cachedInfo(metal='meta')
      schema = metac.bootstrap()
      /#schema.write()
    end method bootstrap;

    method metalangNamed : MetaLanguageConstruct #:
      Obtain the MetaLanguageConstruct instance specified by a name or id.

      Returns a cached instance if present, else parses the schema file
      associated with the specified metalang.
    params:
      var nori : str #:
        The name (or id) of a Meta Language.
    scope:
      cls = self.__class__
      metalangs = self.metalangs()
      result = metalangs.get(nori, None)
      can = nori.lower()

      if result is None:
        metadata = cls.METADATA.get(can, None)
        if not metadata:
          print cls.METADATA.keys()
          raise Error('Unknown metalang %s' % can)

        mlparent = metadata['parent']
        id = can
        name = metadata['name']
        toplevel = metadata['toplevel']
        construct_classes = metadata['constructs']
        baselang_classes = metadata['baselangs'].values()
        basesels = metadata['basesels']

        /# Parse the schema file associated with the language.
        if id != 'Test':
          fs = self.fs()
          metapath = metadata.get('schema', None)
          if not metapath:
            metapath = metax.root.Object.Resource(
              'meta' + id, fqn='metax.c.MetaLanguageConstruct')
          /# print 'LOADING %s' % fs.realpath(metapath)
          with fs.open(metapath, 'r') as fp:
            text = fp.read()
          bootstrap_context = self.bootstrapContext()
          metafile = self.parseMeta(
            metapath, text=text, context=bootstrap_context, is_schema=True)
          if metafile.hasErrors(show=True):
            raise Error('Failed to parse %s' % metapath)
          file = metafile.construct()
          scope = file.rawattr('scope:')
          value = scope.value()
          if len(value) != 1:
            raise Error('Found %d constructs in %s' % (len(value), metapath))
          metalang = value[0]
          if not isinstance(metalang, MetaLanguageConstruct):
            raise Error('Found %s not MetaLanguageConstruct' % metalang.__class__)

          /# Obtain the name, parent and toplevel attributes and store them in
          /# fields.
          /#   - name is required word
          /#   - toplevel is required enum (e.g. list of str)
          /#   - parent is required str except for Meta(Meta).
          name2 = metalang.attrval('name')
          assert name2 == name, 'name "%s" != "%s"' % (name2, name)
          toplevel2 = metalang.attrval('toplevel')
          assert toplevel2 == toplevel, 'For Meta(%s), toplevel "%s" != "%s"' % (name, toplevel2, toplevel)
          mlparent2 = metalang.attrval('parent', default=None)
          assert mlparent2 == mlparent, 'For Meta(%s), mlparent "%s" != "%s"' % (name, mlparent2, mlparent)

        if mlparent:
          if mlparent not in metalangs:
            raise Error(
              'Meta(%s) inherits from Meta(%s) which does not exist' %
              (name, mlparent))
          metalangparent = metalangs[mlparent]
        else:
          metalangparent = None

        /# print 'id=%s name=%s metalangparent=%s toplevel=%s' % (id, name, metalangparent, toplevel)

        metalang.nameIs(name)
        metalang.metalangparentIs(metalangparent)
        metalang.toplevelIs(toplevel)
        metalang.postCreationInitialization()

        /# Add the construct-to-class mapping for Meta(Meta)
        /#  - TODO(wmh): Every Construct construct has an associated 'class'
        /#    construct (in Meta(Oopl)), and the scope of the class is the
        /#    scope of the Construct.
        /#  - Instead of having the various construct classes defined here
        /#    in parser.meta, the code should be moved into the schema file.
        for construct_name, construct_class in construct_classes.iteritems():
          metalang.registerConstructClass(construct_name, construct_class)

        /# Add any specified basesels.
        /#  - TODO(wmh): This is a hack for Meta(Meta). Normally, each
        /#    BaseLanguage that is registered with a MetaLanguage adds
        /#    one or more suffixes, but Meta(Meta) doesn't really need
        /#    to define any BaseLanguages. Clean this up.
        for basesel in basesels:
          metalang.basesels()[basesel] = None

        /# Create the root Context instance associated with this MetaLanguage.
        context = self.metalangToContext(metalang, metafile)
        metalang.contextIs(context)

        /# Add the baselangs
        /#  - TODO(wmh): Instead of explicitly enumerating baselangs, we should
        /#    parse the 'config:' block of the metalang looking for BaseLanguage
        /#    instances.
        for baselang_class in baselang_classes:
          baselang = baselang_class(None, None, context)
          /# baselang.metalangIs(metalang)
          /# baselang.postCreationInitialization(metalang=metalang, name=)
          metalang.registerBase(baselang)


        /# Register metalang in cache.
        metalangs[metalang.id()] = metalang
        metalangs[metalang.id().lower()] = metalang
        metalangs[metalang.name()] = metalang

        result = metalang

      return result

    test:
      _, _, _, metac = test.cachedInfo(metal='meta')
      metameta = metac.metalangNamed('meta')
      metaoopl = metac.metalangNamed('oopl')
      test.issame(metaoopl.metalangparent(), metameta)
      metameta2 = metac.metalangNamed('meta')
      test.issame(metameta2, metameta)
      metaoopl2 = metac.metalangNamed('oopl')
      test.issame(metaoopl2, metaoopl)

      test.iseqvec(test.metameta_consids, sorted(metameta._consmap))
      test.iseqvec(test.metaoopl_consids, sorted(metaoopl._consmap))
    end method metalangNamed;

    method metalangToContext : Context #:
      Given a MetaLanguageConstruct, produce a Context instance.

      TODO(wmh): This needs to be generalized. It should not take a
      MetaLanguageConstruct as input, but rather a ComplexBlock of Construct
      instances (so that it can be applied to 'config:' blocks too).
      It should also pass in a Context (null if we are defining the
      top-level context) that is used to establish defaults.
    params:
      var metalang : MetaLanguageConstruct #:
        The metalang.
      var metafile : MetaFile #:
        The metafile storing the metalang file.
    scope:
      debug = False

      def AttrVal(attribute_construct, key, default=REQUIRED):
        """Obtain an attribute value.

        Obtains the value of the attribute within attribute_construct
        identified by 'key'. If not present locally, look in parent
        before failing.

        Args:
          attribute_construct: AttributeConstruct
          key: str
          default: any
        """
        attr = attribute_construct.rawattr(key, default=None)
        if attr is None:
          /# Not present locally, but parent Constructs may define the same
          /# Attribute.
          parent = attribute_construct
          while parent and not attr:
            parent = self.attributeParent(parent)
            if parent:
              attr = parent.rawattr(key, default=None)
        if attr is None:
          result = default
          if default is REQUIRED:
            raise Error(
              'Failed to find attribute "%s" in %s' %
              (key, attribute_construct.path()))
        else:
          result = attr.value()
        return result

      /# We maintain mappings from Construct ids to ComplexBlock instances,
      /# representing the 'config:' block of each Construct. This is used
      /# to perform lookup in Construct parents.
      configmap = {}
      consmap = {}

      /# This metalang starts with all constructs defined in the parent
      /# Meta class.
      metalang_parent = metalang.rawval('parent', default='meta')
      if metalang_parent != metalang_parent.lower():
        print 'WARNING: metalang uid %s not %s' % (metalang_parent, metalang_parent.lower())

      if metalang_parent == 'meta':
        /# We can add the ConsInfo instances from bootstrapContext instead of
        /# having to parse the Meta(Meta) metalang.
        bootstrap_context = self.bootstrapContext()
        for cons, consinfo in bootstrap_context.consmap().iteritems():
          consmap[cons] = consinfo
      else:
        raise Error('Not yet supporting MetaLang parent %s' % metalang_parent)

      /# The returned Context is the root of the lexical chain of Contexts for
      /# this metalang. As such, there is no parent Context, and no need for a
      /# MetaFile. Note that MetaFile.parseMeta() will invoke subclone() on this
      /# instance to create a metafile-specific Context instance.
      /#metalang.write()

      for construct in metalang.rawattr('config:').value():

        if debug:
          print construct.kindid()

        if construct.kind() == 'Construct':
          kind = construct.id()
          presence = construct.rawval('presence', 'concrete')
          config = construct.rawattr('config:')
          configmap[kind] = config

          /# Establish the class implementing this construct.
          /#
          /# TODO(wmh): For now, this is based on
          /# MetaLanguageConstruct.consmap() and explicit registration via
          /# MetaLanguageConstruct.registerConstructClass(), but should be
          /# determined by the 'scope:' block of Construct instances found
          /# anywhere in the config: chain.  When that happens, we can remove
          /# consmap(), registerConstructClass() and getConstructClass().
          construct_class = metalang.getConstructClass(kind)

          if presence == 'abstract':
            /# The current construct is abstract, so it doesn't produce any
            /# attributes directly. However, other constructs may inherit from
            /# it, in which case the constructs found here will be used to
            /# provide default values.
            continue

          /# Establish if this Construct has a conceptual (not lexical) parent
          /# from which Attributes are inherited.
          parent_name = construct.rawval('parent', None)
          if parent_name is not None:
            /# This Construct construct inherits attributes from parent_name
            parent_config = configmap[parent_name]
          else:
            parent_config = None

          primary = config.cons(kind, default=None)
          if primary is None:
            raise Error(
              'Construct %s does not contain a primary %s attribute' %
              (kind, kind))

          ptype = primary.rawattr('type').value()
          consinfo = ConsInfo(kind, ptype, construct_class)
          consmap[kind] = consinfo
          for attribute in config.value():
            if attribute.kind() == 'Template':
              template = attribute.rawattr('scope:').valueAsStr()
              consinfo.registerTemplate(attribute.id(), template)
            else:
              if debug:
                print '  ' + attribute.kindid()
              aconfig = attribute.rawattr('config:', default=None)
              if aconfig:
                for featval in aconfig.value():
                  if debug:
                    print '    ' + featval.kindid()

              if parent_config:
                parent_attribute = parent_config.cons(attribute.id(), default=None)
                pa = self.attributeParent(attribute)
                assert parent_attribute is pa
              else:
                parent_attribute = None

              akey = attribute.id()
              akind    = AttrVal(attribute, 'kind')
              default  = AttrVal(attribute, 'default')
              type     = AttrVal(attribute, 'type')
              key      = AttrVal(attribute, 'key',      default=None)
              value    = AttrVal(attribute, 'value',    default=None)
              children = AttrVal(attribute, 'children', default=None)
              aliases  = AttrVal(attribute, 'aliases',  default=None)
              autokey  = AttrVal(attribute, 'autokey',  default=None)
              replacer = AttrVal(attribute, 'replacer', default=None)
              comment  = AttrVal(attribute, 'comment',  default=None)

              /# print '%s is %s : %s = %s' % (construct.kindfqn(), akey, type, default)

              keyopt = False
              valopt = False
              autokey = None

              if False and debug:
                print (
                  '    akind=%s key=%s type=%s default=%s aliases=%s keyopt=%s valopt=%s autokey=%s' %
                  (akind, akey, type, default, aliases, keyopt, valopt, autokey))

              if akind == 'feature':
                /# consinfo.registerFeature()
                featvals = EnumAttribute.StrToEnum(type)
                values = {fv: None for fv in featvals}
                consinfo.registerFeature(
                  akey, values=values, default=default, aliases=aliases, delim=None)
              elif akind == 'primary':
                if default == '<auto>':
                  /# The primary key is optional.
                  /# consinfo.primary() maps primary tokens all to the same map.
                  consinfo.primary()[kind]['valopt'] = True
              elif akind == 'secondary':
                /# if default == '<special>': default = None
                consinfo.registerSecondary(
                  akey, type=type, default=default, aliases=aliases,
                  keyopt=keyopt, valopt=valopt, autokey=autokey, children=children)

        elif construct.kind() == 'BaseLanguage':
          pass

        else:
          print '********* WARNING: Not processing %s' % construct.kindid()

      context = Context(None, consmap, self, metafile)

      return context
    test:
      /# cachedInfo() invokes compiler.metalang() which invokes
      /# compiler.metalangToConstruct().
      _, metalang, context, compiler = test.cachedInfo(metal='meta')
      test.iseq(7, len(context.consmap()))

      /# We compare the context produced from metalangToContext() with
      /# bootstrapContext(). They should be identifical ... if not, it means the
      /# definition of Meta(Meta) in
      /#   <<src_root>>/src/schema/meta/schema2.meta
      /# has diverged from the definition of Meta(Meta) in
      /#   metax.c.Compiler.bootstrapContext()
      /# The latter code needs to be updated.
      bootstrap_context = compiler.bootstrapContext()
      bfp = test.newStr()
      bootstrap_context.metafileIs(context.metafile())
      bootstrap_context.show(fp=bfp)
      fp = test.newStr()
      context.show(fp=fp)
      test.iseqtext(fp.getvalue(), bfp.getvalue())

      /# Now we obtain the context for Meta(Oopl)
      metax.c.Debug = True
      _, metalang, context, compiler = test.cachedInfo()
      test.iseqvec(
        test.metaoopl_consids2,
        sorted(context.consmap()))
      consgroup = context.legalInfo(['method', 'field'])
      /# consgroup.show()
      /# context.show()
    end method metalangToContext;

    method attributeParent : AttributeConstruct #:
      Obtain the parent Attribute of a given Attribute.
    params:
      var attribute_construct : AttributeConstruct;
    scope:
      /# Obtain the Construct within which the Attribute resides.
      construct_construct = attribute_construct.parent().parent()
      /# Check if the Construct has a 'parent'
      parent_name = construct_construct.rawval('parent', None)
      if parent_name:
        /# Find the parent, which must exist within the 'config:' block
        /# that the Construct resides within.
        parent_construct = construct_construct.parent().cons(
          parent_name, default=None)
        if not parent_construct:
          raise Error(
            '%s has parent %s which does not exist' % (
              construct_construct.id(), parent_name))
        /# Obtain the AttributeConstruct within parent_construct that matches
        /# attribute_construct.
        config = parent_construct.rawattr('config:')
        result = config.cons(attribute_construct.id(), default=None)
      else:
        /# No parent.
        result = None
      return result
    test:
      _, metalang, _, compiler = test.cachedInfo(basel='python')
      /# In Meta(Oopl), Construct 'class' inherits from '_oopl_' and
      /# has Attribute 'comment:'.
      ac = metalang.parent().child('/oopl@config/class@config/comment:')
      test.iseq('/oopl@config/class@config/comment:', ac.path())
      acp = compiler.attributeParent(ac)
      test.iseq('/oopl@config/_oopl_@config/comment:', acp.path())
      test.isnull(compiler.attributeParent(acp))

      /# In Meta(Oopl), Construct 'field' inherits from '_classic_' which
      /# inherits from '_oopl_', and has Attribute 'comment:'.
    end method attributeParent;

    method basePath : str #:
      Obtain the path within which to write a BaseFile instance.
    params:
      var fqn : str = null #:
        An fqn to convert to a subpath.
      var prefix : str = '' #:
        What to insert before last component of fqn
      var suffix : str = '' #:
        What to insert after last component of fqn
    scope:
      fs = self.fs()
      /#flags = self.cli()
      /#root = fs.join(flags.metadir)
      if fqn:
        parts = fqn.split('.')
        parts[-1] = prefix + parts[-1] + suffix
      else:
        parts = []
      return fs.join(
        self.metalang().id().lower(), self.baselang().id(), *parts)
    test:
      _, _, _, metac = test.cachedInfo(basel='python')
      test.iseq(
        'oopl/python/nm/sp/Class.py',
        metac.basePath('nm.sp.Class', suffix='.py'))
      test.iseq(
        'oopl/python/nm/sp/.Class.map',
        metac.basePath('nm.sp.Class', prefix='.', suffix='.map'))
    end method basePath;

    method basePathToMeta : str #:
      Given a baselang path to a namespace or class file, obtain the path of
      the .meta source file associated with it.
    params:
      var basepath : str #:
        The baselang path.
    scope:
      result = None
      fs = self.fs()

      /# map_path = fs.join(
      /#   fs.dirname(basepath), '.' + fs.basename(basepath) + '.map')
      map_path = self.mapPath(basepath)
      if fs.exists(map_path):
        with open(map_path, 'r') as fp:
          result = fp.readline()[:-1]
          assert result.endswith('.meta2'), '%s does not end with .meta2' % result
      return result
    test:
    end method basePathToMeta;

    method loadMapFile : MetaFile #:
      Load a MapFile from disk.

      This method is paired with MapFile.serialize().
    params:
      var path : str #:
        The path to the .path file.
    scope:
      mapping = []
      map_re = Compiler.MAP_RE
      fs = self.fs()
      with fs.open(path, 'r') as fp:
        /# In meta2, the first line contains
        /#   <source>
        /# (where <source> is the source .meta file), and all subsequent lines
        /# contain
        /#   <baseline> <metaline> <fullid>
        /# However,in meta1, the first line contains
        /#   <baseline> <metaline> <fullid> <source>
        /# We support both variants while we are using meta1 to compile the
        /# parser.meta code. When we have parser.meta2 implemented we can
        /# remove the special case code.
        metapath = fp.readline().rstrip()
        parts = metapath.split()
        if len(parts) == 1:
          /# New style
          pass
        elif len(parts) == 4:
          /# Old style
          mapping.append((int(parts[0]), int(parts[1]), parts[2]))
          metapath = parts[3]
        else:
          raise Error('Invalid metapath: %s' % metapath)
        for line in fp:
          m = map_re.match(line)
          if m:
            mapping.append(
              (int(m.group('baseline')),
              int(m.group('metaline')),
              m.group('fullid')))
          else:
            fs.close(fp)
            with fs.open(path, 'r') as fp:
              print fp.read()
            raise Error('Invalid line "%s"' % line)
      result = MapFile(path, metapath, mapping)
      return result
    test:
    end method loadMapFile;

    method parseMeta : MetaFile #:
      Unconditinoally parse a metafile.
    params:
      var path : str #:
        The path to parse. Even if text is provided, path must be also.
      var text : str = null #:
        The text representing the contents of the metafile to parse.
        Provided to support in-memory parsing in situations where
        a filesystem isn't easily available.
      var debuglevel : int = 0 #:
        How much debugging info to print out.
      var context : Context = null #:
        The context to use to parse the metafile. This is normally null,
        in which case the context associated with the metalang is used. If
        that too is null, we use self.bootstrapContext().
      var is_schema : bool = false #:
        True if we are parsing a schema file.
    scope:
      /# We canonicalize the path
      fs = self.fs()
      if fs.exists(path):
        realpath = fs.realpath(path)
        abspath = fs.abspath(realpath)
        if abspath != realpath:
          raise Error(
            'abspath of realpath should equal realpath? %s vs %s' %
            (abspath, realpath))
      else:
        raise Error('Path %s does not exist' % path)
      metafiles = self.metafiles()

      /# (Sometimes) print a warning if we are reparsing
      if True:
        if path in metafiles:
          print 'WARNING: Reparsing %s (path)' % path
        elif realpath in metafiles:
          print 'WARNING: Reparsing %s (realpath)' % path

      /# Unconditionally parse.
      if context is None:
        metalang = self.metalang()
        context = metalang.context()
        if context is None:
          raise Error('Failed to find a context for Meta(%s)' % metalang.name())
      metafile = MetaFile(realpath, self, debuglevel=debuglevel, text=text)
      metafile.parseMeta(context, is_schema=is_schema)

      /# Determine a unique abbrev for this metafile.
      def AbbrevExists(abr):
        return abr in metafiles and metafiles[abr] is not metafile
      abbrev = fs.basename(abspath).replace('.meta2', '').replace('.meta', '')
      abbrev2 = fs.basename(fs.dirname(abspath)) + '_' + abbrev
      if not AbbrevExists(abbrev):
        pass
      elif False and not AbbrevExists(abbrev2):
        abbrev = abbrev2
      else:
        orig = abbrev
        num = 1
        while AbbrevExists(abbrev):
          num += 1
          abbrev = orig + '_' + str(num)
      metafile.abbrevIs(abbrev)

      /# Register variants of the path in metafiles.
      metafiles[path] = metafile
      metafiles[realpath] = metafile
      metafiles[abbrev] = abbrev
      self.metaorder().append(metafile)

      return metafile
    test:
      /# We create standalone compilers instead of using the cached ones to
      /# ensure a full test.

      /# Parse ex1.meta, which is written in Meta(Meta)
      /#_, _, _, metac = test.cachedInfo(metal='meta')
      metac = metax.c.Compiler(metal='meta', basel='stub')
      ex1, scope, construct, _ = test.getMetaFile(
        'meta', 'ex1', context=metac.bootstrapContext(), compiler=metac)
      test.isinst(ex1, metax.c.MetaFile)
      test.isinst(scope, metax.c.ComplexBlock)
      test.isinst(construct, metax.c.MetaLanguageConstruct)

      /# Parse ex2.meta, which is written in Meta(Oopl)
      /# metax.c.Debug = True
      metac = metax.c.Compiler(metal='oopl', basel='python')
      ex2, scope, construct, path = test.getMetaFile(
        'oopl', 'ex2', debuglevel=0, compiler=metac)
      /# Verify there were no errors during parsing
      test.isfalse(ex2.hasErrors(show=True))
      /# Confirm that the canonicalization of the result matches the
      /# input (this assumes the ex2 input is kept in clean form)
      with metac.fs().open(path, 'r') as fp:
        text = fp.read()
      fp = test.newStr()
      construct.write(fp=fp)
      test.iseqtext(text, fp.getvalue())
    end method parseMeta;

    method getMetas : tuple<vec<MetaFile>,int,int> #:
      Parse, expand, translate and compile .meta files (only if not already parsed)
    params:
      var paths : vec<str> #:
        The .meta files to process.
      var debug : bool = false #:
        If true, print out progress.
      var fp : ostream = null #:
        If non-null, write out progress to given stream.
      var expand : bool = true #:
        If false, do not expand (or import or translate or compile)
      var imports : bool = true #:
        If false, do not import (or translate or compile)
      var translate : bool = true #:
        If false, do not translate (or compile)
      var compile : bool = true #:
        If false, do not compile.
    scope:
      errors = 0
      warnings = 0
      metafiles = []
      for path in paths:
        /# metafile, e, w = self.processMeta(
        metafile = self.getMeta(
          path, debug=debug, fp=fp,
          expand=expand, imports=imports, translate=translate, compile=compile)
        errors += len(metafile.errors())
        warnings += len(metafile.warnings())
        metafiles.append(metafile)
      return metafiles, errors, warnings
    end method getMetas;

    method processMeta : tuple<MetaFile,int,int> #:
      Parse, expand, translate and compile a single .meta file.

      Returns:
       0) The MetaFile instance
       1) The number of errors encountered.
       2) The number of warnings encountered.
    params:
      var path : str #:
        The .meta file to process.
      var debug : bool = false #:
        If true, print out progress.
      var fp : ostream = null #:
        If non-null, write out progress to given stream.
      var expand : bool = true #:
        If false, do not expand (or import or translate or compile)
      var imports : bool = true #:
        If false, do not import (or translate or compile)
      var translate : bool = true #:
        If false, do not translate (or compile)
      var compile : bool = true #:
        If false, do not compile.
    scope:
      flags = self.cli()
      context = self.metalang().context()
      errors, warnings = (0, 0)

      /# Parse
      start = time.time()
      metafile = self.parseMeta(
        path, debuglevel=flags.debug, context=context)
      stats = metafile.stats()
      parse_time = time.time() - start
      /# TODO(wmh): Compare parse_time against metafile.stats()['parse'] to
      /# ensure there isn't a big discrepancy.
      if metafile.hasErrors(show=True):
        errors += 1
      elif expand:
        /# Expand
        metafile.expandMeta()
        if metafile.hasErrors(show=True):
          errors += 1
        elif imports:
          /# Import
          metafile.importMeta()
          if metafile.hasErrors(show=True):
            errors += 1
          elif translate:
            /# Translate
            metafile.translateMeta()
            if metafile.hasErrors(show=True):
              errors += 1
            elif compile:
              /# Compile
              metafile.compileMeta()
              if metafile.hasErrors(show=True):
                errors += 1
              if metafile.hasErrors(show=True, category='W'):
                warnings += 1
              metafile.stateIs('complete')
      return metafile, errors, warnings
    test:
    end method processMeta;

    method getMeta : MetaFile #:
      Obtain a metafile, parsing if necessary but using parsed version if
      available.
    params:
      var path : str #:
        The path of the metafile.
      var expand : bool = true #:
        If false, do not expand (or import or translate or compile)
      var imports : bool = true #:
        If false, do not import (or translate or compile)
      var translate : bool = true #:
        If false, do not translate (or compile)
      var compile : bool = true #:
        If false, do not compile.
      var debug : bool = false #:
        If true, print out progress.
      var fp : ostream = null #:
        If non-null, write out progress to given stream.
    scope:
      /# Canonicalize path.
      fs = self.fs()
      if not fs.exists(path):
        raise Error('%s does not exist' % path)
      realpath = fs.realpath(path)

      result = self.metafiles().get(realpath, None)
      if result is None:
        result, _, _ = self.processMeta(
          realpath, debug=debug, fp=fp,
          expand=expand, imports=imports, translate=translate, compile=compile)
      else:
        if result.state() != 'complete':
          /# raise Error(
          /#   'metafile %s has state %s' % (result.path(), result.state()))
          pass
        if debug:
          print 'Used cached %s' % path
      return result
    test:
    end method getMeta;

    method writeSummary #:
      Summarize the status of this MetaFile after parsing/compilation.

      Print out the number of constructs of each kind for each metafile in a
      table (rows are metafiles, columns are construct kinds, cells are integer
      counts).
    params:
      var metafiles : vec<MetaFile> #:
        The metafiles to summarize.
      var fp : ostream = out #:
        Where to write output
      var indent : str = '' #:
        What each line starts with.
    scope:
      fs = self.fs()
      show_counts = True
      show_times = True
      show_files = True

      consmap = {
        'namespace': 'nmsp',
        'behavior': 'beh',
        'class': 'cls',
        'method': 'meth',
        'initializer': 'init',
        'field': 'fld',
        'receiver': 'rcv',
        'category': 'cat',
        'native': 'ntv',
        'accessor': 'acc',
        'remark': 'rem',
        'resource': 'res',
        'command': 'cmd',
      }
      time_titles = [
        ('parse', 't:p'),
        ('expand', 't:e'),
        ('translate', 't:t'),
        /# ('compile', 't:c'),
      ]
      file_titles = [
        ('Lines', '#Lines'),
        ('Bytes', '#Bytes'),
        ('files', '#files'),
        ('lines', '#lines'),
        ('reallines', '#real'),
        ('bytes', '#bytes'),
      ]

      /# TODO(wmh): Once wmh.table has been migrated into a meta library, we
      /# can use it instead of this homegrown approach.  For now, I'm trying to
      /# avoid having meta code rely on any wmh modules.
      totals = {}

      /# Obtain a mapping from metafile name to construct kind to integer
      /# count of number of instances of that construct kind. Also obtain the
      /# set of all construct kinds.
      cset = set()
      data = {}
      filemap = {}
      for metafile in metafiles:
        name = fs.basename(metafile.path()).replace(metax.c.SUFFIX, '')
        output = metafile.constructs()
        data[name] = {kind: len(output[kind]) for kind in output}
        cset.update(output.keys())
        filemap[name] = metafile

      if data:
        /# Print header.
        order = sorted(cset)
        numc = len(order)

        /# Establish how many chars in each row.
        width = 15
        if show_counts:
          width += (numc*(4+1))
        if show_times:
          width += len(time_titles) * (4+1)
        if show_files:
          width += len(file_titles) * (7+1)
        sep = '-' * width + '\n'
        fp.write(sep)

        /# Print the title line
        fp.write('%s%-15s' % (indent, 'File'))
        if show_counts:
          for kind in order:
            abbrev = consmap.get(kind, kind[:4])
            fp.write(' %4s' % abbrev)
            totals[kind] = 0
        if show_times:
          for kind, abbrev in time_titles:
            fp.write(' %4s' % abbrev)
            totals[kind] = 0
        if show_files:
          for kind, abbrev in file_titles:
            fp.write(' %7s' % abbrev)
            totals[kind] = 0
        fp.write('\n')
        fp.write(sep)

        /# Print rows.
        for name in sorted(data):
          metafile = filemap[name]
          filedata = data[name]
          fp.write('%s%-15s' % (indent, name))
          if show_counts:
            for kind in order:
              cnt = filedata.get(kind, 0)
              totals[kind] += cnt
              if cnt:
                fp.write(' %4d' % cnt)
              else:
                fp.write(' %-4s' % '')
          if show_times:
            timestats = metafile.stats()
            for kind, abbrev in time_titles:
              cnt = timestats.get(kind, 0)
              totals[kind] += cnt
              fp.write(' %4.1f' % cnt)
          if show_files:
            filestats = metafile.computeFileStats()
            for kind, abbrev in file_titles:
              cnt = filestats[kind]
              totals[kind] += cnt
              fp.write(' %7d' % cnt)
          fp.write('\n')
        fp.write(sep)

        /# Print total row.
        if len(metafiles) > 1:
          fp.write('%s%-15s' % (indent, 'TOTAL'))
          if show_counts:
            for kind in order:
              fp.write(' %4d' % totals[kind])
          if show_times:
            for kind, abbrev in time_titles:
              fp.write(' %4.1f' % totals[kind])
          if show_files:
            for kind, abbrev in file_titles:
              fp.write(' %7d' % totals[kind])
          fp.write('\n')
          fp.write(sep)
    end method writeSummary;

    method _parseArgs : map #:
      Parse args into categories.

      Returns:
        metafiles: vec<str>
          Paths to .meta2 files that do exist.
        badfiles: vec<str>
          Paths to .meta2 files that don't exist
        fqns: vec<str>
          Fully qualified namespace/class/method names.
        args: vec<str>
          Anything not in one of the above lists.
        details: vec<map>
          This list has the same number of elements as 'args' (unless 'args' is
          empty and implicit is True). Each map contains:
            arg: str
              some arg-specific string (an absolute path if the arg is
              a metafile, the arg itself if it is an fqn or unknown)
            kind: str
              metafile: the arg is a metafile
              badfile: the arg is not a metafile
              fqn: the arg is a namespace[.class[.method]] fqn.
              unknown: the arg type is unknown
            path: str
              For metafiles, this is just the abspath of the metafile path,
              but for fqns it is the path of the namespace identified by the
              fqn.
            construct: Construct
              Only exists if resolve is true
               - for metafiles, is a FileConstruct (a metafile is obtained
                 by calling Compiler.getMeta(), which will parse but NOT
                 expand/translate/compile the metafile if it hasn't already
                 been loaded). Caller must do these things if they are
                 desired.
               - for fqns, it is a NamespaceConstruct or ClassConstruct or
                 MethodConstruct or FieldConstruct as dictated by the fqn.
    params:
      var args : vec<str> #:
        The non-flag args provided on the command line.
      var errors : bool = false #:
        If true, print out meta files that don't exist.
      var implicit : bool = false #:
        If true, assume that no args means 'find all .meta2 files in current
        dir'
      var resolve : bool = false #:
        If true, a valid metafile or fqn is to be resolved into a construct
        (available as third element of the triples in result['pair']). If
    scope:
      fs = self.fs()
      metafile_paths = []
      bad_paths = []
      fqns = []
      other = []
      details = []

      def PathToConstruct(path):
        construct = None
        if resolve:
          metafile = self.getMeta(
            path, expand=False, translate=False, compile=False)
          if metafile.hasErrors(show=True):
            print 'WARNING: Not returning construct from _parseArgs due to errors'
          else:
            construct = metafile.construct()
        return construct

      if not args:
        if implicit:
          for f in fs.listdir(fs.cwd()):
            if f.endswith(metax.c.SUFFIX) and not f.startswith('.'):
              path = fs.abspath(f)
              metafile_paths.append(path)
              details.append({'arg': f, 'path': path, 'kind': 'metafile'})
      else:
        meta_suffix = metax.c.SUFFIX
        for arg in args:
          argplus = arg + '.meta2'
          if arg.endswith(meta_suffix) and fs.exists(arg):
            abspath = fs.abspath(arg)
            metafile_paths.append(abspath)
            construct = PathToConstruct(abspath)
            details.append(
              {'arg': abspath, 'kind': 'metafile', 'construct': construct})
          elif fs.exists(argplus):
            abspath = fs.abspath(argplus)
            metafile_paths.append(abspath)
            construct = PathToConstruct(abspath)
            details.append(
              {'arg': arg, 'path': abspath, 'kind': 'metafile',
               'construct': construct})
          elif arg.endswith(meta_suffix):
            if errors:
              print 'Meta file %s does not exist (ignored)' % arg
            bad_paths.append(arg)
            details.append(
              {'arg': arg, 'path': None, 'kind': 'badfile',
               'construct': None})
          elif '.' in arg:
            /# TODO(wmh): We currently assume that any arg with a dot is a
            /# target, but we need to verify that the associated path
            /# exists before making that assumption.
            target, test_target, final_path, _, _ = self.fqnToTarget(
              arg, debug=False)
            if final_path:
              fqn = arg
              construct = None
              metapath = self.basePathToMeta(final_path)
              if metapath:
                file_construct = PathToConstruct(metapath)
                if file_construct:
                  construct = file_construct.child(fqn)
              fqns.append(fqn)
              details.append(
                {'arg': fqn, 'path': final_path, 'kind': 'fqn',
                 'construct': construct})
            else:
              other.append(arg)
              details.append(
                {'arg': arg, 'kind': 'unknown', 'path': None,
                 'construct': None})
          else:
            other.append(arg)
            details.append((arg, 'unknown', None))
        assert len(details) == len(args), '%s not same size as %s' % (details, args)
      return {
        'metafiles': metafile_paths,
        'badfiles': bad_paths,
        'fqns': fqns,
        'args': other,
        'details': details,
      }
    test:
      /# TODO(wmh): Create a faux filesystem with some valid .meta files and
      /# some missing files.
      _, _, _, compiler = test.cachedInfo()
      res = compiler._parseArgs(
        ['a.meta2', 'b.meta2', 'nm.sp', 'nm.sp.Class', 'nm.sp.Class.meth', 'c.meta'])
      test.iseq(
        {'metafiles': [], 'fqns': [],
         'args': ['nm.sp', 'nm.sp.Class', 'nm.sp.Class.meth', 'c.meta'],
         'badfiles': ['a.meta2', 'b.meta2'],
         'details': [
           {'path': None, 'kind': 'badfile', 'construct': None, 'arg': 'a.meta2'},
           {'path': None, 'kind': 'badfile', 'construct': None, 'arg': 'b.meta2'},
           {'path': None, 'kind': 'unknown', 'construct': None, 'arg': 'nm.sp'},
           {'path': None, 'kind': 'unknown', 'construct': None, 'arg': 'nm.sp.Class'},
           {'path': None, 'kind': 'unknown', 'construct': None, 'arg': 'nm.sp.Class.meth'},
           {'path': None, 'kind': 'unknown', 'construct': None, 'arg': 'c.meta'}
         ]},
        res)
    end method _parseArgs;

    method canonicalize #:
      Canonicalize metafiles
    params:
      var metafile_paths : vec<str> #:
        The paths to metafiles to canonicalize.
      var mode : map = null #:
        See Construct.write() for details on mode semantics.
    scope:
      fs = self.fs()
      flags = self.cli()
      debuglevel = flags.debug

      for metafile_path in metafile_paths:
        /# Parse the metafile.
        metafile = self.parseMeta(metafile_path, debuglevel=debuglevel)
        if metafile.errors():
          print 'Found parse errors for ' + metafile_path
          errors += 1
        else:
          /# Canonicalize the constructs in the MetaFile instance.
          file_cons = metafile.construct()
          new_path = metafile_path.replace(metax.c.SUFFIX, '-new' + metax.c.SUFFIX)
          if fs.exists(new_path):
            print 'ERROR: %s already exists - not replacing' % new_path
            continue

          /# Write a canonicalized version of the file
          fp = fs.open(new_path, 'w')
          first = True
          for construct in file_cons.rawattr('scope:').value():
            if not first:
              fp.write('\n')
            construct.write(fp=fp, mode=mode)
            first = False
          fp.close()

          /# Show a diff of old and new files, and interactively allow user
          /# to replace old with new or not.
          if Compiler.PromptDiff(metafile_path, new_path, kind='delta'):
            backup_path = metafile_path.replace(
              metax.c.SUFFIX,
              '-' + datetime.datetime.now().strftime('%Y%m%d-%H%M%S') + metax.c.SUFFIX)
            if backup_path == metafile_path:
              print 'ERROR: not supporting files with %s suffix' % metax.c.SUFFIX
              sys.exit(1)
            print 'Moved %s to %s' % (
              fs.relpath(metafile_path), fs.relpath(backup_path))
            fs.rename(metafile_path, backup_path)
            fs.rename(new_path, metafile_path)
          else:
            print 'Not replacing ' + metafile_path
            fs.unlink(new_path)
    test:
    end method canonicalize;

    meta
    method PromptDiff : bool #:
      Show a diff.

      Returns:
        True if the old file is to be replaced with the new file.
    params:
      var original_path : str #:
        The original file
      var new_path : str #:
        The new file to compare against.
      var kind : str  = 'delta' #:
         - if 'raw', do not print out side-by-side diff (normal diff)
         - if 'delta', do not show common lines
         - if 'left', show only left side for common lines
         - if 'full', show all lines for both files.
    scope:
      result = False
      fp = sys.stdout
      args = ['diff']
      if kind == 'raw':
        pass
      else:
        args.append('--side-by-side')
        args.append('--width=166')
        if kind == 'delta':
          args.append('--suppress-common-lines')
        elif kind == 'left':
          args.append('--left-column')
        elif kind != 'full':
          print 'ERROR: Invalid kind %s' % kind
          sys.exit(1)
      args.append(original_path)
      args.append(new_path)
      fp.write('#' * 166 + '\n')
      fp.write('Command: %s\n' % ' '.join(args))
      fp.write('-' * 166 + '\n')
      fp.write('%-80s  | %s\n' % ('Existing Content', '    Canonicalized Content'))
      fp.write('-' * 166 + '\n')
      rc = subprocess.call(args)
      if rc == 0:
        # No differences.
        result = False
        fp.write('No differences found\n')
      else:
        legal = ['replace', 'skip', 'raw', 'delta', 'left', 'full']
        while True:
          fp.write('Action (%s)? ' % '|'.join(legal))
          ans = sys.stdin.readline().strip()
          if ans in legal:
            break
        if ans == 'skip':
          result = False
        elif ans == 'replace':
          result = True
        else:
          result = cls.PromptDiff(original_path, new_path, kind=ans)
      return result
    test:
      /# No testing of this.
      pass
    end method PromptDiff;

    method generateMajorMode : map #:
      Instantiate a major mode by parsing its schema and writing a .el file.
    params:
      var fp : ostream = out #:
        Where to write diagnostic information (NOT where the .el file is
        written).
      var dryrun : bool = false #:
        If True, compute but do not write. Useful for testing, where the
        real filesystem is read-only.
    scope:
      metalang = self.metalang()
      fs = self.fs()
      context = metalang.context()
      consmap = context.consmap()
      /# TODO(wmh): Decide whether metalang ids should be lowercase, or
      /# whether they should be mapped to lowercase when used in file paths,
      /# or to abide by literal case-sensitivity.
      metaid = metalang.id().lower()
      MetaLang = metalang.name()
      metaprefix = 'meta%s%s' % (metaid, metax.c.NEWSUFFIX)

      in_file = metax.root.Object.Resource(
        'emacs_template', fqn='metax.c.Compiler')
      out_file = self.metaPath(
        'src', 'schema', metaid, 'meta%s-mode.el' % metaid)

      fp.write(
        'Creating major mode %s for %s (%s)\n' % (out_file, metaid, MetaLang))

      featkeys = {}
      featvals = {}
      cons_kvs = {}
      allkvs = set()
      secondaries = {}
      ckeys = {}

      for cid, consinfo in consmap.iteritems():
        fks = consinfo.features()
        fvs = consinfo.featvals()
        featkeys.update(fks)
        featvals.update(fvs)
        ckeys.update(consinfo.primary())
        secondaries.update(consinfo.secondaries())
        kvs = set()
        kvs.update(fks.keys())
        kvs.update(fvs.keys())
        allkvs.update(fks.keys())
        allkvs.update(fvs.keys())
        cons_kvs[cid] = kvs

      akeys = filter(
        lambda f: len(f) > 0,
        sorted(
          [key.rstrip(':') for key in
           set(featkeys.keys()).union(set(secondaries.keys()))]))
      fvals = sorted(featvals.keys())

      cons_lines = []
      cons_lines.append('(setq RE (make-hash-table))')
      for cid in sorted(cons_kvs):
        cons_lines.append(
          '(puthash \'%s-%s-kv (concat "\\n\\\\([ \\t]*\\\\)\\\\(" (regexp-opt \'(%s)) "\[ \\t\]\\\\)*") RE)' %
          (metaprefix, cid, ' '.join(['"%s"' % e for e in sorted(cons_kvs[cid])])))
        cid_list = [cid]  # TODO(wmh): Add in cid abbrevs when they exist.
        cons_lines.append(
          '(puthash \'%s-%s-line (concat (gethash \'%s-%s-kv RE) "\\\\(%s\\\\)[ \\t]+\\\\([^ \\t]+\\\\)") RE)' %
          (metaprefix, cid, metaprefix, cid, '\\\\|'.join(cid_list)))
      cons_lines.append(
          '(puthash \'%s-all-kv (concat "\\n\\\\([ \\t]*\\\\)\\\\(" (regexp-opt \'(%s)) "\[ \\t\]\\\\)*") RE)' %
          (metaprefix, ' '.join(['"%s"' % e for e in sorted(allkvs)])))
      cons_lines.append(
        '(puthash \'%s-construct-line (concat (gethash \'%s-all-kv RE) "\\\\(" %s-constructs-re "\\\\)[ \\t]+\\\\([^ \\t]+\\\\)") RE)' %
        (metaprefix, metaprefix, metaprefix))

      kkeys = [
        /# The following are types in Meta(Meta).
        /#  - TODO(wmh): These should only be colored in MetaLanguage files.
        'id', 'xid', 'word', 'num', 'str', 'type', 'expr', 'enum',
        'simple', 'complex',
      ]
      bkeys = set()
      for baselang in metalang.baselist():
        bkeys.update(baselang.keywords())
      fp.write(
        '  Construct  [%3d]: %s\n' % (len(ckeys), ' '.join(sorted(ckeys))))
      fp.write(
        '  Attributes [%3d]: %s\n' % (len(akeys), ' '.join(sorted(akeys))))
      fp.write(
        '  Featvals   [%3d]: %s\n' % (len(fvals), ' '.join(sorted(fvals))))
      fp.write(
        '  Keywords   [%3d]: %s\n' % (len(kkeys), ' '.join(sorted(kkeys))))
      fp.write(
        '  Basewords  [%3d]: %s\n' % (len(bkeys), ' '.join(sorted(bkeys))))

      kwds = {'metaprefix': metaprefix}
      replacements = {
        '<CONSTRUCTS-HERE>': ' '.join(['"%s"' % e for e in sorted(ckeys)]),
        '<ATTRIBUTE-KEYS-HERE>': ' '.join(['"%s"' % e for e in sorted(akeys)]),
        '<FEATURE-VALUES-HERE>': ' '.join(['"%s"' % e for e in sorted(fvals)]),
        '<KEYWORDS-HERE>': ' '.join(['"%s"' % e for e in sorted(kkeys)]),
        '<BASEWORDS-HERE>': ' '.join(['"%s"' % e for e in sorted(bkeys)]),
        '<SPACE-BINDINGS-HERE>': '',
        '<SECONDARY-FONT-LOCK-HERE>':
        '(cons (concat "\\\\<" %(metaprefix)s-keywords-re "\\\\>") font-lock-%(metaprefix)s-keyword-face)' % kwds,
        '<TERTIARY-FONT-LOCK-HERE>':
        '(cons (concat "\\\\<" %(metaprefix)s-basewords-re "\\\\>") font-lock-%(metaprefix)s-baseword-face)' % kwds,
        '<CONS-RES-HERE>': '\n'.join(cons_lines),
      }

      if not dryrun:
        dirname = fs.dirname(out_file)
        if not fs.exists(dirname):
          fs.makedirs(dirname)

        ofp = fs.open(out_file, 'w')
        ifp = fs.open(in_file, 'r')
        replace = False
        for line in ifp:
          if not replace:
            if "'MetaLang' and 'metalang'" in line:
              replace = True
          else:
            line = line.replace('metalang', 'meta%s' % metaid)
            line = line.replace('MetaLang', 'Meta(%s)' % MetaLang)

            reps = []
            reps = replacements.keys()
            for rep in reps:
              if rep in line:
                line = line.replace(rep, replacements[rep])
                reps.append(rep)
                del replacements[rep]

          ofp.write(line)
        fs.close(ifp)
        fs.close(ofp)

      return replacements
    test:
      _, _, _, metameta = test.cachedInfo(metal='meta')
      fs = metameta.fs()
      try:
        fp = test.newStr()
        fs.setenv('METAROOT', '/tmp')
        _, _, _, meta = test.cachedInfo(metal='meta')
        replacements = meta.generateMajorMode(fp=fp, dryrun=True)
        /# import pprint
        /# pprint.pprint(replacements)
        test.iseq(
          '"Attribute" "BaseLanguage" "Construct" "FeatureValue" '
          '"File" "MetaLanguage" "Template"',
          replacements['<CONSTRUCTS-HERE>'])
        /#print fp.getvalue()
      finally:
        fs.unsetenv('METAROOT')
    end method generateMajorMode;

    method runUnitTests #:
      Invoke the test harness on the specified fqns.
    params:
      var fqns : vec<str> #:
        A collection of fully qualified namespaces and/or classes and/or
        methods (to be converted into BUILD unittest targets) or arbitrary
        fully-qualified BUILD targets.
      var verbose : bool = false #:
        If true, print output of tests, etc.
    scope:
      /# Set this to true to debug baselang parsing of bazel output.
      debug = False

      if not fqns:
        raise Error('here')

      flags = self.cli()
      baselang = self.baselang()
      fs = self.fs()
      showout = verbose
      showerr = True

      metarep = self.repositoryPath()
      rootdir = fs.join(metarep, self.basePath())
      cwd = rootdir

      suffix = baselang.suffix()
      basel = baselang.id()
      rawtests = flags.rawtests
      if basel == 'javascript':
        /# No raw mode for javascript.
        rawtests = False

      tester_map = {}
      raw_commands = []
      for fqn in fqns:
        tester = None
        rawcom = {}  # 'cwd' and 'args'

        /# We first check if it is an explicit target.
        if fqn.startswith('//'):
          print (
            'WARNING: Not yet supporting explicit BUILD targets. %s ignored' %
            (fqn))

        else:
          /# We need to determine whether this fqn represents a namespace, a
          /# class, or a method.
          parts = fqn.split('.')

          if len(parts) == 1:
            print 'arg %s looks incorrect' % fqn
            sys.exit(1)

          /# We find the directory matching some initial portion of the fqn.
          trailing = []
          found = False
          while not found and parts:
            path = fs.join(cwd, '/'.join(parts))
            if fs.exists(path):
              namespace_path = path
              found = True
            else:
              trailing.append(parts.pop())

          if not parts:
            print 'WARNING: Invalid namespace %s ignored' % fqn
            continue

          /# The namespace is identified by the found subdirs.
          namespace_name = '.'.join(parts)

          /# The remaining parts of the fqn, if they exist, are a class name
          /# and method name.
          /#  - the class name should have an associated file
          /#      <namespace_path>/<clsname>.<suffix>
          /#    except in python, where it is
          /#      <namespace_path>/.<clsname>.<suffix>
          /#    (note also that in python the actual file defining all classes
          /#    in the module is <namespace_path>/__init__.py and there is no
          /#    strict requirement that the per-class .py files be kept around
          /#    (e.g. a user may delete those files without breaking anything
          /#    except this code).
          /#  - the method name has no file presence so we cannot directly
          /#    verify correctness without some additional info
          /#     - TODO(wmh): Look in .map files? Or just allow an error to
          /#       be generated if an invalid method is specified?
          nt = len(trailing)

          /# print 'NAMESPACE %s trailing %s path %s' % (namespace_name, trailing, namespace_path)

          if nt == 0:
            /# The name represents a namespace.
            method_name = None
            class_name = None
          elif nt == 1:
            /# The name maybe represents a class.
            class_name = trailing[0]
            method_name = None
          elif nt == 2:
            /# The name maybe represents a method
            method_name, class_name = trailing
          else:
            print 'ERROR: fqn %s is not valid' % fqn
            continue

          /# print 'PATH: %s  nn=%s cn=%s mn=%s nt=%d trailing=%s suffix=%s' % (
          /#   path, namespace_name, class_name, method_name, nt, trailing, suffix)

          /# We initially assume a namespace target (will modify if we have a
          /# class and/or method.
          nmsp_prefix = '/'.join(parts[:-1])
          nmsp_suffix = parts[-1]
          tester = {
            'target': '//%s/%s_test:%s_test' %
            (nmsp_prefix, nmsp_suffix, nmsp_suffix)}

          /# Establish the commands to use for non-blaze test invocation.
          /#  - always execute from rootdir, since the code assumes it, and
          /#    bazel puts us into the rootdir before running its tests.
          if rawtests:
            rawcom['cwd'] = rootdir
            if basel == 'python':
              /# Python is a unique little snowflake.
              /# - we verify that the namespace exists.
              class_path = fs.join(namespace_path, '__init__.py')
              if not fs.exists(class_path):
                print 'ERROR: name %s is not a valid target' % namespace_name
                continue

              rawcom['namespace'] = '%s.%s' % (
                nmsp_prefix.replace('/', '.'), nmsp_suffix)
              rawcom['args'] = [
                'python', '%s/%s_test/__init__.py' % (nmsp_prefix, nmsp_suffix)]
              rawcom['env'] = {
                'PYTHONPATH': '.:%s' % (fs.getenv('PYTHONPATH'))
              }
              if flags.write_goldens:
                rawcom['env']['WRITE_GOLDENS'] = 'true'

            elif basel == 'javascript':
              /# There is no raw mode for javascript, and we should have set
              /# rawtests to False and thus should never get here.
              raise InternalError('How did we get here?')

            elif basel == 'cpp':
              /# A bazel test target exists for C++, but we can also compile
              /# the test code without bazel.
              print (
                'WARNING: For now, ignoring --raw (forcing C++ to use bazel '
                'for unittests).')
              rawtests = False

            else:
              /# TODO(wmh): Each language will have a different mechanism for
              /# invoking the raw test harness.
              rawcom['args'] = [
                'fixme', '%s/%s_test%s' % (nmsp_prefix, nmsp_suffix, suffix)]

          if class_name:
            if basel == 'python':
              /# Once again, python is a unique little snowflake. We do not have
              /# per-class targets ... only per-namespace. We instead use
              /# command line args to narrow things down to a class or method.
              testarg = ClassConstruct.TestifyName(class_name)
              if method_name:
                testarg += '.' + ExecutableConstruct.TestifyName(method_name)
              tester['arg'] = testarg
              if rawtests:
                rawcom['args'].append(testarg)
            else:
              /# Now obtain the info bazel needs to test this entity.
              tester = {
                'target': '//%s/%s_test:%sTest' %
                (nmsp_prefix, nmsp_suffix, class_name)}

              if method_name:
                /# TODO(wmh): Verify the method name is legal (by looking in the
                /# map file, for example?)
                testmethod_name = ExecutableConstruct.TestifyName(method_name)
                testclass_name = ClassConstruct.TestifyName(class_name)
                /# TODO(wmh): How to specify a single method in C++ tests?
                /# We'll need to write such logic into the main methods.
                tester['arg'] = '%s.%s' % (testclass_name, testmethod_name)

        tester_map.setdefault(tester['target'], []).append(tester)
        if rawcom:
          raw_commands.append(rawcom)

      /# Establish the metafilt args.
      dofilt = False
      if dofilt:
        metafilt = fs.join(fs.getenv('METAROOT'), 'bin', 'metafilt')
        if not fs.exists(metafilt):
          raise Error('Failed to find ' + metafilt)
        /# filt_args = [metafilt, '--debug', '-V', 'beta', '-b', baselang.id()]
        /# filt_args = [metafilt, '-V', 'beta', '-b', baselang.id(), '--cwd', cwd]
        filt_args = [metafilt]

      if rawtests:
        /# We are to invoke the underlying test harness instead of bazel.
        /#  - we execute the python test harness from
        /#      rootdir = <<repository_path>>/<metalang>/<baselang>
        /#    so that the directories are the same between the bazel version and
        /#    the local version.  Since code should be written such that all
        /#    modules are visible from the above directory (and may not be
        /#    written to be available from the exact directory within which
        /#    the test file resides), this is the right directory to be in.
        cwd = rootdir
        if raw_commands:
          if verbose:
            print '*' * 80
            print 'Running raw tests (e.g. without using bazel)'
            print
          for rawcom in raw_commands:
            args = rawcom['args']
            if verbose:
              print '=' * 80
              print ' %% cd %s' % cwd
              print ' %% %s%s' % (
                ' '.join(args),
                (' | metafilt2 %s' % ' '.join(filt_args[1:])) if dofilt else '')
              print '=' * 80
            env = copy.copy(fs.environ())
            if 'env' in rawcom:
              env.update(rawcom['env'])
            if dofilt:
              p1 = subprocess.Popen(
                args, cwd=cwd, env=env,
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
              p2 = subprocess.Popen(filt_args, stdin=p1.stdout)
              p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.
              p2.communicate()
            else:
              /# print 'ARGS: %s' % str(args)
              /# print 'CWD: %s' % cwd
              /# print 'PYTHONPATH: %s' % env['PYTHONPATH']
              p = subprocess.Popen(
                args, cwd=cwd, env=env,
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
              stdout, stderr = p.communicate()
              self.processPythonTestOutput(
                stdout, stderr, cwd, rawcom['namespace'],
                nofilt=flags.raw, verbosity=1 if verbose else 0)
        else:
          print 'ERROR: Not yet supporting --rawtests for %s' % basel

      else:
        if False:
          for s in dir(flags):
            if s[0] != '_':
              print '%-30s = %s' % (s, getattr(flags, s))

        /# Execute the bazel test commands and pipe to metafilt.
        for target in sorted(tester_map):
          testers = tester_map[target]

          /# Establish the command to invoke
          args = [
            Compiler.CONFIG['bazel'],
            'test',
            /#'--explain',
            /#'--verbose_explanations',
          ]

          if flags.write_goldens:
            /# https://docs.bazel.build/versions/master/user-manual.html#flag--test_env
            args.append('--test_env=WRITE_GOLDENS=true')

          for tester in testers:
            if 'arg' in tester:
              args.append('--test_arg=' + tester['arg'])

          /# Determine whether or not to use Bazel.
          if flags.raw:
            /# Do not use bazel.
            args.append('--test_output=%s' % flags.test_output)
            args.append(target)
            print 'Command: cd ' + cwd
            print 'Command: ' + ' '.join(args)
            subprocess.call(args, cwd=cwd)

          else:
            /# Do use bazel.
            /#
            /# We always invoke the summary version of bazel, then parse the
            /# output which identifies where the full logs are. We then fully
            /# parse the logs to obtain detailed information about every test.
            args.append('--test_output=summary')
            args.append(target)
            print
            print 'Command: cd ' + cwd
            print 'Command: %s | special_filtering' % (' '.join(args))
            print

            p1 = subprocess.Popen(
              args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
            try:
              tests = self.parseBazelOutput(
                stdout=p1.stdout, stderr=p1.stderr, debug=debug)
            except Error as e:
              print 'Internal Error: %s' % str(e)
            else:
              if tests is None:
                /# We encountered compilation errors, and reported them at the
                /# time we encountered them.
                pass
              else:
                self.formatBazelOutput(tests, showout=showout, showerr=showerr)

                if flags.unfilt:
                  print '****** HERE!'
                  print 'Command: cd ' + cwd
                  print 'Command: %s 2>&1 | metafilt %s' % (
                    ' '.join(args), ' '.join(filt_args[1:]))
                  p2 = subprocess.Popen(filt_args, stdin=p1.stdout)
                  p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.
                  p2.communicate()

    end method runUnitTests;

    method processPythonTestOutput #:
      Process the output of non-bazel execution of the python test harness.
    params:
      var stdout : str #:
        The stdout produced by invoking a python test directly
      var stderr : str #:
        The stderr produced by invoking a python test directly
      var cwd : str #:
        The directory from which to process.
      var namespace : str #:
        The namespace under test.
      var nofilt : bool = false #:
        If true, do not filter the stdout/stderr, just print verbatim
      var verbosity : int = 0 #:
        0 = Show only errors
        1 = Show one line for each method, and full errors
    scope:
      ifp = cStringIO.StringIO(stderr or '')
      efp = cStringIO.StringIO()
      self.filterMetaOutput(cwd=cwd, ifp=ifp, ofp=efp)
      filterr = efp.getvalue()

      if nofilt:
        if stdout:
          dsep(title='stdout')
          print stdout
        if stderr:
          dsep(title='stderr')
          /#print stderr
          print filterr
        if stdout or stderr:
          dsep(end=True)
        return

      /# Perform base-to-meta line mapping on stderr
      outlines = stdout.split('\n')
      errlines = filterr.split('\n')

      /# Establish some vars.
      outre = re.compile(
        r'^(?P<fqn>\S+)\s+\.\.\.(?P<rest>.*)')
      timere = re.compile(
        r'^(?P<head>.*?)\s+(?P<us>\d+) us  (?:(?P<status>.*))?$')
      failre = re.compile(
        r'^(?P<status>FAIL|ERROR): test_(?P<method>\S+) \(\S+\.(?P<class>\S+)Test\)')
      sepre = re.compile('^(?P<c>[=-])(?P=c){60,}')
      ranre = re.compile(r'^Ran (?P<numtests>\d+) tests? in (?P<seconds>\S+)s')

      def PrintStripped(data, prefix):
        """Strip leading/trailing lines of whitespace from data list."""
        i = 0
        n = len(data)
        if False:
          /# We should NOT be stripping blank leading/trailing lines if they
          /# represent actual output produced by the code ... if spurious
          /# blank lines are being introduced, fix that issue rather than
          /# stripping potentially valuable empty lines from actual output.
          while i < n and not data[i].strip():
            i += 1
          while n > 0 and not data[n-1].strip():
            n -= 1
        for j in range(i, n):
          print prefix + data[j]

      /# We'll add one dict per test to data, merging stdout and stderr.
      /#   name: str
      /#     fqn of test.
      /#   time: int
      /#     number of microseconds
      /#   stdout: vec<str>
      /#   stderr: vec<str>
      data = []
      /# datamap maps fqn name to the same dict stored in data for that fqn.
      datamap = {}

      /# Parse stdout
      /#  - we are expecting lines of the form:
      /#      <class>.<method>                   ...    <time> us  [<status>]
      /#    optionally followed by output from a test method.
      current_fqn = None
      for line in outlines:
        m = outre.match(line)
        if m:
          fqn = m.group('fqn')
          item = {
            'fqn': fqn, 'stdout': [], 'stderr': [], 'status': None,
            'time': None}
          rest = m.group('rest')
          tm = timere.match(rest)
          if tm:
            /# We have a time for this test ... no output expected.
            item['time'] = int(tm.group('us'))
            item['status'] = tm.group('status')
            current_fqn = None
          else:
            /# We did not find a time for this test, which means the test
            /# produced some output on stdout. We consume it in subsequent
            /# iterations through the loop, until we find a line ending in
            /# a timespec.
            current_fqn = fqn
            item['stdout'].append(rest)
          data.append(item)
          datamap[fqn] = item
        else:
          if current_fqn is None:
            /# We are not currently expecting output
            if line.strip():
              print 'UNKNOWN STDOUT: %s' % line
          else:
            /# This is stdout for current_fqn
            item = datamap[current_fqn]
            tm = timere.match(line)
            if tm:
              /# We've found the end of expected stdout
              current_fqn = None
              item['time'] = int(tm.group('us'))
              item['status'] = tm.group('status')
              head = tm.group('head')
              if head:
                item['stdout'].append(head)
            else:
              item['stdout'].append(line)

      /# Parse stderr
      /#  - we are expecting records of the form:
      /#
      /#      =================================================================
      /#      ERROR: test_attrinfo (__main__.ContextTest)
      /#      -----------------------------------------------------------------
      /#      Traceback (most recent call last):
      /#        File "metax/c_test/__init__.py", line 1610, in setUp
      /#          _, _, _, compiler = self.cachedInfo(metal='meta')
      /#      AttributeError: 'ContextTest' object has no attribute 'cachedInfo'
      /#
      /# - It is possible that we will encounter a class/method pair in stderr
      /#   that is NOT present in stdout (not sure how, but it happens).
      i = 0
      N = len(errlines)
      current_fqn = None
      postamble = None
      summary_data = {}
      while i < N:
        line = errlines[i]
        i += 1
        /# We ignore separator lines, as the line after seplines uniquely
        /# identifies which section we are in (at least in output I've seen).
        if sepre.match(line): continue
        failm = failre.match(line)
        ranm = ranre.match(line)

        if failm:
          d = failm.groupdict()
          fqn = '%s.%s' % (d['class'], d['method'])
          if not sepre.match(errlines[i]):
            raise Error('Should have found separator line after "%s"' % line)
          if fqn not in datamap:
            item = {
              'fqn': fqn, 'stderr': [], 'stdout': [], 'status': None,
              'time': None
            }
            data.append(item)
            datamap[fqn] = item
          current_fqn = fqn
        elif ranm:
          /# End of tests ... grab all remaining output.
          summary_data.update(ranm.groupdict())
          assert not errlines[i].strip()
          summary_data['status'] = errlines[i+1]
          j = i+2
          while j < len(errlines) and not errlines[j].strip():
            j += 1
          postamble = errlines[j:]
          break
        elif current_fqn is None:
          print 'UNKNOWN STDERR: %s' % line
        else:
          /# A line of stderr for current fqn, if one exists.
          item = datamap[current_fqn]
          item['stderr'].append(line)

      /# Merge the stdout and stderr into a single stream, in the same
      /# format as used in the bazel-generated output.
      sep = '-' * 70
      show_nums = False
      /# print stdout
      last_printed_sep = False
      for i, item in enumerate(data):
        out = item['stdout']
        err = item['stderr']
        special = out or err

        if special and not last_printed_sep: print sep

        if special or verbosity:
          prefix = '%3d) ' % i if show_nums else ''
          print '%s%-40s ... %7d us   %s' % (
            prefix, item['fqn'], item['time'] or -1, item['status'])

        PrintStripped(out, ' |')
        PrintStripped(err, 'E|')

        if special:
          print sep
          last_printed_sep = True
        elif verbosity:
          last_printed_sep = False

      if summary_data:
        print '%-20s: %3d tests in %s seconds: %s' % (
          namespace, int(summary_data['numtests']), summary_data['seconds'],
          summary_data['status'])
      if postamble:
        for line in postamble:
          print line
    test:
    end method processPythonTestOutput;

    method fqnToTarget : tuple<str,str,str,str,vec<str>> #:
      Given a fully qualified namespace/class/method, obtain target info.

      Returns:
       0. the target.
       1. the test target.
       2. the path to a baselang file.
       3. the test path to a baselang file.
       4. the args to pass in to the test binary identified by 0 and 1.
    params:
      var fqn : str #:
        The fqn to obtain info for.
      var debug : bool = false #:
        Turn on debugging.
    scope:
      fs = self.fs()
      baselang = self.baselang()
      namespace_primary = baselang.config('namespace_primary')
      basel = baselang.id()
      rootdir = fs.realpath(self.workspaceDirectory())

      if debug:
        print 'ROOTDIR: %s' % rootdir

      /# The collection of arguments/flags to pass into the test harness
      test_args = []

      /# Identify the prefix portion of fqn that corresponds to directories
      /# in the filesystem.
      parts = fqn.split('.')
      index = None
      path = rootdir
      for i, part in enumerate(parts):
        newpath = fs.join(path, part)
        if not fs.exists(newpath):
          if debug:
            print 'Failed to find %s' % newpath
          index = i
          break
        if debug:
          print 'Found %s' % newpath
        path = newpath
      namespace_dir = path

      /# At this point, 'path' is the directory containing the namespace portion
      /# of fqn, and parts[index:] represents class/method symbols.
      nmparts = parts[:index]
      if nmparts:
        if namespace_primary:
          if basel == 'python':
            /# The __init__.py file contains the namespace data.
            namespace_path = fs.join(namespace_dir, '__init__.py')
            testspace_path = fs.join(
              NamespaceConstruct.TestifyName(namespace_dir), '__init__.py')
            final_path = namespace_path
            final_testpath = testspace_path
          else:
            raise Error('Not yet supporting %s' % basel)
        else:
          /# In class-primary languages there is no single file containing
          /# the namespace, so the paths stay as directories.
          namespace_path = namespace_dir
          testspace_path = NamespaceConstruct.TestifyName(namespace_dir)
          /# These will be modified below if a class name is present in parts.
          final_path = namespace_path
          final_testpath = testspace_path

        if debug:
          print parts
          print index
          print nmparts
          print final_path
          print final_testpath

        /# The target and test_target are the same for both namespace-primary and
        /# class-primary languages, but are implemented differently (e.g. in
        /# python the test target is a py_test target, in class-primary languages
        /# it is a test_suite of test class targets).
        target = '//%s:%s' % ('/'.join(nmparts), nmparts[-1])
        testspace_base = NamespaceConstruct.TestifyName(nmparts[-1])
        if len(nmparts) == 1:
          test_target = '//%s:%s' % (testspace_base, testspace_base)
        else:
          test_target = '//%s/%s:%s' % (
            '/'.join(nmparts[:-1]), testspace_base, testspace_base)
      else:
        /# This is clearly not a valid fqn
        target = None
        test_target = None
        indext = None

      if debug:
        print 'index = %s' % index

      if index is not None:
        /# There are some left-over parts of the fqn not matching directories,
        /# so they represent a class (and method).
        if namespace_primary:
          if basel == 'python':
            class_name = parts[index]
            class_path = fs.join(namespace_dir, '.' + class_name + '.py')
          else:
            raise Error('Not yet supporting %s' % basel)
        else:
          class_name = parts[index]
          class_path = fs.join(namespace_path, class_name + baselang.suffix())
          final_path = class_path
          /# TODO(wmh): In addition to BaseLanguageOopl.classSubPath(), there
          /# should be a BaseLanguageOopl.classTestBase() method that returns
          /# the basename of the file containing the tests for a class. Both
          /# classSubPath() and this method could then use that method.
          /# Alternatively, we could just obtain the basename of the result
          /# of a call to baselang.classSubPath(), but we currently need a
          /# class construct ... generalize the method to support fqn.
          baselang_test_infix = '_test' if basel == 'javascript' else ''
          final_testpath = fs.join(
            testspace_path,
            ClassConstruct.TestifyName(class_name)
            + baselang_test_infix + baselang.suffix())

        if fs.exists(class_path):
          if namespace_primary:
            test_args.append(ClassConstruct.TestifyName(class_name))
          if len(parts) > index+1:
            test_method = ExecutableConstruct.TestifyName(parts[index+1])
            if test_args:
              test_args[-1] += '.' + test_method
            else:
              test_args.append(test_method)
        else:
          /# print 'ERROR: %s is not a valid class' % '.'.join(parts[:index+1])
          final_path = None
          final_testpath = None
      return (target, test_target, final_path, final_testpath, test_args)
    test:
      def Chk(expected_target, expected_test_target, expected_suffix,
              expected_test_suffix, expected_test_args, res):
        target, test_target, path, test_path, test_args = res
        test.iseq(expected_target, target)
        test.iseq(expected_test_target, test_target)
        test.endswith(expected_suffix, path)
        test.endswith(expected_test_suffix, test_path)
        test.iseqvec(expected_test_args, test_args)

      /# Python
      testpy = test.getTestCompiler(basel='python')

      Chk(
        '//demo/cards2:cards2',
        '//demo/cards2_test:cards2_test',
        'testdata/repo/oopl/python/demo/cards2/__init__.py',
        'testdata/repo/oopl/python/demo/cards2_test/__init__.py',
        [],
        testpy.fqnToTarget('demo.cards2'))

      Chk(
        '//demo/cards2:cards2',
        '//demo/cards2_test:cards2_test',
        'testdata/repo/oopl/python/demo/cards2/__init__.py',
        'testdata/repo/oopl/python/demo/cards2_test/__init__.py',
        ['CardTest'],
        testpy.fqnToTarget('demo.cards2.Card'))

      Chk(
        '//demo/cards2:cards2',
        '//demo/cards2_test:cards2_test',
        'testdata/repo/oopl/python/demo/cards2/__init__.py',
        'testdata/repo/oopl/python/demo/cards2_test/__init__.py',
        ['DeckTest.test_shuffle'],
        testpy.fqnToTarget('demo.cards2.Deck.shuffle'))

      /# Javascript
      testjs = test.getTestCompiler(basel='javascript')

      Chk(
        '//demo/cards2:cards2',
        '//demo/cards2_test:cards2_test',
        'testdata/repo/oopl/javascript/demo/cards2',
        'testdata/repo/oopl/javascript/demo/cards2_test',
        [],
        testjs.fqnToTarget('demo.cards2'))

      Chk(
        '//demo/cards2:cards2',
        '//demo/cards2_test:cards2_test',
        'testdata/repo/oopl/javascript/demo/cards2/Card.js',
        'testdata/repo/oopl/javascript/demo/cards2_test/CardTest_test.js',
        [],
        testjs.fqnToTarget('demo.cards2.Card'))

      Chk(
        '//demo/cards2:cards2',
        '//demo/cards2_test:cards2_test',
        'testdata/repo/oopl/javascript/demo/cards2/Deck.js',
        'testdata/repo/oopl/javascript/demo/cards2_test/DeckTest_test.js',
        ['test_shuffle'],
        testjs.fqnToTarget('demo.cards2.Deck.shuffle'))

      /# C++
      testcc = test.getTestCompiler(basel='cpp')

      return

      Chk(
        '//demo/cards2:cards2',
        '//demo/cards2_test:cards2_test',
        'testdata/repo/oopl/cpp/demo/cards2',
        'testdata/repo/oopl/cpp/demo/cards2_test',
        [],
        testcc.fqnToTarget('demo.cards2'))

      Chk(
        '//demo/cards2:cards2',
        '//demo/cards2_test:cards2_test',
        'testdata/repo/oopl/cpp/demo/cards2/Card.js',
        'testdata/repo/oopl/cpp/demo/cards2_test/CardTest_test.js',
        [],
        testcc.fqnToTarget('demo.cards2.Card'))

      Chk(
        '//demo/cards2:cards2',
        '//demo/cards2_test:cards2_test',
        'testdata/repo/oopl/cpp/demo/cards2/Deck.js',
        'testdata/repo/oopl/cpp/demo/cards2_test/DeckTest_test.js',
        ['test_shuffle'],
        testcc.fqnToTarget('demo.cards2.Deck.shuffle'))

    end method fqnToTarget;

    method verifyBazelOutput #:
      Verify bazel output matches expectations.
       - invokes the test code for a given fqn using raw and bazel modes,
         capturing stdout and stderr of each command.
       - verifies that the reverse engineered structure of bazel output
         relative to raw output is as expected.
       - verifies that the specified fqn can be tested using bazel or raw.

      From commandline:
        % meta2 bazel-verify demo.cards2
        % meta2 bazel-verify demo.cards2.Card
        % meta2 bazel-verify demo.cards2.Deck.shuffle
    params:
      var fqn : str;
    scope:
      verbose = True   # show commands if true
      debug = True     # show debugging info if true
      error = None
      fs = self.fs()
      rundir = fs.realpath(self.workspaceDirectory())
      target, test_target, path, test_path, test_args = self.fqnToTarget(fqn)

      def Run(args, cwd, verbose=False, debug=False):
        if verbose:
          print ' %% cd %s' % cwd
          print ' %% %s' % ' '.join(args)
        p = subprocess.Popen(
          args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
        stdout, stderr = p.communicate()
        if debug:
          print '#' * 70
          print stdout
          print '@' * 70
          print stderr
          print '#' * 70
        return {'args': args, 'stdout': stdout, 'stderr': stderr}

      /# Modify the environment so that invocations of 'python' will work
      /# properly.
      python_path = fs.getenv('PYTHONPATH')
      fs.setenv('PYTHONPATH', '%s:%s' % (rundir, python_path))

      /# We first invoke the raw test command.
      raw_args = ['python', test_path] + test_args
      rawdata = Run(raw_args, rundir, verbose=verbose, debug=debug)

      /# Now we invoke the bazel test command.
      bazel_args = [
        /# TODO(wmh): Make this bazel path more generalized (hermetic?)
        '/usr/local/bin/bazel',
        'test', '--test_output=all']
      for test_arg in test_args:
        bazel_args.append('--test_arg=%s' % test_arg)
      bazel_args.append(test_target)
      bazeldata = Run(bazel_args, rundir, verbose=verbose, debug=debug)

      /# Verify expectations
      /#  - raw_stdout is:
      /#     |<class>.<method>           ... <us> us [<status>]
      /#     |...
      /#
      /#  - raw_stderr is:
      /#     |<status_line>
      /#     |<failure>
      /#     |...
      /#     |
      /#     |----------------------------------------------------------------------
      /#     |Ran 5 tests in 0.002s
      /#     |
      /#     |FAILED (failures=2)
      /#
      /#  - bazel_stdout is:
      /#     |==================== Test output for <test_target>:
      /#     |<raw_stderr>
      /#     |<raw_stdout>
      /#     |================================================================================
      /#     |<summary>
      /#     |Executed <m> out of <n> test: <k> fails locally.
      /#
      /#  - bazel_stderr is:
      /#     |____Loading...
      /#     |____Found 1 test target...
      /#     |blaze: Entering directory `/private/var/tmp/_bazel_wmh/daa2249567ca0e385fd2b02766058831/execroot/python/'
      /#     |FAIL: //demo/cards2_test:cards2_test (see /private/var/tmp/_bazel_wmh/daa2249567ca0e385fd2b02766058831/execroot/python/bazel-out/local-fastbuild/testlogs/demo/cards2_test/cards2_test/test.log)
      /#     |____From Testing //demo/cards2_test:cards2_test:
      /#     |blaze: Leaving directory `/private/var/tmp/_bazel_wmh/daa2249567ca0e385fd2b02766058831/execroot/python/'
      /#     |Target //demo/cards2_test:cards2_test up-to-date:
      /#     |  bazel-bin/demo/cards2_test/cards2_test
      /#     |____Elapsed time: 0.442s, Critical Path: 0.27s
      bazel_stdout_re = Compiler.BAZEL_STDOUT_RE
      m = bazel_stdout_re.match(bazeldata['stdout'])
      if not m:
        error = 'Failed to match bazel stdout against expected regexp!'
        print '#' * 70
        print bazeldata['stdout']
        print '@' * 70
        print bazel_stdout_re.pattern
        print '#' * 70

      else:
        def Patch(val):
          /# In stderr, generalize the summary line.
          val = re.sub(r'Ran \d+ tests? in \S+', 'Ran <m> tests in <time>', val)
          /# Generalize time references.
          val = re.sub(r' *\d+(?:\.\d+)?\s*(s|us)( |$)', r' <time>\2', val)
          /# Generalize file paths.
          val = re.sub(r'File \"/.*(oopl/python|__main__)/', 'File \"', val)
          return val.rstrip()

        def MultiLineEqual(expected_text, text):
          result = True
          expected_text = Patch(expected_text)
          text = Patch(text)
          if expected_text != text:
            expected_lines = expected_text.splitlines(True)
            lines = text.splitlines(True)
            diff = '\n' + ''.join(difflib.ndiff(expected_lines, lines))
            print '#' * 80
            print 'Found differences between expected and actual text:'
            print diff
            print '#' * 80
            result = False
          return result

        if not MultiLineEqual(rawdata['stdout'], m.group('stdout')):
          error = 'mismatch in stdout'
        elif not MultiLineEqual(rawdata['stderr'], m.group('stderr')):
          error = 'mismatch in stderr'

      if error:
        print 'ERROR: %s' % error
      else:
        /# print 'Verified raw vs bazel stdout/stderr for %s' % fqn
        pass
      return not bool(error)
    test:
      /# TODO(wmh): This test method only works when ./testdata/oopl/<baselang>
      /# is made writeable (these dirs are intentionally made read-only in
      /# testdata/Makefile to that tests do NOT write into it).
      if False:
        testpy = test.getTestCompiler(basel='python')
        testpy.verifyBazelOutput('demo.cards2')
    end method verifyBazelOutput;

    method parseBazelOutput : map #:
      Parse bazel output and analyzing log files.

      Some invariants related to bazel output:
       % cd <<repository_path>>/oopl/python
       % python metax/c_test.py > out.raw 2> err.raw
       % bazel test --test_output=all //metax:c_test > out.bzl 2> err.bzl

      Returns:
        Keys are bazel class test targets, values are maps containing:
          cached: str
            ???
          count: int
            Number of methods in this class test
          dir: str
            The directory containing the logs for this test
          log: str
            The contents of the log for this test
          logpath: str
            The path to the logfile for this class test
          methods: map
            maps class.method to map:
              stdout: str
                the stdout of the test method
              stderr: str
                the stderr of the test method
              us: int
                microseconds taken for this method test
          status: str
            The status of the test as reported during the bazel summary
          status2: str
            The status of the test as reported in the log file
          target: str
            The target of this class test (same as the key storing this map)
          time: str
            The time of the test(s) as reported during the bazel summary
          time2: str
            The time of the test(s) as reported in the log file
    params:
      var stdout : istream = in #:
        A file handle opened for reading on the stdout of the bazel command.
      var stderr : istream = in #:
        A file handle opened for reading on the stderr of the bazel command.
      var logdir : str = null #:
        Where to find the logs produced by bazel. Normally null, in which
        case the dir is obtained from the input stream. Can be set explicitly
        to perform unittests.
      var debug : bool = false #:
        If true, enable debugging output.
    scope:
      tests = {}
      fs = self.fs()
      stdout_lines = stdout.readlines()
      stdout_text = ''.join(stdout_lines)
      stderr_lines = stderr.readlines()
      stderr_text = ''.join(stderr_lines)
      baselang = self.baselang()

      if debug:
        dsep('Compiler.parseBazelOutput Input', subtitle='stdout')
        print ''.join(stdout_lines)
        dsep(delim='-', subtitle='stderr')
        print ''.join(stderr_lines)
        dsep('Compiler.parseBazelOutput Input', end=True)

      /# If syntax errors were found, stdout will contain a line like
      /#    Executed 0 out of 1 test: 1 fails to build.
      if re.search(r' \d+ fail\S+ to build', stdout_text):
        /# TODO(wmh): Perform baseline-to-metaline conversion on stderr!
        print '#' * 37 + ' STDERR ' + '#' * 37
        print stderr_text
        print '#' * 80
        return None

      if not logdir:
        /# No logdir has been explicitly provided (rarely is), so we need to
        /# establish the log directory from the output.  The stderr of bazel
        /# looks like:
        /#    ____Loading...
        /#    ____Found 8 test targets...
        /#    blaze: Entering directory `/private/var/tmp/_bazel_wmh/8a547b9529defa4d451cf083bf4156d1/execroot/python/'
        /#    FAIL: //demo/cards2_test:FrenchPackTest (see /private/var/tmp/_bazel_wmh/8a547b9529defa4d451cf083bf4156d1/execroot/python/bazel-out/local-fastbuild/testlogs/demo/cards2_test/FrenchPackTest/test.log)
        /#    blaze: Leaving directory `/private/var/tmp/_bazel_wmh/8a547b9529defa4d451cf083bf4156d1/execroot/python/'
        /#    ____Elapsed time: 0.315s, Critical Path: 0.22s
        /# and we can obtain the logdir from the 'blaze: Entering directory' line
        logroot = None
        dir_re = re.compile(
          r'^(?:bazel|blaze): Entering directory `(?P<path>.*)\'$')
        for line in stderr_lines:
          m = dir_re.match(line);
          if m:
            logroot = m.group('path')
            break
        if not logroot:
          print '#' * 80
          print ''.join(stderr_lines)
          print '#' * 80
          raise Error('Failed to find a log directory')

      /#pprint.pprint(tests)
      if logdir is None:
        assert logroot is not None
        /# TODO(wmh): How to make this baselang-independent?
        if baselang.id() == 'cpp':
          fastbuild = 'darwin-fastbuild'
        else:
          fastbuild = 'local-fastbuild'
        logdir = fs.join(logroot, 'bazel-out', fastbuild, 'testlogs')

      /# Now parse the bazel stdout. The stdout from bazel looks like:
      /#    //demo/cards2_test:CardTest                                     (cached) PASSED in 0.3s
      /#    //demo/cards2_test:Card__MetaTest                               (cached) PASSED in 0.3s
      /#    //demo/cards2_test:FrenchPack__MetaTest                         (cached) PASSED in 0.3s
      /#    //demo/cards2_test:PackTest                                     (cached) PASSED in 0.3s
      /#    //demo/cards2_test:Pack__MetaTest                               (cached) PASSED in 0.3s
      /#    //demo/cards2_test:PileTest                                     (cached) PASSED in 0.3s
      /#    //demo/cards2_test:Pile__MetaTest                               (cached) PASSED in 0.2s
      /#    //demo/cards2_test:FrenchPackTest                                        FAILED in 0.2s
      /#      /private/var/tmp/_bazel_wmh/8a547b9529defa4d451cf083bf4156d1/execroot/python/bazel-out/local-fastbuild/testlogs/demo/cards2_test/FrenchPackTest/test.log
      /#
      /#    Executed 1 out of 8 tests: 7 tests pass and 1 fails locally.
      /#
      /# and we are interested in the target lines (starting with '//')
      test_re = re.compile(
        r'^(?P<target>//\S+)\s+'
        r'(?P<cached>\(cached\))?\s*'
        r'(?P<status>PASSED|FAILED|NO STATUS)'
        r'(?:\s+in\s+(?P<time>\S+))?'
      )
      for line in stdout_lines:
        m = test_re.match(line)
        if m:
          tests[m.group('target')] = m.groupdict()
        else:
          if line.startswith('//'):
            raise Error('Line "%s" does not match test_re but should' % line[:-1])

      if debug:
        import pprint
        pprint.pprint(tests)

      /# Parse the log out for each target found in tests
      for target in sorted(tests):
        tdata = tests[target]
        subpath = target[2:].replace(':', '/')
        parts = subpath.split('/')
        nmsp = '.'.join(parts[:-1]).replace('_test', '')
        tdata['namespace'] = nmsp
        tdata['class'] = parts[-1].replace('Test', '')
        status = tdata['status']
        if status == 'NO STATUS':
          print 'Skipping %-30s: %s' % (subpath, status)
          continue

        /# Identify the directory containing log info for this target
        /#   test.cache_status
        /#   test.log
        /#   test.xml
        testdir = fs.join(logdir, subpath)
        tdata['dir'] = testdir
        /#print fs.listdir(testdir)

        /# Read/cache the test.log file
        logpath = fs.join(testdir, 'test.log')
        tdata['logpath'] = logpath
        logdata = fs.read(logpath)
        tdata['log'] = logdata

        /# Each log file contains results for zero or more methods:
        /#  - how long the test took
        /#  - stderr
        /#  - stdout
        methods = collections.OrderedDict()
        tdata['methods'] = methods

        /# Parse the log file (baselang-specific).
        baselang.parseBazelLog(logdata, tdata, debug=debug)
        if debug:
          pprint.pprint(tdata)
      return tests
    test:
      _, _, _, metac = test.cachedInfo()
      fs = metac.fs()
      sample_logs = test.resourcePath('sample_logs')
      stdout = test.newStr(fs.read(fs.join(sample_logs, 'bazel_stdout')))
      stderr = test.newStr(fs.read(fs.join(sample_logs, 'bazel_stderr')))
      tests = metac.parseBazelOutput(
        stdout=stdout, stderr=stderr, logdir=sample_logs)
      tdata = tests['//demo/cards2_test:FrenchPackTest']
      for key in ('dir', 'log', 'logpath'):
        del tdata[key]
      test.iseq(
        {'cached': None,
         'class': 'FrenchPack',
         'count': 2,
         'methods': {'FrenchPack.__init__': {'stdout': 'demo.cards2.FrenchPack.__init__ missing unittest\n',
                                             'us': 14},
                     'FrenchPack.asStr': {'stderr': '----------------------------------------------------------------------\nTraceback (most recent call last):\n  File "/private/var/tmp/_bazel_wmh/8a547b9529defa4d451cf083bf4156d1/bazel-sandbox/e96aaaed-7873-4fb6-a866-0c97391c7dd1-0/execroot/python/bazel-out/local-fastbuild/bin/demo/cards2_test/FrenchPackTest.runfiles/__main__/demo/cards2_test/FrenchPackTest.py", line 13, in test_asStr\n    card = demo.cards2.Card(1, 2)\nAttributeError: \'module\' object has no attribute \'Card\'\n\n----------------------------------------------------------------------',
                                          'stdout': '',
                                          'us': 163}},
         'namespace': 'demo.cards2',
         'status': 'FAILED',
         'status2': 'FAILED',
         'target': '//demo/cards2_test:FrenchPackTest',
         'time': '0.2s',
         'time2': '0.001s'},
        tdata)
    end method parseBazelOutput;

    method formatBazelOutput #:
      Produce output based on parsed bazel output
    params:
      var tests : map #:
        A map as returned from parseBazelOutput.
      var fp : ostream = out #:
        Where to write output.
      var indent : str = '' #:
        What to add before each line.
      var showerr : bool = false #:
        If true, show error output
      var showout : bool = false #:
        If true, show stdout
    scope:
      scope_sep = Context.TOKENS['scope_sep']
      for target in sorted(tests):
        tdata = tests[target]
        namespace_name = tdata['namespace']
        class_name = tdata['class']
        fqcn = namespace_name + scope_sep + class_name
        /# the amount of time taken to run the whole class test is in tenths of
        /# seconds (not great resolution
        clstime = '%6dms' % (1000 * float(tdata['time'][:-1]))
        cstatus = tdata['status']
        cstatus2 = tdata['status2']
        if cstatus2 == 'OK': cstatus2 = ''
        fp.write(
          '%s%-60s %10s   %-6s\n' %
          (indent, fqcn, clstime, cstatus))
        meths = tdata['methods']
        for cmname in sorted(meths):
          clsname, method_name = cmname.split(scope_sep)
          fqn = namespace_name + scope_sep + cmname
          mdata = meths[cmname]
          mstatus = ' FAIL' if 'stderr' in mdata else ''
          fp.write('%s  %-60s %8dus%s\n' % (indent, fqn, mdata['us'], mstatus))
          if showerr:
            stderr = mdata.get('stderr', '')
            if stderr:
              for line in stderr.rstrip().split('\n'):
                fp.write('%s    E|%s\n' % (indent, line))
          if showout:
            stdout = mdata.get('stdout', '')
            if stdout:
              for line in stdout.rstrip().split('\n'):
                fp.write('%s     |%s\n' % (indent, line))

        /#pprint.pprint(tdata)
    test:
      _, _, _, metac = test.cachedInfo()
      fs = metac.fs()
      sample_logs = test.resourcePath('sample_logs')
      stdout = test.newStr(fs.read(fs.join(sample_logs, 'bazel_stdout')))
      stderr = test.newStr(fs.read(fs.join(sample_logs, 'bazel_stderr')))
      tests = metac.parseBazelOutput(
        stdout=stdout, stderr=stderr, logdir=sample_logs)

      ofp = test.newStr()
      metac.formatBazelOutput(tests, fp=ofp)
      test.iseqtext(
        >|"""demo.cards2.Card                                                  300ms   PASSED
        >|  demo.cards2.Card.__init__                                          18us
        >|demo.cards2.Card__Meta                                            300ms   PASSED
        >|demo.cards2.FrenchPack                                            200ms   FAILED
        >|  demo.cards2.FrenchPack.__init__                                    14us
        >|  demo.cards2.FrenchPack.asStr                                      163us FAIL
        >|demo.cards2.FrenchPack__Meta                                      300ms   PASSED
        >|  demo.cards2.FrenchPack__Meta.__init__                              36us
        >|demo.cards2.Pack                                                  300ms   PASSED
        >|  demo.cards2.Pack.asStr                                             15us
        >|  demo.cards2.Pack.shuffle                                            4us
        >|demo.cards2.Pack__Meta                                            300ms   PASSED
        >|demo.cards2.Pile                                                  300ms   PASSED
        >|demo.cards2.Pile__Meta                                            200ms   PASSED
        >|""",
        ofp.getvalue())

      ofp = test.newStr()
      metac.formatBazelOutput(tests, fp=ofp, showerr=True, showout=True)
      test.iseqtext(
        >|"""demo.cards2.Card                                                  300ms   PASSED
        >|  demo.cards2.Card.__init__                                          18us
        >|     |demo.cards2.Card.__init__ missing unittest
        >|demo.cards2.Card__Meta                                            300ms   PASSED
        >|demo.cards2.FrenchPack                                            200ms   FAILED
        >|  demo.cards2.FrenchPack.__init__                                    14us
        >|     |demo.cards2.FrenchPack.__init__ missing unittest
        >|  demo.cards2.FrenchPack.asStr                                      163us FAIL
        >|    E|----------------------------------------------------------------------
        >|    E|Traceback (most recent call last):
        >|    E|  File "/private/var/tmp/_bazel_wmh/8a547b9529defa4d451cf083bf4156d1/bazel-sandbox/e96aaaed-7873-4fb6-a866-0c97391c7dd1-0/execroot/python/bazel-out/local-fastbuild/bin/demo/cards2_test/FrenchPackTest.runfiles/__main__/demo/cards2_test/FrenchPackTest.py", line 13, in test_asStr
        >|    E|    card = demo.cards2.Card(1, 2)
        >|    E|AttributeError: 'module' object has no attribute 'Card'
        >|    E|
        >|    E|----------------------------------------------------------------------
        >|demo.cards2.FrenchPack__Meta                                      300ms   PASSED
        >|  demo.cards2.FrenchPack__Meta.__init__                              36us
        >|     |demo.cards2.FrenchPack__Meta.__init__ missing unittest
        >|demo.cards2.Pack                                                  300ms   PASSED
        >|  demo.cards2.Pack.asStr                                             15us
        >|     |demo.cards2.Pack.asStr missing unittest
        >|  demo.cards2.Pack.shuffle                                            4us
        >|     |demo.cards2.Pack.shuffle missing unittest
        >|demo.cards2.Pack__Meta                                            300ms   PASSED
        >|demo.cards2.Pile                                                  300ms   PASSED
        >|demo.cards2.Pile__Meta                                            200ms   PASSED
        >|""",
        ofp.getvalue())
    end method formatBazelOutput;

    method filterMetaOutput #:
      Replace baselang-specific file references in ifp with meta-level refs.
    params:
      var baselang : metax.c.BaseLanguage = null #:
        The baselanguage generating the output being processed.
      var cwd : str = null #:
        The directory to use when making relative paths absolute. If None,
        the current working directory is used.
      var ifp : istream = in #:
        The input to be processed.
      var ofp : ostream = out #:
        Where output should be written.
      var debug : bool = false #:
        If True, print out information useful in debugging this method.
      var metakind : str = 'relpath' #:
        How to handle metafiles. Valid values are:
          abbrev: print metapath abbrevs (and the abbrev/path mapping afterwards)
          path: keep original path
          relpath: use relative path
      var basekind : str = 'abbrev' #:
        How to handle base files. Valid values are:
          abbrev: print base path abbrevs (and the abbrev/path mapping afterwards)
          path: keep original path
          relpath: use relative path
          none: do not show
    scope:
      fs = self.fs()
      if baselang is None:
        baselang = self.baselang()

      meta_paths = {}
      base_paths = {}

      metarep = self.repositoryPath()

      def PathAbbrev(paths, path):
        /# Return an abbrev for a path.
        /# var paths : dict
        /#   The current set of paths with abbrevs.
        /# var path: str
        /#   The path to obtain an abbrev for.
        /# Returns: str
        distinguishers = ('', '@', '#', '$', '%', '^', '&')
        base = fs.basename(path)
        result = None
        for dist in distinguishers:
          basename = base + dist
          if basename in paths:
            if paths[basename] == path:
              /# This basename already exists and is for the desired path,
              /# so it is what we want to return.
              result = basename
              break
            else:
              /# This basename refers to a different path, so we need to
              /# try another basename.
              pass
          else:
            /# This basename/path has never been seen before, so we create
            /# the mapping and return this basename.
            paths[basename] = path
            result = basename
            break
        return result

      if cwd is None:
        cwd = fs.cwd()
      /# TODO(wmh): Should these regexps be placed in the individual
      /# baselang classes (OoplPython, OoplCpp, etc.)?
      LANG_RE = {
        'python': {
          'match': re.compile(
            r'(?P<indent>\s*)File \"(?P<path>[^\"]+)\", line (?P<line>\d+), '
            r'in (?P<method>\S+)'),

          /# This contains a match, and multiple possible replacements.
          'replace': (
            r'File \"[^\"]+\", line (\d+)',
            {'both': '%(metapath)s:%(metaline)d (%(path)s:%(line)s)',
             'meta': '%(metapath)s:%(metaline)d'}),
        },
        'cpp': {
          'match': re.compile(
            r'^(?P<path>[^ :]+):(?P<line>\d+):(?P<column>\d+): (?P<error>.*)'),

          /# This contains a match, and multiple possible replacements.
          'replace': (
            r'^[^ :]+:\d+:\d+:',
            {'meta': '%(metapath)s:%(metaline)d:%(column)s',
             /# TODO(wmh): Fix this ... add in the baselang info.
            'both': '%(metapath)s:%(metaline)d:%(column)s'}),
        },
        'javascript': {
          'match': re.compile(r'^(?P<path>[^:]+):(?P<line>\d+): (?P<error>.*)'),

          /# This contains a match, and multiple possible replacements.
          'replace': (
            r'^[^:]+:\d+:',
            {'both': '%(metapath)s:%(metaline)d (%(path)s:%(line)s)',
             'meta': '%(metapath)s:%(metaline)d'}),
        },
      }
      repeat = fs.getenv('METAFILTECHO', 'false') == 'true'
      if repeat:
        /# ofp.write('META: repeat=%s\n' % repeat)
        pass
      error_re = LANG_RE[baselang.id()]['match']
      matcher, replace_options = LANG_RE[baselang.id()]['replace']
      mappings = {}

      if debug:
        print '#' * 70
        print fs.cwd()
        print 'matcher = %s' % str(matcher)
        print 'repopts = %s' % str(replace_options)
        /# print fs.join(fs.cwd(), 'metax')
        /# print fs.listdir(fs.join(fs.cwd(), 'metax'))
        /#print fs.listdir('/Users/wmh/src/meta/lib/beta/python/metax')
        /#fp = fs.open('/Users/wmh/src/wmh/lib/meta/oopl/python/metax/c.py', 'r')
        /#print 'HERE with %s' % Mapping
        /#print '#' * 70

      while True:
        line = ifp.readline()
        if not line: break

        error_match = error_re.match(line)
        if error_match:
          /# We attempt to map the baselang-level file/line reference to a
          /# meta-level file/line.  The 'line' variable will be modified if
          /# successful, and stays the same if not successful.
          /# Establish the baselang path and line number.
          metadata = error_match.groupdict()
          if debug:
            print '#' * 70
            sys.stdout.write('Found error match for: ' + line)
            pprint.pprint(metadata)
            print '#' * 70
          linenum = int(metadata['line'])
          path = metadata['path']
          if path[0] != '/':
            path = fs.normpath(fs.join(cwd, path))

          /# Special case to handle tracebacks encountered during bazel-based
          /# test runs. The paths cited no longer exist by the time this code
          /# is encountered.  However, we assume the bazel test applies to code
          /# found in METAREP, and map the bazel path to an appropriate subpath
          /# of METAREP.
          if '/bazel-sandbox/' in path:
            maintext = '/__main__/'
            idx = path.find(maintext)
            if idx == -1:
              raise Error('Unexpected failed to find %s in %s' % (maintext, path))
            subpath = path[idx + len(maintext):]
            /#print '**** HERE: %s' % subpath
            path = fs.join(metarep, 'oopl', 'python', subpath)
            /#print '**** NOW: %s' % path

          /# Obtain the base-to-meta mapping file for 'path'
          realpath = fs.realpath(path)
          map_path = self.mapPath(realpath)

          /# print 'PATH: %s\nREAL: %s\nMAP : %s' % (path, realpath, map_path)

          mapfile = mappings.get(map_path, None)
          if mapfile is None:
            if fs.exists(map_path):
              mapfile = self.loadMapFile(map_path)
              mappings[map_path] = mapfile
              if debug:
                ofp.write('META: Loading %s\n' % map_path)
                print 'PATH: ' + path
                print 'MAPP: ' + map_path
            else:
              if debug:
                ofp.write('META: Ignoring %s (no %s)\n' % (path, map_path))
                print 'PATH: ' + path
                print 'REAL: ' + realpath
                print 'MAPP: ' + map_path
              metadata = None

          if mapfile:
            metapath, metaline = mapfile.baseToMeta(linenum)
            /# Establish the metapath string to write.
            if debug:
              print 'NOTE: Converting baseline %d to meta gives %s' % (linenum, metaline)
            if metakind == 'path':
              pass
            elif metakind == 'abbrev':
              metadata['metapath'] = PathAbbrev(meta_paths, metapath)
            elif metakind == 'relpath':
              metadata['metapath'] = fs.relpath(metapath)
            else:
              raise Error('Invalid metakind %s' % metakind)

            /# Establish the metapath line number.
            if metaline is None:
              /# print 'NO metaline'
              metadata = None
            else:
              metadata['metaline'] = metaline

          if metadata:
            /# Maybe reformat the baselang file path.
            replacer = replace_options['both']
            if basekind is None or basekind == 'none':
              replacer = replace_options['meta']
            elif basekind == 'path':
              pass
            elif basekind == 'relpath':
              metadata['path'] = fs.relpath(path)
            elif basekind == 'abbrev':
              metadata['path'] = PathAbbrev(base_paths, path)
            else:
              raise Error('Invalid basekind %s' % basekind)
            if repeat:
              ofp.write(line)  # newline already present

            /# Rewrite the line based on metadata.
            line = re.sub(matcher, replacer % metadata, line)
        ofp.write(line)  # newline already present

      if meta_paths or base_paths:
        dsep('Meta File Map', delim='-', fp=ofp)
        maxwidth = max([len(k) for k in meta_paths] + [len(k) for k in base_paths])
        for kind, paths in (('meta', meta_paths), ('base', base_paths)):
          if paths:
            for abbrev in sorted(paths):
              ofp.write(
                '%s = %s\n' % (str.ljust(abbrev, maxwidth), paths[abbrev]))
        /# too noisy for no real gain
        /# dsep(' End File Map', delim='-', fp=ofp)

    test:
      /# IMPORTANT: Be careful with print out the input lines during testing.
      /# If you are running meta in a mode that invokes metafilt, the printed
      /# lines will get converted by metafilt and look like they are being
      /# converted by this code!
      /#test.fixenv()

      _, _, _, metac = test.cachedInfo()
      /# TODO(wmh): The following is very fragile ... need to stop relying on
      /# actual filesystem
      ifp = test.newStr("""
        >|Traceback (most recent call last):
        >|  File "/Users/wmh/src/meta/bin/meta2", line 40, in <module>
        >|    Main()
        >|  File "/Users/wmh/src/meta/bin/meta2", line 36, in Main
        >|    metac.interact(args)
        >|  File "/Users/wmh/src/meta/lib/beta/python/metax/c.py", line 15436, in interact
        >|    self.compileHook()
        >|  File "/Users/wmh/src/meta/lib/beta/python/metax/c.py", line 15520, in compileHook
        >|    metafiles, errors, warnings = self.processMeta(metafile_paths, fp=fp)
        >|  File "/Users/wmh/src/meta/lib/beta/python/metax/c.py", line 15376, in processMeta
        >|    file_construct.translateMeta()
        >|  File "/Users/wmh/src/meta/lib/beta/python/metax/c.py", line 8693, in translateMeta
        >|    child.translateMeta()
        >|  File "/Users/wmh/src/meta/lib/beta/python/metax/c.py", line 9279, in translateMeta
        >|    basefiles = self.compilePython(kind='merge', triples=triples)
        >|  File "/Users/wmh/src/meta/lib/beta/python/metax/c.py", line 9428, in compilePython
        >|    print 'HERE with %s' % initpath
        >|TypeError: not all arguments converted during string formatting
        >|""")
      ofp = test.fp()
      metac.filterMetaOutput(ifp=ifp, ofp=ofp)
      test.iseqtext("""
        >|Traceback (most recent call last):
        >|  File "/Users/wmh/src/meta/bin/meta2", line 40, in <module>
        >|    Main()
        >|  File "/Users/wmh/src/meta/bin/meta2", line 36, in Main
        >|    metac.interact(args)
        >|  ../../../../../meta2/src/kernel/parser.meta:12706 (c.py:15436), in interact
        >|    self.compileHook()
        >|  ../../../../../meta2/src/kernel/parser.meta:13006 (c.py:15520), in compileHook
        >|    metafiles, errors, warnings = self.processMeta(metafile_paths, fp=fp)
        >|  ../../../../../meta2/src/kernel/parser.meta:12646 (c.py:15376), in processMeta
        >|    file_construct.translateMeta()
        >|  ../../../../../meta2/src/kernel/parser.meta:6710 (c.py:8693), in translateMeta
        >|    child.translateMeta()
        >|  ../../../../../meta2/src/kernel/parser.meta:7487 (c.py:9279), in translateMeta
        >|    basefiles = self.compilePython(kind='merge', triples=triples)
        >|  ../../../../../meta2/src/kernel/parser.meta:7536 (c.py:9428), in compilePython
        >|    print 'HERE with %s' % initpath
        >|TypeError: not all arguments converted during string formatting
        >|-------------------------------- Meta File Map ---------------------------------
        >|c.py = /Users/wmh/src/meta/lib/beta/python/metax/c.py
        >|""",
        ofp.getvalue())
    end method filterMetaOutput;

    method executeBazelCommand : tuple<int,str,str> #:
      Execute a bazel command and return stdout and sterr.

      Returns:
       0) rc: int
            The return code.
       1) stdout: str
       2) stderr: str
    params:
      var args : vec<str> #:
        The args (not including the bazel command itself).
      var cwd : str = null #:
        The directory to execute within.  If null, current directory is used.
      var dryrun : bool = false #:
        If true, do NOT execute the command, just print it out.
      var quiet : bool = false #:
        If true, do NOT print out the command being executed.
      var prompt : bool = false #:
        If true, prompt before executing the command. If the user indicates
        no execution, the returned values are (1, None, None).
      var show : bool = false #:
        If true, print out stdout and stderr.
    scope:
      return self.executeCommand(
        'bazel', args, cwd=cwd, dryrun=dryrun, quiet=quiet, prompt=prompt,
        show=show)
    test:
    end method executeBazelCommand;

    method executeCommand : tuple<int,str,str> #:
      Execute a bazel command and return stdout and sterr.

      Returns:
       0) rc: int
            The return code.
       1) stdout: str
       2) stderr: str
    params:
      var command : str #:
        The command being executed.
      var args : vec<str> #:
        The args (not including the bazel command itself).
      var cwd : str = null #:
        The directory to execute within.  If null, current directory is used.
      var dryrun : bool = false #:
        If true, do NOT execute the command, just print it out.
      var quiet : bool = false #:
        If true, do NOT print out the command being executed.
      var prompt : bool = false #:
        If true, prompt before executing the command. If the user indicates
        no execution, the returned values are (1, None, None).
      var show : bool = false #:
        If true, print out stdout and stderr.
    scope:
      fs = self.fs()
      env = copy.copy(fs.environ())
      extra_env = []

      if command == 'bazel':
        /# We do some special-casing for bazel.
        command = Compiler.CONFIG['bazel']
        /# TODO(wmh): Decide whether to limit the env passed to bazel.  Not
        /# hermetic by relying on existing env!  Should we set env to {}?
        env['CC'] = Compiler.CONFIG['cpp_compiler']
        env['BAZEL_USE_CPP_ONLY_TOOLCHAIN'] = '1'
        extra_env = ['CC', 'BAZEL_USE_CPP_ONLY_TOOLCHAIN']

      allargs = [command] + args

      if not quiet:
        print 'NOTE: %sExecuting command:' % ('(NOT) ' if dryrun else '')
        if cwd:
          print ' %% cd %s' % cwd
        argstr = ' '.join(args)
        if extra_env:
          print ' %% %s \\' % ' '.join(
            ['%s=%s' % (evar, env[evar]) for evar in extra_env])
          print '    %s %s' % (command, argstr)
        else:
          print ' %% %s %s' % (command, argstr)
      else:
        if prompt:
          raise Error('Cannot specify quiet and prompt at the same time')

      /# Prompt if prompting desired.
      proceed = not dryrun
      if prompt and proceed:
        while True:
          ans = raw_input('Execute (Y/n)? ').strip().lower()
          if not ans or ans[0] == 'y':
            proceed = True
            break
          elif ans[0] == 'n':
            proceed = False
            break
          else:
            /# Not legal ... reprompt.
            pass

      /# Execute the command.
      if proceed:
        p = subprocess.Popen(
          allargs, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
          env=env, cwd=cwd)
        stdout, stderr = p.communicate()
        rc = p.returncode

        if show:
          if stdout:
            for line in stdout.strip().split('\n'):
              print ' |' + line
          if stderr:
            for line in stderr.strip().split('\n'):
              print 'E|' + line
      else:
        rc = 1
        stdout = None
        stderr = None

      return rc, stdout, stderr
    test:
    end method executeCommand;

    method parseRepository : map #:
      Parse a meta repository
    params:
      var repopath : str = null #:
        Which repository to parse. If null, the one from Config() is used.
    scope:
      if repopath is None:
        repopath = self.repositoryPath()
      fs = self.fs()

      /# We will produce a mapping from basel to namespace id to class id to
      /# map of class data:
      /#   decl: str
      /#     The path of the declaration. For languages with no separation,
      /#     returns the sole file representing the class.
      /#   defn: str
      /#     The path of the definition. e.g. in C++, this is the .cc file.
      /#   map: str
      /#     The map file
      /#   bazel: str
      /#     The file containing the BUILD snippet for the class.

      for basel in ('python', 'javascript', 'cpp'):
        topdir = fs.join(repopath, 'oopl', basel)

    test:
    end method parseRepository;

    method generateUmlDiagram #:
      Generate a UML diagram (using graphviz dot) for all metafiles.
    params:
      var metafiles : vec<MetaFile>;
      var destpath : str #:
        Where to write the dot output.
      var config : map #:
        Specifies information about how and what should be displayed in the UML.
        Legal keys are:
          field: dict
            name: str
              Only those fields whose name matches the regexp are chosen.
            visibility: restr
              Only those fields whose visibility matches the regexp are chosen.
            level: restr
              Only those fields whose level matches the regexp are chosen.
          method: dict
            name: str
              Only those fields whose name matches the regexp are chosen.
            visibility: restr
              Only those methods whose visibility matches the regexp are chosen.
            level: restr
              Only those methods whose level matches the regexp are chosen.
            params: str = 'none'
              One of
                none = do not show params
                required-names = show required names, no types, no optionals
                required = show required names and types, no optionals
                all-names = show required and optional names, no types or defaults
                all = show required and optional names and types, no defaults
                all* = show required and optional names and types, with default vals
      var show_user : bool = true #:
        Show user classes.
      var show_meta : bool = false #:
        Show metaclasses. If false, means do not show user-defined meta
        classes either.
      var show_test : bool = false #:
        Show testclasses. If false, means do not show user-defined test
        classes either.
      var display : bool = false #:
        If True, display the generated UML image.
      var verbose : bool = false #:
        If true, print out details of actions performed.
    scope:
      debug = False
      fs = self.fs()

      /# See
      /#   http://www.ffnn.nl/pages/articles/media/uml-diagrams-using-graphviz-dot.php
      /#   https://fsteeg.wordpress.com/2006/11/17/uml-class-diagrams-with-graphviz/
      /# for a discussion on how we can use graphviz dot to render UML class
      /# diagrams.
      /#
      /# See also
      /#   http://www.umlgraph.org/
      /#   https://www.graphviz.org/doc/info/attrs.html
      /#   http://rich-iannone.github.io/DiagrammeR/graphviz_and_mermaid.html (more for the visualization of graphviz options than for DiagrammeR)
      /#   http://rich-iannone.github.io/DiagrammeR/img/X11_Color_Names.png
      basepath, suffix = fs.splitext(destpath)
      if suffix != '.dot':
        /# We do this to ensure the person didn't accidentaly type something like:
        /#   % metac -U env.meta root.meta
        /# which would tromp over env.meta. Should be
        /#   % metac -U out.dot env.meta root.meta
        print 'ERROR: UML output file "%s" must end with .dot' % (
          destpath)
        return False
      impath = basepath + '.png'

      /# IMPLEMENTATION:
      /#  - We need to know:
      /#    - for each class
      /#      - what its base name is
      /#      - what namespace it is in
      /#      - what its parent(s) is
      /#      - which fields to display
      /#      - which methods to display
      /#      - the associations this class has with other classes
      baselang = self.baselang()

      /# Create a mapping from namespace fqn to dict containing:
      /#   construct: NamespaceConstruct
      /#   scope: ComplexBlock
      /#   classes: collections.OrderedDict()
      /#     Maps class ids to 
      /#
      /# Also create a mapping from class fqn to dict containing:
      /#    name: str
      /#    fqn: str
      /#    namespace: ?  (str or NamespaceConstruct?)
      /#    parent: ?  (str or ClassConstruct?)
      /#    construct: ClassConstruct
      /#    field: collections.OrderedDict()
      /#      name: str
      /#      construct: FieldConstruct
      /#      visibility: str
      /#      level: str
      /#      type: Type
      /#    method: collections.OrderedDict()
      /#      name: str
      /#      construct: MethodConstruct
      /#      visibility: str
      /#      level: str
      /#      type: Type
      allclasses = self.classes()
      namespaces = {}
      classes = {}

      for metafile in metafiles:
        /# Per-metafile processing
        filec = metafile.construct()
        for namespace in filec.attrval('scope:', default=None) or []:
          /# Per-namespace processing
          if namespace.kind() != 'namespace': continue
          nscope = namespace.attr('scope:', default=REQUIRED)
          nclasses = {}
          for klass in nscope.value():
            /# Per-class processing
            if klass.kind() != 'class': continue
            variant = klass.variant()
            if variant == 'user' and not show_user: continue
            if 'meta' in variant and not show_meta: continue
            if 'test' in variant and not show_test: continue
            cfqn = klass.fqn()
            cid = klass.id()

            fields = collections.OrderedDict()
            methods = collections.OrderedDict()
            parents = klass.parentclasses()
            parentinfo = parents[0] if parents else {}
            pfqn = parentinfo.get('metafqn', parentinfo.get('fqn', None))
            cinfo = {
              'name': cid,
              'fqn': cfqn,
              'parent': pfqn,
              'namespace': namespace,
              'construct': klass,
              'field': fields,
              'method': methods,
            }
            for classic in klass.attrval('scope:', default=None) or []:
              kind = classic.kind()
              if kind == 'field':
                fmdata = fields
                fmtype = classic.attrval('type', default=None)
                /# TODO(wmh): Decide how field visibility is going to be
                /# handled. The visibility of the state itself is private by
                /# default, but we probably need to allow for it to be protected
                /# or public.
                visibility = 'private'
              elif kind == 'method':
                fmdata = methods
                fmtype = classic.attrval('returns', default=None)
                visibility = classic.attrval('visibility')
              else:
                continue
              fmdata = cinfo[kind]
              efqn = classic.fqn()
              location = classic.attrval('location')
              attrkind = classic.attrval('kind')
              fmdata[efqn] = {
                'name': classic.id(),
                'construct': classic,
                'visibility': visibility,
                'level': location,
                'type': fmtype,
              }
            classes[cfqn] = cinfo
            nclasses[cid] = cinfo
          ninfo = {
            'construct': namespace,
            'scope': nscope,
            'classes': nclasses
          }
          namespaces[namespace.fqn()] = ninfo

      /# Add an entry to 'classes' for the root class of the baselang.
      /#  - TODO(wmh): Generalize to all baselangs.
      if baselang.id() == 'python':
        classes['object'] = {
          'name': 'object', 
          'fqn': 'object',
          'construct': None,
          'field': {},
          'method': {},
          'namespace': None,
          'parent': None,
        }

      associnfo = config.pop('assocs') if 'assocs' in config else {}
      /# print 'associnfo: %s' % str(associnfo)

      def Match(value, restr):
        /# Determine if a value matches a restr.
        if not restr or restr == 'false':
          result = False
        elif restr == 'true':
          result = True
        else:
          r = re.compile(restr)
          result = r.search(value)
        return result

      def Matches(construct, config, level, visibility, debug=False):
        /# Determine if a construct matches a config.
        /#  - if config is empty, we assume no match.
        /#  - if any item in the config fails, it means no match
        /#  - only if all items in the config match is it a match.
        if not config:
          return False
        kind = construct.kind()
        kindid = construct.kindid()
        cfg = config.get(kind, {})
        fails = []
        data = {'name': construct.id(), 'level': level, 'visibility': visibility}
        for key in data:
          if key in cfg:
            value = data[key]
            if not Match(value, cfg[key]):
              fails.append(
                '%s has %s %s !~ %s' % (kindid, key, value, cfg[key]))
        if debug and fails:
          print '#' * 40
          print construct.kindid()
          print '=' * 40
          pprint.pprint(fails)
        return len(fails) == 0

      def MethodSignature(method, cfg):
        result = method.id()
        ptype = cfg.get('params', 'none')
        plist = []
        if ptype != 'none':
          params = method.attrval('params:', default=None) or []
          reqonly = 'required' in ptype
          namesonly = '-names' in ptype
          for var in params:
            default = var.attrval('default', default=None)
            if default is not None and reqonly:
              /# We've finished parsing all the required args and are not to
              /# include optional args.
              plist.append('...')
              break
            psig = var.id()
            if not namesonly:
              ptype = var.attrval('type')
              psig += ' : ' + ptype.raw()
              /# TODO(wmh): Fix this ... all* isn't a type in v2
              if default is not None and ptype == 'all*':
                psig += ' = ' + default
            plist.append(psig)
        result += '(' + ', '.join(plist) + ')'
        return result

      def DotSafeId(name):
        /# Convert an identifier to one that is safe for use in graphviz dot.
        return name.replace('.', '_')

      def DotSafeField(field):
        /# Convert a field (an entry within a record-valued label) to dot safety.
        return field.replace('<', '\\<').replace('>', '\\>').replace('|', '\\|')

      vismap = {
        /# http://www.uml-diagrams.org/visibility.html
        'pubget': '+',
        'public': '+',
        'protected': '#',
        'private': '-',
        'package': '~',
      }

      /# Each element is a dict containing
      /#   src: str (required)
      /#     a fully qualified class name
      /#   dest: str (required)
      /#     a fully qualified class name
      /#   edge: dict (optional)
      /#     graphviz edge key/value pairs. Common keys include:
      /#       arrowtail
      /#       headlabel
      /#       taillabel
      /#       constraint
      /#     See http://www.graphviz.org/doc/info/attrs.html for details
      associations = []

      /# Analyze namespaces, classes, methods and fields looking for UML-related
      /# constructs.  This includes:
      /#  - inheritance relationships between classes
      /#  - the collection of fields defined within each class (and their
      /#    types and visibility)
      /#  - the collection of methods defined within each class (and their
      /#    return types, visibility and args).
      /#  - the associations between classes:
      /#     - any field whose type is a non-library class defines an
      /#       association between the class containing the field and the
      /#       class identified by the type of the field.
      /#        - whether it is composition or delegation
      for nmsp, nmdata in namespaces.iteritems():
        namespace = nmdata['construct']
        if debug:
          print '  ' + namespace.kindid()
        for clsname, clsdata in nmdata['classes'].iteritems():
          classy = clsdata['construct']
          if debug:
            print '    ' + classy.kindid()
          clsdata['uml_fields'] = []
          clsdata['uml_methods'] = []
          for fmkind in ('field', 'method'):
            for fmid, fmdata in clsdata[fmkind].iteritems():
              fmcons = fmdata['construct']
              vis = fmdata['visibility']
              level= fmdata['level']
              if Matches(fmcons, config, level, vis):
                if debug:
                  print '      ' + fmcons.kindid()
                fmtype = fmdata['type']
                /# Establish any extra text to appear after the name
                /# before the type.
                extra = ''
                if fmkind == 'field':
                  signature = fmcons.id()
                elif fmkind == 'method':
                  /# TODO(wmh): Conditionally add parameters (or params plus
                  /# types). Various config options:
                  /#  - do not show any params
                  /#  - show only required param names
                  /#  - show only required param names and types
                  /#  - show only required param names and types, with a
                  /#    special indicator if there are optional params.
                  /#  - show positional and optional names (with indicator
                  /#    for optional names).
                  /#  - show positional and optional names and types
                  /#  - show positional and optional names and types, and
                  /#    default values for optional params.
                  signature = MethodSignature(fmcons, config[fmkind])

                /# Indicate the level.
                if level == 'meta':
                  signature = '<u>' + signature + '</u>'

                /# Add an entry for this field/method.
                umlkey = 'uml_' + fmkind + 's'
                clsdata[umlkey].append(
                  '%s %s : %s' %
                  (vismap[vis], signature, fmtype.raw()))

              if fmkind == 'field':
                /# We analyze the fields looking for references to other
                /# classes, which indicates an association
                fmtype = fmdata['type']
                basetype = fmtype.base()
                if fmtype.isPrimitive():
                  pass
                elif fmtype.isNative():
                  /# TODO(wmh): For all container-based native types, we need
                  /# to see if the elements are class types.
                  if basetype == 'vec':
                    /# Check if elements are class types.
                    print 'FixMe: Currently ignoring %s.%s.%s : %s' % (
                      nmsp, clsname, fmid, fmtype.raw())
                  elif 'map' in basetype:
                    /# Check if values are class types.
                    print 'FixMe: Currently ignoring %s.%s.%s : %s' % (
                      nmsp, clsname, fmid, fmtype.raw())
                else:
                  /# Not primitive and not native means class type.
                  assoc_fqn = fmtype.base()
                  if assoc_fqn is None:
                    /# The type is not legal. Could be a disjunctive type.
                    assoc_nmsp = None
                    assoc_name = None
                  else:
                    assoc_nmsp, assoc_name = assoc_fqn.rsplit('.', 1)

                  good = assoc_fqn in classes
                  print '%s%s.%s.%s : %s [%s]' % (
                    '*' if good else ' ',
                    nmsp, clsname, fmid, fmtype.raw(), assoc_fqn)
                  if good:
                    edge = {
                      'arrowtail': 'odiamond',
                      'taillabel': '"1"',
                      'headlabel': '"0..1"' if fmtype.isPtr() else '"1"',
                      'label': '"%s"' % fmid,
                    }
                    associations.append(
                      {'src': DotSafeId(clsdata['fqn']),
                       'dest': DotSafeId(assoc_fqn),
                       'edge': edge})

      /# Now create the .dot file.
      /#  - See http://www.graphviz.org/doc/info/attrs.html for details on what
      /#    attributes exist for nodes, edges, etc.
      with open(destpath, 'w') as fp:
        fp.write("""
          >|digraph G {
          >|  fontname = "Bitstream Vera Sans"
          >|  fontsize = 8
          >|
          >|  node [
          >|    fontname = "Bitstream Vera Sans"
          >|    fontsize = 8
          >|    shape = "record"
          >|    style = "filled"
          >|    fillcolor = "gray95"
          >|    height = 0.25
          >|  ]
          >|
          >|  edge [
          >|    fontname = "Bitstream Vera Sans"
          >|    fontsize = 8
          >|  ]
          >|""")
        /# Print out the namespaces and each class within them.
        max_entries = 50
        for nmsp in sorted(namespaces):
          fp.write('\n')
          fp.write('  subgraph cluster_%s {\n' % DotSafeId(nmsp))
          fp.write('    label = "Namespace %s"\n\n' % nmsp)
          cmap = namespaces[nmsp]['classes']
          for name in sorted(cmap):
            clsdata = cmap[name]

            /# TODO(wmh): Is this restricting of sizes necessary any more?
            fields = clsdata['uml_fields']
            if len(fields) > max_entries:
              fields = fields[:max_entries-1] + ['...']
            methods = clsdata['uml_methods']
            if len(methods) > max_entries:
              methods = methods[:max_entries-1] + ['...']

            fqn = clsdata['fqn']
            fp.write('    %s [\n' % DotSafeId(fqn))

            /# Now render the label for this class. At the very least, it contains
            /# the name of the class, but may also include 0 or more fields and
            /# 0 or more methods.
            /#
            /# TODO(wmh): Consider switching to using HTML-like labels per
            /#   http://www.graphviz.org/doc/info/shapes.html/#html
            /# They are more flexible relative to the more concise format in
            /#   http://www.graphviz.org/doc/info/shapes.html/#record
            /# for example:
            /#   HTML supports <u>, <s>, etc. whereas I don't think it is possible
            /#   to underline or strikethru in record labels without html syntax.
            /# but there are some questions to resolve:
            /#  - how to specify newlines in a particular row of the table?
            /#    Presumably just <br>?
            /#  -
            if fields or methods:
              fp.write(
                /# NOTE(wmh): It is apparently necessary to end the fields and
                /# mehods lists with a \l so that the last field doesn't get
                /# centered instead of left-justified.  This is probably a bug in
                /# graphviz that will get fixed ... consider testing this later
                /# (2016/08/28).
                '      label = "{%s|%s\l|%s\l}"\n' %
                (name,
                 '\\l'.join([DotSafeField(field) for field in fields]),
                 '\\l'.join([DotSafeField(method) for method in methods])))
            else:
              fp.write('      label = "{%s}"\n' % name)
            fp.write('    ]\n')
          fp.write('  }\n')

        /# Find all classes that are in the inheritance hierarchy that we
        /# haven't created nodes for.
        missing = []
        for fqn in sorted(classes):
          cmap = classes[fqn]
          fqparent = cmap['parent']
          if fqparent and fqparent not in classes:
            if fqparent not in missing:
              /# Remeber the parent
              missing.append(fqparent)
              pklass = allclasses.get(fqparent, None)
              ppcs = pklass.parentclasses()
              pc = ppcs[0] if ppcs else None
              ppc = pc['fqn'] if pc else None
              /# print ' *** MISSING %s = %s' % (fqparent, ppc)
              classes[fqparent] = {
                'name': fqparent, 'fqn': fqparent, 'parent': ppc}

        /# Create an 'external' subgraph and add all missing classes to it.
        fp.write('  subgraph cluster_external {\n')
        fp.write('    label = "Classes not in this compilation"\n')
        for fqn in missing:
          fp.write('    %s [\n' % DotSafeId(fqn))
          fp.write('      label = "{%s}"\n' % fqn)
          fp.write('    ]\n')
          /# Remember that we've generated this class.
          classes[fqn] = {
            'name': fqn, 'fqn': fqn, 'parent': None}
        fp.write('  }\n')

        /# Now specify the parent/child inheritance relationships.
        fp.write("""
          >|  edge [
          >|    dir = "back"
          >|    arrowtail = "empty"
          >|  ]
          >|""")
        for fqn in sorted(classes):
          cmap = classes[fqn]
          parent = cmap['parent']
          if parent is None:
            pass
          elif parent in classes:
            fp.write('  %s -> %s\n' % (DotSafeId(parent), DotSafeId(fqn)))
          else:
            /# The 'parent' is probably a baselang parent not defined in Meta.
            /# We dump it verbatim.
            fp.write('  %s -> %s\n' % (DotSafeId(parent), DotSafeId(fqn)))
            /# print 'WARNING: %s has unknown parent %s' % (fqn, parent)

        /# Now specify associations.
        if False:
          for assoc in associations:
            edgecfg = assoc.get('edge', {})
            fp.write(
              '  %s -> %s [%s]\n' %
              (assoc['src'], assoc['dest'],
               ', '.join(['%s=%s' % (k,edgecfg[k]) for k in sorted(edgecfg)])))

        /# Finish the dot file.
        fp.write('}\n')
        if verbose:
          print 'Wrote ' + destpath

      /# Now create the image file.
      args = ['dot', '-Tpng', '-o', impath, destpath]
      if verbose:
        print 'Command: ' + ' '.join(args)
      p = subprocess.Popen(
        args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
      stdout, stderr = p.communicate()
      if stderr:
        print 'ERROR: %s' % stderr
      else:
        if verbose:
          print 'Wrote ' + impath

        /# Now display the image file.
        if display:
          args = ['display', impath]
          if verbose:
            print 'Command: ' + ' '.join(args)
          try:
            subprocess.check_output(args)
          except KeyboardInterrupt:
            pass
    test:
      root_command, cli = metastrap.ParseArgv(
        ['dummy-binary'], metax.cli, root_module=metax.root)

      metafile, file_scope, namespace, path = test.getMetaFile(
        'oopl', 'cards2', expand=True, imports=True)
      metac = metafile.compiler()
      config = metac.__class__.CONFIG
      fs = metac.fs()
      dotpath = fs.join(config['src_root'], 'src', 'kernel', 'tmp.dot')
      metac.generateUmlDiagram([metafile], dotpath, config={})
    end method generateUmlDiagram;

    meta
    method MakeSnapshot #:
      Create a new snapshot (and, optionally, release).

      A snapshot is a private copy of the meta and baselang source code needed
      to implement Meta.
      - Snapshots are used to ameliorate the issues with writing self-modifying code
        - The meta compiler uses classes in metax.*, and invoking the meta
          compiler writes classes in metax.*, so any bugs introduced breaks
          the compiler.
        - By being able to use an snapshot of the metax.* code instead of the
          'live' metax.* code, we can recover from such issues.
        - Snapshots are a fourth layer to the traditional three-layer version:
            <major>.<minor>.<release>.<snapshot>
      
      A release is a public copy of the meta and baselang source code needed to
      implement Meta.
      - Releases will be available on http://metaxy.org for download

      TODO(wmh): Consider making this a meta method in metax.c.Compiler. But it
      is more high-level than the compiler. Maybe define metax.c.Env?
    params:
      var fs : metax.fs.FileSystem #:
        The filesystem instance to use for I/O operations.
      var verbose : bool = false #:
        If true, print out actions performed.
      var make_release : bool = false #:
        If true, make a public release (creates .tgz file)
    scope:
      /###  
      /# We first check if there are any .meta2 symlinks below the kernel dir.
      /#  - such symlinks usually occur because of an accidental invocation of
      /#    meta2 within a subdir.
      /#  - if there is a .meta2 symlink inside a directory that is included
      /#    as a resource, we will have a problem when we use 'tar czhf' to
      /#    tar up files ... symlinks are followed, and having spurious .meta2
      /#    links around brings in a massive amount of additional unnecessary files.
      /#  - we'll need to loosen this up a bit in the future, but better safe than
      /#    broken.
      config, _ = meta.Config()
      kerneldir = fs.join(config['src_root'], 'src', 'kernel')
      for path in (
        fs.join(kerneldir, 'testdata', '.meta2'),
      ):
        if fs.exists(path):
          fs.unlink(path)
          if verbose:
            print 'NOTE: Removed ' + path
      problems = subprocess.check_output(
        ['find', '.', '-type', 'l', '-a', '-name', '.meta2', '-a',
         '-mindepth', '2',  '-print'],
        cwd=kerneldir)
      if problems:
        print 'WARNING: Not produces snapshot because of spurious .meta2 links.'
        print problems
        sys.exit(1)
      bazel_links = subprocess.check_output(
        ['find', '.', '-type', 'l', '-a', '-name', 'bazel-*', '-print'],
        cwd=kerneldir)
      if bazel_links:
        print 'WARNING: Found bazel-* links.'
        print bazel_links
        ans = raw_input('Remove (yes|no)? ').strip()
        if ans.lower() == 'yes':
          for path in bazel_links.strip().split('\n'):
            fs.unlink(path)
            if verbose:
              print 'Removed ' + path
        bazel_links = subprocess.check_output(
          ['find', '.', '-type', 'l', '-a', '-name', 'bazel-*', '-print'],
          cwd=kerneldir)
        if bazel_links:
          print 'Not proceeding.'
          sys.exit(1)

      /###
      /# Establish the new version number
      /# CODETANGLE(version_path): in metastrap.py
      release_dir = fs.join(config['src_root'], 'lib', 'versions')
      vre = re.compile(r'^v(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$')
      versions = []
      for base in fs.listdir(release_dir):
        m = vre.match(base)
        if m:
          major = int(m.group(1))
          minor = int(m.group(2))
          release = int(m.group(3))
          snapshot = int(m.group(4) or 0)
          assert major == 0   # for now
          assert minor == 7   # for now
          versions.append((base, major, minor, release, snapshot))
      versions = sorted(
        versions, cmp=lambda p1, p2: (
          cmp(p1[1], p2[1]) or cmp(p1[2], p2[2]) or cmp(p1[3], p2[3]) or
          cmp(p1[4], p2[4])))
      previous_version, major, minor, release, snapshot = versions[-1]

      release_version = None
      if make_release:
        release_version = 'v%d.%d.%d' % (major, minor, release + 1)
        new_version = release_version + '.00'
      else:
        new_version = 'v%d.%d.%d.%02d' % (major, minor, release, snapshot + 1)
        
      newpath = fs.join(release_dir, new_version)

      /###
      /# Create the new version dir
      assert not fs.exists(newpath)
      fs.mkdir(newpath, 0755)
      if verbose:
        print 'NOTE: Created %s' % newpath

      /###
      /# Copy metastrap.py <newpath>/src
      import metastrap
      metastrap_path = metastrap.__file__
      if metastrap_path.endswith('.pyc'):
        metastrap_path = metastrap_path.replace('.pyc', '.py')
      metastrap_dest = fs.join(newpath, 'metastrap.py')
      fs.copyfile(metastrap_path, metastrap_dest)
      if verbose:
        print 'NOTE: Copied %s to %s' % (metastrap_path, metastrap_dest)

      /###
      /# Copy <<src_root>>/src/kernel/*.meta2 to <newpath>/src
      srcdir = fs.join(newpath, 'src')
      fs.mkdir(srcdir, 0755)  
      for base in fs.listdir(kerneldir):
        if base.endswith('.meta2') and base != '.meta2':
          srcfile = fs.join(kerneldir, base)
          destfile = fs.join(srcdir, base)
          fs.copyfile(srcfile, destfile)
          if verbose:
            print 'NOTE: Copied %s to %s' % (srcfile, destfile)
            
      /###
      /# Copy <<repository_path>>/oopl/python/metax to <newpath>/lib
      /#  - we specifically want symlinks to be converted into real files so
      /#    that the copy is self-contained. HOWEVER, this is dangerous if
      /#    there are symlinks that are massive ... how to address this?
      repometax = fs.join(
        config['repository_path'], 'oopl', 'python', 'metax')
      libdir = fs.join(newpath, 'lib')
      fs.mkdir(libdir, 0755)
      destmetax = fs.join(libdir, 'metax')
      fs.copytree(repometax, destmetax, symlinks=False)
      if verbose:
        print 'NOTE: Copied %s to %s' % (repometax, destmetax)

      /###
      /# Copy <<src_root>>/src/schema/{meta,oopl}/schema.meta to <newpath>/schema
      schemasrc = fs.join(config['src_root'], 'src', 'schema')  
      schemadir = fs.join(newpath, 'schema')
      metadir = fs.join(schemadir, 'meta')
      oopldir = fs.join(schemadir, 'oopl')
      fs.mkdir(schemadir, 0755)  
      fs.mkdir(metadir, 0755)  
      fs.mkdir(oopldir, 0755)
      meta_schema_src = fs.join(schemasrc, 'meta', 'schema.meta')
      oopl_schema_src = fs.join(schemasrc, 'oopl', 'schema.meta')
      meta_schema_dst = fs.join(metadir, 'schema.meta')
      oopl_schema_dst = fs.join(oopldir, 'schema.meta')
      fs.copyfile(meta_schema_src, meta_schema_dst)
      if verbose:
        print 'NOTE: Copied %s to %s' % (meta_schema_src, meta_schema_dst)
      fs.copyfile(oopl_schema_src, oopl_schema_dst)
      if verbose:
        print 'NOTE: Copied %s to %s' % (oopl_schema_src, oopl_schema_dst)

      /###
      /# Copy $HOME/.config/metameta to <newpath>/config/metameta
      configdir = fs.join(newpath, 'config')
      fs.mkdir(configdir, 0755)
      config_src = fs.join(fs.getenv('HOME'), '.config', 'metaxy')
      config_dst = fs.join(configdir, 'metaxy')
      fs.copytree(config_src, config_dst)
      if verbose:
        print 'NOTE: Copied %s to %s' % (config_src, config_dst)

      /###
      /# Update the 'current' link
      current_link = fs.join(release_dir, 'current')
      if fs.lexists(current_link):
        if not fs.islink(current_link):
          raise IOError('Expecting %s to be a symlink' % current_link)
        fs.unlink(current_link)
      fs.symlink(newpath, current_link)

      /###
      /# Update the 'stable' link
      stable_link = fs.join(release_dir, 'stable')
      if fs.lexists(stable_link):
        if not fs.islink(stable_link):
          raise IOError('Expecting %s to be a symlink' % stable_link)
        fs.unlink(stable_link)
      fs.symlink(
        fs.join(release_dir, previous_version), stable_link)

      /###
      /# Create a tar file (for releases)
      /#  - see https://superuser.com/questions/119928/weird-bug-in-tar-not-including-files-named-init-py
      /#    for details on why the env.vars. are being set.
      if make_release:
        release_path = fs.join(release_dir, release_version)
        fs.symlink(newpath, release_path)
        tarbase = release_version + '.tgz'
        tarpath = fs.join(release_dir, tarbase)
        env = copy.copy(fs.environ())
        env['COPY_EXTENDED_ATTRIBUTES_DISABLE'] = 'true'
        env['COPYFILE_DISABLE'] = 'true'
        tarcmd = ['tar', '-czhf', tarbase, release_version]
        subprocess.call(tarcmd, cwd=release_dir, env=env)
        if verbose:
          print 'NOTE: Created ' + tarpath
    end method MakeSnapshot;

    command main #:
      The public interface to the Meta compiler.

      Note that this assumes that the 'meta2' script does the following:
       - creates a Command for generic flags (--baselang, --metalang, etc.)
         and a catch-all arg.
       - instantiates the command on argv to process top-level flags.
       - invokes this Entry with all unprocessed args/flags in subsequent args.
         The assumption is that the first such value is a named command
         defined within this command.
       - meta2 passes in the Command instance created and instantiated, so that
         the top-level Command instance created by this 'command' block can
         inherit from it to obtain access to the meta2-level flags.
       - if the first arg passed in is NOT one of the commands recognized here,
         we hack up a special catch-all
    scope:

      block preamble #:
        This initial block creates a Command instance and performs some
        initial sanity checks.
      scope:
        /# IMPORTANT: This entry point is somewhat non-standard, because the
        /# 'meta2' script creates a Command instance, parses some flags, then
        /# invokes this entry method, which creates another Command and various
        /# subCommands.
        /#  - passing the right argv, and the right 'parent' to the
        /#    constructors and 'instantiate' method is critically important.
        /#    - the argv passed by the 'meta2' script into the Entry method
        /#      ensures that the first arg is 'main' so that when we
        /#      instantiate the top-level construct within the auto-generated
        /#      code-base, the right values are analyzed.
        /#  - the auto-generated code uses a special meta__names variable
        /#    to compare values in the nested command structure, and this
        /#    variable is assumed to have the name of the main construct
        /#
        /# CODETANGLE(meta2_entry_main): First arg must be 'main'
        assert args[0] == 'main'
        while meta__names[0] != 'main':
          meta__names.pop(0)
          meta__names.append(False)

        /# We update MetaObject's idea of instantiated command.
        assert metax.root.MetaObject.CLI() is not None
        metax.root.MetaObject.CLI()._command_Is(selected_command)

        /# Create the Compiler instance.
        metac = metax.c.Compiler(metal=cli.metalang, basel=cli.baselang)
        metax.c.Compiler.CurrentIs(metac)
        /# Ensure that the repository directory exists.
        if not metac.verifyDirectory(metadir='.meta2'):
          sys.exit(1)

        /# The Entry method is meta-level, so 'self' isn't defined.  We
        /# have self refer to the newly created Compiler instance. This will
        /# make it easy to flip between virtual and function implementations
        /# of the code.
        self = metac
      end block preamble;

      command verify_bazel #:
        Test parsing of bazel logs relative to non-bazel test invocations.

        Verify that bazel test stdout/stderr matches expectations relative to an
        invocation of the test harness without bazel.
      scope:
        named block ::
          argmap = self.argmap()
          for fqn in argmap['fqns']:
            self.verifyBazelOutput(fqn)
      end command verify_bazel;

      command canonical #:
        Canonicalize the specified meta files and report diffs.
      scope:
        named block ::
          flags = self.cli()
          argmap = self._parseArgs(flags.rest)
          metafile_paths = argmap['metafiles']
          context = self.metalang().context()
          errors = 0

          for path in metafile_paths:
            metafile = self.parseMeta(
              path, debuglevel=flags.debug, context=context)
            if metafile.hasErrors(show=True):
              errors += 1
            else:
              if False and flags.expand:
                metafile.construct().expandMeta()
                if metafile.hasErrors(show=True):
                  errors += 1
              if errors == 0:
                print '#' * 80
                print path
                for construct in metafile.construct().attr('scope:').value():
                  construct.write()
      end command canonical;

      command cd #:
        Change (conceptual) directory.
      scope:
        named block ::
          flags = self.cli()
          command = flags._command_()
          command.show()
          print 'hello!'
      end command cd;

      command checkmap #:
        Verify that a baselang map file is correct.
      scope:
        named block ::
          print 'WARNING: Command "checkmap" is not yet implemented.'
      end command checkmap;

      command checkrep #:
        Verify that the Meta repository is sane.
      scope:
        named block ::
          print 'WARNING: Command "checkrep" is not yet implemented.'
      end command checkrep;

      command clean #:
        Remove a class from the Meta repository
      scope:
        named block ::
          print 'WARNING: Command "clean" is not yet implemented.'
      end command clean;

      command compare #:
        Run normal code and experimental code and compare generated results.
      scope:
        named block ::
          print 'WARNING: Command "compare" is not yet implemented.'
      end command compare;

      command compile #:
        Compile specified .meta files.
      scope:
        named block ::
          /# TODO(wmh): Get aliases working on primary keys so we can
          /# implement 'arg'!
          /# arg args : list<str>;
          flags = self.cli()
          argmap = self._parseArgs(flags.rest, implicit=True)
          metafile_paths = argmap['metafiles']
          fp = sys.stdout
          try:
            metafiles, errors, warnings = self.getMetas(metafile_paths, fp=fp)
          except Exception as e:
            text = traceback.format_exc()
            if False:
              print '#' * 70
              print text
              print '=' * 70
            ifp = cStringIO.StringIO(text)
            /# Note that the baselang being compiled is NOT what is important
            /# when performing baseling-to-metaline conversions ... it is the
            /# baselang being used to compile the code that is important!
            /# This parser.meta code is currently assuming a python implementation,
            /# so that is the baselang we use.
            baselang = self.metalang().baselangNamed('python')
            self.filterMetaOutput(baselang=baselang, ifp=ifp, debug=False)

            sys.exit(1)
          else:
            self.writeSummary(metafiles)

          if flags.test:
            targets = []
            for metafile in metafiles:
              for namespace in metafile.construct().attrval('scope:', default=EMPTY):
                if namespace.variant() == 'user':
                  targets.append(namespace.fqn())
            flags.rawtests = True
            if targets:
              self.runUnitTests(targets, verbose=flags.verbose)
          return errors == 0
      end command compile;

      command config #:
        Print out the config values
      scope:
        named block ::
          config = Compiler.CONFIG
          cli = self.cli()
          if len(cli.rest) == 1:
            var = cli.rest[0]
            print config.get(var, '<INVALID>')
          else:
            vars = cli.rest or sorted(config)
            for var in vars:
              print '%-20s = %s' % (var, config.get(var, '<INVALID>'))
      end command config;

      command emacs #:
        Generate an emacs major mode for the current meta language.
      scope:

        named block ::
          self.generateMajorMode()
      end command emacs;

      command expand #:
        Expand a specified .meta file.  Consider using 'get' instead.
      scope:
        named block ::
          cli = self.cli()
          fs = self.fs()
          argmap = self._parseArgs(cli.rest)
          errors = False
          metafiles = []
          for path in argmap['metafiles']:
            metafile = self.getMeta(
              path, expand=True,
              imports=False, translate=False, compile=False)
            if metafile.hasErrors(show=True):
              pass
            else:
              newpath = path + '.exp'
              newpath = newpath.replace('.meta2.exp', '.exp.meta2')
              file_construct = metafile.construct()
              with fs.open(newpath, 'w') as fp:
                for construct in file_construct.attrval('scope:', default=None) or []:
                  if construct.kind() != 'namespace': continue
                  construct.write(fp=fp)
              print 'Wrote ' + newpath
            metafiles.append(metafile)
      end command expand;

      command get #:
        Get a .meta file (parse, expand, import, translate and compile).
      scope:
        named block ::
          cli = self.cli()
          argmap = self._parseArgs(cli.rest)
          errors = False
          metafiles = []
          for path in argmap['metafiles']:
            metafile = self.getMeta(
              path, expand=True, imports=True, translate=True, compile=True)
            if metafile.hasErrors(show=True):
              errors = True
              break
            metafiles.append(metafile)
          if not errors:
            self.writeSummary(metafiles)
      end command get;

      command help #:
        Implement the 'help' command.

        Print out a summary of available commands
      scope:
        named block ::
          command = self.cli()._command_()
          command.help()
      end command help;

      command html #:
        Create .html files for the specified metafile(s) and their basefiles.
      scope:
        named block ::
          cls = self.__class__
          fs = self.fs()
          verbose = True

          /# We create a local compiler so that we can limit scope to the
          /# files and namespaces specified on the command, rather than all
          /# files parsed in this shell.
          metac = metax.c.Compiler(
            metal=self.metalang().id(),
            basel=self.baselang().id(),
            rootdir=fs.rootdir(),
            metadir=fs.metadir(),
            kind=fs.kind(),
            repodir=self.repodir())

          /# Some useful vars
          flags = metac.cli()
          argmap = metac._parseArgs(flags.rest)
          metafile_paths = argmap['metafiles']
          metalang = metac.metalang()
          context = metalang.context()
          errors = 0
          suffix = '.meta2'
          chatty = True

          /# Establish the rootdir for .html files.
          /#  - one possibility is to write hidden .html files adjacent to
          /#    each .meta file
          /#  - another possibility is to write into
          /#       <<repository_path>>/<metalang>/meta/<namespace>
          /#    for each namespace in the .meta files.
          /# Although there are pros and cons of both, there is utility in
          /# putting as much generated data as possible into the repository,
          /# so that we can do post-analysis, display via the shell, etc.
          metadir = fs.join(
            self.repositoryPath(), metalang.id(), 'meta')

          /# Parse the specified paths.
          for path in metafile_paths:
            /# Parse the file.
            metafile = metac.parseMeta(
              path, debuglevel=flags.debug, context=context)

            if not metafile.hasErrors(show=True):
              /# Generate the HTML file BEFORE we expand the metafile!
              filecons = metafile.construct()
              for namespace in filecons.attr('scope:').value():
                outlines = []

                /# Obtain the htmlish contents.
                fp = cStringIO.StringIO()
                mode = {'form': 'html', 'out': {}}
                namespace.write(fp=fp, mode=mode)
                lines = fp.getvalue().split('\n')
                out = mode['out']
                allids_json = json.dumps(out)
                import pprint
                /# pprint.pprint(out)
                outlines.append('<div class="metadex">')
                outlines.append('  <center><b>%s</b></center>' % namespace.id())
                outlines.append('  <table>')
                bout = out['block']
                for i, bkey in enumerate(sorted(bout)):
                  argstr = "allids.block['%s']" % bkey
                  outlines.append(
                    '    <tr>'
                    '<td>%s</td>'
                    '<td></td>'
                    '<td>%s</td>'
                    '<td onclick="slist(%s)">S</td>'
                    '<td onclick="ulist(%s)">U</td>'
                    '<td onclick="tlist(%s)">T</td>'
                    '</tr>' %
                    ('block' if i == 0 else '',
                     bkey, argstr, argstr, argstr))
                lout = out['lang']
                for i, lkey in enumerate(sorted(lout)):
                  baseout = lout[lkey]
                  for j, bkey in enumerate(sorted(baseout)):
                    argstr = "allids.lang.%s['%s']" % (lkey, bkey)
                    outlines.append(
                      '    <tr>'
                      '<td>%s</td>'
                      '<td>%s</td>'
                      '<td>%s</td>'
                      '<td onclick="slist(%s)">S</td>'
                      '<td onclick="ulist(%s)">U</td>'
                      '<td onclick="tlist(%s)">T</td>'
                      '</tr>' %
                      ('baselang' if (i == 0 and j == 0) else '',
                       lkey if j == 0 else '',
                       bkey, argstr, argstr, argstr))
                cout = out['construct']
                outlines.append('  </table>')
                outlines.append('</div>')

                /# Now wrap the htmlized lines into an overarching structure
                /# that shows line numbers, indents blocks, allows blocks to
                /# be opened and closed, etc.
                outlines.append('<div class="metafile">')
                dentlevel = 0
                linenum = 0
                for line in lines:
                  indent = '  ' * (dentlevel + 1)
                  if line and line[0] == '':
                    /# Escape sequence indicating block start/end.
                    _, block_kind, conskind, block_uid, attrkey, basel, se = line.split(' ')
                    if se == 'start':
                      /# print 'starting %s %s' % (consfqn, attrkey)
                      dentlevel += 1
                      classes = []
                      is_code = 'scope' in attrkey or 'test' in attrkey
                      if block_kind == 'simple' and is_code:
                        classes.append('baselang')
                        classes.append(basel)
                      if attrkey in ('comment:', '#:'):
                        classes.append('face-comment')
                      outlines.append(
                        indent + '<div id="%s" class="%s">' % (
                          block_uid, ' '.join(classes)))
                    else:
                      /# print 'ending   %s %s' % (consfqn, attrkey)
                      dentlevel -= 1
                      outlines.append(indent[2:] + '</div>')
                  else:
                    /# We first remove the indentation from the beginning of the
                    /# line.
                    idx = dentlevel * 2
                    prefix = line[:idx]
                    line = line[idx:]

                    linenum += 1
                    if chatty:
                      subindent = indent + '  '
                      outlines.append(indent + '<div>')
                      outlines.append(
                        subindent + '<span class="linenum">%d</span>' % linenum)
                      outlines.append(
                        subindent + '<span class="indent%d"></span>' % dentlevel)
                      outlines.append(
                        subindent + '<span class="linetext"><code>%s</code></span>' % line)
                      outlines.append(indent + '</div>')
                    else:
                      outlines.append(
                        '%s<div>'
                        '<span class="linenum">%d</span>'
                        '<span class="indent%d"></span>'
                        '<span class="linetext"><code>%s</code></span>'
                        '</div>' %
                        (indent, linenum, dentlevel, line))

                /# Write the result to the dest file.
                parts = namespace.id().split('.')
                htmldir = fs.join(metadir, *parts)
                if not fs.exists(htmldir):
                  fs.makedirs(htmldir, 0755)
                htmlpath = fs.join(htmldir, 'index.html')
                with fs.open(htmlpath, 'w') as fp:
                  html_head = cls.HTML_HEAD.replace('${#allids#}', allids_json)
                  fp.write(
                    '<html>\n  <head>\n%s\n  </head>\n' % html_head)
                  fp.write('  <body>\n')
                  for line in outlines:
                    fp.write(line)
                    fp.write('\n')
                  fp.write('  </body>\n')
                  fp.write('</html>\n')
                  if verbose:
                    print 'Wrote ' + htmlpath

              /# Now expand and translate.
              filecons.expandMeta()
              if not metafile.hasErrors(show=True):
                filecons.translateMeta()
                if not metafile.hasErrors(show=True):
                  /# Create HTML files for the baselang files generated.
                  pass
      end command html;

      command index #:
        Print out the index of namespaces/classes/methods.
      scope:
        flag min @ m : int = 0 #:
          Do not print out constructs with level less than this.
        flag max @ M : int = 100000 #:
          Do not print out constructs with level greater than this.
        flag kind : str = 'org1' #:
          Selects amongst a variety of named formats and delimiters. If
          form is provided explicitly, the form value specified by kind
          is overridden, but the delim of kind is maintained.
          TODO(wmh): Should be of type enum<num|org1|org2>, but
          need to provide user-level access to Meta enum types to support this.
        flag form : str = '' #:
          The 'form' value to pass to Construct.writeIndex. Usually easier
          to use --kind unless the options don't match needs.
        flag suffix : str = '' #:
          The 'suffix' value to pass to Construct.writeIndex
        flag adj : int = 0 #:
          How much to adjust level by when computing indent value.
        flag filter : str = '' #:
          If present, only summary lines matching this regexp are shown.

        named block ::
          baselang = self.baselang()
          fs = self.fs()
          flags = self.cli()

          kinds = {
            /# Line number at left margin, then indented kind and id
            'num': {},
            /# Indentation, then '- ', then kind, id and [line]
            'org1': {
              'form': '%(indent)s%(sep)s %(kind)s %(id)s [%(line)d]',
              'delim': ' ',
              'sep': '-',
              'adj': -1,
            },
            /# Indentation using '*', then kind, id and [line]
            'org2': {
              'form': '%(indent)s %(kind)s %(id)s [%(line)d]',
              'delim': '*',
            },
          }

          kwds = {
            'sep': ' ',
            'minlevel': flags.min,
            'maxlevel': flags.max,
            'adj': flags.adj,
          }

          if flags.kind:
            more = kinds.get(flags.kind, None)
            if more is not None:
              kwds.update(more)
            else:
              print 'WARNING: --kind %s is unknown (ignored)' % flags.kind
          if flags.form:
            kwds['form'] = flags.form
          if flags.suffix:
            kwds['suffix'] = flags.suffix
          if flags.filter:
            try:
              kwds['filter'] = re.compile(flags.filter)
            except sre_constants.error as e:
              print 'ERROR: regexp "%s" is invalid (ignored)' % flags.filter

          argmap = self._parseArgs(flags.rest, resolve=True)

          for details in argmap['details']:
            if construct:
              lines = construct.writeIndex(**kwds)
              for line in lines:
                print line
            else:
              print 'WARNING: Ignoring %s (%s)' % (
                details['arg'], details['kind'])
      end command index;

      command mirror #:
        Mirror a meta-generate python hierarchy to another directory.

        Creates symlinks for all production .py files. Useful in, for example,
        GAE.

        TODO(wmh): Add support for mirroring all sub-namespaces within a
        specified namespace!
      scope:
        flag dir @ d : str = '' #:
          Required flag.

        flag tests @ t : bool = false #:
          If true, include tests.

        flag collapse @ c : bool = false #:
          Currently only relevant for baeslang python. If true, convert
          nm/sp/__init__.py to nm/sp.py unless there is also
          nm/sp/sub/__init__.py.

        named block ::
          verbose = True
          cli = self.cli()
          rootdir = self.workspaceDirectory()
          fs = self.fs()

          def CopySrc2Dst(srcpath, verbose=False):
            /# Given a baselang source path and cli, obtain the full destpath
            assert srcpath.startswith(rootdir)
            basedir = fs.dirname(srcpath)
            subdir = basedir[len(rootdir)+1:]
            subparts = subdir.split('/')
            destdir = fs.join(cli.dir, subdir)
            if cli.collapse:
              basename = fs.basename(destdir)
              destdir = fs.dirname(destdir)
              destpath = fs.join(destdir, basename + baselang.suffix())
              subparts.pop()
            else:
              destpath = fs.join(destdir, fs.basename(srcpath))
            if not fs.exists(destdir):
              fs.makedirs(destdir, 0700)
              if verbose:
                print 'Note: Created %s' % destdir

            fs.copyfile(srcpath, destpath)
            if verbose:
              print 'Note: Copied %s to %s' % (srcpath, destpath)

            if baselang.id() == 'python':
              /# Hackery to ensure that __init__.py files exist up the chain.
              tmpdir = destdir
              assert tmpdir.endswith('/'.join(subparts))
              while subparts:
                ipath = fs.join(tmpdir, '__init__.py')
                if not fs.exists(ipath):
                  fs.touch(ipath)
                  if verbose:
                    print 'Note: Touched %s' % ipath
                subparts.pop()
                tmpdir = fs.dirname(tmpdir)

            return destpath

          argmap = self._parseArgs(cli.rest)
          baselang = self.baselang()
          for details in argmap['details']:
            if details['kind'] == 'fqn':
              basepath = details['path']
              testpath = (
                fs.join(
                  fs.dirname(basepath) + '_test', fs.basename(basepath))
                if cli.tests else None)
              CopySrc2Dst(basepath, verbose=verbose)
              if testpath and fs.exists(testpath):
                CopySrc2Dst(testpath, verbose=verbose)
            else:
              print 'WARNING: Ignoring arg "%s"' % details['arg']
      end command mirror;

      command parents #:
        Print out the parents (and metaparents) of the specified class.
      scope:
        named block ::
          print 'WARNING: Command "parents" is not yet implemented.'
      end command parents;

      command parse #:
        Parse a specified .meta file.  Consider using 'get' instead.
      scope:
        named block ::
          cli = self.cli()
          argmap = self._parseArgs(cli.rest)
          errors = False
          metafiles = []
          for path in argmap['metafiles']:
            metafile = self.parseMeta(path)
            if metafile.hasErrors(show=True):
              errors = True
              break
            metafiles.append(metafile)
          if not errors:
            self.writeSummary(metafiles)
      end command parse;

      command repl #:
        Invoke a baselang-specific read-execute-print loop (REPL).
      scope:
        named block ::
          self.baselang().repl()
        block ::
          print '*** HELLO!'
      end command repl;

      command reverse #:
        Reverse compile baselang files into meta files.
      scope:
        named block ::
          print 'WARNING: Command "reverse" is not yet implemented.'
      end command reverse;

      command run #:
        Invoke a class-specific entry point
      scope:
        named block ::
          baselang = self.baselang()
          fs = self.fs()
          flags = self.cli()
          allargs = flags.rest
          if allargs:
            fqcn = allargs[0]
            path = fs.join(
              self.repositoryPath(), self.baselang().classPath(fqcn))
            if fs.exists(path):
              parts = fqcn.split('.')
              clsname = parts.pop()
              nmsp = '.'.join(parts)

              /# TODO(wmh): Create a baselang behavior for this
              if baselang.id() == 'python':
                /# TODO(wmh): How to get this to interact with Bazel?
                module = importlib.import_module(nmsp)
                cls = getattr(module, clsname, None)
                if cls is None:
                  /# TODO(wmh): Why didn't we detect this earlier?
                  print 'ERROR: Unknown class ' + fqcn
                else:
                  entry = getattr(cls, 'Entry', None)
                  if entry is None:
                    print 'ERROR: %s does not have an entry point defined' % fqcn
                  else:
                    args = ['meta-dynamic'] + allargs[1:]
                    entry(args)
              else:
                print 'Not yet implementing run for %s' % baselang.id()
            else:
              print 'ERROR: Invalid class ' + fqcn
          else:
            print 'usage: meta2 run <fqcn> [arg]...'
      end command run;

      command setup #:
        Perform specialized baselang-specific WORKSPACE configuration.
      scope:

        named block ::
          debug = True
          baselang = self.baselang()
          wdir = self.workspaceDirectory()
          metaroot = self.metaRoot()
          fs = self.fs()
          commands = []

          if debug:
            print 'baselang          %s' % baselang.id()
            print 'workingdir        %s' % wdir
            print 'metaroot          %s' % metaroot

          /# NOTE(wmh): We currently do NOT untar the oopl.tgz file here ... it is
          /# done at a higher level than a specific baselang. Keep it a manual
          /# process?
          if False:
            oopl_tgz = fs.join(metaroot, 'src', 'templates', 'oopl.tgz')
            if debug:
              print 'oopl.tgz          %s' % oopl_tgz
            if not fs.exists(oopl_tgz):
              raise Error('Failed to find %s' % oopl_tgz)
            repopath = self.repositoryPath()
            commands.append({'args': ['tar', 'xzf', oopl_tgz], 'cwd': repopath})

          /# (Maybe) clean the repository so we can start afresh.
          rc, _, _ = self.executeBazelCommand(
            ['clean', '--expunge'], cwd=wdir, dryrun=False, prompt=True)

          /# As of 2017-12-22, we have a special setup flow for C++, because the
          /# default C++ compiler on macos (clang) does not handle std::any, so
          /# we use g++ instead, which does.
          /#  - a special CROSSTOOL has been created ... we copy it into the
          /#    default location.
          if baselang.id() == 'cpp':

            /# Establish the location of the default crosstool file.
            rc, output_base, stderr = self.executeBazelCommand(
              ['info', 'output_base'], cwd=wdir, prompt=False, dryrun=False)
            if rc:
              raise Error(
                "ERROR executing 'bazel info output_base':\n%s" % stderr)
            default_crosstool = fs.join(
              output_base.strip(), 'external', 'local_config_cc', 'CROSSTOOL')
            if debug:
              print 'default_crosstool %s' % default_crosstool

            /# If the default crosstool file is missing, invoke bazel to
            /# have it auto-generated.
            /#  - TODO(wmh): Is this even necessary if we have our own copy?
            /#    My concern is that the autogen process does more than just
            /#    write the CROSSTOOL file, so safer to do it then tromp.
            if not fs.exists(default_crosstool):
              /# This will happen if the above 'bazel clean --expunge' was
              /# performed.
              rc, _, _ = self.executeBazelCommand(
                ['build', 'metastrap:__Meta__'],
                cwd=wdir, dryrun=False, show=True)

            /# If we have a local crosstool file, replace the default one with it.
            system = platform.system()
            special_crosstool = fs.join(wdir, 'CROSSTOOL.%s.g++' % system)
            if debug:
              print 'special_crosstool %s' % special_crosstool
            if fs.exists(special_crosstool):
              fs.copyfile(special_crosstool, default_crosstool)
              print 'NOTE: Replaced\n  %s\nwith\n  %s' % (
                default_crosstool, special_crosstool)
      end command setup;

      command shell #:
        An interactive shell within which any meta2 command can be invoked.
      scope:
        named block scope:

          if True:
            /# New implementation based on metax.c.shell.Shell
            shell = metax.c.shell.Shell(self)
            shell.run()

          else:
            /# Old implementation ... no access to special logic
            prompt = 'meta> '

            flags = self.cli()
            cmd = flags._command_()
            while cmd.id() != 'main':
              cmd = cmd.parent()
            root = cmd
            /#root.show()
            /#root.show(mode='help')
            parent = root.parent()

            while True:
              line = raw_input(prompt).strip()
              if not line: continue
              args = line.split()  # TODO(wmh): shlex
              command = args[0]
              cmd = root.instantiate([root.id()] + args, parent=parent)
              if cmd.id() == 'main':
                /# Failed to find a valid command.
                print 'Unknown command "%s"' % command
              else:
                /# Command instantiation identified a command.

                /# We update the global metax.cli.Values() instance with a
                /# new Command.
                self.updateCLI(cmd)

                /# Individual commands should set this. In fact, consider
                /# deleting this field.
                self.argmapIs(None)

                func_name = command + '_command'
                method = getattr(self, func_name, None)
                if method:
                  method()
                elif command in ('quit', 'exit'):
                  break
                else:
                  print 'Unknown command "%s" (ignored)' % command
      end command shell;

      command snapshot @ snap #:
        Create a snapshot.
      scope:
        flag release @ rel : bool = false #:
          If true, perform a release rather than a snapshot.

        named block ::
          cli = self.cli()
          verbose = cli.verbose or True  # FIX ME
          self.__class__.MakeSnapshot(
            self.fs(), verbose=verbose, make_release=cli.release)
      end command snapshot;

      command summarize #:
        Print out a summary of all specified metafiles.
      scope:
        named block scope:
          metafiles = self.metafiles().values()
          fs = self.fs()
          for metafile in sorted(metafiles, key=lambda mf: mf.path()):
            path = fs.realpath(metafile.path())
            parts = path.split('/')
            subpath = '/'.join(parts[-3:])
            print subpath

            filecons = metafile.construct()
            for construct in filecons.attrval('scope:'):
              fkind = construct.kind()
              if fkind == 'namespace':
                print '  %s scope:' % construct.kindfqn()
                for ncons in construct.attrval('scope:'):
                  print '    ' + ncons.kindid()
                  if ncons.kind() == 'class':
                    for econs in ncons.attrval('scope:'):
                      print '      ' + econs.kindid()
              elif fkind == 'MetaLanguage':
                print '  %s config:' % construct.kindfqn()
                for mcons in construct.attrval('config:'):
                  print '    ' + mcons.kindid()
      end command summarize;

      command test #:
        Test specified namespaces/classes/methods.
      scope:
        named block scope:
          argmap = self.argmap()
          targets = argmap['fqns']
          flags = self.cli()
          self.runUnitTests(targets, verbose=flags.verbose)
      end command test;

      command uml #:
        Generate a UML diagram of all classes in all specified metafiles.
      scope:
        flag display @ d : bool #:
          Display the UML diagram after generating it.
          By default, the image file is produced but not displayed.
        flag showuser : bool = true #:
          Display user-defined classes.
        flag showtest : bool = false #:
          Display testclasses.
        flag showmeta : bool = false #:
          Display metaclasses.

        named block ::
          cli = self.cli()

          argmap = self._parseArgs(cli.rest)
          errors = False
          paths = argmap['metafiles']
          if paths:
            dotpath = 'out.dot'
            config = {}
            metafiles = []
            for path in paths:
              metafile = self.getMeta(path)
              if not metafile.hasErrors(show=True):
                metafiles.append(metafile)
            self.generateUmlDiagram(
              metafiles, dotpath, config=config, display=cli.display,
              show_user=cli.showuser, show_meta=cli.showmeta,
              show_test=cli.showtest)
          else:
            print 'Must provide metafile(s) to generate uml for'
      end command uml;

      command __default__ #:
        Compile specified .meta files.
      scope:
        block ::
          /# As a convenience, if all are .meta2 files or fqns, we assume the
          /# action is a combination of 'compile' and 'test.
          allargs = cli.rest
          if allargs:
            command = allargs[0]
            argmap = self._parseArgs(allargs, implicit=True)
            if (
              not argmap['args']
              and not argmap['badfiles']
              and (argmap['metafiles'] or argmap['fqns'])
            ):
              /# All args are .meta2. or fqns. We parse/expand/compile the
              /# .meta2 files then invoke the blaze test targets associated with
              /# each fqn.
              self.argmapIs(argmap)
              if self.compile_command():
                if argmap['fqns']:
                  self.test_command()
            else:
              print 'ERROR : Unknown command "%s"' % command
      end command __default__;

    end command main;

  end class Compiler;

  test
  native scope:
    /# IMPORTANT: TestCase.cachedInfo() returns a cached
    /# baselang/metalang/context/compiler. Assuming none of the test code
    /# modifies the schema/context/compiler, it should be safe to use these
    /# cached values across different tests. However, if you see odd behavior,
    /# consider not using cachedInfo() in specific tests.
    METALANGS = {}
    COMPILERS = {}
  end;

  test
  class TestCase < metax.test.TestCase assocs:
    std assoc optparse;

    resource ex1 path "./testdata/ex1.meta2";
    resource ex2 path "./testdata/ex2.meta2";
    resource cards1 path "./testdata/cards1.meta2";
    resource cards2 path "./testdata/cards2.meta2";
    resource cards3 path "./testdata/cards3.meta2";

    resource sample_logs path "./testdata/sample_logs";
  scope:

    lifecycle setup:
      /# To ensure complete independence between tests, we clear the
      /# MetaLanguage repository.
      /#metax.c.MetaLanguage.Repository = {}
      self._oopl = None
      self._meta = None
      self.compiler = None

      self.metameta_consids = [
        'Attribute', 'BaseLanguage', 'Construct', 'FeatureValue', 'File',
        'MetaLanguage', 'Template'
      ]
      self.metaoopl_consids = [
        'Attribute', 'BaseLanguage', 'Construct', 'FeatureValue', 'File',
        'MetaLanguage', 'Template',
        'accessor', 'assoc', 'behavior', 'block',
        'category', 'class', 'command',
        'field', 'flag',
        'lifecycle', 'method', 'namespace', 'native',
        'receiver', 'remark', 'resource', 'testx', 'var',
      ]
      self.metaoopl_consids2 = [
        'Attribute', 'BaseLanguage', 'Construct', 'FeatureValue', 'File',
        'MetaLanguage', 'Template',
        'accessor', 'assoc', 'behavior', 'block',
        'category', 'class', 'command',
        'field', 'flag',
        'lifecycle', 'loop', 'method', 'namespace', 'native', 'receiver',
        'remark', 'resource', 'testx', 'var',
      ]

      self._invoked_fixenv = False

      if metax.c.Compiler.CONFIG is None:
        metax.c.Compiler.CONFIG = metax.root.MetaObject.Config()[0]

    teardown:
      self.unfixenv()
    end lifecycle;

    method basics : Construct #:
      Create a compiler, context and construct.
    scope:
      _, _, _, compiler = self.cachedInfo(metal='meta')
      self.compiler = compiler

      context = compiler.bootstrapContext()
      self.context = context
      metafile = metax.c.MetaFile('/faux/a.meta', compiler, text='fake text')
      self.metafile = metafile
      /# Create
      /#   file a.meta scope:
      /#     namespace nm.sp scope:
      /#       class Person scope:
      /#       end;
      context.metafileIs(metafile)
      file = metax.c.FileConstruct('a.meta', None, context)
      file_scope = metax.c.ComplexBlock(file, 'scope:', [], line=0, col=12)
      file.registerAttribute(file_scope)
      namespace = metax.c.NamespaceConstruct('nm.sp', file_scope, context)
      file_scope.registerConstruct(namespace)
      namespace_scope = metax.c.ComplexBlock(
        namespace, 'scope:', [], line=1, col=18)
      namespace.registerAttribute(namespace_scope)
      klass = metax.c.ClassConstruct('Person', namespace_scope, context)
      klass.namespaceIs(namespace)
      namespace_scope.registerConstruct(klass)
      self.construct = klass
      class_scope = metax.c.ComplexBlock(klass, 'scope:', [], line=2, col=17)
      klass.registerAttribute(class_scope)
      klass.termcodeIs(3)
      return klass
    end method basics;

    method metafileFor : MetaFile #:
      Obtain a MetaFile for provided text.
    params:
      var text : str #:
        The text of the metafile.
      var metal : str = 'Oopl' #:
        The metalang the text is implemented in.
    scope:
      _, _, _, compiler = self.cachedInfo(metal=metal)
      metafile = metax.c.MetaFile('/faux/a.meta', compiler, text=text)
      return metafile
    end method metafileFor;

    method fixenv #:
      Set some required environment variables to faux values.
    scope:
      /# Define some environment variables required by Meta
      _, _, _, metameta = test.cachedInfo(metal='meta')
      fs = metameta.fs()
      fs.setenv('METAREP', '/some/path/meta/rep')
      /# Set to /tmp so that the directory exists in bazel (albeit readonly)
      fs.setenv('METAROOT', '/tmp')
      self._invoked_fixenv = True
    end method fixenv;

    method unfixenv #:
      Undo changes made in fixenv
    scope:
      if self._invoked_fixenv:
        _, _, _, metameta = test.cachedInfo(metal='meta')
        fs = metameta.fs()
        fs.unsetenv('METAREP')
        fs.unsetenv('METAROOT')
    end method unfixenv;

    method flags : any #:
      The (default) command-line flags
    scope:
      /# TODO(wmh): This is a subset of the flags defined in metameta.
      /# Find a way to merge the two in such a way that we do not need
      result = metax.c.Compiler.Flags()
      if result is None:
        options = optparse.OptionParser()
        options.add_option(
          '-A', '--debug', dest='debug', default=0, type='int',
          help='Control debugging level')
        options.add_option(
          '-b', '--baselang', dest='baselang', default='python',
          help='The base language to compile into.')
        options.add_option(
          '-L', '--metalang', dest='metalang', default='oopl',
          help='The meta language we are compiling')
        options.add_option(
          '--metadir', dest='metadir', default=metax.c.SUFFIX,
          help='The subdir to write code to')
        options.add_option(
          '-M', '--inmemory', action='store_true', dest='inmemory', default=False,
          help='If True, use memory filesystem instead of disk filesystem.')
        options.add_option(
          '-O', '--optimize_level', dest='optimize_level', default='high', type='choice',
          choices=['off', 'low', 'avg', 'high', 'max'],
          help='The amount of optimization to enable compiled files.')
        options.add_option(
          '-V', '--version', action='store', dest='version', default='current',
          help='Which version of the meta library to use (beta, current, previous).')

        /# Note that we request the filesystem be inmemory, for two reasons:
        /#  - it is messy to get access to the real filesystem within bazel
        /#    (and it is readonly anyways)
        /#  - unittests are an exceelent mechanism for verifying that inmemory
        /#    support is working properly.
        result, _ = options.parse_args(
          ['executable', '--inmemory'])

        assert result.inmemory

        metax.c.Compiler.FlagsIs(result)
      return result
    end method flags;

    method defineAttributes #:
      Create some test attribute instances.
    scope:
      construct = self.basics()
      compiler = self.compiler
      context = self.context

      self.feature = metax.c.FeatureAttribute(
        construct, 'gender', 'male', line=10, col=2)
      self.id = metax.c.IdAttribute(
        construct, 'person', 'bob', line=10, col=9)
      self.num = metax.c.NumAttribute(
        construct, 'count', '42', line=10, col=40)
      self.word = metax.c.WordAttribute(
        construct, 'default', '<special>', line=10, col=51)
      self.simple = metax.c.SimpleBlock(
        construct, 'comment:',
        ['this is a', 'test of a simple block'],
        line=11, col=2)

      /# TODO(wmh): Make some constructs to add to this complex block.
      self.complex = metax.c.ComplexBlock(
        construct, 'scope:', [], line=14, col=2)

      expr = metax.c.Expr('str', '"this is a test"', '"this is a test"')
      self.expr = metax.c.ExprAttribute(
        construct, 'value', expr, line=10, col=50)

      self.type = metax.c.TypeAttribute(
        construct, 'type', metax.c.Type.Instance('vec<str>'), line=20, col=42)

      self.enum = metax.c.EnumAttribute(
        construct, 'fruit', '<apple|banana|cantelope>', line=30, col=17)
    end method defineAttributes;

    method defineConstructs #:
      Create some test construct instances.
    scope:
      test.defineAttributes()
      construct = test.construct
      construct.registerAttribute(test.feature)
      primary = metax.c.IdAttribute(construct, construct.kind(), construct.id())
      construct.registerAttribute(primary)
      construct.registerAttribute(test.id)
      construct.registerAttribute(test.num)
      construct.registerAttribute(test.word)
      construct.registerAttribute(test.expr)
      construct.registerAttribute(test.type)
      construct.registerAttribute(test.enum)
      construct.registerAttribute(test.simple)
      construct.registerAttribute(test.complex)
      construct.termcodeIs(7);
      return construct
    end method defineConstructs;

    method resourcePath : str #:
      Obtain the path to a resource given the resource name (only for
      resources defined on this class).
      TODO(wmh): Improve metax.root.Object.Resource() to accept an xid
      resname instead of having to pass fqn as a second param).
    params:
      var name : str #:
        The name of a resource defined on TestCase.
    scope:
      result = metax.root.Object.Resource(name, fqn='metax.c_test.TestCase')
      _, _, _, metameta = test.cachedInfo(metal='meta')
      fs = metameta.fs()
      if not fs.exists(result):
        raise Error('Resource "%s" (%s) does not exist' % (name, result))
      return result
    end method resourcePath;

    method getMetaFile
    returns tuple<metax.c.MetaFile,ComplexBlock,MetaLanguageConstruct,str>
    params:
      var metal : str #:
        The metalang id.
      var resname : str #:
        The resource name to obtain.
      var context : Context = null #:
        If null, uses compiler.metalang().context().
      var compiler : Compiler = null #:
        Which compiler instance to use.
      var debuglevel : int = 0;
      var expand : bool = false #:
        If true, expand the metafile
      var imports : bool = false #:
        If true, import the metafile deps
    scope:
      path = metax.root.Object.Resource(resname, fqn='metax.c_test.TestCase')

      if compiler:
        metalang = compiler.metalang()
        assert metalang.id() == metal, 'Metalang %s != %s' % (metalang.id(), metal)
      else:
        _, metalang, _, compiler = self.cachedInfo(metal=metal)
        self.compiler = compiler

      if imports and not expand:
        expand = True

      if context is None:
        context = metalang.context()

      /# TODO(wmh): It may be dangerous to re-use a pre-existing parsed file
      /# here!
      fs = compiler.fs()
      realpath = fs.realpath(path) if fs.exists(path) else path
      metafile = compiler.metafiles().get(realpath, None)
      if metafile is None:
        metafile = compiler.parseMeta(
          realpath, debuglevel=debuglevel, context=context)
        if expand and not metafile.hasErrors():
          metafile.expandMeta()
          if imports and not metafile.hasErrors():
            metafile.importMeta()
      else:
        /# print 'REUSING %s' % path
        pass

      file = metafile.construct()
      scope = file.rawattr('scope:')
      value = scope.value()
      construct = value[0] if value else None
      return metafile, scope, construct, path
    end method getMetaFile;

    method schemaParser : tuple<MetaFile,Context> #:
      Create a parser for provided schema text.
    params:
      var text : str #:
        A multi-line string representing a Meta(Meta) file.
    scope:
      test.basics()
      compiler = self.compiler
      context = self.context
      metafile = metax.c.MetaFile('fauxpath', compiler, text=text, debuglevel=0)
      metafile.contextIs(context)
      context.metafileIs(metafile)
      return metafile, context
    end method schemaParser;

    method newTestSchema : tuple<MetaLanguageConstruct,Context,MetaFile>
    params:
      var text : str #:
        The text making up the metalang schema file.
    scope:
      metafile, context = self.schemaParser(text)
      schema = metax.c.MetaLanguageConstruct('Test', None, context)
      return schema, context, metafile
    test:
    end method newTestSchema;

    method parserFor : MetaFile #:
      Obtain a parser for given text written in a specific metalang.
    params:
      var metal : str;
      var text : str;
      var debuglevel : int = 0;
    scope:
      _, _, _, compiler = self.cachedInfo(metal=metal)
      metalang = compiler.metalang()
      context = metalang.context()
      context.compilerIs(compiler)
      metafile = metax.c.MetaFile(
        '/faux/path', compiler, debuglevel=debuglevel, text=text)
      metafile.contextIs(context)
      return metafile
    end method parserFor;

    method context : Context #:
      Obtain a Context instance for use in a test.
    scope:
      return self.cachedInfo()[2]
    test:
    end method context;

    method getTestCompiler : Compiler #:
      Obtain a Compiler instance whose filesystem is setup to read from
      ./testdata/repo (writing disallowed by making the directory readonly).
    params:
      var metal : str = 'Oopl';
      var basel : str = 'python';
    scope:
      /# NOTE: We intentionally create a new instance each time this is
      /# called, because:
      /#  - Compiler and Filesystem construction is not that expensive
      /#  - this method won't be used all the time and it is best for us to
      /#    be in a clean slate for those test methods that really need it.
      repo_path = metax.root.Object.Resource('test_repo', fqn='metax.c.Compiler')
      compiler = metax.c.Compiler(
        metal=metal, basel=basel, kind='disk',
        rootdir=repo_path, metadir='.', repodir=repo_path)
      return compiler
    end method getTestCompiler;

    method cachedInfo : tuple<BaseLanguage,MetaLanguage,Context,Compiler> #:
      Obtain a cached set of important objects
    params:
      var basel : str = null #:
        The name/id/alias/suffix of a baselang.
      var metal : str = null #:
        The name of the metalang. Needs to be explicitly set to 'meta' if
        the basel isn't for oopl.
    scope:
      if metal is None:
        metal = 'Oopl'
      else:
        metal = metal.capitalize()
      if basel is None:
        if metal == 'Oopl':
          basel = 'python'
        else:
          basel = 'stub'

      key = '%s/%s' % (metal, basel)

      compiler = COMPILERS.get(key, None)
      if compiler is None:
        compiler = metax.c.Compiler(metal=metal, basel=basel)
        baselang = compiler.baselang()
        if baselang:
          bls = set([basel, baselang.id(), baselang.name()] + baselang.suffixes())
        else:
          bls = ['stub']
        for bl in bls:
          xkey = '%s/%s' % (metal, bl)
          if xkey in COMPILERS:
            raise metax.c.Error(
              '****** Found %s for %s and %s' % (xkey, compiler, COMPILERS[xkey]))
          COMPILERS[xkey] = compiler

      baselang = compiler.baselang()
      metalang = compiler.metalang()
      context = metalang.context()

      return baselang, metalang, context, compiler
    test:
    end method cachedInfo;

    method defineClassAndMethods #:
      Define a simple class (Card) and method (show).
    params:
      var basenora : str #:
        One of the baselang ids, names, aliases or suffixes.
      var context : metax.c.Context = null #:
        The context to use.
      var init_lines : vec<str> = null #:
        If provided, the lines to use as the body of the initializer.
    scope:
      if context is None:
        /# We need the baselang to ensure that the compiler has the correct
        /# baselang, used implicitly be various methods in various classes.
        baselang, _, context, _ = self.cachedInfo(basel=basenora)
      else:
        baselang = context.compiler().baselang()
      assert baselang

      /# TODO(wmh): Initialized metalang?
      self.baselang = baselang
      self.context = context

      /# An expr to be used as the 'super' attribute of 'initializer' and
      /# 'method2'.
      expr = metax.c.ExprParser(self.metafileFor('(a, b=1, c=false)\n')).parse()

      /# Define a namespace nm.sp
      self.namespace = metax.c.NamespaceConstruct.NewFromData(
        'nm.sp', context,
        secondaries=[('scope:', [])])

      /# Define a class Card
      /#  - we invoke initParentClasses() to ensure that klass.parentclasses()
      /#    is initialized. Note that this is baselang specific (e.g. we
      /#    have to have the proper baselang instance in the compiler instance).
      klass = metax.c.ClassConstruct.NewFromData(
        'Card', context, parent=self.namespace.attr('scope:'),
        secondaries=[('parent', 'metax.root.Object'), ('scope:', [])])
      klass.initParentClasses()
      klass.variantIs('user')
      kscope = klass.attr('scope:')
      self.klass = klass
      self.kscope = kscope
      assert klass.baselang() is baselang

      /# Define the metaclass of Card
      metaclass = metax.c.ClassConstruct.NewFromData(
        'CardMeta', context,
        secondaries=[('parent', 'metax.root.ObjectMeta'), ('scope:', [])])
      metaclass.initParentClasses()
      metaclass.variantIs('meta')
      self.metaclass = metaclass
      klass.metaclassIs(metaclass)
      metaclass.userclassIs(klass)
      metaclass.underclassIs(klass)

      /# Define a method 'show' with a comment.
      method = metax.c.MethodConstruct.NewFromData(
        'show', context, parent=kscope,
        features=[('kind', 'method')],
        secondaries=[
          ('comment:', ['This is a test', 'of a multiline comment'])
        ])
      method.myclassIs(klass)
      self.method = method

      /# Define a method 'f' with a super.
      MetaType = metax.c.Type.Instance
      params = metax.c.ExecutableConstruct.CreateParams(
        [{'var': 'a', 'secondaries': [(':', MetaType('str'))]},
         {'var': 'b',
          'secondaries': [
            (':', MetaType('int')),
            /# ('=', metax.c.ExprParser(self.metafileFor('1\n')).parse())
            ('=', metax.c.Expr('int', '1', 1)),
          ]},
         {'var': 'c',
          'secondaries': [
            (':', MetaType('bool')),
            /# ('=', metax.c.ExprParser(self.metafileFor('1\n')).parse())
            ('=', metax.c.Expr('var', 'false', 'false')),
          ]},
        ],
        context)
      method2 = metax.c.MethodConstruct.NewFromData(
        'f', context, parent=test.kscope,
        secondaries=[
          (':', MetaType('int')), ('params:', params), ('super', expr)])
      method2.myclassIs(klass)
      self.method2 = method2

      /# Define an initializer with a super.
      features = [('kind', 'initializer')]
      secondaries = [('super', expr)]
      if init_lines:
        secondaries.append(('scope:', init_lines))
      initializer = metax.c.MethodConstruct.NewFromData(
        '__init__', context, parent=kscope,
        features=features, secondaries=secondaries)
      initializer.myclassIs(klass)
      self.initializer = initializer
    end method defineClassAndMethods;

  end class TestCase;

end namespace metax.c;
