namespace metax.test #:
  Classes related to unit-testing.
scope:

  specific
  class FakeFcntl parent<py> ^object #:
    A fake fcntl object.
  assocs<py>:
    std assoc fcntl;
  scope<py>:

    meta
    lifecycle scope:
      meta.LOCK_UN = fcntl.LOCK_UN
      meta.LOCK_SH = fcntl.LOCK_SH
      meta.LOCK_EX = fcntl.LOCK_EX
    end lifecycle;

    field filesystem : any;

    lifecycle params:
      var fs : any;
    scope:
      self._filesystem = fs
    test:
      pass
    end lifecycle;

    method fcntl params:
      var fd : any;
      var op : any;
      var arg : any = 0;
    scope:
      pass
    test:
      /# noop
      /# TODO(wmh): Is there a way to verify this method does nothing?
      pass
    end method fcntl;

    method ioctl params:
      var fd : any;
      var op : any;
      var arg : any = 0;
      var mutate_flag : any = false;
    scope:
      pass
    test:
      /# noop
      /# TODO(wmh): Is there a way to verify this method does nothing?
      pass
    end method ioctl;

    method flock params:
      var fd : any;
      var op : any;
    scope:
      pass
    test:
      /# noop
      /# TODO(wmh): Is there a way to verify this method does nothing?
      pass
    end method flock;

    method lockf params:
      var fd : any;
      var op : any;
      var length : any = 0;
      var start : any = 0;
      var whence : any = 0;
    scope:
      pass
    test:
      /# noop
      /# TODO(wmh): Is there a way to verify this method does nothing?
      pass
    end method lockf;
  end class FakeFcntl;

  specific
  class StubHolder parent<py> ^object
  comment:
    Support class for stubbing methods out for unit testing.
    
    Sample Usage:
    
    You want os.path.exists() to always return true during testing.
    
       stubs = StubHolder()
       stubs.Set(os.path, 'exists', lambda x: 1)
         ...
       stubs.CleanUp()
    
    The above changes os.path.exists into a lambda that returns 1.  Once
    the ... part of the code finishes, the CleanUp() looks up the old
    value of os.path.exists and restores it.
  scope<py>:

    lifecycle scope:
      self.cache = []
      self.stubs = []
    test:
      pass
    end lifecycle;

    method __del__ comment:
      Do not rely on the destructor to undo your stubs.
      
      You cannot guarantee exactly when the destructor will get called without
      relying on implementation details of a Python VM that may change.
    scope:
      self.CleanUp()
    test:
      pass
    end method __del__;

    method __enter__ scope:
      return self
    test:
      pass
    end method __enter__;

    method __exit__ params:
      var unused_exc_type : any;
      var unused_exc_value : any;
      var unused_tb : any;
    scope:
      self.CleanUp()
    test:
      pass
    end method __exit__;

    method CleanUp comment:
      Undoes all SmartSet() & Set() calls, restoring original definitions.
    scope:
      self.SmartUnsetAll()
      self.UnsetAll()
    test:
      pass
    end method CleanUp;

    method SmartSet params:
      var obj : any #:
        The object whose attributes we want to modify.
      var attr_name : str #:
        The name of the attribute to modify.
      var new_attr : any #:
        The new value for the attribute.
    comment:
      Replace obj.attr_name with new_attr.
      
      This method is smart and works at the module, class, and instance level
      while preserving proper inheritance. It will not stub out C types however
      unless that has been explicitly allowed by the type.
      
      This method supports the case where attr_name is a staticmethod or a
      classmethod of obj.
      
      Notes:
       - If obj is an instance, then it is its class that will actually be
         stubbed. Note that the method Set() does not do that: if obj is
         an instance, it (and not its class) will be stubbed.
       - The stubbing is using the builtin getattr and setattr. So, the __get__
         and __set__ will be called when stubbing.
      
      Raises:
        AttributeError: If the attribute cannot be found.
    scope:
      if (inspect.ismodule(obj) or
          (not inspect.isclass(obj) and attr_name in obj.__dict__)):
        orig_obj = obj
        orig_attr = getattr(obj, attr_name)
      else:
        if not inspect.isclass(obj):
          mro = list(inspect.getmro(obj.__class__))
        else:
          mro = list(inspect.getmro(obj))

        mro.reverse()

        orig_attr = None
        found_attr = False

        for cls in mro:
          try:
            orig_obj = cls
            orig_attr = getattr(obj, attr_name)
            found_attr = True
          except AttributeError:
            continue

        if not found_attr:
          raise AttributeError('Attribute not found.')

      /# Calling getattr() on a staticmethod transforms it to a 'normal' function.
      /# We need to ensure that we put it back as a staticmethod.
      old_attribute = obj.__dict__.get(attr_name)
      if old_attribute is not None and isinstance(old_attribute, staticmethod):
        orig_attr = staticmethod(orig_attr)

      self.stubs.append((orig_obj, attr_name, orig_attr))
      setattr(orig_obj, attr_name, new_attr)
    test:
      pass
    end method SmartSet;

    method SmartUnsetAll comment:
      Reverses SmartSet() calls, restoring things to original definitions.
      
      This method is automatically called when the StubOutForTesting()
      object is deleted; there is no need to call it explicitly.
      
      It is okay to call SmartUnsetAll() repeatedly, as later calls have
      no effect if no SmartSet() calls have been made.
    scope:
      for args in reversed(self.stubs):
        setattr(*args)

      self.stubs = []
    test:
      pass
    end method SmartUnsetAll;

    method Set params:
      var parent : *any #:
        The_context_in_which_the_attribute_child_name_is_to_be_changed.
      var child_name : *any #:
        The_name_of_the_attribute_to_change.
      var new_child : *any #:
        The_new_value_of_the_attribute
    comment:
      In parent, replace child_name's old definition with new_child.
      
      The parent could be a module when the child is a function at
      module scope.  Or the parent could be a class when a class' method
      is being replaced.  The named child is set to new_child, while the
      prior definition is saved away for later, when UnsetAll() is
      called.
      
      This method supports the case where child_name is a staticmethod or a
      classmethod of parent.
    scope:
      old_child = getattr(parent, child_name)

      old_attribute = parent.__dict__.get(child_name)
      if old_attribute is not None and isinstance(old_attribute, staticmethod):
        old_child = staticmethod(old_child)

      self.cache.append((parent, old_child, child_name))
      setattr(parent, child_name, new_child)
    test:
      pass
    end method Set;

    method UnsetAll comment:
      Reverses Set() calls, restoring things to their original definitions.
      
      This method is automatically called when the StubOutForTesting()
      object is deleted; there is no need to call it explicitly.
      
      It is okay to call UnsetAll() repeatedly, as later calls have no
      effect if no Set() calls have been made.
    scope:
      /# Undo calls to Set() in reverse order, in case Set() was called on the
      /# same arguments repeatedly (want the original call to be last one undone)
      for (parent, old_child, child_name) in reversed(self.cache):
        setattr(parent, child_name, old_child)
      self.cache = []
    test:
      pass
    end method UnsetAll;
  end class StubHolder;

  native fixme scope<py>:
    import cStringIO
    cStringIOClass = cStringIO.StringIO().__class__
  end native;    
  
  class TestCase #:
    /# The JUnit testing infrastructure for Java (which came from a testing
    /# infrastructure for Smalltalk) has gained cross-language recognition, and
    /# there is an xUnit implementation for basically every OO language
    /# (e.g. CppUnit, JSUnit, python unit (unittest), etc.).
    /# 
    /# See $METAROOT/UseGuide.wmd (/Meta/Meta From The Middle Ground/Unit Tests)
    /# for a discussion of xUnit and how Meta implements this testing paradigm
    /# across all baselangs.
    /# 
    /# See the src/kernel/asserts.org file for details on alerts across
    /# baselangs.
    /# 
    /# In javascript, the normal idiom for doing javascript testing using
    /# bazel and google closure is as follows:
    /#  - unittests are implemented in some file ending in _test.js
    /#  - the file must goog.require('goog.testing.jsunit'), which:
    /#     - creates cached G_testRunner (if G_testRunner already exists, noop)
    /#     - creates a window.onerror handler to report errors during test
    /#       initialization
    /#     - creates a window.onload handler so that when the page containing
    /#       the *_test.js file is loaded:
    /#        - invokes any already specified onload code
    /#        - creates a timeout to execute the following after 500ms
    /#          - if G_testRunner is not yet initialized:
    /#             - create a TestCase instance 'testCase'
    /#             - invoke goog.testing.TestCase.initializeTestRunner(testCase)
    /#                - invokes testCase.setOrder()
    /#                - invokes testCase.setTestsToRun() based on a parsing
    /#                  of the 'runTests' parameter in the url found at
    /#                  goog.global.location.search
    /#                - invokes gTestRunner.initialize(testCase)
    /#                   - sets testCase and initialized fields
    /#          - invokes G_testRunner.execute()
    /#             - invokes this.testCase.setCompletedCallback()
    /#             - invokes this.testCase.runTests()
    /#                - invokes testCase.setUpPage()
    /#                - invokes testCase.execute()
    /#                   - invokes testCase.cycleTests()
    /#                      ...
    /# 
    /# In Meta<javascript>, the above control flow is changed as follows:
    /#  - For user-defined class <C> in namespace <N>, Meta implicitly defines
    /#    test class <N>_test.<C>Test in file <N>/<C>_test.js.
    /#  - The <C>_test.js file does NOT goog.require('goog.testing.jsunit').
    /#  - The <C>Test class inherits (directly or indirectly) from
    /#    metax.test.TestCase (which inherits from goog.testing.TestCase),
    /#    and has zero or more 'test_<M>*' methods defined for every user-defined
    /#    method <M> defined on <C> depending on the presence of 'test' or 'tests'
    /#    attributes on <M>.
    /#  - In <C>_test.js file, after the definition of <C>Test, the following
    /#    code exists:
    /#      var testCase = new <N>.<C>Test('<N>.<C>Test');
    /#      testCase.run();
    /#  - The 'run' method (metax.test.TestCase.run) does the following:
    /#     - Invokes jsunit(), which does similar work to what goog.testing.jsunit
    /#       does.
    /#     - Invokes setTestObj(), which does similar work to 
    /#       goog.testing.TestCase.setTestObj()
    /#     - Invokes gTestRunner.setStrict(false) to all 0 tests
    /#     - Invokes goog.testing.TestCase.initializeTestRunner()
    /#     - Invokes gTestRunner.execute()
    /#         ...
    /# 
    /# Modifications needed to io_bazel_rules_closure
    /#  - created local repository at $WMH/src/google/rules_closure
    /#    with
    /#      % cd $WMH/src/google
    /#      % git clone https://github.com/bazelbuild/rules_closure.git
    /#      % cd rules_closure
    /#  - modified
    /#     closure/testing/phantomjs_harness.js
    /#      - parse out optional --key=value args before the html file and .js files
    /#      - create query string
    /#      - add query string to url
    /#      - change 'path == VIRTUAL_PAGE' to 'page.startsWith(VIRTUAL_PAGE)'
    /#     closure/testing/phantomjs_test.bzl
    /#      - based on --test_arg, insert values into the 'args' list before
    /#        ctx.file.html.short_path.
    /#      - TODO(wmh): How to get access to --test_arg (and/or --test_env)?
    /#        ctx.configuration.default_shell_env doesn't store --test_env,
    /#        and ctx.configuration.test_env doesn't even exist, contrary to
    /#        https://bazel.build/versions/master/docs/skylark/lib/configuration.html
  parent<py> ^unittest.TestCase
  parent<js> ^goog.testing.TestCase
  parent<cc> ^.testing.Test
  assocs<py>:
    std assoc shutil;
    std assoc cStringIO;
    std assoc logging;
    usertest std assoc os;
    std assoc re;
    std assoc stat;
    usertest std assoc sys;
    usertest std assoc tempfile;
    std assoc time;
    std assoc types;
    std assoc unittest #:
      TODO(wmh): Why isn't this being implicitly included due to being a
      parent? Because it is '^'?

    resource cipherfile path "testdata/testing/cipherfile";
    resource entry_mre path "testdata/testing/entry.mre";

  assocs<js>:
    cls assoc ^goog.testing.TestCase
    target "@io_bazel_rules_closure//closure/library:testing" #:
      Defines goog.testing.TestCase, the parent of this class.

    cls assoc ^goog.testing.TestRunner
    target "@io_bazel_rules_closure//closure/library:testing" #:
      Defines the test runner.

    lib assoc goog.testing.asserts
    target "@io_bazel_rules_closure//closure/library:testing,@io_bazel_rules_closure//closure/library:library" #:
      Introduces the various assert commands.

    lib assoc goog.asserts
    target "@io_bazel_rules_closure//closure/library:library" #:
      Introduces the various assert commands.

    cls assoc ^goog.testing.PropertyReplacer
    target "@io_bazel_rules_closure//closure/library:testing" #:
      Provides stubbing functionality.

  assocs<cc>:
    std assoc strstream;
    std assoc typeinfo;
    lib assoc gtest.gtest target "@gtest//:main";    
    cls assoc metax.root.Error;
  scope:

    meta
    field Debug : bool #:
      What to initialize TestCase.debug to.
    meta
    field InstanceCount : int = 1 #:
      Counts the number of instances created so we can assign unique ids.
      Useful for debugging purposes.
    meta
    field WriteGoldens : bool #:
      If true, methods that invoke iseqstrgold() or iseqfilegold() will
      update goldens instead of compare goldens.
    meta
    field CanonicalStdout : ostream #:
      The 'normal' stdout.
    meta
    field CanonicalStderr : ostream #:
      The 'normal' stderr.
    meta
    field Interactive : bool #:
      Set this to True to enable interactive unit tests.      

    meta
    lifecycle #:
      Initialize class-level variables.  This includes variables for
      controlling golden writing, interactivity, debugging, etc, based on
      the value of envars.

      TODO(wmh): This should be added to the 'meta lifecycle' above, when
      support has been provided by Meta.
    scope<py>:
      /# TODO(wmh): How can we set environment variables when using bazel?
      /# The --action_env flag from
      /#    https://bazel.build/designs/2016/06/21/environment.html
      /# does not appear to be working the way I understand it,
      /# neither with entries in ~/.bazelrc or explicitly specified on
      /# the command line:
      /#   bazel test --action_env=BLAH=blork --test_output=all //wmh:regexp_test
      import os
      meta.WriteGoldensIs(os.getenv('WRITE_GOLDENS', '') == 'true')
      debug = os.getenv('META_DEBUG', '')
      if ' tests ' in debug:
        meta.DebugIs(True)
      meta.CanonicalStdoutIs(sys.stdout)
      meta.CanonicalStderrIs(sys.stderr)

      meta.cStringIOClass = cStringIO.StringIO().__class__
    scope<js>:
      /# TODO(wmh): Establish whether there is any way to emulate
      /# class variables in Javascript other than adding them as
      /# instance variables within the meta class.
    scope<cc>:
      /# Initialize the class-level vars!
    end lifecycle;

    field debug : bool #:
      If True, prints out each invocation of the initializer, setup,
      teardown and finalizer methods.
    field uid : @str #:
      The name of the method that this instance of TestCase is
      responsible for testing. Although the parent initializer also
      stores this, each baselang uses a different name for the field.
      Rather than encoding this name in each baselang, we just store a
      new copy locally.
    field tmpfiles : @vec<str> #:
      The collection of temporary files created via tmpFile().
    field tmpdirs : @vec<str> #:
      The collection of temporary dirs created via tmpDir()
    field moxlist : @vec<any> #:
      The collection of mocking objects created via newMox.
      TODO(wmh): Rename this something non-python-centric.
    field stdout : ostream #:
      The current stream used for stdout.  If null, the default is used.
    field stderr : ostream #:
      The current stream used for stderr.  If null, the default is used.
    field stdin : istream #:
      The current stream used for stdin.  If null, the default is used.
    field fsinfo : @map #:
      Maps module names to dicts containing:
        module: the module itself
        fs: the fake filesystem for the module.
    field envars : @map #:
      Records environment variables modified during a test (so they
      can be reinstated).

    field fs #:
      Only initialized if SetupSharedFilesystem() is invoked.
    type<py> fake_filesystem.FakeFilesystem
    type<js> any
    type<cc> *void
    end field fs;

    field stubs #:
      Allows us to stub out methods and have them implicitly reverted.
    type<py> any
    type<js> goog.testing.PropertyReplacer
    type<cc> *void
    end field stubs;

    field strstreams : @vec<*strstream> #:
      A list of strstream instances allocated via fp().  Cleaned up in
      teardown, and used in out().
 
    field method_name : @str #:
      The name of the method being tested.
      TODO(wmh): Redundant in Python and Javascript since the superclass
      defines a similar field. Need a way to define 'specific' fields
      for only certain baselangs.

    field silent : bool = false #:
      If true, teardown does not print out test + time.
      Primarily introduced to avoid issues during testing of TestCase, but
      may be useful in other contexts too.

    lifecycle #:
      In all XUnit testing environments, a TestCase is a class defining
      a collection of test methods (methods starting with 'test') and
      service methods (methods not starting with 'test'). There is a specific
      order of operation for how these TestCases are executed.
       - the meta-level SetUp() method is invoked to perform one time
         initialization of the TestCase.
       - if there are N test methods in the Test Case, N instances of
         TestCase are created
       - for each instance created above:
          - invoke the setUp() method
          - invoke the test method that this instance was created to run
          - invoke the tearDown() method.
       - the finalizers for each instance of TestCase are invoked.
       - the meta-level TearDown() method is invoked to cleanup anything
         done in SetUp()

      The exact names of the setUp, tearDown, SetUp and TearDown methods
      vary across baselangs, which is why the 'lifecycle' construct exists ...
      it knowns the underlying method names that need to be generated in
      each baselang, allowing the user to focus simply on the
      init/setup/teardown/finalize sequence.

      Note that the javascript asserting methods are available in 
        $CLOSURE_ROOT/library/closure/goog-orig/testing/asserts.js
      They are rather odd in having the optional message be the first argument
      of the method (so we have to do some reversal to get the more intuitive
      'optional message as last arg' idiom.

      Note that the 'location' feature attribute of the 'lifecycle' construct
      specifies whether we are referring to an explicit class, the implicit meta
      class associated with an explicit class, or the implicit test class
      associated with an explicit class.  If the class itself has 'location'
      meta, it doesn't make sense to have any of its 'lifecycle' instances
      also have location 'meta' (a meta class does not have a meta class).
      The same is true for 'test' (a test class does not have a test class).
      However, a meta class can have a test class, and a test class has a
      meta class.
    params:
      var method_name #:
        A name for the test case.
        IMPORTANT: Since the Meta compiler implicitly adds a parameter to
        meta lifecycles of testcase classes, it is important that we ...???
      type<py> str
      type<js> @str 
      type<cc> &str;
    super<py> (method_name)
    super<js> (method_name)
    init<py>:
      self.debugIs(self.__class__.Debug())
      count = metax.test.TestCase.InstanceCount() + 1
      metax.test.TestCase.InstanceCountIs(count)
      self.uidIs('%s:%d' % (method_name, count))
      self.deblog('Invoking %s initializer for %s' % (self.name(), method_name))
      self.method_nameIs(method_name)
      self._start = None
    init<js>:
      var count = MetaTestCase.InstanceCount() + 1;
      MetaTestCase.InstanceCountIs(count);
      console.log('Here with ' + method_name + ' and ' + this.methname());
      this.uidIs(method_name + ':' + count);
      this.deblog(
          'Invoking ' + this.name() + ' initializer for ' + method_name);
      this.method_nameIs(method_name);
    init<cc>:
      int count = MetaTestCase->InstanceCount() + 1;
      MetaTestCase->InstanceCountIs(count);
      this->deblog(
        std::string("Invoking ") + this->name() + " initializer for "
        + method_name);
      this->method_nameIs(method_name);
    finalize<py>:
      self.deblog('Invoking %s finalizer for %s' % (self.name(), self.methname()))
    setup<py>:
      self.deblog('Invoking %s setUp for %s' % (self.name(), self.methname()));
      testname = '%s.%s' % (self.name(), self.methname())
      username = re.sub(r'Test\.testx?_?', '.', testname)
      logging.info('Starting ' + testname)

      visname = username[:39] + '$' if len(username) > 40 else username
      if not self.silent():
        sys.stdout.write('%-40s ...' % visname)
      self._start = time.time()
      /# NOTE: Most fields have been initialized to their default values within
      /# the initializer.
      self._stubs = StubHolder()
      self.maxDiff = None
    setup<js>:
      this.deblog('Invoking ' + this.name() + ' setUp for ' + this.methname());
      /# TODO(wmh): Look into the stub mechanism provided by
      /# goog.testing.propertyreplacer.js
      this._stubs = new /* goog.testing.*/ PropertyReplacer();
    setup<cc>:
      this->deblog(
        "Invoking " + this->name() + " setUp for " + this->methname());
    setupcase<py>:
      if meta.Debug():
        print 'Invoking %s SetUp' % meta.__name__
    setupcase<js>:
      if (/* metax.test.*/ MetaTestCase.Debug()) {
        console.log('Invoking ' + this.constructor.name + ' SetUp');
      }
    setupcase<cc>:
      if (MetaTestCase->Debug()) {
        std::cout << "Invoking " << MetaTestCase->metaname() << " SetUp" << std::endl;
      }
    teardown<py>:
      /# Reinstate I/O
      sys.stdout = TestCase.CanonicalStdout()
      sys.stderr = TestCase.CanonicalStderr()

      seconds = time.time() - self._start
      self.deblog('Invoking %s tearDown for %s' % (self.name(), self.methname()))
      status = self.status()
      if not self.silent():
        sys.stdout.write('%8d us  %s\n' % (seconds * 1000000, status))

      /# Clean up moxes
      self.clearMoxes()

      /# Remove stubs
      self._stubs.CleanUp()

      /# Delete temporary files
      for tmpfile in self._tmpfiles:
        if os.path.exists(tmpfile):
          logging.info('Deleting tmp file %s' % tmpfile)
          os.unlink(tmpfile)
      del self._tmpfiles[:]

      /# Delete temporary dirs
      for tmpdir in self._tmpdirs:
        if os.path.exists(tmpdir):
          logging.info('Deleting tmp dir %s' % tmpdir)
          shutil.rmtree(tmpdir)
      del self._tmpdirs[:]

      /# Restore filesystem.
      for modinfo in self._fsinfo.values():
        self.revertFilesystem(modinfo['module'])

      /# Restore env.vars.
      for evar in self._envars:
        if evar in ENV:
          os.environ[evar] = ENV[evar]
        else:
          del os.environ[evar]
    teardown<js>:
      /# $CLOSURE_ROOT/library/closure/goog-orig/testing/testcase.js
      this.deblog(
        'Invoking ' + this.name() + ' tearDown for ' + this.methname());
      /# From goog.testing.propertyreplacer.js
      /# this._stubs.reset();
    teardown<cc>:
      std::cerr << "Fix C++ teardown" << std::endl;

      /# Delete all strstreams in strstreams()
      auto& strstreams = this->strstreamsRef();
      /# More here!

    teardowncase<py>:
      if meta.Debug():
        print 'Invoking %s TearDown' % cls.__name__
    teardowncase<js>:
      if (MetaTestCase.Debug()) {
        console.log('Invoking ' + this.constructor.name + ' TearDown');
      }
    teardowncase<cc>:
      if (MetaTestCase->Debug()) {
        std::cerr << "Invoking " << MetaTestCase->metaname() << " TearDown" << std::endl;
      }
    end lifecycle;

    specific
    method runSelfTests #:
      Initializes the test runner.

      The suggested mechanism for running unittests on a goog.module() is
      discussed in https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide#how-do-i-write-a-unit-test-for-a-googmodule
        goog.module('goog.baseModuleTest');
        goog.setTestOnly('goog.baseModuleTest');

        var jsunit = goog.require('goog.testing.jsunit');
        var testSuite = goog.require('goog.testing.testSuite');

        testSuite({
          testMethod: function() {},
        });

      The object passed into testSuite() is the object that defines all the
      test methods and related infrastructure (any executable starting with
      'test' is assumed to be a test method).  The code of testSuite() is
      in $CLOSURE_ROOT/library/closure/goog-orig/testing/testsuite.js:
          // Runs the lifecycle methods (setUp, tearDown, etc.) and test* methods from
          // the given object. For use in tests that are written as JavaScript modules
          // or goog.modules.
          //
          // @param {!Object<string, function()>} obj An object with one or more test
          //     methods, and optional setUp, tearDown and getTestName methods, etc.
         goog.testing.testSuite = function(obj) {
           var testCase = goog.labs.testing.Environment.getTestCaseIfActive() ||
               new goog.testing.TestCase(document.title);
           testCase.setTestObj(obj);
           goog.testing.TestCase.initializeTestRunner(testCase);
         };

      Note that it creates a new TestCase instance, and passes an independent
      object to that testcase. In Meta, however, the testcase class itself
      is the object defining the tests.  So in Meta we invoke unittests
      slightly differently:
        goog.module('nm.sp.FooTest');
        goog.setTestOnly('nm.sp.FooTest');
        const TestCase = goog.require('metax.test.TestCase');

        class FooTest extends TestCase { ... }
        var tc = new FooTest('nm.sp.FooTest');
        tc.runSelfTests();
    scope<js>:
      /# The object defining the test methods is this TestCase subclass
      /# instance.
      this.setTestObj(this);
      TestCase.initializeTestRunner(this);
      var testrunner = /** @type {?TestRunner} */ (goog.global['G_testRunner']);
      testrunner.setStrict(false);
    test:
    end method runSelfTests;

    method status : &str #:
      The status of an individual test.

      Returns:
        One of '', 'FAIL' or 'ERROR'.
    scope<py>:
      /# TODO(wmh): This relies on a private method in unittest.TestCase, and
      /# is thus inherently fragile. Can we do better?  Also, in python 3.4,
      /# the field is _outcomeForDoCleanups. See
      /#    https://stackoverflow.com/questions/4414234/getting-pythons-unittest-results-in-a-teardown-method
      /# for details.  I considered defining the method failureException(msg)
      /# in metax.test.TestCase ... this would override the field
      /#   self.failureException
      /# introduced in unittest.case._AssertRaisesContext and inherited into
      /# unittest.TestCase.  The code in case.py almost always uses this
      /# field in the form:
      /#   raise self.failureException(msg)
      /# so defining it as a method that accepts a msg param and always returns
      /# AssertionError should work (the method could then set state as
      /# desired).  Unfortunately, unittest.TestCase.run() has a single
      /# use of the field using
      /#    except self.failureException:
      /# which wouldn't work properly if it became a method.  But if we were
      /# to make self.failureException a property, we could insert some
      /# code in addiiton to returning AssertionError. Note that that approach
      /# would be much more efficient than the following, which performs
      /# O(N) searches thru two lists to find matches. However, the lists will
      /# usually be very small (list of failures and errors). Also, the
      /# property solution would not capture all failures (for example,
      /# _UnexpectedSuccess exceptions).
      text_test_result = self._resultForDoCleanups
      if text_test_result:
        for tst, err in text_test_result.failures:
          if self is tst:
            return 'FAIL'
        for tst, err in text_test_result.errors:
          if self is tst:
            return 'ERROR'
      return ''
    scope<js>:
      /# console.log('Fix TestCase.status in Javascript');
      return 'FIXME';
    scope<cc>:
      static std::string result("FIXME");
      return result;
    end method status;

    new
    method deblog #:
      Print out a Meta specific log message.
    params:
      var msg : &str;
    scope<py>:
      if self.debug():
        print '%s: %s' % (self.uid(), msg)
    scope<js>:
      if (this.debug()) {
        this.log(this.uid() + ': ' + msg);
      }
    scope<cc>:
      if (this->debug()) {
        std::cout << this->uid() << ": " << msg << std::endl;
      }
    end method deblog;

    new
    method name : &str #:
      The name of this testcase.
      See methname for the name of the method within the testcase.
    scope<py>:
      return self.__class__.__name__
    scope<js>:
      return this.constructor.name;
    scope<cc>:
      static std::string result(typeid(*this).name());
      return result;
    end method name;

    new
    method methname : &str #:
      The name of the method defined within a subclass of TestCase to be
      invoked as the test.

      Meta:suppress: visibility
    scope<py>:
      return self._testMethodName
    scope<js>:
      return this.name_;
    scope<cc>:
      return this->method_name();
    end method methname;

    specific
    method clearMoxes #:
      # Unset any Mox instances.
    scope<py>:
      if self._moxlist:
        for m in self._moxlist:
          m.UnsetStubs()
        self._moxlist = []
    end method clearMoxes;

    new
    method setenv params:
      var evar : str;
      var value : str;
    scope<py>:
      raise Error('setenv() is not yet working properly (do not use)')
      current = os.environ.get(evar, None)
      if current != ENV.get(evar, None):
        raise Error(
          'Expecting evar = "%s" not "%s"' % (ENV.get(evar, None), current))
      os.environ[evar] = value
      self._envars[evar] = current
    test<py>:
      /# TODO(wmh): Work on this.
      return

      home = os.getenv('HOME', None)
      self._tc.setenv('HOME', '/home/bob')
      self.assertEqual('/home/bob', os.getenv('HOME', None))
      self.assertEqual(home, os.getenv('HOME', None))
    scope<js>:
      throw new Error('TestCase.setenv() not yet implemented');
    scope<cc>:
      throw metax::root::Error("TestCase.setenv() not yet implemented");
    end;

    new specific
    method metaTestPath : str #:
      Obtain the path of a testdata file within the
      same directory as a specified .meta file.

      TODO(wmh): Javascript does not yet properly handle varargs.

      scope<js>:
        var dirname = metafile.match(/.*//);
        var result = dirname;
        for (var i = 0; i < subpaths.length; ++i) {
          result += '/' + subpaths[i];
        }
        return result;
    params:
      var metafile : str #:
        The path of the meta file defining the test.
      multi var subpaths : vec #:
        The path within the directory containing the
        metafile.
    scope<py>:
      return os.path.join(os.path.dirname(metafile), *subpaths)
    end method metaTestPath;

    new specific
    method captureStdout #:
      Capture all subsequent output written to stdout until getStdout() is
      invoked.
    scope<py>:
      self._stdout = cStringIO.StringIO()
      sys.stdout = self._stdout
    test<py>:
      self.assertTrue(sys.stdout is metax.test.TestCase.CanonicalStdout())
      self._tc.captureStdout()
      self.assertTrue(isinstance(sys.stdout, metax.test.cStringIOClass))
      print 'hello world'
      out = self._tc.getStdout()
      self.assertTrue(sys.stdout is metax.test.TestCase.CanonicalStdout())
      self.assertEqual('hello world\n', out)
    end method captureStdout;

    new specific
    method getStdout #:
      Obtain the stdout captured since the last call to captureStdout().
      Resets stdout to what it was before captureStdout() was invoked.
    scope<py>:
      /# TODO(wmh): Use self._stdout to test.
      cls = sys.stdout.__class__
      if cls is TestCase.cStringIOClass or isinstance(sys.stdout, StringIO.StringIO):
        result = sys.stdout.getvalue()
      else:
        result = None
      sys.stdout = TestCase.CanonicalStdout()
      self._stdout = None
      return result
    test<py>:
      /# noop, tested in test_captureStdout()
      pass
    end method getStdout;

    new specific
    method captureStderr #:
      Capture all subsequent output written to stderr until getStderr() is
      invoked.
    scope<py>:
      self._stderr = cStringIO.StringIO()
      sys.stderr = self._stderr
    test<py>:
      self.assertTrue(sys.stderr is metax.test.TestCase.CanonicalStderr())
      self._tc.captureStderr()
      self.assertTrue(isinstance(sys.stderr, metax.test.cStringIOClass))
      sys.stderr.write('hello world\n')
      err = self._tc.getStderr()
      self.assertTrue(sys.stderr is metax.test.TestCase.CanonicalStderr())
      self.assertEqual('hello world\n', err)
    end method captureStderr;

    new specific
    method getStderr #:
      Obtain the stderr captured since the last call to captureStderr().
      Resets stdout to what it was before captureStderr() was invoked.
    scope<py>:
      /# TODO(wmh): Use self._stdout to test.
      cls = sys.stderr.__class__
      if cls is TestCase.cStringIOClass or isinstance(sys.stderr, StringIO.StringIO):
        result = sys.stderr.getvalue()
      else:
        result = None
      sys.stderr = TestCase.CanonicalStderr()
      self._stderr = None
      return result
    test<py>:
      /# noop, tested in test_captureStderr()
      pass
    end method getStderr;

    new specific
    method newMox params:
      multi var stubs : vec;
    comment:
      Return a new mox.Mox, optionally stubbing out various entities.
    scope<py>:
      /# TODO(wmh): EXPERIMENTAL. This is meant to act as a more concise
      /# and readable means of mocking out methods (and, perhaps,
      /# invoking with emulation). The goal is to be able to pass in
      /# objects, and from those objects, obtain the "container" and the
      /# "name" of the object within "container", which would then be passed
      /# to mox.StubOutWithMock.  However:
      /#   - I do not know how to obtain the module object within which
      /#     a class 'c' resides.  Note that 'c.__module__' returns the
      /#     *name* of the module, not the module object.
      /#   - I do not know how to obtain the class object within which
      /#     a static function 's' resides.  Note that 's.__class__' returns the
      /#     *name* of the class, not the class object.
      /#
      /# It is very possible this isn't the right solution to the problem of
      /# mox readability, but more exploration is warranted.

      /# TODO(wmh): Get this working in bazel.
      import mox

      m = mox.Mox()

      /# We stub out those methods (et.al.) specified in stubs.
      for item in stubs:
        if isinstance(item, tuple) and len(item) == 2:
          obj, name = item
        elif isinstance(item, (types.FunctionType, types.MethodType)):
          obj = item.im_class
          name = item.__name__
        else:
          raise Error('Unrecognized item %s' % item)
        logging.debug('Stubbing out %s within %s', name, obj)
        m.StubOutWithMock(obj, name)

      self._moxlist.append(m)
      return m
    test<py>:
      tc = self._tc
      tc.setUp()

      self.assertEqual(0, len(tc._moxlist))

      /# Basic mox
      m1 = tc.newMox()
      self.assertEqual(1, len(tc._moxlist))
      m1.UnsetStubs()

      /# Another mox, this time with a stub.
      m2 = tc.newMox(tc.tmpFile)
      tc.tmpFile().AndReturn('blah')
      m2.ReplayAll()
      res = tc.tmpFile()
      self.assertEqual('blah', res)
      m2.VerifyAll()

      /# TODO(wmh): Add additional code for verifying static and
      /# class method stubs?

      /# Important to clean up tc here!
      tc.tearDown()
    end method newMox;

    new
    method newStr : *strstream #:
      Create a new string stream for use anywhere a istream or
      ostream is required.
    params:
      var content : str = null;
    scope<py>:
      return self.fp(content=content)
    scope<js>:
      throw new Error('TestCase.newStr() not yet implemented');
    scope<cc>:
      return this->fp();
    end method newStr;

    new
    method fp : *strstream #:
      Create a new string stream for use anywhere a istream or
      ostream is required.

      TODO(wmh): Decide which of 'newStr' or 'fp' to keep.
    params:
      var content : str = null;
    scope<py>:
      if content is None:
        result = cStringIO.StringIO()
      else:
        result = cStringIO.StringIO(content)
      self.strstreamsRef().append(result)
      return result
    scope<js>:
      throw new Error('TestCase.fp() not yet implemented');
    scope<cc>:
      std::stringstream* result;
      if (content == nullptr) {
        result = new std::stringstream();
      } else {
        result = new std::stringstream(*content);
      }
      this->strstreamsRef().push_back(result);
      return result;
    end method fp;

    new
    method out : str #:
      The output of the most recently created strstream via fp().
    scope<py>:
      strstreams = self.strstreams()
      if strstreams:
        result = strstreams[-1].getvalue()
      else:
        result = None
      return result
    scope<js>:
      throw new Error('TestCase.out() not yet implemented');
    scope<cc>:
      auto* strstreams = self.strstreams();
      int size = strstreams->size()
      if (size > 0) {
        return strstreams[size].str();
      } else {
        return "";
      }
    end method out;

    new
    method tmpFile #:
      Create a temporary file and return its path.
    params:
      var create : bool = true;
    scope<py>:
      fd, tmpfile = tempfile.mkstemp()
      os.close(fd)
      self._tmpfiles.append(tmpfile)
      if not create:
        os.unlink(tmpfile)
      return tmpfile
    test<py>:
      /# TODO(wmh): There is some other test method in TestCase that is causing
      /# this test to fail (works fine by itself).
      print 'fix TestCase.tmpFile'
      if False:
        self._tc.setUp()
        self.assertEqual([], self._tc._tmpfiles)
        tmpfile = self._tc.tmpFile()
        self.assertEqual([tmpfile], self._tc._tmpfiles)
        self.assertTrue(os.path.exists(tmpfile))
        tmpfile2 = self._tc.tmpFile(create=False)
        self.assertEqual([tmpfile, tmpfile2], self._tc._tmpfiles)
        self.assertFalse(os.path.exists(tmpfile2))
        self._tc.tearDown()
        self.assertFalse(os.path.exists(tmpfile))
        self.assertFalse(os.path.exists(tmpfile2))
    scope<js>:
      throw new Error('TestCase.tmpFile() not yet implemented');
    scope<cc>:
      throw metax::root::Error("TestCase.tmpFile() not yet implemented");
    end method tmpFile;

    new
    method tmpDir #:
      Create a temporary directory and return its path.
    params:
      var create : bool = true;
    scope<py>:
      tmpdir = tempfile.mkdtemp()
      self._tmpdirs.append(tmpdir)
      if not create:
        os.rmdir(tmpdir)
      return tmpdir
    test<py>:
      /# TODO(wmh): There is some other test method in TestCase that is causing
      /# this test to fail (works fine by itself).
      print 'fix TestCase.tmpDir'
      if False:
        self._tc.setUp()
        self.assertEqual([], self._tc._tmpdirs)
        tmpdir = self._tc.tmpDir()
        self.assertEqual([tmpdir], self._tc._tmpdirs)
        self.assertTrue(os.path.exists(tmpdir))
        tmpdir2 = self._tc.tmpDir(create=False)
        self.assertEqual([tmpdir, tmpdir2], self._tc._tmpdirs)
        self.assertFalse(os.path.exists(tmpdir2))
        self._tc.tearDown()
        self.assertFalse(os.path.exists(tmpdir))
        self.assertFalse(os.path.exists(tmpdir2))
    scope<js>:
      throw new Error('TestCase.tmpDir() not yet implemented');
    scope<cc>:
      throw metax::root::Error("TestCase.tmpDir() not yet implemented");
    end method tmpDir;

    new
    method fileContents #:
      Return the contents of a specified file.
    params:
      var path : any;
    scope<py>:
      if os.path.exists(path):
        fp = open(path, 'r')
        result = fp.read()
        fp.close()
      else:
        result = None
      return result
    test<py>:
      /# TODO(wmh): There is some other test method in TestCase that is causing
      /# this test to fail (works fine by itself).
      print 'fix TestCase.fileContents'
      if False:
        /# path = os.path.join(
        /#   os.path.dirname(__metafile__), './testdata/testing/cipherfile')
        path = metax.root.Object.Resource(
          'cipherfile', fqn='metax.test.TestCase')
        self.assertEqual('aes-128-cbc\ntesting\n', self._tc.fileContents(path))
    scope<js>:
      throw new Error('TestCase.fileContents() not yet implemented');
    scope<cc>:
      throw metax::root::Error("TestCase.fileContents() not yet implemented");
    end method fileContents;

    new
    method isInteractive : bool #:
      Determine whether this TestCase is marked as supporting tests that
      require interactive responses from a user.
    scope<py>:
      return TestCase.Interactive()
    test<py>:
      pass
    scope<js>:
      return MetaTestCase.Interactive();
    scope<cc>:
      return MetaTestCase->Interactive();
    end method isInteractive;

    new
    method allowNetwork : bool #:
      Determine whether this TestCase is marked s supporting tests that
      require network access.
    params:
      var guarding : any;
    scope<py>:
      result = os.getenv('ALLOW_NETWORK', '') == 'true'
      if not result:
        logging.info('NOT ' + guarding)
      return result
    scope<js>:
      throw new Error('TestCase.allowNetwork() not yet implemented');
    scope<cc>:
      throw metax::root::Error("TestCase.allowNetwork() not yet implemented");
    end method allowNetwork;

    new specific
    method setupSharedFilesystem #:
      Configure multiple modules to share the same fake filesystem.
    params:
      var modules : vec #:
        The modules to configure with the same fake filesystem.
      var path_specs : vec = null #:
        See SetupFilesystem for details.
    scope<py>:
      first_module = modules[0]
      fs = self.setupFilesystem(first_module, path_specs=path_specs)
      for module in modules[1:]:
        fs2 = self.setupFilesystem(
            module, path_specs=None, from_module=first_module)
        if fs2 is not fs:
          raise Error("Shared filesystem isn't being shared.")
      self._fs = fs
      return fs
    test<py>:
      tc = self._tc
      tc.setUp()

      self.assertEqual(None, tc._fs)

      modules = [metax.test, sys.modules[__name__]]
      tc.setupSharedFilesystem(
          modules, [('/a/b/c', {'contents': 'blah'})])

      fsinfo = tc._fsinfo
      self.assertEqual(
          ['__main__', 'metax.test'],
          sorted(fsinfo.keys()))
      self.assertTrue(
        fsinfo['__main__']['objs'] is
        fsinfo['metax.test']['objs'])
      self.assertNotEqual(None, tc._fs)
    end method setupSharedFilesystem;

    new specific
    method setupFilesystem : any #:
      Configure module so that it uses a fake filesystem.
      
      Raises:
        Error: if the method is called on a module multiple times.
        Error: if from_module is not None and has not been setup.
      Returns fake_filesystem.FakeFilesystem
    params:
      var module : any #:
        The module to configure.
      var path_specs : *vec = null #:
        The paths to create. Each element is either a string (path) or
        a two-tuple, with the first element being the path, and the second
        element being a dict of keyword args to send to 
        fake_filesystem.CreateFile().
      var from_module : any = null #:
        If specified, the faux filesystem objects are obtained from
        the given module, rather than being created anew.  This means
        that the same filesystem objects are shared across multiple
        modules (arguably the most sensible way to test things).
    scope<py>:
      /# TODO(wmh): Get this working in bazel!
      import fake_filesystem

      mname = module.__name__
      fsinfo = self._fsinfo
      if mname in fsinfo:
        raise Error(
            'Attempt to setupFilesystem on %s when it is already setup' %
            mname)

      fsinfo[mname] = {'module': module, 'objs': {}}
      info = fsinfo[mname]

      if from_module:
        oname = from_module.__name__
        if oname not in fsinfo:
          raise Error(
              'Request to setup faux filesystem for module %s based on module %s'
              ' which has not been set up.' % (mname, oname))
        info['objs'] = fsinfo[oname]['objs']
        objs = info['objs']
        fs = objs['fs']
      else:
        fs = fake_filesystem.FakeFilesystem()
        objs = info['objs']
        objs['fs'] = fs
        objs['fcntl'] = FakeFcntl(fs)
        objs['open'] = fake_filesystem.FakeFileOpen(fs)
        objs['os'] = fake_filesystem.FakeOsModule(fs)

      module.open = objs['open']
      for modname in ('os', 'fcntl'):
        if hasattr(module, modname):
          self._stubs.Set(module, modname, objs[modname])
      if path_specs:
        self.populateFilesystem(fs, path_specs)
      return fs
    test<py>:
      tc = self._tc
      tc.setUp()

      self.assertEqual({}, tc._fsinfo)
      tc.setupFilesystem(
          metax.test,
          path_specs=[
              '/home/bob/file1',
              ('/home/bob/file2',
               {'contents': 'hello world\n', 'perms': 0640}),
              ('/home/bob/dir1', 'dir'),
              ('/home/bob/dir2', {'type': 'dir', 'perms': 0755}),
              ('/home/bob/link1',
               {'type': 'link', 'srcpath': '/home/bob/file1'}),
          ])

      /# Verify that tc._fsinfo has been augmented.
      self.assertEqual(
          ['metax.test'],
          tc._fsinfo.keys())

      /# Basic test (more thorough testing in testPopulateFilesystem()).
      self.assertEqual(
          True, metax.test.os.path.exists('/home/bob/file1'))
      stat_info = metax.test.os.stat('/home/bob/file1')

      self.assertEqual(0, stat_info.st_size)
      self.assertEqual('100666', '%o' % stat_info.st_mode)
      self.assertEqual(None, tc._fs)
    end method setupFilesystem;

    new specific
    method populateFilesystem params:
      var fs : fake_filesystem.FakeFilesystem #:
        The filesystem to populate.
      var path_specs : vec #:
        The paths to create.  If any element is a two-tuple, the
        first element is the path, and the second element is a dict
        containing zero or more of these keys:
          type = str
            One of 'file', 'dir' or 'link'.  Default is 'file'.
          inode = int
            An inode for the file.  Ignored for 'link'.
          perms = int
            The stat.S_IF contant representing the file type.
          contents = str
            The entire contents of the file.
          contents_path = str
            A path to a file to use as the contents of this file.
          size = int
            The size of the file (only if contents or content_path
            are not specified).
          apply_umask = bool
            If True, apply current umask to st_mode
          srcpath = str
            Only valid if type == 'link', specifies the path to which
            the symlink points.
    comment:
      Create files within a fake filesystem.
      
      Raises:
        Error: if an illegal key is passed in path_specs subdata.
    scope<py>:
      for path_info in path_specs:
        /# path_info can be either:
        /#   a) a string (specifies a path to a file)
        /#   b) a two-tuple containing string (path of file) and string
        /#      (one of 'file', 'dir' or 'link', indicating the file type).
        /#   c) a two-tuple containing string (path of file) and dict
        /#      where the dict specifies various key/value pairs for
        /#      configuring the file.
        if isinstance(path_info, (list, tuple)):
          path, info = path_info
          if isinstance(info, dict):
            in_kwds = info
          else:
            in_kwds = {'type': info}
        else:
          path = path_info
          in_kwds = {}

        /# Verify that in_kwds contains only legal keys.
        legal_keys = set([
            'type', 'inode', 'perms', 'contents', 'contents_path', 'size',
            'apply_umask', 'srcpath'])
        for key in in_kwds:
          if key not in legal_keys:
            raise Error(
                "Invalid key '%s' passed to path_specs arg in populateFilesystem"
                % key)

        type_ = in_kwds.get('type', 'file')
        kwds = {}
        if type_ == 'file':
          /# Build up a kwds dict suitable for passing to
          /# fake_filesystem.FakeFilesystem.CreateFile()
          if 'perms' in in_kwds:
            kwds['st_mode'] = stat.S_IFREG | in_kwds['perms']
          if 'contents_path' in in_kwds:
            kwds['contents'] = self._readFile(in_kwds['contents_path'])
          elif 'contents' in in_kwds:
            kwds['contents'] = in_kwds['contents']
          if 'inode' in in_kwds:
            kwds['inode'] = in_kwds['inode']
          if 'apply_umask' in in_kwds:
            kwds['apply_umask'] = in_kwds['apply_umask']
          kwds['create_missing_dirs'] = True
          fs.CreateFile(path, **kwds)

        elif type_ == 'dir':
          /# Build up a kwds dict suitable for passing to
          /# fake_filesystem.FakeFilesystem.CreateDir()
          if 'perms' in in_kwds:
            kwds['perm_bits'] = in_kwds['perms']
          if 'inode' in in_kwds:
            kwds['inode'] = in_kwds
          fs.CreateDirectory(path, **kwds)

        elif type_ == 'link':
          /# Build up a kwds dict suitable for passing to
          /# fake_filesystem.FakeFilesystem.CreateLink()
          if 'srcpath' not in in_kwds:
            raise Error('Request to create a symlink without a src file')
          link_target = in_kwds['srcpath']
          fs.CreateLink(path, link_target)
        else:
          raise Error("Invalid file type '%s'" % type_)
    test<py>:
      /# TODO(wmh): Get this working in bazel
      import mox

      tc = self._tc
      tc.setUp()

      self.assertEqual({}, tc._fsinfo)

      if False:
        epath = os.path.join(
          os.path.dirname(__metafile__),
          './testdata/regexp/entry.mre')
        with open(epath, 'r') as fp:
          contents = fp.read()
      else:
        epath = metax.root.Object.Resource(
          'entry_mre', fqn='metax.test.TestCase')
        /# print '**** HERE with epath=%s' % epath
        with open(epath, 'r') as fp:
          contents = fp.read()

      /# We mock out the single call to metax.test.TestCase._ReadFile() which
      /# will be invoked for '/home/bob/file3'
      m = tc.newMox()
      m.StubOutWithMock(tc, '_readFile')
      tc._readFile(mox.IsA(str)).AndReturn(contents)
      m.ReplayAll()

      /# Calling SetupFilesystem() will call PopulateFileSystem(), and it is
      /# easier to test after fully initializing than to test in isolation.
      tc.setupFilesystem(
          metax.test,
          path_specs=[
              '/home/bob/file1',
              ('/home/bob/file2',
               {'contents': 'hello world\n', 'perms': 0640}),
              ('/home/bob/dir1', 'dir'),
              ('/home/bob/dir2', {'type': 'dir', 'perms': 0755}),
              ('/home/bob/link1',
               {'type': 'link', 'srcpath': '/home/bob/file1'}),
              ('/home/bob/file3',
               {'contents_path': epath}),
          ])
      package = 'metax.test'
      self.assertTrue(package in tc._fsinfo)
      self.assertTrue(metax.test is tc._fsinfo[package]['module'])
      for k in ('fs', 'open', 'os', 'fcntl'):
        self.assertTrue(k in tc._fsinfo[package]['objs'])

      /# file1 is a file with no content.
      self.assertEqual(
          True, metax.test.os.path.exists('/home/bob/file1'))
      stat_info = metax.test.os.stat('/home/bob/file1')
      self.assertEqual(0, stat_info.st_size)
      self.assertEqual('100666', '%o' % stat_info.st_mode)

      /# file2 is a file with content.
      fp = metax.test.open('/home/bob/file2', 'r')
      self.assertEqual('hello world\n', fp.read())
      fp.close()
      stat_info = metax.test.os.stat('/home/bob/file2')
      self.assertEqual('100640', '%o' % stat_info.st_mode)

      /# dir1 is a directory with default permissions.
      self.assertEqual(
          True, metax.test.os.path.isdir('/home/bob/dir1'))
      stat_info = metax.test.os.stat('/home/bob/dir1')
      self.assertEqual('40777', '%o' % stat_info.st_mode)

      /# dir2 is a directory with specific permissions.
      self.assertEqual(
          True, metax.test.os.path.isdir('/home/bob/dir2'))
      stat_info = metax.test.os.stat('/home/bob/dir2')
      self.assertEqual('40755', '%o' % stat_info.st_mode)

      /# link1 is a symlink to file1
      stat_info = metax.test.os.stat('/home/bob/link1')
      self.assertEqual('100666', '%o' % stat_info.st_mode)

      /# file3 has content initialized from a file.
      self.assertEqual(
          True, metax.test.os.path.exists('/home/bob/file3'))
      stat_info = metax.test.os.stat('/home/bob/file3')
      self.assertEqual(28, stat_info.st_size)
      self.assertEqual('100666', '%o' % stat_info.st_mode)

      m.VerifyAll()
    end method populateFilesystem;

    new specific
    method fakeFile : any params:
      var path : str #:
        The path to the file.
    comment:
      Obtain a fakefile instance.
      
      Raises:
        Error: If one invokes this method without first invoking
               SetupSharedFilesystem().
      Returns fake_filesystem.FakeFile
    scope<py>:
      if not self._fs:
        raise metax.root.Error(
            'Attempt to invoke FakeFile() without first invoking '
            'SetupSharedFilesystem()')
      return self._fs.GetObject(path)
    test<py>:
      /# TODO(wmh): Get this working in bazel
      import fake_filesystem

      tc = self._tc
      tc.setUp()

      /# If we don't first call SetupSharedFilesystem, FakeFile() is an error.
      self.assertRaises(metax.root.Error, tc.fakeFile, '/any/path')

      fs = tc.setupSharedFilesystem(
          [metax.test], [('/a/b/c', {'contents': 'blah'})])
      fake = tc.fakeFile('/a/b/c')
      self.assertTrue(isinstance(fake, fake_filesystem.FakeFile))
      self.assertEqual('blah', fake.contents)
    end method fakeFile;

    new specific
    method fakeFileExists : bool params:
      var path : str #:
        The path to the file.
    comment:
      Determine if a fake file exists.
      Returns bool
    scope<py>:
      return self._fs.Exists(path)
    test<py>:
      pass
    end method fakeFileExists;

    new specific
    method fakeContents : str params:
      var path : str #:
        The path to the file.
    comment:
      Obtain the contents of a fake file.
      
      Raises:
        Error: If one invokes this method without first invoking
               SetupSharedFilesystem().
      Returns str (file contents)
    scope<py>:
      return self.fakeFile(path).contents
    test<py>:
      tc = self._tc
      tc.setUp()

      /# If we don't first call SetupSharedFilesystem, FakeContent() is an error.
      self.assertRaises(metax.root.Error, tc.fakeContents, '/any/path')

      fs = tc.setupSharedFilesystem(
          [metax.test], [('/a/b/c', {'contents': 'blah'})])
      self.assertEqual('blah', tc.fakeContents('/a/b/c'))
    end method fakeContents;

    new specific
    method _readFile : str params:
      var filename : str #:
        The path to the file.
    comment:
      Obtain contents of a file.
      Returns str
    scope<py>:
      with open(filename, 'r') as fp:
        contents = fp.read()
      return contents
    test<py>:
      pass
    end method _readFile;
 
    new specific
    method revertFilesystem #:
      Undo all stubs to create a faux filesystem.
    params:
      var module : any;
    scope<py>:
      fsinfo = self._fsinfo
      mname = module.__name__
      if mname not in fsinfo:
        raise Error(
            'Attempt to revert filesystem for %s when no filesystem set up'
            % mname)
      del module.open
      del fsinfo[mname]
    test<py>:
      tc = self._tc
      tc.setUp()
      mname = metax.test.__name__
      self.assertFalse(mname in tc._fsinfo)
      unused_fs = tc.setupFilesystem(metax.test)
      self.assertTrue(mname in tc._fsinfo)
      tc.revertFilesystem(metax.test)
      self.assertFalse(mname in tc._fsinfo)
    end method revertFilesystem;

    method assertDictContains #:
        keyval iterate over subdata into (k,v) scope:
          expr switch scope:
            case [k not in data] scope:
              @self.fail('Failed to find ${k} in dict');
            case [data[k] != v] scope:
              @self.fail('${k} = ${data[k]} != ${v}');

        iterate subdata (k,v) scope:
          expr switch scope:
            case [k not in data] scope:
              @self.fail('Failed to find ${k} in dict');
            case [data[k] != v] scope:
              @self.fail('${k} = ${data[k]} != ${v}');
    params:
      var data : map;
      var subdata : map;
    scope<py>:
      for k, v in subdata.iteritems():
        if k not in data:
          self.fail('Failed to find %s in dict' % k)
        elif data[k] != v:
          self.fail('%s = %s != %s' % (k, data[k], v))
    scope<js>:
      throw new Error('TestCase.assertDictContains() not yet implemented');
    scope<cc>:
      throw metax::root::Error(
        "TestCase.assertDictContains() not yet implemented");
    end method assertDictContains;

    method startswith params:
      var prefix : str;
      var strval : str;
    scope<py>:
      self.assertTrue(
        strval.startswith(prefix),
        'String\n  "%s"\ndoes not start with\n  "%s"' % (strval, prefix))
    test<py>:
      pass
    scope<js>:
      assertTrue(
        'String\n  \"' + strval + '\"\ndoes not start with\n  \"' + prefix + '\"',
        strval.startsWith(/** @type {!string} */ (prefix)));
    scope<cc>:
      throw metax::root::Error("TestCase.startswith() not yet implemented");
    end method startswith;

    method endswith params:
      var suffix : str;
      var strval : str;
    scope<py>:
      if strval is None:
        self.fail(
          'String is null when expecting non-null ending with\n  "%s"' % suffix)
      else:
        self.assertTrue(
          strval.endswith(suffix),
          'String\n  "%s"\ndoes not end with\n  "%s"' % (strval, suffix))
    scope<js>:
      assertTrue(
        'String\n  \"' + strval + '\"\ndoes not end with\n  \"' + suffix + '\"',
        strval.endsWith(/** @type {!string} */ (suffix)));
    scope<cc>:
      throw metax::root::Error("TestCase.endswith() not yet implemented");
    end method endswith;

    method contains params:
      var member : any;
      var container : any;
      var msg : str = null;
    scope<py>:
      self.assertIn(member, container, msg=msg);
    scope<js>:
      if (msg) {
        assertContains(msg, member, container);
      } else {
        assertContains(member, container);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.contains() not yet implemented");
    end method contains;

    method matches #:
      A string value matches a regexp. 
    params:
      var restr : str #:
        The regexp to match against (as a string).
      var value : str #:
        The value to match.
    scope<py>:
      m = re.match(restr, value)
      if not m:
        self.fail('Expected match failed:\n  %s\n  %s' % (restr, value))
    scope<js>:
      console.log('Fix TestCase.matches in Javascript');
    scope<cc>:
      throw metax::root::Error("TestCase.matches() not yet implemented");
    end method matches;

    method iseq #:
      Compare an arbitrary two entities for equality (not pointer equality!)

      NOTE: This method may not be implementable in C++. Decide whether we
      want to keep it for use in other baselangs, or if allowing it
      encourages people to use methods that won't work in <cc> and <*>.
    params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        eval = str(expected).replace('\n', '\\n')
        aval = str(item).replace('\n', '\\n')
        message = '"%s" != "%s"' % (eval, aval)
      self.assertEqual(expected, item, message)
    scope<js>:
      if (message == null) {
        assertEquals(expected, item);
      } else {
        assertEquals(message, expected, item);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.iseq() not yet implemented");
    end method iseq;

    method noteq #:
      Compare an arbitrary two entities for non-equality (not pointer equality!)

      See comment in 'eq' about viability in C++ and ramifications on this
      method.
    params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s == %s' % (str(expected), str(item))
      self.assertNotEqual(expected, item, message)
    scope<js>:
      if (message == null) {
        assertNotEquals(expected, item);
      } else {
        assertNotEquals(message, expected, item);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.noteq() not yet implemented");
    end method noteq;

    method iseqstr #:
      Compare an arbitrary two entities for equality (not pointer equality!)

      NOTE: This method may not be implementable in C++. Decide whether we
      want to keep it for use in other baselangs, or if allowing it
      encourages people to use methods that won't work in <cc> and <*>.
    params:
      var expected : &str;
      var item : &str;
      var message : str = null;
    scope<py>:
      if message is None:
        message = '%s != %s' % (expected, item)
      self.assertEqual(expected, item, message)
    scope<js>:
      if (message == null) {
        assertEquals(expected, item);
      } else {
        assertEquals(message, expected, item);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.iseq() not yet implemented");
      if (message == nullptr) {
      } else {
      }
    test<py>:
    end method iseqstr;

    method noteqstr #:
      Compare an arbitrary two entities for non-equality (not pointer equality!)
    params:
      var expected : &str;
      var item : &str;
      var message : str = null;
    scope<py>:
      if message is None:
        message = '%s == %s' % (expected, item)
      self.assertNotEqual(expected, item, message)
    scope<js>:
      if (message == null) {
        assertNotEquals(expected, item);
      } else {
        assertNotEquals(message, expected, item);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.iseq() not yet implemented");
      if (message == nullptr) {
      } else {
      }
    end method noteqstr;

    method iseqvec params:
      var expected : vec;
      var items : vec;
      var message : str = null;
    scope<py>:
      self.assertListEqual(expected, items, message)
    scope<js>:
      if (message == null) {
        assertElementsEquals(expected, items);
      } else {
        assertElementsEquals(message, expected, items);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.iseqvec() not yet implemented");
    end method iseqvec;

    method iseqmap params:
      var expected : any;
      var data : any;
      var msg : any = null;
      var width : int = 30;
    scope<py>:
      if expected != data:
        if msg is None:
          msg = '%s != %s' % (expected, data)

        def Trunc(val, width):
          val = str(val)
          if len(val) > width:
            val = val[:width - 1] + '$'
          return val

        form = '%%-10s %%-2s %%-%ds %%-%ds' % (width, width)
        notes = []
        for k in sorted(set(expected.keys() + data.keys())):
          expval = expected[k] if k in expected else '---'
          dval = data[k] if k in data else '---'
          sign = '  ' if (expval == dval) else '!='
          notes.append(
            form % (
              Trunc(k, 10),
              sign,
              Trunc(expval, width + 2),
              Trunc(dval, width + 2)))
        self.fail(msg + '\n' + '\n'.join(notes))
    scope<js>:
      if (msg) {
        assertHashEquals(msg, expected, data);
      } else {
        assertHashEquals(expected, data);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.iseqmap() not yet implemented");
    end method iseqmap;

    method iseqtext params:
      var first : str;
      var second : str;
      var text : str = null;
    scope<py>:
      self.assertMultiLineEqual(first, second, msg=text)
    scope<js>:
      if (text === null) {
        assertEquals(first, second);
      } else {
        assertEquals(text, first, second);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.iseqtext() not yet implemented");
    end method iseqtext;

    method iseqfile params:
      var file1 : any;
      var file2 : any;
    scope<py>:
      info = os.system('diff %s %s' % (file1, file2))
      signum = info & 0xff
      status = info >> 8
      self.assertTrue(
        status == 0, 'Files %s and %s differ' % (file1, file2))
    scope<js>:
      throw new Error('TestCase.() not yet implemented');
    scope<cc>:
      throw metax::root::Error("TestCase.iseqfile() not yet implemented");
    end method iseqfile;

    method iseqstrgold params:
      var content : any;
      var golden : any;
    scope<py>:
      if self.meta().WriteGoldens():
        with open(golden, 'w') as fp:
          fp.write(content)
        print 'Wrote %d bytes to golden %s' % (len(content), golden)
      else:
        if True:
          with open(golden, 'r') as fp:
            content2 = fp.read()
            /# By comparing the golden on the right, the output produced
            /# reflects what needs to be done to the passed in 'content',
            /# not what needs to be done to the golden. For example, '+'
            /# means add a line to content, '-' means remove a line, etc.
            self.assertMultiLineEqual(content, content2)
        else:
          fd, tmpfile = tempfile.mkstemp()
          os.write(fd, content)
          os.close(fd)
          self.iseqfile(golden, tmpfile)
          os.unlink(tmpfile)
    scope<js>:
      throw new Error('TestCase.() not yet implemented');
    scope<cc>:
      throw metax::root::Error("TestCase.iseqstrgold() not yet implemented");
    end method iseqstrgold;

    method iseqfilegold params:
      var path : any;
      var golden : any;
    scope<py>:
      if self.meta().WriteGoldens():
        shutil.copyfile(path, golden)
        print 'Copied %s to %s' % (path, golden)
      else:
        self.iseqfile(golden, path)
    scope<js>:
      throw new Error('TestCase.() not yet implemented');
    scope<cc>:
      throw metax::root::Error("TestCase.iseqfilegold() not yet implemented");
    end method iseqfilegold;

    method isapprox #:
      Compare two float values for closeness.
    params:
      var f1 : double;
      var f2 : double;
      var delta : double = 0.00001;
      var msg : str = null;
    scope<py>:
      self.assertAlmostEqual(f1, f2, delta=delta, msg=msg)
    scope<js>:
      if (msg) {
        assertRoughlyEquals(msg, f1, f2, delta);
      } else {
        assertRoughlyEquals(f1, f2, delta);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.isapprox() not yet implemented");
    end method isapprox;

    method isapproxvec #:
      Compare two lists of float values for closeness.
    params:
      var lf1 : double;
      var lf2 : double;
      var delta : double = 0.00001;
      var msg : str = null;
    scope<py>:
      /# TODO(wmh): Make this more robust
      /# TODO(wmh): Make a general purpose comparison method that can handle
      /# nested dicts/lists and supports approximate float comparisons.
      len1 = len(lf1)
      len2 = len(lf2)
      if len1 != len2:
        self.fail('list1 has %d element, list2 has %d elements' % (len1, len2))
      else:
        for i in range(0, len1):
          self.assertAlmostEqual(lf1[i], lf2[i], delta=delta, msg=msg)
    end method isapproxvec;

    method islt params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s >= %s' % (str(expected), str(item))
      self.assertLess(expected, item, message)
    scope<js>:
      if (message == null) {
        message = '' + expected + ' >= ' + item;
      }
      assertTrue(message, expected < item);
    scope<cc>:
      throw metax::root::Error("TestCase.islt() not yet implemented");
    end method islt;

    method isle params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s > %s' % (str(expected), str(item))
      self.assertLessEqual(expected, item, message)
    scope<js>:
      if (message == null) {
        message = '' + expected + ' > ' + item;
      }
      assertTrue(message, expected <= item);
    scope<cc>:
      throw metax::root::Error("TestCase.isle() not yet implemented");
    end method isle;

    method isgt params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s <= %s' % (str(expected), str(item))
      self.assertGreater(expected, item, message)
    scope<js>:
      if (message == null) {
        message = '' + expected + ' <= ' + item;
      }
      assertTrue(message, expected > item);
    scope<cc>:
      throw metax::root::Error("TestCase.isgt() not yet implemented");
    end method isgt;

    method isge params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s < %s' % (str(expected), str(item))
      self.assertGreaterEqual(expected, item, message)
    scope<js>:
      if (message == null) {
        message = '' + expected + ' < ' + item;
      }
      assertTrue(message, expected >= item);
    scope<cc>:
      throw metax::root::Error("TestCase.isge() not yet implemented");
    end method isge;

    method raises #:
      Confirm that the given method raises an exception.

      Note that the python version accepts arbitrary positional and
      keyword args while the javascript version does not. Need to get 
      varargs supported in javascript before we can try implementing it.
    params:
      var eclass : class #:
        The exception class raised
      var func : &#function #:
        The callable object
      multi var args : vec #:
        The positional args to pass to func.
      multi var kwds : map #:
        The keyword args to pass to func.
    scope<py>:
      self.assertRaises(eclass, func, *args, **kwds)
    scope<js>:
      /# TODO(wmh): goog.testing.asserts.assertThrows() is rather limited:
      /#  - it only handles methods that that don't require any args
      /#  - it only detects whether any exception is raised, not whether a
      /#    specific exception is raised.
      /# A better version of assertThrows() is certainly possible. Implement
      /# it.
      /* var e = */ assertThrows(func);
      /# TODO(wmh): At the very least, we can compare the exception 'e' against
      /# expected 'eclass'.
    scope<cc>:
      throw metax::root::Error("TestCase.raises() not yet implemented");
    end method raises;

    method issame params:
      var obj1 : any;
      var obj2 : any;
    scope<py>:
      self.assertTrue(obj1 is obj2, "%s is not %s" % (repr(obj1), repr(obj2)))
    scope<js>:
      assertTrue(obj1 + ' is not ' + obj2, obj1 === obj2);
    scope<cc>:
      throw metax::root::Error("TestCase.issame() not yet implemented");
    end method issame;

    method notsame params:
      var obj1 : any;
      var obj2 : any;
    scope<py>:
      self.assertFalse(obj1 is obj2, "%s is %s" % (repr(obj1), repr(obj2)))
    scope<js>:
      assertFalse(obj1 + ' is ' + obj2, obj1 === obj2);
    scope<cc>:
      throw metax::root::Error("TestCase.notsame() not yet implemented");
    end method notsame;

    method istrue #:
      Note that we cannot use 'true' as a method because that is reserved in
      various languages (and we want a common interface across all languages).
    params:
      var val : bool;
      var msg : str = null;
    scope<py>:
      self.assertTrue(val, msg)
    scope<js>:
      if (msg == null) {
        assertTrue(val);
      } else {
        assertTrue(msg, val);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.istrue() not yet implemented");
    end method istrue;

    method isfalse #:
      Note that we cannot use 'false' as a method because that is reserved in
      various languages (and we want a common interface across all languages).
    params:
      var val : bool;
      var msg : str = null;
    scope<py>:
      self.assertFalse(val, msg)
    scope<js>:
      if (msg) {
        assertFalse(msg, val);
      } else {
        assertFalse(val);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.isfalse() not yet implemented");
    end method isfalse;

    method isnull #:
      Confirm the arg is null.
    params:
      var val : any;
      var msg : str = null;
    scope<py>:
      self.assertIsNone(val, msg)
    scope<js>:
      if (msg) {
        assertNull(msg, val);
      } else {
        assertNull(val);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.isnull() not yet implemented");
    end method isnull;

    method notnull #:
      Confirm the arg is not null.
    params:
      var val : any;
      var msg : str = null;
    scope<py>:
      self.assertIsNotNone(val, msg)
    scope<js>:
      if (msg) {
        assertNotNull(msg, val);
      } else {
        assertNotNull(val);
      }
    scope<cc>:
      throw metax::root::Error("TestCase.notnull() not yet implemented");
    end method notnull;

    method isinst params:
      var obj : any #:
        The object to test.
      var cls : any #:
        The class the object is expected to be an instance of.
        In javascript, this is the constructor function.
    scope<py>:
      self.istrue(
        isinstance(obj, cls),
        'Expecting %s to be an instance of %s' % (obj, cls))
    scope<js>:
      this.istrue(
        typeof obj == cls,
        'Expecting ' + obj + ' to be an instance of ' + cls);
    scope<cc>:
      throw metax::root::Error("TestCase.isinst() not yet implemented");
    end method isinst;

    method fail #:
      # Invoked to indicate an unconditional failure.
    params:
      var msg : str;
    scope<js>:
      this.istrue(false, msg);
    scope<py>:
      super(TestCase, self).fail(msg);
    scope<cc>:
      throw metax::root::Error("TestCase.fail() not yet implemented");
    end;

    test
    lifecycle setup:
      self._tc = metax.test.TestCase('captureStdout')
      /# This is important to stop various tests from printing out output
      /# that confuses the python parsing scripts.
      self._tc.silentIs(True)
    end;

  end class TestCase;  

  native #:
    The code needed to run the namespace level tests.
  scope<py>:
    def main():
      /# In Python, one invokes unittests using the simple idiom:
      /#   if __name__ == '__main__':
      /#      unittest.main()
      /#
      /# In Meta<Python>, a similar idiom is used (although users don't see it):
      /#   if __name__ == '__main__':
      /#      metax.test.main()
      /#
      /# The method you are in rigt now is metax.test.main().

      import os
      tsd = os.getenv('TEST_SRCDIR', None)
      if tsd is None:
        /# This code is NOT being executed via bazel.  In order to ensure that
        /# metax.root.Object.Resource() works properly we set an envvar that
        /# can be used to determine that we are running unittest code but
        /# not in bazel.
        os.environ['IN_UNITTEST'] = 'true'
      else:
        /# This code IS being executed via bazel
        pass
      /# By passing verbosity=0, we disable unittest.TextTestRunner's default
      /# behavior of printing out a '.' (or 'E' or 'F') for each test. Meta
      /# provides its own output.
      unittest.main(verbosity=0)
  end native;

end namespace metax.test;
