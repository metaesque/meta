namespace metax.test #:
  Classes related to unit-testing.
scope:

  class TestCase #:
    /# The JUnit testing infrastructure for Java (which came from a testing
    /# infrastructure for Smalltalk) has gained cross-language recognition, and
    /# there is an xUnit implementation for basically every OO language
    /# (e.g. CppUnit, JSUnit, python unit (unittest), etc.).
    /# 
    /# See $METAROOT/UseGuide.wmd (/Meta/Meta From The Middle Ground/Unit Tests)
    /# for a discussion of xUnit and how Meta implements this testing paradigm
    /# across all baselangs.
    /# 
    /# See the src/kernel/asserts.org file for details on alerts across
    /# baselangs.
    /# 
    /# In javascript, the normal idiom for doing javascript testing using
    /# bazel and google closure is as follows:
    /#  - unittests are implemented in some file ending in _test.js
    /#  - the file must goog.require('goog.testing.jsunit'), which:
    /#     - creates cached G_testRunner (if G_testRunner already exists, noop)
    /#     - creates a window.onerror handler to report errors during test
    /#       initialization
    /#     - creates a window.onload handler so that when the page containing
    /#       the *_test.js file is loaded:
    /#        - invokes any already specified onload code
    /#        - creates a timeout to execute the following after 500ms
    /#          - if G_testRunner is not yet initialized:
    /#             - create a TestCase instance 'testCase'
    /#             - invoke goog.testing.TestCase.initializeTestRunner(testCase)
    /#                - invokes testCase.setOrder()
    /#                - invokes testCase.setTestsToRun() based on a parsing
    /#                  of the 'runTests' parameter in the url found at
    /#                  goog.global.location.search
    /#                - invokes gTestRunner.initialize(testCase)
    /#                   - sets testCase and initialized fields
    /#          - invokes G_testRunner.execute()
    /#             - invokes this.testCase.setCompletedCallback()
    /#             - invokes this.testCase.runTests()
    /#                - invokes testCase.setUpPage()
    /#                - invokes testCase.execute()
    /#                   - invokes testCase.cycleTests()
    /#                      ...
    /# 
    /# In Meta<javascript>, the above control flow is changed as follows:
    /#  - For user-defined class <C> in namespace <N>, Meta implicitly defines
    /#    test class <N>_test.<C>Test in file <N>/<C>_test.js.
    /#  - The <C>_test.js file does NOT goog.require('goog.testing.jsunit').
    /#  - The <C>Test class inherits (directly or indirectly) from
    /#    metax.test.TestCase (which inherits from goog.testing.TestCase),
    /#    and has zero or more 'test_<M>*' methods defined for every user-defined
    /#    method <M> defined on <C> depending on the presence of 'test' or 'tests'
    /#    attributes on <M>.
    /#  - In <C>_test.js file, after the definition of <C>Test, the following
    /#    code exists:
    /#      var testCase = new <N>.<C>Test('<N>.<C>Test');
    /#      testCase.run();
    /#  - The 'run' method (metax.test.TestCase.run) does the following:
    /#     - Invokes jsunit(), which does similar work to what goog.testing.jsunit
    /#       does.
    /#     - Invokes setTestObj(), which does similar work to 
    /#       goog.testing.TestCase.setTestObj()
    /#     - Invokes gTestRunner.setStrict(false) to all 0 tests
    /#     - Invokes goog.testing.TestCase.initializeTestRunner()
    /#     - Invokes gTestRunner.execute()
    /#         ...
    /# 
    /# Modifications needed to io_bazel_rules_closure
    /#  - created local repository at $WMH/src/google/rules_closure
    /#    with
    /#      % cd $WMH/src/google
    /#      % git clone https://github.com/bazelbuild/rules_closure.git
    /#      % cd rules_closure
    /#  - modified
    /#     closure/testing/phantomjs_harness.js
    /#      - parse out optional --key=value args before the html file and .js files
    /#      - create query string
    /#      - add query string to url
    /#      - change 'path == VIRTUAL_PAGE' to 'page.startsWith(VIRTUAL_PAGE)'
    /#     closure/testing/phantomjs_test.bzl
    /#      - based on --test_arg, insert values into the 'args' list before
    /#        ctx.file.html.short_path.
    /#      - TODO(wmh): How to get access to --test_arg (and/or --test_env)?
    /#        ctx.configuration.default_shell_env doesn't store --test_env,
    /#        and ctx.configuration.test_env doesn't even exist, contrary to
    /#        https://bazel.build/versions/master/docs/skylark/lib/configuration.html
    /# 
    /# Meta:suppress: legacyGoogScopeRequire
  parent<py> ^unittest.TestCase
  parent<js> ^goog.testing.TestCase
  assocs<py>:
    std assoc unittest #:
      TODO(wmh): Why isn't this being implicitly included due to being a
      parent? Because it is '^'?
  scope:

    meta
    field Debug : bool #:
      What to initialize TestCase.debug to.
    meta
    field InstanceCount : int = 1 #:
      Counts the number of instances created so we can assign unique ids.
      Useful for debugging purposes.
    meta
    field WriteGoldens : bool #:
      If true, methods that invoke iseqstrgold() or iseqfilegold() will
      update goldens instead of compare goldens.

    meta
    lifecycle #:
      Initialize class-level variables.  This includes variables for
      controlling golden writing, interactivity, debugging, etc, based on
      the value of envars.

      TODO(wmh): This should be added to the 'meta lifecycle' above, when
      support has been provided by Meta.
    scope<py>:
      /# TODO(wmh): How can we set environment variables when using bazel?
      /# The --action_env flag from
      /#    https://bazel.build/designs/2016/06/21/environment.html
      /# does not appear to be working the way I understand it,
      /# neither with entries in ~/.bazelrc or explicitly specified on
      /# the command line:
      /#   bazel test --action_env=BLAH=blork --test_output=all //wmh:regexp_test
      import os
      meta.WriteGoldensIs(os.getenv('WRITE_GOLDENS', '') == 'true')
      debug = os.getenv('META_DEBUG', '')
      if ' tests ' in debug:
        meta.DebugIs(True)
    scope<js>:
      /# TODO(wmh): Establish whether there is any way to emulate
      /# class variables in Javascript other than adding them as
      /# instance variables within the meta class.
    end lifecycle;

    field debug : bool #:
      If True, prints out each invocation of the initializer, setup,
      teardown and finalizer methods.
    field uid : str #:
      The name of the method that this instance of TestCase is
      responsible for testing. Although the parent initializer also
      stores this, each baselang uses a different name for the field.
      Rather than encoding this name in each baselang, we just store a
      new copy locally.
    field tmpfiles : @vec<str> #:
      The collection of temporary files created via tmpFile().
    field tmpdirs : @vec<str> #:
      The collection of temporary dirs created via tmpDir()
    field moxlist : @vec<any> #:
      The collection of mocking objects created via newMox.
      TODO(wmh): Rename this something non-python-centric.
    field stdout : meta!ostream #:
      The current stream used for stdout.  If null, the default is used.
    field stderr : meta!ostream #:
      The current stream used for stderr.  If null, the default is used.
    field stdin : meta!istream #:
      The current stream used for stdin.  If null, the default is used.
    field fsinfo : @map #:
      Maps module names to dicts containing:
        module: the module itself
        fs: the fake filesystem for the module.
    field envars : @map #:
      Records environment variables modified during a test (so they
      can be reinstated).
    field fs #:
      Only initialized if SetupSharedFilesystem() is invoked.
    type<py> fake_filesystem.FakeFilesystem
    type<js> any
    end field fs;

    field stubs #:
      Allows us to stub out methods and have them implicitly reverted.
    type<py> any
    type<js> goog.testing.PropertyReplacer
    end field stubs;

    lifecycle #:
      In all XUnit testing environments, a TestCase is a class defining
      a collection of test methods (methods starting with 'test') and
      service methods (methods not starting with 'test'). There is a specific
      order of operation for how these TestCases are executed.
       - the meta-level SetUp() method is invoked to perform one time
         initialization of the TestCase.
       - if there are N test methods in the Test Case, N instances of
         TestCase are created
       - for each instance created above:
          - invoke the setUp() method
          - invoke the test method that this instance was created to run
          - invoke the tearDown() method.
       - the finalizers for each instance of TestCase are invoked.
       - the meta-level TearDown() method is invoked to cleanup anything
         done in SetUp()

      The exact names of the setUp, tearDown, SetUp and TearDown methods
      vary across baselangs, which is why the 'lifecycle' construct exists ...
      it knowns the underlying method names that need to be generated in
      each baselang, allowing the user to focus simply on the
      init/setup/teardown/finalize sequence.

      Note that the javascript asserting methods are available in 
        $CLOSURE_ROOT/library/closure/goog-orig/testing/asserts.js
      They are rather odd in having the optional message be the first argument
      of the method (so we have to do some reversal to get the more intuitive
      'optional message as last arg' idiom.

      Note that the 'location' feature attribute of the 'lifecycle' construct
      specifies whether we are referring to an explicit class, the implicit meta
      class associated with an explicit class, or the implicit test class
      associated with an explicit class.  If the class itself has 'location'
      meta, it doesn't make sense to have any of its 'lifecycle' instances
      also have location 'meta' (a meta class does not have a meta class).
      The same is true for 'test' (a test class does not have a test class).
      However, a meta class can have a test class, and a test class has a
      meta class.
    params:
      var method_name type str type<js> @str #:
        A name for the test case.
        IMPORTANT: Since the Meta compiler implicitly adds a parameter to
        meta lifecycles of testcase classes, it is important that we ...???
    super<py> (method_name)
    super<js> (method_name)
    init<py>:
      self.debugIs(self.__class__.Debug())
      count = metax.test.TestCase.InstanceCount() + 1
      metax.test.TestCase.InstanceCountIs(count)
      self.uidIs('%s:%d' % (method_name, count))
      self.deblog('Invoking %s initializer for %s' % (self.name(), method_name))
    init<js>:
      var count = metax.test.TestCase.InstanceCount() + 1;
      metax.test.TestCase.InstanceCountIs(count);
      this.uidIs(method_name + ':' + count);
      this.deblog(
          'Invoking ' + this.name() + ' initializer for ' + method_name);
    finalize<py>:
      self.deblog('Invoking %s finalizer for %s' % (self.name(), self.methname()))
    end lifecycle;

    new
    method deblog #:
      Print out a Meta specific log message.
    params:
      var msg : str;
    scope<js>:
      if (this.debug()) {
        this.log(this.uid() + ': ' + msg);
      }
    scope<py>:
      if self.debug():
        print '%s: %s' % (self.uid(), msg)
    end method deblog;

    new
    method name : str #:
      The name of this testcase.
      See methname for the name of the method within the testcase.
    scope<py>:
      return self.__class__.__name__
    scope<js>:
      return this.constructor.name;
    end method name;

    new
    method methname : str #:
      The name of the method defined within a subclass of TestCase to be
      invoked as the test.

      Meta:suppress: visibility
    scope<py>:
      return self._testMethodName
    scope<js>:
      return this.name_;
    end method methname;

    specific
    method clearMoxes #:
      # Unset any Mox instances.
    scope<py>:
      if self._moxlist:
        for m in self._moxlist:
          m.UnsetStubs()
        self._moxlist = []
    end method clearMoxes;

    new
    method setenv params:
      var evar : str;
      var value : str;
    scope<py>:
      raise Error('setenv() is not yet working properly (do not use)')
      current = os.environ.get(evar, None)
      if current != ENV.get(evar, None):
        raise Error(
          'Expecting evar = "%s" not "%s"' % (ENV.get(evar, None), current))
      os.environ[evar] = value
      self._envars[evar] = current
    test<py>:
      /# TODO(wmh): Work on this.
      return

      home = os.getenv('HOME', None)
      self._tc.setenv('HOME', '/home/bob')
      self.assertEqual('/home/bob', os.getenv('HOME', None))
      self._tc.tearDown()
      self.assertEqual(home, os.getenv('HOME', None))
    scope<js>:
      throw new Error('TestCase.setenv() not yet implemented');
    end;

    new specific
    method metaTestPath : str params:
      var metafile : str #:
        The path of the meta file defining the test.
      multi var subpaths : vec #:
        The path within the directory containing the
        metafile.
    comment:
      Obtain the path of a testdata file within the
      same directory as a specified .meta file.

      TODO(wmh): Javascript does not yet properly handle varargs.

      scope<js>:
        var dirname = metafile.match(/.*//);
        var result = dirname;
        for (var i = 0; i < subpaths.length; ++i) {
          result += '/' + subpaths[i];
        }
        return result;
    scope<py>:
      return os.path.join(os.path.dirname(metafile), *subpaths)
    end method metaTestPath;

    new specific
    method captureStdout #:
      Capture all subsequent output written to stdout until getStdout() is
      invoked.
    scope<py>:
      self._stdout = cStringIO.StringIO()
      sys.stdout = self._stdout
    test<py>:
      self.assertTrue(sys.stdout is meta.testing.TestCase.STDOUT)
      self._tc.captureStdout()
      self.assertTrue(isinstance(sys.stdout, meta.testing.cStringIOClass))
      print 'hello world'
      out = self._tc.getStdout()
      self.assertTrue(sys.stdout is meta.testing.TestCase.STDOUT)
      self.assertEqual('hello world\n', out)
    end method captureStdout;

    new specific
    method getStdout #:
      Obtain the stdout captured since the last call to captureStdout().
      Resets stdout to what it was before captureStdout() was invoked.
    scope<py>:
      /# TODO(wmh): Use self._stdout to test.
      cls = sys.stdout.__class__
      if cls is cStringIOClass or isinstance(sys.stdout, StringIO.StringIO):
        result = sys.stdout.getvalue()
      else:
        result = None
      sys.stdout = TestCase.STDOUT
      self._stdout = None
      return result
    test<py>:
      /# noop, tested in test_captureStdout()
      pass
    end method getStdout;

    new specific
    method captureStderr #:
      Capture all subsequent output written to stderr until getStderr() is
      invoked.
    scope<py>:
      self._stderr = cStringIO.StringIO()
      sys.stderr = self._stderr
    test<py>:
      self.assertTrue(sys.stderr is meta.testing.TestCase.STDERR)
      self._tc.captureStderr()
      self.assertTrue(isinstance(sys.stderr, meta.testing.cStringIOClass))
      sys.stderr.write('hello world\n')
      err = self._tc.getStderr()
      self.assertTrue(sys.stderr is meta.testing.TestCase.STDERR)
      self.assertEqual('hello world\n', err)
    end method captureStderr;

    new specific
    method getStderr #:
      Obtain the stderr captured since the last call to captureStderr().
      Resets stdout to what it was before captureStderr() was invoked.
    scope<py>:
      /# TODO(wmh): Use self._stdout to test.
      cls = sys.stderr.__class__
      if cls is cStringIOClass or isinstance(sys.stderr, StringIO.StringIO):
        result = sys.stderr.getvalue()
      else:
        result = None
      sys.stderr = TestCase.STDERR
      self._stderr = None
      return result
    test<py>:
      /# noop, tested in test_captureStderr()
      pass
    end method getStderr;

    new specific
    method newMox params:
      multi var stubs : vec;
    comment:
      Return a new mox.Mox, optionally stubbing out various entities.
    scope<py>:
      /# TODO(wmh): EXPERIMENTAL. This is meant to act as a more concise
      /# and readable means of mocking out methods (and, perhaps,
      /# invoking with emulation). The goal is to be able to pass in
      /# objects, and from those objects, obtain the "container" and the
      /# "name" of the object within "container", which would then be passed
      /# to mox.StubOutWithMock.  However:
      /#   - I do not know how to obtain the module object within which
      /#     a class 'c' resides.  Note that 'c.__module__' returns the
      /#     *name* of the module, not the module object.
      /#   - I do not know how to obtain the class object within which
      /#     a static function 's' resides.  Note that 's.__class__' returns the
      /#     *name* of the class, not the class object.
      /#
      /# It is very possible this isn't the right solution to the problem of
      /# mox readability, but more exploration is warranted.

      m = mox.Mox()

      /# We stub out those methods (et.al.) specified in stubs.
      for item in stubs:
        if isinstance(item, tuple) and len(item) == 2:
          obj, name = item
        elif isinstance(item, (types.FunctionType, types.MethodType)):
          obj = item.im_class
          name = item.__name__
        else:
          raise Error('Unrecognized item %s' % item)
        logging.debug('Stubbing out %s within %s', name, obj)
        m.StubOutWithMock(obj, name)

      self._moxlist.append(m)
      return m
    test<py>:
      tc = self._tc
      self.assertEqual(0, len(tc._moxlist))

      /# Basic mox
      m1 = tc.newMox()
      self.assertEqual(1, len(tc._moxlist))
      m1.UnsetStubs()

      /# Another mox, this time with a stub.
      m2 = tc.newMox(tc.tmpFile)
      tc.tmpFile().AndReturn('blah')
      m2.ReplayAll()
      res = tc.tmpFile()
      self.assertEqual('blah', res)
      m2.VerifyAll()

      /# TODO(wmh): Add additional code for verifying static and
      /# class method stubs?

      /# Important to clean up tc here!
      tc.tearDown()
    end method newMox;

    new
    method newStr #:
      Create a new string stream for use anywhere a meta!istream or
      meta!ostream is required.
    params:
      var content : any = null;
    scope<py>:
      if content:
        result = cStringIO.StringIO(content)
      else:
        result = cStringIO.StringIO()
      return result
    scope<js>:
      throw new Error('TestCase.newStr() not yet implemented');
    end method newStr;

    new
    method fp #:
      Create a new string stream for use anywhere a meta!istream or
      meta!ostream is required.

      TODO(wmh): Decide which of 'newStr' or 'fp' to keep.
    params:
      var content : any = null;
    scope<py>:
      if content is None:
        result = cStringIO.StringIO()
      else:
        result = cStringIO.StringIO(content)
      return result
    test<py>:
      pass
    scope<js>:
      throw new Error('TestCase.fp() not yet implemented');
    end method fp;

    new
    method tmpFile #:
      Create a temporary file and return its path.
    params:
      var create : any = true;
    scope<py>:
      fd, tmpfile = tempfile.mkstemp()
      os.close(fd)
      self._tmpfiles.append(tmpfile)
      if not create:
        os.unlink(tmpfile)
      return tmpfile
    test<py>:
      self.assertEqual([], self._tc._tmpfiles)
      tmpfile = self._tc.tmpFile()
      self.assertEqual([tmpfile], self._tc._tmpfiles)
      self.assertTrue(os.path.exists(tmpfile))
      tmpfile2 = self._tc.tmpFile(create=False)
      self.assertEqual([tmpfile, tmpfile2], self._tc._tmpfiles)
      self.assertFalse(os.path.exists(tmpfile2))
      self._tc.tearDown()
      self.assertFalse(os.path.exists(tmpfile))
      self.assertFalse(os.path.exists(tmpfile2))
    scope<js>:
      throw new Error('TestCase.tmpFile() not yet implemented');
    end method tmpFile;

    new
    method tmpDir #:
      Create a temporary directory and return its path.
    params:
      var create : any = true;
    scope<py>:
      tmpdir = tempfile.mkdtemp()
      self._tmpdirs.append(tmpdir)
      if not create:
        os.rmdir(tmpdir)
      return tmpdir
    test<py>:
      self.assertEqual([], self._tc._tmpdirs)
      tmpdir = self._tc.tmpDir()
      self.assertEqual([tmpdir], self._tc._tmpdirs)
      self.assertTrue(os.path.exists(tmpdir))
      tmpdir2 = self._tc.tmpDir(create=False)
      self.assertEqual([tmpdir, tmpdir2], self._tc._tmpdirs)
      self.assertFalse(os.path.exists(tmpdir2))
      self._tc.tearDown()
      self.assertFalse(os.path.exists(tmpdir))
      self.assertFalse(os.path.exists(tmpdir2))
    scope<js>:
      throw new Error('TestCase.tmpDir() not yet implemented');
    end method tmpDir;

    new
    method fileContents #:
      Return the contents of a specified file.
    params:
      var path : any;
    scope<py>:
      if os.path.exists(path):
        fp = open(path, 'r')
        result = fp.read()
        fp.close()
      else:
        result = None
      return result
    test<py>:
      /# path = os.path.join(
      /#   os.path.dirname(__metafile__), './testdata/testing/cipherfile')
      path = meta.root.Object.Resource(
        'cipherfile', fqn='meta.testing.TestCase')
      self.assertEqual('aes-128-cbc\ntesting\n', self._tc.fileContents(path))
    scope<js>:
      throw new Error('TestCase.fileContents() not yet implemented');
    end method fileContents;

    new
    method isInteractive : bool #:
      Determine whether this TestCase is marked as supporting tests that
      require interactive responses from a user.
    scope<py>:
      return TestCase.Interactive
    test<py>:
      pass
    scope<js>:
      return meta.testing.TestCase.Interactive;
    end method isInteractive;

    new
    method allowNetwork : bool #:
      Determine whether this TestCase is marked s supporting tests that
      require network access.
    params:
      var guarding : any;
    scope<py>:
      result = os.getenv('ALLOW_NETWORK', '') == 'true'
      if not result:
        logging.info('NOT ' + guarding)
      return result
    scope<js>:
      throw new Error('TestCase.allowNetwork() not yet implemented');
    end method allowNetwork;

    new specific
    method setupSharedFilesystem #:
      Configure multiple modules to share the same fake filesystem.
    params:
      var modules : vec #:
        The modules to configure with the same fake filesystem.
      var path_specs : vec = null #:
        See SetupFilesystem for details.
    scope<py>:
      first_module = modules[0]
      fs = self.setupFilesystem(first_module, path_specs=path_specs)
      for module in modules[1:]:
        fs2 = self.setupFilesystem(
            module, path_specs=None, from_module=first_module)
        if fs2 is not fs:
          raise Error("Shared filesystem isn't being shared.")
      self._fs = fs
      return fs
    test<py>:
      tc = self._tc
      self.assertEqual(None, tc._fs)

      modules = [meta.testing, sys.modules[__name__]]
      tc.setupSharedFilesystem(
          modules, [('/a/b/c', {'contents': 'blah'})])

      fsinfo = tc._fsinfo
      self.assertEqual(
          ['__main__', 'meta.testing'],
          sorted(fsinfo.keys()))
      self.assertTrue(
        fsinfo['__main__']['objs'] is
        fsinfo['meta.testing']['objs'])
      self.assertNotEqual(None, tc._fs)
    end method setupSharedFilesystem;

    new specific
    method setupFilesystem : any #:
      Configure module so that it uses a fake filesystem.
      
      Raises:
        Error: if the method is called on a module multiple times.
        Error: if from_module is not None and has not been setup.
      Returns fake_filesystem.FakeFilesystem
    params:
      var module : any #:
        The module to configure.
      var path_specs : *vec = null #:
        The paths to create. Each element is either a string (path) or
        a two-tuple, with the first element being the path, and the second
        element being a dict of keyword args to send to 
        fake_filesystem.CreateFile().
      var from_module : any = null #:
        If specified, the faux filesystem objects are obtained from
        the given module, rather than being created anew.  This means
        that the same filesystem objects are shared across multiple
        modules (arguably the most sensible way to test things).
    scope<py>:
      mname = module.__name__
      fsinfo = self._fsinfo
      if mname in fsinfo:
        raise Error(
            'Attempt to setupFilesystem on %s when it is already setup' %
            mname)

      fsinfo[mname] = {'module': module, 'objs': {}}
      info = fsinfo[mname]

      if from_module:
        oname = from_module.__name__
        if oname not in fsinfo:
          raise Error(
              'Request to setup faux filesystem for module %s based on module %s'
              ' which has not been set up.' % (mname, oname))
        info['objs'] = fsinfo[oname]['objs']
        objs = info['objs']
        fs = objs['fs']
      else:
        fs = fake_filesystem.FakeFilesystem()
        objs = info['objs']
        objs['fs'] = fs
        objs['fcntl'] = FakeFcntl(fs)
        objs['open'] = fake_filesystem.FakeFileOpen(fs)
        objs['os'] = fake_filesystem.FakeOsModule(fs)

      module.open = objs['open']
      for modname in ('os', 'fcntl'):
        if hasattr(module, modname):
          self._stubs.Set(module, modname, objs[modname])
      if path_specs:
        self.populateFilesystem(fs, path_specs)
      return fs
    test<py>:
      tc = self._tc
      self.assertEqual({}, tc._fsinfo)
      tc.setupFilesystem(
          meta.testing,
          path_specs=[
              '/home/bob/file1',
              ('/home/bob/file2',
               {'contents': 'hello world\n', 'perms': 0640}),
              ('/home/bob/dir1', 'dir'),
              ('/home/bob/dir2', {'type': 'dir', 'perms': 0755}),
              ('/home/bob/link1',
               {'type': 'link', 'srcpath': '/home/bob/file1'}),
          ])

      /# Verify that tc._fsinfo has been augmented.
      self.assertEqual(
          ['meta.testing'],
          tc._fsinfo.keys())

      /# Basic test (more thorough testing in testPopulateFilesystem()).
      self.assertEqual(
          True, meta.testing.os.path.exists('/home/bob/file1'))
      stat_info = meta.testing.os.stat('/home/bob/file1')

      self.assertEqual(0, stat_info.st_size)
      self.assertEqual('100666', '%o' % stat_info.st_mode)
      self.assertEqual(None, tc._fs)
    end method setupFilesystem;

    new specific
    method populateFilesystem params:
      var fs : fake_filesystem.FakeFilesystem #:
        The filesystem to populate.
      var path_specs : vec #:
        The paths to create.  If any element is a two-tuple, the
        first element is the path, and the second element is a dict
        containing zero or more of these keys:
          type = str
            One of 'file', 'dir' or 'link'.  Default is 'file'.
          inode = int
            An inode for the file.  Ignored for 'link'.
          perms = int
            The stat.S_IF contant representing the file type.
          contents = str
            The entire contents of the file.
          contents_path = str
            A path to a file to use as the contents of this file.
          size = int
            The size of the file (only if contents or content_path
            are not specified).
          apply_umask = bool
            If True, apply current umask to st_mode
          srcpath = str
            Only valid if type == 'link', specifies the path to which
            the symlink points.
    comment:
      Create files within a fake filesystem.
      
      Raises:
        Error: if an illegal key is passed in path_specs subdata.
    scope<py>:
      for path_info in path_specs:
        /# path_info can be either:
        /#   a) a string (specifies a path to a file)
        /#   b) a two-tuple containing string (path of file) and string
        /#      (one of 'file', 'dir' or 'link', indicating the file type).
        /#   c) a two-tuple containing string (path of file) and dict
        /#      where the dict specifies various key/value pairs for
        /#      configuring the file.
        if isinstance(path_info, (list, tuple)):
          path, info = path_info
          if isinstance(info, dict):
            in_kwds = info
          else:
            in_kwds = {'type': info}
        else:
          path = path_info
          in_kwds = {}

        /# Verify that in_kwds contains only legal keys.
        legal_keys = set([
            'type', 'inode', 'perms', 'contents', 'contents_path', 'size',
            'apply_umask', 'srcpath'])
        for key in in_kwds:
          if key not in legal_keys:
            raise Error(
                "Invalid key '%s' passed to path_specs arg in populateFilesystem"
                % key)

        type_ = in_kwds.get('type', 'file')
        kwds = {}
        if type_ == 'file':
          /# Build up a kwds dict suitable for passing to
          /# fake_filesystem.FakeFilesystem.CreateFile()
          if 'perms' in in_kwds:
            kwds['st_mode'] = stat.S_IFREG | in_kwds['perms']
          if 'contents_path' in in_kwds:
            kwds['contents'] = self._readFile(in_kwds['contents_path'])
          elif 'contents' in in_kwds:
            kwds['contents'] = in_kwds['contents']
          if 'inode' in in_kwds:
            kwds['inode'] = in_kwds['inode']
          if 'apply_umask' in in_kwds:
            kwds['apply_umask'] = in_kwds['apply_umask']
          kwds['create_missing_dirs'] = True
          fs.CreateFile(path, **kwds)

        elif type_ == 'dir':
          /# Build up a kwds dict suitable for passing to
          /# fake_filesystem.FakeFilesystem.CreateDir()
          if 'perms' in in_kwds:
            kwds['perm_bits'] = in_kwds['perms']
          if 'inode' in in_kwds:
            kwds['inode'] = in_kwds
          fs.CreateDirectory(path, **kwds)

        elif type_ == 'link':
          /# Build up a kwds dict suitable for passing to
          /# fake_filesystem.FakeFilesystem.CreateLink()
          if 'srcpath' not in in_kwds:
            raise Error('Request to create a symlink without a src file')
          link_target = in_kwds['srcpath']
          fs.CreateLink(path, link_target)
        else:
          raise Error("Invalid file type '%s'" % type_)
    test<py>:
      tc = self._tc
      self.assertEqual({}, tc._fsinfo)

      if False:
        epath = os.path.join(
          os.path.dirname(__metafile__),
          './testdata/regexp/entry.mre')
        with open(epath, 'r') as fp:
          contents = fp.read()
      else:
        epath = meta.root.Object.Resource(
          'entry_mre', fqn='meta.testing.TestCase')
        /# print '**** HERE with epath=%s' % epath
        with open(epath, 'r') as fp:
          contents = fp.read()

      /# We mock out the single call to meta.testing.TestCase._ReadFile() which
      /# will be invoked for '/home/bob/file3'
      m = tc.newMox()
      m.StubOutWithMock(tc, '_readFile')
      tc._readFile(mox.IsA(str)).AndReturn(contents)
      m.ReplayAll()

      /# Calling SetupFilesystem() will call PopulateFileSystem(), and it is
      /# easier to test after fully initializing than to test in isolation.
      tc.setupFilesystem(
          meta.testing,
          path_specs=[
              '/home/bob/file1',
              ('/home/bob/file2',
               {'contents': 'hello world\n', 'perms': 0640}),
              ('/home/bob/dir1', 'dir'),
              ('/home/bob/dir2', {'type': 'dir', 'perms': 0755}),
              ('/home/bob/link1',
               {'type': 'link', 'srcpath': '/home/bob/file1'}),
              ('/home/bob/file3',
               {'contents_path': epath}),
          ])
      package = 'meta.testing'
      self.assertTrue(package in tc._fsinfo)
      self.assertTrue(meta.testing is tc._fsinfo[package]['module'])
      for k in ('fs', 'open', 'os', 'fcntl'):
        self.assertTrue(k in tc._fsinfo[package]['objs'])

      /# file1 is a file with no content.
      self.assertEqual(
          True, meta.testing.os.path.exists('/home/bob/file1'))
      stat_info = meta.testing.os.stat('/home/bob/file1')
      self.assertEqual(0, stat_info.st_size)
      self.assertEqual('100666', '%o' % stat_info.st_mode)

      /# file2 is a file with content.
      fp = meta.testing.open('/home/bob/file2', 'r')
      self.assertEqual('hello world\n', fp.read())
      fp.close()
      stat_info = meta.testing.os.stat('/home/bob/file2')
      self.assertEqual('100640', '%o' % stat_info.st_mode)

      /# dir1 is a directory with default permissions.
      self.assertEqual(
          True, meta.testing.os.path.isdir('/home/bob/dir1'))
      stat_info = meta.testing.os.stat('/home/bob/dir1')
      self.assertEqual('40777', '%o' % stat_info.st_mode)

      /# dir2 is a directory with specific permissions.
      self.assertEqual(
          True, meta.testing.os.path.isdir('/home/bob/dir2'))
      stat_info = meta.testing.os.stat('/home/bob/dir2')
      self.assertEqual('40755', '%o' % stat_info.st_mode)

      /# link1 is a symlink to file1
      stat_info = meta.testing.os.stat('/home/bob/link1')
      self.assertEqual('100666', '%o' % stat_info.st_mode)

      /# file3 has content initialized from a file.
      self.assertEqual(
          True, meta.testing.os.path.exists('/home/bob/file3'))
      stat_info = meta.testing.os.stat('/home/bob/file3')
      self.assertEqual(28, stat_info.st_size)
      self.assertEqual('100666', '%o' % stat_info.st_mode)

      m.VerifyAll()
    end method populateFilesystem;

    new specific
    method fakeFile : any params:
      var path : str #:
        The path to the file.
    comment:
      Obtain a fakefile instance.
      
      Raises:
        Error: If one invokes this method without first invoking
               SetupSharedFilesystem().
      Returns fake_filesystem.FakeFile
    scope<py>:
      if not self._fs:
        raise Error(
            'Attempt to invoke FakeFile() without first invoking '
            'SetupSharedFilesystem()')
      return self._fs.GetObject(path)
    test<py>:
      tc = self._tc

      /# If we don't first call SetupSharedFilesystem, FakeFile() is an error.
      self.assertRaises(meta.testing.Error, tc.fakeFile, '/any/path')

      fs = tc.setupSharedFilesystem(
          [meta.testing], [('/a/b/c', {'contents': 'blah'})])
      fake = tc.fakeFile('/a/b/c')
      self.assertTrue(isinstance(fake, fake_filesystem.FakeFile))
      self.assertEqual('blah', fake.contents)
    end method fakeFile;

    new specific
    method fakeFileExists : bool params:
      var path : str #:
        The path to the file.
    comment:
      Determine if a fake file exists.
      Returns bool
    scope<py>:
      return self._fs.Exists(path)
    test<py>:
      pass
    end method fakeFileExists;

    new specific
    method fakeContents : str params:
      var path : str #:
        The path to the file.
    comment:
      Obtain the contents of a fake file.
      
      Raises:
        Error: If one invokes this method without first invoking
               SetupSharedFilesystem().
      Returns str (file contents)
    scope<py>:
      return self.fakeFile(path).contents
    test<py>:
      tc = self._tc

      /# If we don't first call SetupSharedFilesystem, FakeContent() is an error.
      self.assertRaises(meta.testing.Error, tc.fakeContents, '/any/path')

      fs = tc.setupSharedFilesystem(
          [meta.testing], [('/a/b/c', {'contents': 'blah'})])
      self.assertEqual('blah', tc.fakeContents('/a/b/c'))
    end method fakeContents;

    new specific
    method _readFile : str params:
      var filename : str #:
        The path to the file.
    comment:
      Obtain contents of a file.
      Returns str
    scope<py>:
      with open(filename, 'r') as fp:
        contents = fp.read()
      return contents
    test<py>:
      pass
    end method _readFile;
 
    new specific
    method revertFilesystem #:
      Undo all stubs to create a faux filesystem.
    params:
      var module : any;
    scope<py>:
      fsinfo = self._fsinfo
      mname = module.__name__
      if mname not in fsinfo:
        raise Error(
            'Attempt to revert filesystem for %s when no filesystem set up'
            % mname)
      del module.open
      del fsinfo[mname]
    test<py>:
      tc = self._tc
      mname = meta.testing.__name__
      self.assertFalse(mname in tc._fsinfo)
      unused_fs = tc.setupFilesystem(meta.testing)
      self.assertTrue(mname in tc._fsinfo)
      tc.revertFilesystem(meta.testing)
      self.assertFalse(mname in tc._fsinfo)
    end method revertFilesystem;

    method assertDictContains params:
      var data : map;
      var subdata : map;
    scope<py>:
      for k, v in subdata.iteritems():
        if k not in data:
          self.fail('Failed to find %s in dict' % k)
        elif data[k] != v:
          self.fail('%s = %s != %s' % (k, data[k], v))
    scope<js>:
      throw new Error('TestCase.assertDictContains() not yet implemented');
    scope<*>:
      remark #:
        keyval iterate over subdata into (k,v) scope:
          expr switch scope:
            case [k not in data] scope:
              @self.fail('Failed to find ${k} in dict');
            case [data[k] != v] scope:
              @self.fail('${k} = ${data[k]} != ${v}');

        iterate subdata (k,v) scope:
          expr switch scope:
            case [k not in data] scope:
              @self.fail('Failed to find ${k} in dict');
            case [data[k] != v] scope:
              @self.fail('${k} = ${data[k]} != ${v}');
            
    end method assertDictContains;

    method startswith params:
      var prefix : str;
      var strval : str;
    scope<py>:
      self.assertTrue(
        strval.startswith(prefix),
        'String\n  "%s"\ndoes not start with\n  "%s"' % (strval, prefix))
    test<py>:
      pass
    scope<js>:
      assertTrue(
        'String\n  \"' + strval + '\"\ndoes not start with\n  \"' + prefix + '\"',
        strval.startsWith(/** @type {!string} */ (prefix)));
    end method startswith;

    method endswith params:
      var suffix : str;
      var strval : str;
    scope<py>:
      self.assertTrue(
        strval.endswith(suffix),
        'String\n  "%s"\ndoes not end with\n  "%s"' % (strval, suffix))
    scope<js>:
      assertTrue(
        'String\n  \"' + strval + '\"\ndoes not end with\n  \"' + suffix + '\"',
        strval.endsWith(/** @type {!string} */ (suffix)));
    end method endswith;

    method contains params:
      var member : any;
      var container : any;
      var msg : str = null;
    scope<py>:
      self.assertIn(member, container, msg=msg);
    scope<js>:
      if (msg) {
        assertContains(msg, member, container);
      } else {
        assertContains(member, container);
      }
    end method contains;

    method matches #:
      A string value matches a regexp. 
    params:
      var restr : str #:
        The regexp to match against (as a string).
      var value : str #:
        The value to match.
    scope<py>:
      m = re.match(restr, value)
      if not m:
        self.fail('Expected match failed:\n  %s\n  %s' % (restr, value))
    scope<js>:
      console.log('Fix TestCase.matches in Javascript');
    end method matches;

    method iseq params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s != %s' % (str(expected), str(item))
      self.assertEqual(expected, item, message)
    scope<js>:
      if (message == null) {
        assertEquals(expected, item);
      } else {
        assertEquals(message, expected, item);
      }
    end method iseq;

    method noteq params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s == %s' % (str(expected), str(item))
      self.assertNotEqual(expected, item, message)
    scope<js>:
      if (message == null) {
        assertNotEquals(expected, item);
      } else {
        assertNotEquals(message, expected, item);
      }
    end method noteq;

    method iseqvec params:
      var expected : vec;
      var items : vec;
      var message : str = null;
    scope<py>:
      self.assertListEqual(expected, items, message)
    scope<js>:
      if (message == null) {
        assertElementsEquals(expected, items);
      } else {
        assertElementsEquals(message, expected, items);
      }
    end method iseqvec;

    method iseqmap params:
      var expected : any;
      var data : any;
      var msg : any = null;
      var width : int = 30;
    scope<py>:
      if expected != data:
        if msg is None:
          msg = '%s != %s' % (expected, data)

        def Trunc(val, width):
          val = str(val)
          if len(val) > width:
            val = val[:width - 1] + '$'
          return val

        form = '%%-10s %%-2s %%-%ds %%-%ds' % (width, width)
        notes = []
        for k in sorted(set(expected.keys() + data.keys())):
          expval = expected[k] if k in expected else '---'
          dval = data[k] if k in data else '---'
          sign = '  ' if (expval == dval) else '!='
          notes.append(
            form % (
              Trunc(k, 10),
              sign,
              Trunc(expval, width + 2),
              Trunc(dval, width + 2)))
        self.fail(msg + '\n' + '\n'.join(notes))
    scope<js>:
      if (msg) {
        assertHashEquals(msg, expected, data);
      } else {
        assertHashEquals(expected, data);
      }
    end method iseqmap;

    method iseqtext params:
      multi var args : vec;
      multi var kwds : map;
    scope<py>:
      self.assertMultiLineEqual(*args, **kwds)
    end method iseqtext;

    method iseqfile params:
      var file1 : any;
      var file2 : any;
    scope<py>:
      info = os.system('diff %s %s' % (file1, file2))
      signum = info & 0xff
      status = info >> 8
      self.assertTrue(
        status == 0, 'Files %s and %s differ' % (file1, file2))
    scope<js>:
      throw new Error('TestCase.() not yet implemented');
    end method iseqfile;

    method iseqstrgold params:
      var content : any;
      var golden : any;
    scope<py>:
      if self.WriteGoldens:
        with open(golden, 'w') as fp:
          fp.write(content)
        print 'Wrote %d bytes to golden %s' % (len(content), golden)
      else:
        if True:
          with open(golden, 'r') as fp:
            content2 = fp.read()
            self.assertMultiLineEqual(content, content2)
        else:
          fd, tmpfile = tempfile.mkstemp()
          os.write(fd, content)
          os.close(fd)
          self.iseqfile(golden, tmpfile)
          os.unlink(tmpfile)
    scope<js>:
      throw new Error('TestCase.() not yet implemented');
    end method iseqstrgold;

    method iseqfilegold params:
      var path : any;
      var golden : any;
    scope<py>:
      if self.WriteGoldens:
        shutil.copyfile(path, golden)
        print 'Copied %s to %s' % (path, golden)
      else:
        self.iseqfile(golden, path)
    scope<js>:
      throw new Error('TestCase.() not yet implemented');
    end method iseqfilegold;

    method isapprox #:
      Compare two float values for closeness.
    params:
      var f1 : any;
      var f2 : any;
      var delta : any = 0.00001;
      var msg : str = null;
    scope<py>:
      self.assertAlmostEqual(f1, f2, delta=delta, msg=msg)
    scope<js>:
      if (msg) {
        assertRoughlyEquals(msg, f1, f2, delta);
      } else {
        assertRoughlyEquals(f1, f2, delta);
      }
    end method isapprox;

    method islt params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s >= %s' % (str(expected), str(item))
      self.assertLess(expected, item, message)
    scope<js>:
      if (message == null) {
        message = '' + expected + ' >= ' + item
      }
      assertTrue(message, expected < item);
    end method islt;

    method isle params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s > %s' % (str(expected), str(item))
      self.assertLessEqual(expected, item, message)
    scope<js>:
      if (message == null) {
        message = '' + expected + ' > ' + item
      }
      assertTrue(message, expected <= item);
    end method isle;

    method isgt params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s <= %s' % (str(expected), str(item))
      self.assertGreater(expected, item, message)
    scope<js>:
      if (message == null) {
        message = '' + expected + ' <= ' + item
      }
      assertTrue(message, expected > item);
    end method isgt;

    method isge params:
      var expected : any;
      var item : any;
      var message : any = null;
    scope<py>:
      if message is None:
        message = '%s < %s' % (str(expected), str(item))
      self.assertGreaterEqual(expected, item, message)
    scope<js>:
      if (message == null) {
        message = '' + expected + ' < ' + item
      }
      assertTrue(message, expected >= item);
    end method isge;

    method raises #:
      Confirm that the given method raises an exception.

      Note that the python version accepts arbitrary positional and
      keyword args while the javascript version does not. Need to get 
      varargs supported in javascript before we can try implementing it.
    params:
      var func : any #:
        The executable to invoke (with args and kwds).
      multi var args : vec;
      multi var kwds : map;
    scope<py>:
      self.assertRaises(func, *args, **kwds)
    scope<js>:
      /# TODO(wmh): Fix me.
      /# assertThrows(func);
    end method raises;

    method issame params:
      var obj1 : any;
      var obj2 : any;
    scope<py>:
      self.assertTrue(obj1 is obj2, "%s is not %s" % (repr(obj1), repr(obj2)))
    scope<js>:
      assertTrue(obj1 + ' is not ' + obj2, obj1 === obj2);
    end method issame;

    method notsame params:
      var obj1 : any;
      var obj2 : any;
    scope<py>:
      self.assertFalse(obj1 is obj2, "%s is %s" % (repr(obj1), repr(obj2)))
    scope<js>:
      assertFalse(obj1 + ' is ' + obj2, obj1 === obj2);
    end method notsame;

    method istrue #:
      Note that we cannot use 'true' as a method because that is reserved in
      various languages (and we want a common interface across all languages).
    params:
      var val : bool;
      var msg : str = null;
    scope<py>:
      self.assertTrue(val, msg)
    scope<js>:
      if (msg == null) {
        assertTrue(val);
      } else {
        assertTrue(msg, val);
      }
    end method istrue;

    method isfalse #:
      Note that we cannot use 'false' as a method because that is reserved in
      various languages (and we want a common interface across all languages).
    params:
      var val : bool;
      var msg : str = null;
    scope<py>:
      self.assertFalse(val, msg)
    scope<js>:
      if (msg) {
        assertFalse(msg, val);
      } else {
        assertFalse(val);
      }
    end method isfalse;

    method isnull #:
      Confirm the arg is null.
    params:
      var val : any;
      var msg : str = null;
    scope<py>:
      self.assertIsNone(val, msg)
    scope<js>:
      if (msg) {
        assertNull(msg, val);
      } else {
        assertNull(val);
      }
    end method isnull;

    method notnull #:
      Confirm the arg is not null.
    params:
      var val : any;
      var msg : str = null;
    scope<py>:
      self.assertIsNotNone(val, msg)
    scope<js>:
      if (msg) {
        assertNotNull(msg, val);
      } else {
        assertNotNull(val);
      }
    end method notnull;

    method isinst params:
      var obj : any #:
        The object to test.
      var cls : any #:
        The class the object is expected to be an instance of.
        In javascript, this is the constructor function.
    scope<py>:
      self.istrue(
        isinstance(obj, cls),
        'Expecting %s to be an instance of %s' % (obj, cls))
    scope<js>:
      this.istrue(
        typeof obj == cls,
        'Expecting ' + obj + ' to be an instance of ' + cls);
    end method isinst;

    method fail #:
      # Invoked to indicate an unconditional failure.
    params:
      var msg : str;
    scope<js>:
      this.istrue(false, msg);
    scope<py>:
      super(TestCase, self).fail(msg);
    end;

    new specific
    method run #:
      Execute this test case.

      Meta:suppress: constantProperty
    params:
      var restr : str = null #:
        A regexp string. Only methods matching this regexp are considered when
        looking for test methods to register.
    scope<js>:
      this.log('Starting run');
      var location = goog.global.location;
      this.log('location = ' + location);
      if (restr) {
        this.log('restr = ' + restr);
      }
      /# To parallel the junit mechanisms used in Java, Python, etc, in
      /# Meta<Javascript> we define a subclass <C>Test of goog.testing.TestCase
      /# for every user-defined class <C>, and implement one or more test
      /# methods for each method defined on <C> within that <C>Test.
      /#
      /# The javascript closure environment uses
      /#   goog.testing.TestCase.setTestObj()
      /# to specify the object to search for test methods (e.g. methods
      /# starting with 'test' and the special 'setUp[Page]' and 'tearDown[Page]'
      /# method).
      /#
      /# For Meta<Javascript> the object containing the test methods is the
      /# TestCase instance invoking the 'run' method. Rather than invoking
      /# goog.testing.TestCase.setTestObj(), we provide a new version locally
      /# named 'registerTests()'.  It is very similar to setTestObj(), but
      /# provides the ability to limit the set of methods registered based
      /# on a regexp.
      //goog.testing.jsunit.AUTO_RUN_ONLOAD = false;  // disable onload handler
      this.jsunit();
      this.setTestObj(this, restr);
      /** @type {!goog.testing.TestRunner} */var gTestRunner = goog.global['G_testRunner'];
      gTestRunner.setStrict(false);  // allow testsuites with zero tests.
      goog.testing.TestCase.initializeTestRunner(this);
      gTestRunner.execute();
      this.deblog('Finishing run');
    end method run;

    new specific
    method jsunit #:
      A Meta-specific replacement for goog.testing.jsunit.

      See discussion in TestCase comment for details.

      Meta:suppress: reportUnknownTypes
    scope<js>:
      this.deblog('Starting jsunit()');
      var thisTestCase = this;

      /# NOTE: While experimenting with the best way to set up TestCase for
      /# javascript, the code can run in two versions.  If this.useold() is
      /# true, the code uses the normal javascript testing idiom as much
      /# as possible.  If useold() is false, it means we can use new and
      /# improved implementations where relevant.
      /#
      /# For most methods, it is a simple matter of invoking the parent
      /# version of the method if useold(), and providing a new implementation
      /# if useold() is false.  But for jsunit, this isn't possible because
      /# the code is executed via goog.require('goog.testing.jsunit'), which
      /# is unappealing magically.
      /#
      /# This method is a faithful representation of what happens in
      /# goog.testing.jsunit ... divergences from the default implementation
      /# are guarded by this.useold() == false.

      /# Base path for JsUnit app files, relative to Closure's base path.
      /** @type {string} */ var BASE_PATH = '../../third_party/java/jsunit/core/app/';

      /# Filename for the core JS Unit script.
      /** @type {string} */ var CORE_SCRIPT = BASE_PATH + 'jsUnitCore.js';

      /# If this code is being parsed by JsTestC, we let it disable
      /# the onload handler to avoid running the test in JsTestC.
      /** @type {boolean} */ var AUTO_RUN_ONLOAD = true;

      /# Sets a delay in milliseconds after the window onload event
      /# and running the tests. Used to prevent interference with
      /# Selenium and give tests with asynchronous operations time to
      /# finish loading.
      /** @type {number} */ var AUTO_RUN_DELAY_IN_MS = 500;

      /# Only allow one global test runner to be created on a page.
      if (goog.global['G_testRunner'] instanceof goog.testing.TestRunner) {
        /# This can happen, for example, if the test code has goog.requried
        /# goog.testing.jsunit, which performs this same functionality. 
        /# The hope is that we can avoid using goog.testing.jsunit in faavor
        /# of this method, which gives more insight and control over what
        /# happens and allows us to implement additional features.
        console.log(
          'WARNING: G_testRunner initialized ... verify goog.testing.jsunit ' +
          'is NOT being goog.required');
        return;
      }

      /# Increases the maximum number of stack frames in Google Chrome from the
      /# default 10 to 50 to get more useful stack traces.
      Error.stackTraceLimit = 50;

      /# Store a reference to the window's timeout so that it can't be overridden
      /# by tests.
      /** @type {!Function} */ var realTimeout = window.setTimeout;

      /# Check for JsUnit's test runner (need to check for >2.2 and <=2.2)
      if (top['JsUnitTestManager'] || top['jsUnitTestManager']) {
        /# Running inside JsUnit so add support code.
        var path = goog.basePath + CORE_SCRIPT;
        document.write(
            '<script type="text/javascript" src="' + path + '"></' +
            'script>');
        this.deblog('Instrumented document with javascript ' + path);

      } else {
        /# Create a test runner.
        var tr = new goog.testing.TestRunner();
        this.deblog('Created new TestRunner');

        /# Export it so that it can be queried by Selenium and tests that use a
        /# compiled test runner.
        goog.exportSymbol('G_testRunner', tr);
        goog.exportSymbol('G_testRunner.initialize', tr.initialize);
        goog.exportSymbol('G_testRunner.isInitialized', tr.isInitialized);
        goog.exportSymbol('G_testRunner.isFinished', tr.isFinished);
        goog.exportSymbol('G_testRunner.isSuccess', tr.isSuccess);
        goog.exportSymbol('G_testRunner.getReport', tr.getReport);
        goog.exportSymbol('G_testRunner.getRunTime', tr.getRunTime);
        goog.exportSymbol('G_testRunner.getNumFilesLoaded', tr.getNumFilesLoaded);
        goog.exportSymbol('G_testRunner.setStrict', tr.setStrict);
        goog.exportSymbol('G_testRunner.logTestFailure', tr.logTestFailure);
        goog.exportSymbol('G_testRunner.getTestResults', tr.getTestResults);

        /# Export debug as a global function for JSUnit compatibility.  This just
        /# calls log on the current test case.
        if (!goog.global['debug']) {
          goog.exportSymbol('debug', goog.bind(tr.log, tr));
        }

        /# If the application has defined a global error filter, set it now.  This
        /# allows users who use a base test include to set the error filter before
        /# the testing code is loaded.
        if (goog.global['G_errorFilter']) {
          tr.setErrorFilter(goog.global['G_errorFilter']);
        }

        /# Add an error handler to report errors that may occur during
        /# initialization of the page.
        var onerror = window.onerror;

        /**
         * An error handler to report errors that may occur during
         * initialization of the page.
         * @param {!string} error
         * @param {!string} url
         *   The url ... ?
         * @param {!number} line
         *   The line number (or is this the line text??)
         */
        window.onerror = function(error, url, line) {
          /# Call any existing onerror handlers.
          if (onerror) {
            onerror(error, url, line);
          }
          if (typeof error == 'object') {
            /# Webkit started passing an event object as the only argument to
            /# window.onerror.  It doesn't contain an error message, url or line
            /# number.  We therefore log as much info as we can.
            if (error.target && error.target.tagName == 'SCRIPT') {
              tr.logError('UNKNOWN ERROR: Script ' + error.target.src);
            } else {
              tr.logError('UNKNOWN ERROR: No error information available.');
            }
          } else {
            tr.logError('JS ERROR: ' + error + '\nURL: ' + url + '\nLine: ' + line);
          }
        };

        if (this.useold()) {
          /# This is the original code ... not needed for Meta<javascript>.

          /# Create an onload handler, if the test runner hasn't been
          /# initialized then no test has been registered with the test runner
          /# by the test file. We then create a new test case and auto discover
          /# any tests in the global scope. If this code is being parsed by
          /# JsTestC, we let it disable the onload handler to avoid running the
          /# test in JsTestC.
          if (AUTO_RUN_ONLOAD) {
            this.deblog('Setting up window.onload');
            var onload = window.onload;
            /**
             * An onload handler.
             * @param {?Event} e
             */
            window.onload = function(e) {
              /# Call any existing onload handlers.
              if (onload) {
                onload(e);
              }
              /# Wait so that we don't interfere with WebDriver.
              realTimeout(function() {
                if (!tr.initialized) {
                  thisTestCase.deblog('Initializing test runner');
                  var testCase = new goog.testing.TestCase(document.title);
                  goog.testing.TestCase.initializeTestRunner(testCase);
                }
                thisTestCase.deblog('Executing test runner');
                tr.execute();
              }, AUTO_RUN_DELAY_IN_MS);
              window.onload = null;
            };
          }
        } else {
          /# We do not need the onload handler for Meta<javascript>.
          this.deblog('NOT creating onload handler in jsunit');
        }
      }
      this.deblog('Finishing jsunit()');
    end method jsunit;

    override specific
    method setTestObj #:
      Add specified tests to the TestCase.

      Meta:suppress: accessControls
    params<js>:
      var obj : ^Object = null #:
        The object to search for test and lifecycle methods.  If not specified,
        'this' is assumed.
      var restr : str = null #:
        A regexp string. Only test methods (e.g. methods starting with 'test')
        whose names subsequently match this regexp will be added.
    scope<js>:
      if (obj == null) { obj = this; }
      this.deblog('Starting setTestObj with ' + obj);

      if (this.useold()) {
        /# Use original code.
        this.deblog('  Using original code');
        goog.testing.TestCase.prototype.setTestObj.call(this, obj);
      } else {
        /# Drop any previously added (likely auto-discovered) tests, only one
        /# source of discovered test and life-cycle methods is allowed.
        var tests = this.getTests();
        goog.asserts.assert(
            tests.length == 0, 'Test methods have already been configured.');

        /# Establish the regexp to use for identifying desired test methods.
        var fullrestr = '^' + this.getAutoDiscoveryPrefix();
        if (restr) {
          if (restr[0] == '^') {
            restr = restr.substring(1);
          }
          fullrestr += '.*' + restr;
        }
        var regex = new RegExp(fullrestr);

        /# Register all the test methods matching regex.
        for (var name in obj) {
          if (regex.test(name)) {
            /** @type {function(...*)} */ var testMethod = obj[name];
            if (goog.isFunction(testMethod)) {
              this.addNewTest(name, testMethod, obj);
              /# console.log('Adding test ' + name);
            }
          }
        }

        /# This code (copied from goog.testing.TestCase.setTestObj) is probably
        /# unnecessary in this implementation.
        /# TODO(wmh): Delete it?  Seems to work fine without it.
        if (obj['getTestName']) {
          var gtn = /** @type {function():string} */ (obj['getTestName']);
          this.name_ = gtn();
        }

        /# NOTE: The autoDiscoverLifecycle method looks for certain methods
        /# defined on 'obj' and replaces the definitions of those methods
        /# within 'this' with the implementation from 'obj'.  Note that when
        /# 'obj' == 'this', this method is a noop.
        if ((this === obj) && (!this.useold())) {
          this.deblog('Avoiding unnecessary call to autoDiscoverLifecycle');
        } else {
          this.autoDiscoverLifecycle(obj);
        }
      }

      this.deblog('Finishing setTestObj');
    end method setTestObj;

    specific postx
    method setTestsToRun #:
      Extends parent definition.
    params:
      var tests : *map<@str,bool> #:
        The set of tests to run.  Entries in the set may be test names,
        like 'testFoo', or numeric indices. Only those tests identified by
        the names/indices specified will be executed.
    super (tests)
    scope<js>:
      this.deblog('In setTestsToRun:');
      for (var key in tests) {
        this.deblog(key);
      }
    end method setTestsToRun;

    specific override
    method autoDiscoverTests #:
      We override goog.testing.TestCase.autoDiscoverTests() with our own
      implementation so we hve control over various things.

      Note the the code in goog.testing.testcase.js around auto discovery is a
      bit muddled. Both setTestObj(obj) and autoDiscoverTests() perform auto
      detection of test methods (e.g. methods starting with 'test'), and both
      invoke autoDiscoverLifecycle() to detect setUp(), tearDown(), etc. And
      yet both methods get invoked during normal control flow:
        - goog.require('goog.testing.jsunit')
           - G_testRunner obtained
           - window.onerror handler created
           - window.onload handle created that:
              - initializes ...

      Meta:suppress: reportUnknownTypes, visibility
    scope<js>:
      this.deblog('Starting autoDiscoverTests');
      if (this.useold()) {
        /# We just use the parent definition.
        this.deblog('  Using parent definition');
        goog.testing.TestCase.prototype.autoDiscoverTests.call(this);

      } else {
        /# We provide our own definition
        var prefix = this.getAutoDiscoveryPrefix();
        var testSources = this.getGlobals(prefix);

        var foundTests = [];

        for (var i = 0; i < testSources.length; i++) {
          var testSource = testSources[i];
          for (var name in testSource) {
            if ((new RegExp('^' + prefix)).test(name)) {
              var ref;
              try {
                ref = testSource[name];
              } catch (ex) {
                /# NOTE(brenneman): When running tests from a file:// URL on Firefox
                /# 3.5 for Windows, any reference to goog.global.sessionStorage raises
                /# an "Operation is not supported" exception. Ignore any exceptions
                /# raised by simply accessing global properties.
                ref = undefined;
              }

              if (goog.isFunction(ref)) {
                foundTests.push(this.createTestFromAutoDiscoveredFunction(name, ref));
              }
            }
          }
        }

        for (var i = 0; i < foundTests.length; i++) {
          this.add(foundTests[i]);
        }
        this.orderTests_();

        this.deblog(this.getCount() + ' tests auto-discovered');

        /# The code for goog.testing.TestCase.autoDiscoverLifecycle notes:
        /#   TODO(user): Do this as a separate call. Unfortunately, a lot of
        /#   projects currently override autoDiscoverTests and expect lifecycle
        /#   events to be registered as a part of this call.
        /# We are not constrained by legacy usecases in Meta, so we can remove
        /# this here and call it separately where needed.  And since the
        /# test object is what is being run, autoDiscoverLifecycle() would
        /# just be copying methods from this into this, so it is a noop
        /# twice-over.
        /#### this.autoDiscoverLifecycle();
      }
      this.deblog('Finished autoDiscoverTests');
    end method autoDiscoverTests;

    prex specific
    method autoDiscoverLifecycle #:
      Add a bit of functionality to parent definition.
    scope<js>:
      this.deblog('In autoDiscoverLifecycle');
    end method autoDiscoverLifecycle;

  end class TestCase;  

  native _ scope<py>:
    def main():
      import os
      tsd = os.getenv('TEST_SRCDIR', None)
      if tsd is None:
        /# This code is NOT being executed via bazel.  In order to ensure that
        /# meta.root.Object.Resource() works properly we set an envvar that
        /# can be used to determine that we are running unittest code but
        /# not in bazel.
        os.environ['IN_UNITTEST'] = 'true'
      else:
        /# This code IS being executed via bazel
        pass
      unittest.main()
  end native;

end namespace metax.test;
