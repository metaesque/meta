namespace metax.root #:
  The top-level classes that Meta provides.
scope:

  meta  
  class ObjectMetaRoot #:
    The root of the metaclass hierarchy in Meta. 

    There are two ways we can handle the interaction between metaclasses
    in Meta and those in the baselang:
      1) The meta-level metaclass is-a baselang-provided metaclass
      2) The meta-level metaclass has-a baselang-provided metaclass
    See ../../README.md for details. Currently implementing variant #1.
  parent<py> ^type
  parent<js> ^Object
  parent<cc> void
  assocs<cc>:
    std assoc string;
    std assoc vector;
    std assoc map;
  scope:

    field metaname : @str #:
      The name of the class being represented by this metaclass.
      TODO(wmh): This field is not needed in python ... need a way to
      have 'specific' fields. But we do want to define metaname() to return
      the name as stored in the type metaclass.
      TODO(wmh): This should be a readonly field, so no setter or reffer.

    field metabases : @vec<class> #:
      The parent classes of the class.
      TODO(wmh): This field is not needed in python ... need a way to
      have 'specific' fields.  But we do want to define metabases() to return
      the bases as stored in the type metaclass.
      TODO(wmh): This should be a readonly field, so no setter or reffer.

    field metasymbols : @map #:
      The symbols available within the class.
      TODO(wmh): This field is not needed in python ... need a way to
      have 'specific' fields.  But we do want to define metasymbols() to return
      the symbols as stored in the type metaclass.
      TODO(wmh): This should be a readonly field, so no setter or reffer.

    lifecycle #:
      Every user-defined class has an auto-generated metaclass created for it,
      and that metaclass inherits (eventually) from this class.  The meta
      compiler implicitly inserts a params: block in meta class initializers
      (if users define a meta-level lifecycle construct, they should not
      specify params:, as that will be an error).

      This signature is currently motivated by the signature of metaclasses in
      Python. As additional baselangs are added to Meta, we may need to
      generalize this implicit signature. Note that Javascript and C++ do not
      have metaclasses, so we are not constrained by these baselangs). But when
      we add in support for Java, we will need to establish whether
      java.lang.Class can be subclassed (or whether metax.root.ObjectMeta will
      need to act as a wrapper around a java.lang.Class instance) and how that
      influences this signature.
    params:
      var name : &str #:
        The name of the class being created
      var bases : &vec<class> #:
        The parent classes of the class (instances of metaclasses)
      var symbols : &map #:
        The symbols available within the class.
    super<py> (name, bases, symbols)
    scope<py>:
    scope<js>:
      this.metanameIs(name);
      this.metabasesIs(bases);
      this.metasymbolsIs(symbols);
    scope<cc>:
      this->metanameIs(name);
      this->metabasesIs(bases);
      this->metasymbolsIs(symbols);
    end lifecycle;

  end class ObjectMetaRoot;

  class Object #:
    Except in special circumstances, every class defined within Meta inherits
    from this class. Every base language provides a specialized implementation
    that defines functionality useful in implementing Meta-level semantics
    within that base language. Some of the methods defined here are present in
    all languages, some are only present in a subset of languages or in just one
    language.

    This class does NOT introduce any instance-level state, but does define
    a significant amount of instance-level and meta-level functionality
    available to every subclass intance and subclass respectively.

    Note that the metaparent of this class is always ObjectMetaRoot. Any
    class that inherits from Object will have a metaclass that inherits
    from ObjectMetaRoot.  Any user-defined meta class by default inherits
    from ObjectMetaRoot (semantics implemented in
    metax.c.ClassConstruct.metaClassInfo().

    Meta:suppress: JSC_UNKNOWN_EXPR_TYPE
  parent<py> ^object
  parent<js> ^Object
  parent<cc> void
  metaparent metax.root.ObjectMetaRoot
  assocs<cc>:
    cls assoc metax.root.ObjectMetaRoot;
  scope:

    user
    lifecycle #:
      Do NOT introduce any instance-level state here.
    scope:
    end lifecycle;            

    remark hidden #:
      We are currently disabling the test class for Object because it adds to
      the complexity of bootstrapping javascript. Consider reinstating these.

      raw test field obj : metax.root.Object;

      test 
      lifecycle #:
        A test lifecycle that creates an Object instance.
      setup<py>:
        test.obj = metax.root.Object()
      setup<js>:
        test.obj = new metax.root.Object();
      end;

      test method test_generic
      scope<py>:
        print 'here with %s' % test.obj
      scope<js>:
        console.log('here with ' + test.obj);
      end;
    end remark hidden;

  end class Object;

  nometa
  class Error #:
    The exception hierarchy is documented in the following places:
      python: https://docs.python.org/2/library/exceptions.html
      javascript: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error
  parent<py> ^Exception
  parent<js> ^Error
  parent<cc> ^std.runtime_error
  assocs<cc>:
    cls assoc ObjectMetaRoot;
    std assoc exception;
  scope:
  end class Error;

end namespace metax.root;

