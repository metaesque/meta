MetaLanguage family name Family parent meta toplevel <family> #:
  The constructs in Meta(Family).
config:

  abstract
  Construct _familyroot_ clsname FamilyRootConstruct #:
    All constructs in Meta(Family) inherit from this abstract construct,
    so the Attribute definitions here are available in subconstructs.
    However, note that the existence of an Attribute here does NOT mean it
    is automatically included in the subconstruct ... the subconstruct
    must specify the primary attribute (and any customization of other
    values).
  config:
    
    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      An arbitrary multi-line comment used to describe the purpose of the
      construct.

    secondary
    Attribute config: : complex = <empty> children <Construct> #:
      The complex block within which Construct/Attribute instances can be
      modified.

    secondary
    Attribute scope: : complex = <empty> aliases <::> #:
      The collection of subconstructs.

  scope:
  end Construct _familyroot_;

  Construct family < _familyroot_ #:
    Each family is defined by a family construct.
  assocs:
    cls assoc wmh.family.Person;
  config:

    primary
    Attribute family : word = <required> #:
      A unique identifier for the family

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <person|mating>;

  expand:
    env = wmh.family.Env.Instance
    if env is None:
      raise Error('wmh.family.Env.Instance not initialized')
    self.envIs(env)
    for child in self.attrval('scope:'):
      child.expandMeta()
  translate:
  scope:

    field env : Env;

  end Construct family;

  Construct person < _familyroot_ #:
    A person within a family.
  assocs:
    cls assoc wmh.family.Person;
    cls assoc wmh.date.Date;
  config:

    feature
    Attribute gender : <female|male|trans|nongendered> = nongendered #:
      The gender of the character.

    primary
    Attribute person : word = <required> #:
      The name of the person, with given and surname separated by '@' and
      any spaces replaced with '_'.

    secondary 
    Attribute cid : word = <empty> #:
      An explicit cid, rather than using a heuristic on id().
      IMPORTANT: When 'replacer' semantics in implemented in meta2, this should
      be changed ... cid should be an implicit primary, and a secondary
      attribute 'name' should have 'replacer' semantics. Thus,
         character Lisa@Z age 28y;
      would mean
         character __Meta1__ name Lisa@Z age 28y;
      (with implicit cid lisa_z), while
         character lisa name Lisa@Z age 28y;
      would explicitly specify the id ('lisa') and name ('Lisa@Z').

    secondary 
    Attribute alias : str = <empty> #:
      When $name is seen anywhere, it is replaced by this if present, or by
      'name' if present or by capitalized id otherwise.

    secondary 
    Attribute abbrev : word = <empty> #:
      A one-or-two-char abbrev for this person.

    secondary 
    Attribute dob : word = <required> #:
      Date of birth in YYYY-mm-dd format (with optional THH:MM:SS allowed).
      Can also be a <ymd> specification relative to start date of story.

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <person|event|link>;

  expand:
    pcons = self.parentConstruct()
    parent = pcons.person() if pcons.kind() == 'person' else None
    fcons = self.ancestor('family')
    env = fcons.env()
    gender = self.attrval('gender')
    dobattr, dobstr = self.attrpair('dob')
    cid = self.attrval('cid') or None
    dob = wmh.date.Date.FromStr(dobstr)
    key = self.id()

    parent2 = None
    mother = None
    father = None
    if parent:
      /# We see if we can find a second parent based on marriage events on the
      /# parent. Note that this fails to capture out-of-marriage conceptions,
      /# and thus a better mechanism is needed (see the 'mating' construct for a
      /# possibility).
      for event in parent.events():
        if event.kind() == 'marriage':
          other = event.pair(parent)
          if parent2:
            print 'WARNING: Assuming %s conceived by %s not %s' % (
              parent2.name(), other.name())
          else:
            parent2 = other
      if parent2:
        /# print 'NOTE: Identified %s as implicit parent of %s' % (parent2.name(), key)
        mother = parent if parent.gender() == 'female' else parent2 if parent2.gender() == 'female' else None
        father = parent if parent.gender() == 'male' else parent2 if parent2.gender() == 'male' else None
      else:
        mother = parent if parent.gender() == 'female' else None
        father = parent if parent.gender() == 'male' else None

    if dob is None:
      self.metafile().error('Invalid dob "%s"' % dobstr, line=dobattr.line())
    else:
      person = env.person(key)
      if person:
        if not person.gender():
          person.genderIs(gender)
        if not person.dob():
          person.dobIs(dob)
        if not person.mother():
          person.motherIs(mother)
        if not person.father():
          person.fatherIs(father)
      else:
        person = wmh.family.Person(
          env, key, gender, dob, mother=mother, father=father, cid=cid)
        env.register(person)
      self.personIs(person)
      if parent:
        parent.addChild(person)
      if parent2:
        parent2.addChild(person)

      for child in self.attrval('scope:'):
        child.expandMeta()

      /# We ensure that all events in the person are sorted ascending by date.
      person.events().sort(key=lambda e: e.date())
  translate:
  scope:

    field person : Person;

  end Construct person;

  Construct event < _familyroot_ #:
    An event that occurs in a person's life (marriage, death, etc.)
  config:

    feature
    Attribute kind : <marriage|divorce|death|unknown> = unknown #:
      What kind of event this is.

    primary
    Attribute event : word = <auto>;

    secondary
    Attribute when : word = <empty>  aliases <@> #:
      A date (YYYY-mm-dd or YYYY-mm-ddTHH:MM:SS) or a <cname>:<ymd>.

    secondary
    Attribute where : str = <empty> aliases <%> #:
      A string describing where the event takes place.

    secondary
    Attribute who : word = <empty> aliases <:> #:
      Comma-separated list of character baseids.
      See comment in 'summary' for a shorthand.

    Attribute comment:;
    Attribute config:;

  expand:
    pcons = self.parentConstruct()
    person = pcons.person()
    assert person
    env = person.env()
    when_attr, when = self.attrpair('when')
    where = self.attrval('where', default=None)
    who = self.attrval('who')
    kind = self.attrval('kind')

    date = wmh.date.Date.FromStr(when)
    if date is None:
      self.metafile().error('Invalid date "%s"' % when)
    else:
      other = None
      if kind == 'marriage':
        other = env.person(who)
        if other is None:
          /# We create a Person instance.
          /#  - we assume het marriage ... if this is a FF or MM marriage,
          /#    define the spouse beforehand with the proper gender so that
          /#    we won't get into this block of code.
          ogender = 'female' if person.gender() == 'male' else 'male'
          other = wmh.family.Person(env, who, ogender, None)
          env.register(other)
      event = wmh.family.Event(person, kind, date, other)
      person.addEvent(event)
  scope:
  end Construct event;

  Construct link < _familyroot_ #:
    A link between a person and some other person
  config:

    primary
    Attribute link = <auto> : id #:
      The id of the link (often auto-assigned)

    secondary
    Attribute to = <required> : word #:
      The id of the person being linked to.

    secondary
    Attribute color : word = <empty> #:
      The color of the link

    secondary
    Attribute text : str = <empty> #:
      Text to assign to the link.

    Attribute comment:;
    Attribute config:;
  expand:
  translate:
  scope:
  end Construct link;

  Construct mating < _familyroot_ #:
    An alternative experimental way of characterizing families.
    
    The current mechanism, whereby one side a family is selected as primary and
    others are secondary, is not intuitive. This new model explores a different
    mechanism whereby children are provided within mating scopes. However, the
    downside of this new approach is the inherit requirement that there be
    exactly one female and one male in the pairing. This is technically true
    biologically, but isn't useful for capturing the complexity of human
    dynamics. Need to consider more whether this is the right way to
    characterize things.
  config:

    primary
    Attribute mating = <auto> : id #:
      The id of the mating (often auto-assigned)

    secondary
    Attribute female = <required> : word #:
      The id of the female person in the mating.

    secondary
    Attribute male = <required> : word #:
      The id of the male person in the mating.

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <person|event|link>;

  expand:
  translate:
  scope:
  end Construct mating;

end MetaLanguage family;
