MetaLanguage oopl name Oopl parent meta toplevel <namespace|class> #:
  Augmentation and unification of object-oriented programming languages.
config:

  abstract
  Construct _oopl_ #:
    Abstract construct from which all Meta(Oopl) constructs inheret.

    All constructs in Meta(Oopl) inherit from this abstract construct,
    so the Attribute definitions here are available in subconstructs.
    However, note that the existence of an Attribute here does NOT mean it
    is automatically included in the subconstruct ... the subconstruct
    must specify the primary attribute (and any customization of other
    values).
  config:

    feature
    Attribute location : <user|test|meta|usertest> = user #:
      Which class this construct applies to (user, test or meta).

      Many constructs have an associated class, and each user-defined
      class has an associated test-class and meta-class. This feature
      attribute allows one to indicate which class (user, test or meta)
      the construct in question is associated with.  The default is
      the user class.

      Note that the 'usertest' value is not applicable to all sub-constructs. A
      different mechanism for specifying multiple classes is being implemented.

      TODO(wmh): Make this a multi-value attribute and remove 'usertest'.
    config:
      FeatureValue user #:
        Applies to user-provided class (the most common situation).
      FeatureValue test #:
        Applies to the testclass of the class this construct belongs to.

        If the class has location 'test' it is an error to specify location
        value 'test' on a child, as that would require a test class of the
        test class, which is not supported.
      FeatureValue meta #:
        Applies to the metaclass of the class this construct belongs to.

        If the class has location 'meta' it is an error to specify location
        value 'meta' on a child, as that would require a meta class of the
        meta class, whcih is not supported.
      FeatureValue usertest #:
        Applies to both user and test class. Temporary.

        This is only legal in a small number of subconstructs. For example,
        an 'assoc' may be needed in both user and test class.
        TODO(wmh): Remove this option from here and add it in 'assoc'.
    end Attribute location;

    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      Arbitrary multi-line text describing the purpose of the construct.

    secondary
    Attribute config: : complex = <empty> children <Construct> #:
      The complex block that defines/modifies Construct/Attribute instances.

    secondary
    Attribute scope: : complex = <empty> aliases <::> #:
      The collection of subconstructs.

  end Construct _oopl_;

  Construct namespace < _oopl_ #:
    The namespace construct.
  config:

    primary
    Attribute namespace : xid = <required> #:
      The name of the namespace.

    secondary
    Attribute preports: : simple = <empty> #:
      Lines to insert before any imports within a namespace.

      This can be used, for example, to modify sys.path in python before
      imports are specified.

    secondary
    Attribute testpreports: : simple = <empty> #:
      Lines to insert before any imports within a test namespace.

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <class|behavior|native|field|method>;

    Template python scope:
      >|WARNING: THIS TEMPLATE NOT CURRENTLY USED
      >|# -*- coding: utf-8 -*-
      >|${comment}
      >|${preports}
      >|${imports}
      >|${classes}
      >|${postamble}
    end Template python;

    Template python_test scope:
      >|WARNING: THIS TEMPLATE NOT CURRENTLY USED
      >|# -*- coding: utf-8 -*-
      >|${comment}
      >|${preports}
      >|${imports}
      >|${classes}
      >|${postamble}
      >|
      >|
      >|if __name__ == '__main__':
      >|  metax.test.main()
    end Template python_test;

  end Construct namespace;

  Construct class < _oopl_ #:
    The class construct.
  config:

    Attribute location;

    feature
    Attribute visibility : <public|private> = public #:
      The visibility of the class.
    config:
      FeatureValue public #:
        The class is visible everywhere.
      FeatureValue private #:
        The class is only visible to other classes in same namespace.
        TODO(wmh): Should this be package instead of private?
    end Attribute visibility;

    feature
    Attribute autogen : <std|nometa|notest|nometanotest> = std #:
      Controls which auto-generated classes are generated.
      TODO(wmh): This should be a regexp-defined attribute of the form:
        '^(?:[+-](?:meta|test))+$'
      with the default being '+meta+test'
    config:
      FeatureValue std #:
        If the class has location=user
         - a metaclass is generated
         - a testlass is generated
        If the class has location=meta
         - a testclass is generated
        If the class has location=test
         - a metaclass is generated
      FeatureValue nometa #:
        No meta class is generated
      FeatureValue notest #:
        No test class is generated
      FeatureValue nometanotest #:
        No test class is generated
    end Attribute autogen;

    feature
    Attribute presence : <concrete|abstract> = concrete #:
      Dictates whether this class can be instantiated or not.
    config:
      FeatureValue abstract #:
        One cannot create instances of an abstract class, but other classes
        can inherit from it.
      FeatureValue concrete #:
        A class of which instances can be created.
    end Attribute presence;

    feature
    Attribute span : <general|specific> = general #:
      Whether the class should be defined in all base languages or only those
      with a scope block.
    config:
      FeatureValue specific #:
        The compiler does not generate a class for baselangs without a scope
        block.
      FeatureValue general #:
        The compiler reports a warning if the class is being compiled into
        a baselang and does not have a scope block for that baselang.
    end Attribute span;

    primary
    Attribute class : id = <required> #:
      The name of the class.

    secondary
    Attribute parent : word = metax.root.Object aliases <<> #:
      The parent class.  If multiple parents are needed, use the block-valued
      parent: construct.  This is an xid, optionally preceeded by '^' to
      indicate that the referenced class was not generated by Meta and
      that it is fully qualified as-is.

    secondary
    Attribute testparent : word = <special> aliases <<<> #:
      The parent class of the test class associated with this user class. This
      is an xid, optionally preceeded by '^' to indicate that the referenced
      class was not generated by Meta and that it is fully qualified as-is.
      Alternatively, it can be the value '<special>', which indicates that the
      default testparent should be heuristically determined (if a TestCase class
      exists in the same namespace, it is used, otherwise metax.test.TestCase
      is used).

    secondary
    Attribute metaparent : word = <special> aliases <<<<> #:
      The parent metaclass of the metaclass associated with this user class.
      This is an xid, optionally preceeded by '^' to indicate that the
      referenced class was not generated by Meta and that it is fully qualified
      as-is. Alternatively, it can be the value '<special>', which indicates
      that the default metaparent should be heuristically determined. This
      attribute is necessary in situations where a class is inheriting from a
      class defined outside of Meta that has a metaclass.

    secondary
    Attribute associations: : complex = <empty> aliases <assocs:> #:
      The collection of assoc and resource instances needed by this class.
    children <assoc|resource|remark>;

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <lifecycle|method|field|native|category|remark|command>;

    secondary
    Attribute flags: : complex = <empty> children <flag> #:
      The collection of flags used by this class.

    Template python scope:
      >|${imports}
      >|##########  End Imports  ##########
      >|${preclass}
      >|
      >|
      >|class ${class}(${parentspec}):
      >|  ${comment}
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|${postclass}
    end Template python;

    Template python_test scope:
      >|${imports}
      >|##########  End Imports  ##########
      >|${preclass}
      >|
      >|
      >|class ${class}(${parentspec}):
      >|  ${comment}
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|${postclass}
      >|########## Start Harness ##########
      >|
      >|
      >|if __name__ == '__main__':
      >|  metax.test.main()
    end Template python_test;

    Template javascript #:
      How to define javascript classes using ES2015 class sytnax and goog.module().
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
      https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide
    scope:
      >|${overview}
      >|goog.module('${fqcn}');
      >|goog.module.declareLegacyNamespace();
      >|${imports}
      >|${preclass}
      >|
      >|${comment}
      >|class ${class}${parentspec} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|}
      >|${postclass}
    end Template javascript;

    Template javascript_test #:
      How to define javascript test classes using ES2015 class sytnax.
    scope:
      >|${overview}
      >|goog.module('${fqcn}');
      >|goog.setTestOnly('${fqcn}');
      >|goog.module.declareLegacyNamespace();
      >|${imports}
      >|${preclass}
      >|
      >|${comment}
      >|class ${class}${parentspec} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|}
      >|${postclass}
    end Template javascript_test;

    Template cpp_decl scope:
      >|#ifndef ${namespace_under}_${class}_h
      >|#define ${namespace_under}_${class}_h 1
      >|
      >|${imports}
      >|
      >|${namespace_spec}
      >|${preclass}
      >|
      >|${comment}
      >|class ${class}${parentspec} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|};
      >|${postclass}
      >|
      >|${end_namespace}
      >|
      >|${imposts}
      >|#endif // ${namespace_under}_${class}_h
    end Template cpp_decl;

    Template cpp_defn scope:
      >|#include "${header}"
      >|${imports_local}
      >|
      >|${namespace_spec}
      >|${preclass_local}
      >|${scope}
      >|${postclass_local}
      >|
      >|${end_namespace}
      >|${imposts_local}
    end Template cpp_defn;

    Template cpp_test_decl scope:
      >|#ifndef ${namespace_under}_${class}_h
      >|#define ${namespace_under}_${class}_h 1
      >|
      >|${imports}
      >|
      >|${namespace_spec}
      >|${preclass}
      >|
      >|${comment}
      >|class ${class}${parentspec} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|};
      >|${postclass}
      >|
      >|${end_namespace}
      >|
      >|#endif // ${namespace_under}_${class}_h
    end Template cpp_test_decl;

    Template cpp_test_defn scope:
      >|#include "${header}"
      >|${imports_local}
      >|
      >|${namespace_spec}
      >|${preclass_local}
      >|
      >|${scope}
      >|
      >|${postclass_local}
      >|
      >|${end_namespace}
      >|${imposts_local}
      >|
      >|
      >|int main(int argc, char* argv[]) {
      >|  ::testing::InitGoogleTest(&argc, argv);
      >|  return RUN_ALL_TESTS();
      >|}
    end Template cpp_test_defn;

  end Construct class;

  abstract
  Construct _classic_ < _oopl_ #:
    Abstract construct for constructs within class scope sharing certain
    attributes. Not all constructs within class scope inherit from this.
  config:

    Attribute location;

    feature
    Attribute kind : <instance|static> = instance #:
      Each ${kind} comes in a variety of levels.
    config:
      FeatureValue instance #:
        The ${kind} is defined on instances of the class.
      FeatureValue static #:
        The ${kind} is defined within the scope of the class but does not
        reside in the instance or metaclass (and is not inherited into
        child classes).                                             
    end Attribute kind;

    Attribute comment:;
    Attribute config:;
    Attribute scope:;
  end Construct _classic_;

  Construct field < _classic_ #:
    The field construct.
  config:

    feature
    Attribute access : <ro|rw|rwx|raw> = ro #:
      Which accessors are public (the others are protected).

      TODO(wmh): This mechanism is somewhat limited. If we could specify,
      for each accessor, whether or not it is to be generated, and its
      visibility, that would be best.

      Suppose we use
        r = getter
        w = setter
        x = reffer
        i = adj
        @ = the field itself
        $ = element-of

      We could specify a particular accessor with:
        +r = getter is public
        -r = getter is private
        #r = getter is protected
        ~r = getter is package
        !r = getter is not generated
      
      And the complete set could be:
        +r+w
        +r-w-x
        etc.
      
      However, the above would require a different mechanism for defining
      feature values. Two possibilities:
       1. the set of feature values is
            r +r -r #r ~r !r
            w +w -w #w ~w !w
            x +x -x #x ~x !x
            i +i -i #i ~i !i
          and this feature key allows multiple values separated by ''.
          (note that 'r' is shorthand for '+r').  We may also want to
          add support for abbrevs for the complete value (e.g. 'raw'
          is an alias for '!r!w!x!i').
       2. we add support for regexp-based feature values:
            ([@+#~!-]?[rwxi])+
          (we could add special abbrevs to this regexp ... 'raw' means
           '!r!w!x!i+@' ... but mapping those abbrevs to their actual
           semantics would need to be hardcoded into the implementation
           rather than being specified in the schema file unless we provide
           remapping syntax).
    config:
      FeatureValue ro #:
        The getter is public, setter is protected, no other accessors.
      FeatureValue rw #:
        The getter and setter are public, no other accessors.
      FeatureValue rwx #:
        The getter, setter and reffer are public, no other accessors.
      FeatureValue raw #:
        No accessors are generated.
    end Attribute access;

    feature
    Attribute visibility : <tmppublic|tmpprivate> = tmpprivate #:
      The visibility of the field.

      TODO(wmh): This attribute is temporary. It is subsumed by the 
      multi-valued version of 'access', and code should start migrating
      away from the use of this field.  Hence the 'tmp' prefix on
      legal values.
    config:
      FeatureValue tmppublic #:
        The field itself (as opposed to its accessors) is public.
      FeatureValue tmpprivate #:
        The field itself (as opposed to its accessors) is private.
    end Attribute visibility;

    feature
    Attribute status : <required|optional> = required #:
      Whether this field is optional.
    config:
      FeatureValue required #:
        The field is always defined
      FeatureValue optional #:
        The field does not take up any space if it is not set or has
        default value.
    end Attribute status;

    feature
    Attribute ownership : <owned|unowned> = unowned #:
      Whether this field is optional.
    config:
      FeatureValue owned #:
        The class instance is responsible for cleaning up this field.
        In UML diagrams, this marks composition.
      FeatureValue unowned #:
        The class instance is not responsible for cleaning up this field.
        In UML diagrams, this marks aggregation.
    end Attribute ownership;

    Attribute location;
    Attribute kind;

    feature
    Attribute pack : <unpacked|packed> = unpacked #:
      Whether the field is packed into a word with other fields or not.
    config:
      FeatureValue unpacked #:
        No packing ... the field takes up 8+ bytes (on a 64bit machine).
      FeatureValue packed #:
        The field is packed with other fields. The type of the field specifies
        how many bits are needed. For example, int<5>, real<32>, uint<17>, etc.
    end Attribute pack;

    feature
    Attribute inheritance : <new|override> = override #:
      Whether the accessors are defined in parents or not.
      TODO(wmh): We need to be able to specify this on a per-accessor
      basis. This can be done by moving the 'access' feature attribute to
      a more robust implementation, and/or by adding a feature key on
      the 'accessor' construct.

      The 'accessor' construct can be used to override this value on an
      individual basis.
    config:
      FeatureValue new #:
        The accessors are not defined in a parent class.
      FeatureValue override #:
        The accessors are defined in a parent class.
    end Attribute inheritance;

    primary
    Attribute field : id = <required> #:
      The name of the field.

    secondary
    Attribute type : type = <required> aliases <:> #:
      The metatype of the field.

    secondary
    Attribute default : expr = <empty> aliases <=> #:
      The default value of the field.  If not provided, a type-specific
      default is used:
        int     0
        uint    0
        real    0.0
        bool    false
        *<any>  null 
        @vec    []
        @map    {}
    end Attribute default;

    secondary
    Attribute role : str = <empty> #:
      The role name to add to UML class diagrams to identify how the field
      participates with this class. Only meaningful for fields of class type.
      Note that there will not be a role label on the side of the link connected
      to the class within which the field resides unless the class of which the
      field is an instance has a reciprocal field linking to an instance, and
      specifies a 'role' attribute.  Multiplicity is establish by the type
      of the field (is it a vec/map/etc?)

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <accessor>;

    Template python_get scope:
      >|${decorator}
      >|def ${field}(${receiver?}): ${scope}

    Template python_set scope:
      >|${decorator}
      >|def ${field}Is(${receiver?, }value): ${scope}

    Template python_ref scope:
      >|${decorator}
      >|def ${field}Ref(${receiver?}): ${scope}

  end Construct field;

  Construct accessor < _oopl_ #:
    The accessor construct, appearing in the 'scope:' block of the 'field'
    construct.
  config:

    primary
    Attribute accessor : id = <required> #:
      Unlike in almost all other constructs, the set of legal identifiers
      for accessors is predefined. The legal identifiers are:
        get: the getter
        set: the setter
        ref: the reffer
        adj: allows a numeric field to be incremented/decremented by given val.
        print: how to provide human-readable value
        write: how to serialize the field
        TODO(wmh): what other accessors are there?

    secondary
    Attribute lazy: : simple = <empty> children <_statement_> #:
      A block of code used to compute a value for the field on demand. Meta
      provides the wrapper code around this block to check if the field is
      already initialized, and to perform the initialization code if not.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

    secondary
    Attribute test: : simple = <empty> children <_statement_> #:
      A single test block associated with this field. For the field
      nm.sp.Foo.name, the test method is nm.sp.FooTest.test_name.

  end Construct accessor;

  abstract
  Construct _executable_ < _classic_ #:
    The method construct.
  config:

    feature
    Attribute presence : <concrete|abstract> = concrete #:
      Dictates whether this method has an implementaton or not.
    config:
      FeatureValue abstract #:
        Subclasses must provide an explicit scope in order to be instantiated.
      FeatureValue concrete #:
        A scope must be provided with this method.
    end Attribute presence;

    feature
    Attribute visibility : <public|private|protected|package> = public #:
      The visibility of the method.
    config:
      FeatureValue public #:
        The method is visible to any class.
      FeatureValue protected #:
        The method is only visible within this class and its subclasses.
      FeatureValue private #:
        The method is only visible within this class itself.
      FeatureValue package #:
        The method is only visible within classes in the same namespace.
    end Attribute visibility;

    feature
    Attribute span : <general|specific> = general #:
      Whether the executable applies to all base languages or only those
      with a scope block.
    config:
      FeatureValue specific #:
        The compiler does not generate a method for baselangs without a scope
        block.
      FeatureValue general #:
        The compiler reports a warning if the method is being compiled into
        a baselang and does not have a scope block for that baselang (and
        defines a method with empty body).
    end Attribute span;

    feature
    Attribute mutability : <mutable|const|immutable> = mutable #:
      Whether the receiver is modified within this method.
    config:
      FeatureValue mutable #:
        The receiver may be modified.
      FeatureValue const #:
        The receiver may not be modified (but objects within this may be)
      FeatureValue immutable #:
        The receiver may not be modified, nor any objects linked from it.
    end Attribute mutability;

    feature
    Attribute autogen : <std|notest> = std #:
      Controls which a test method is auto-generated even when no
      test block exists.
    config:
      FeatureValue std #:
        Auto-generate a test method for the executable.
      FeatureValue notest #:
        No test method is generated
    end Attribute autogen;

    feature
    Attribute extensibility : <extendable|final> = extendable #:
      Whether subclasses can override the method.
    config:
      FeatureValue extendable #:
        Subclasses can override the method.
      FeatureValue final #:
        Subclasses cannot override (or, at least won't be paid attention to
        when receivers are typed of this class as opposed to the subclass).
    end Attribute extensibility;

    feature
    Attribute dispatch : <autodispatch|nonvirtual|virtual> = virtual #:
      How dispatch occurs on this method.
    config:
      FeatureValue autodispatch #:
        Use baselang-specific default
        TODO(wmh): We need a baselang-independent semantics for this! Or it
        needs to be removed.
      FeatureValue nonvirtual #:
        Which implementation of this method is to be invoked at a particular
        callsite is determined based on the static type of the receiver as
        opposed to the dynamic type.
      FeatureValue virtual #:
        Which implementation of this method is to be invoked at a particular
        callsite is determined based on the dynamic type of the receiver as
        opposed to the static type.
    end Attribute dispatch;

    feature
    Attribute optimization : <outline|inline> = outline #:
      Whether the executable should be considered for optimization
      via inlining. Accessors are always marked as inlined.
    config:
      FeatureValue outline #:
        The executable is not marked as inlineable.
      FeatureValue inline #:
        The executable is marked as inlineable.
    end Attribute optimization;

    feature
    Attribute inheritance : <new|override|prex|postx|superx> = new #:
      How inheritance behaves for this method.

      TODO(wmh): Determine whether this is the right place for prex/postx/superx
      or whether they should be separated into a different feature attribute.

      TODO(wmh): Determine whether the default should be 'override' or 'new'.
    config:
      FeatureValue new #:
        The method is not defined in a parent, and is defined newly here.
      FeatureValue override #:
        The method overrides an inherited definition by completing replacing
        functionality.
      FeatureValue prex #:
        The method extends an inherited definition by always invoking its
        parent implementation (with same args) after doing class-specific actions.
      FeatureValue postx #:
        The method extends an inherited definition by always invoking its
        parent implementation (with same args) before doing class-specific actions.
      FeatureValue superx #:
        The method extends an inherited definition by always invoking its parent
        implementation (with same args) somewhere within its method body, via
        the special META_SUPER syntax.
    end Attribute inheritance;

    Attribute location;

    feature
    Attribute kind : <instance|static|cls|closure|initializer|finalizer> = instance #:
      Identifies one of a variety of mutually exclusive kinds of methods.

      TODO(wmh): The fact that executables have a feature attribute named kind',
      combined with us using 'kind to refer to the primary key, is destined to
      pose confusion. Consider renaming one or the other use.
    config:
      FeatureValue instance #:
        A ${kind} defined on a class having a receiver object typed of that
        class.
      FeatureValue static aliases <function> #:
        A method that does not contain a receiver (e.g. a static method when
        defined at class scope is a function). However, a function can appear
        in more places ... at namespace level, within methods, etc.
        TODO(wmh): Is 'static' just an alias for 'function'?
      FeatureValue cls #:
        This is a special case for handling an issue in Python between metaclasses
        and @classmethods.  It indicates that the method should have a @classmethod
        decorator. It would be preferable to define such methods as having
        location 'meta', but in Meta that puts the method in the metaclass instead
        of being an @classmethod method.  Python does not treat @classmethods
        entirely as methods on the metaclass, which breaks things, hence the need
        for this special case.  This value should be considered an implementation
        detail and NOT used in user-level code, as it does not have a correlate in
        most other baselangs. It is used internally by Meta when @classmethods
        are needed to implement some higher-level meta concept.
      FeatureValue closure #:
        A function that has access to the variables in the scope within which
        it is lexically defined.
      FeatureValue initializer aliases <init> #:
        Called a constructor in most languages ... the method that initializes
        state of an instance.
      FeatureValue finalizer #:
        Called a destructor in some languages, cleans up state before an object
        is freed up (either explicitly or implicitly).
    end Attribute kind;

    secondary
    Attribute alias : word = <empty> #:
      Alternative names for this entity. Although singular, it can be a
      comma-separate list of identifiers. For example, a method may have
      id 'perimeter' and alias 'circumference', in which case both are legal.
      TODO(wmh): Make this an idlist instead of word!

    secondary
    Attribute params: : complex = <required> children <var> #:
      The parameters of this method.

    secondary
    Attribute super : expr = <empty> #:
      The args to pass to parent implementation when prex/postx/superx.

    secondary
    Attribute returns : type = void aliases <:> #:
      The return type of the method.  The returns: complex block allows
      one to document the return type and to define thrown exceptions.

    secondary
    Attribute returns: : type = void aliases <->:> #:
      A block that specifies the return type and thrown exceptions.
    children <return|throw>;

    secondary
    Attribute pres: : complex = <empty> children <pre> #:
      Preconditions

    secondary
    Attribute posts: : complex = <empty> children <post> #:
      Preconditions

    secondary
    Attribute test: : simple = <empty> children <_statement_> #:
      A single test block associated with this method. For the method
      nm.sp.Foo.name, the test method is nm.sp.FooTest.test_name.

    secondary
    Attribute tests: : complex = <empty> children <testx> #:
      Allows multiple tests to be defined. The ids of each testx are used as
      suffixes to the test method name formed by the user-provided method. For
      the method nm.sp.Foo.name, if there are three testx constructs in the
      'tests' block with ids 'a', 'b', and 'c', the test methods will be
      nm.sp.FooTest.test_name_a, nm.sp.FooTest.test_name_b, and
      nm.sp.FooTest.test_name_c

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

  end Construct _executable_;

  Construct method < _executable_ #:
    The method construct.
  config:

    Attribute presence;
    Attribute visibility;
    Attribute span;
    Attribute mutability;
    Attribute autogen;
    Attribute extensibility;
    Attribute optimization;
    Attribute dispatch;
    Attribute inheritance;
    Attribute location;
    Attribute kind;

    primary
    Attribute method : id = <required> #:
      The name of the method.

    Attribute alias;

    Attribute params:;
    Attribute super;
    Attribute returns;
    Attribute returns:;
    Attribute pres:;
    Attribute posts:;
    Attribute test:;
    Attribute tests:;

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

    Template python scope:
      >|
      >|${modifiers}
      >|def ${method}${params}:
      >|  ${comment}
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
    end Template;

    Template javascript scope:
      >|
      >|${comment}
      >|${method}${params} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|};
      >|${postmethod}
    end Template;

    Template javascript_oldstyle scope:
      >|
      >|${comment}
      >|${method_prefix}${method} = function${params} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|};
      >|${postmethod}
    end Template;

    Template javascript_test_oldstyle scope:
      >|
      >|${comment}
      >|function ${method}() {
      >|  ${scope}
      >|}
    end Template;

    Template cpp_decl scope:
      >|
      >|${comment}
      >|${modifiers? }${returns? }${method}${params}${inline}
    end Template cpp_decl;

    Template cpp_defn scope:
      >|
      >|${returns? }${class_base}::${method}${params}${initlist} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|}
    end Template cpp_defn;

    Template cpp_decl_test scope:
      >|// No decl code needed for ${method}
    end Template cpp_decl_test;

    Template cpp_defn_test scope:
      >|
      >|TEST_F(${class_base}, ${method}) {
      >|  ${scope}
      >|}
    end Template cpp_defn_test;

  end Construct method;

  Construct lifecycle < _executable_ #:
    The lifecycle construct.

    Most of the attributes of lifecycle apply to the initializer
    implicitly generated by lifecycle. The other implicit methods
    (finalizer, cloner, mover, setup, teardown, etc.) do not take
    params and have pre-defined semantics in other ways.

    Note that lifecycle does not support the 'inheritance' feature
    attribute because inheritance semantics is predefined for all
    generated methods.
  config:

    Attribute presence;
    Attribute visibility;
    Attribute span;
    Attribute mutability;
    Attribute autogen;
    Attribute extensibility;
    Attribute dispatch;
    Attribute inheritance = postx;
    Attribute location;
    Attribute kind;

    primary
    Attribute lifecycle : id = <auto> #:
      The name of the lifecycle.

    Attribute params:;
    Attribute super;
    Attribute returns;
    Attribute returns:;
    Attribute pres:;
    Attribute posts:;
    Attribute test:;
    Attribute tests:;

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex aliases <init:|::> children <_statement_> #:
      The initializer block.

    secondary
    Attribute clinit: : simplex = <empty> #:
      A static field initialization block. Invoked exactly once for each class,
      unlike the metaclass initializer, which is invoked N+1 times if the class
      has N descendent classes.

    secondary
    Attribute finalize: : simplex = <empty> aliases <::> #:
      A finalizer block for cleaning up the object before garbage
      collection.

    secondary
    Attribute metainit: : simplex = <empty> #:
      An block found within a user-level lifecycle defining a meta-class
      initializer. Convenience mechanism so that we can define everything in
      a single lifecycle instead of having a user lifecycle, test lifecycle
      and meta lifecycle.  A location=meta lifecycle is implicitly created
      and the metainit: block is moved to the scope: of this new lifecycle.

    secondary
    Attribute metafinalize: : simplex = <empty> #:
      An block found within a user-level lifecycle defining a meta-class
      finalizer. Convenience mechanism so that we can define everything in a
      single lifecycle instead of having a user lifecycle, test lifecycle and
      meta lifecycle. A location=meta lifecycle is implicitly created and the
      metafinalize: block is moved to the finalize: of this new lifecycle.

    secondary
    Attribute setup: : simplex = <empty> #:
      This may appear in an instance-level lifecycle or a test-level
      lifecycle. In both cases, it defines a setup method for the test
      class.

    secondary
    Attribute clsetup: : simplex = <empty> #:
      This may appear in an instance-level lifecycle or a test-level lifecycle.
      In both cases, it defines a class-level setup method for the test class.

    secondary
    Attribute teardown: : simplex = <empty> #:
      This may appear in an instance-level lifecycle or a test-level
      lifecycle. In both cases, it defines a teardown method for the test
      class.

    secondary
    Attribute clteardown: : simplex = <empty> #:
      This may appear in an instance-level lifecycle or a test-level lifecycle.
      In both cases, it defines a class-level teardown method for the test
      class.

  end Construct lifecycle;

  Construct behavior < _executable_ #:
    The behavior construct.
  config:

    Attribute presence;
    Attribute visibility;
    Attribute span;
    Attribute mutability;
    Attribute autogen;
    Attribute extensibility;
    Attribute optimization;
    Attribute dispatch;
    Attribute inheritance;
    Attribute location;
    Attribute kind;

    primary
    Attribute behavior : id = <required> #:
      The name of the behavior.

    Attribute alias;

    Attribute params:;
    Attribute super;
    Attribute returns;
    Attribute returns:;
    Attribute pres:;
    Attribute posts:;
    Attribute test:;
    Attribute tests:;

    Attribute comment:;
    Attribute config:;
    Attribute scope: : complex children <receiver>;

  end Construct behavior;

  Construct receiver < _oopl_ #:
    The receiver construct.
  config:

    feature
    Attribute presence : <<concrete|abstract> = concrete config:
      FeatureValue abstract #:
        The method is marked abstract (no scope).
      FeatureValue concrete #:
        A scope is required.
    end Attribute presence;

    primary
    Attribute receiver : id = <required> #:
      The name of the receiver.

    secondary
    Attribute test: : simple = <empty> children <_statement_> #:
      A single test block associated with this method. For the method
      nm.sp.Foo.name, the test method is nm.sp.FooTest.test_name.

    secondary
    Attribute tests: : complex = <empty> children <testx> #:
      Allows multiple tests to be defined. The ids of each testx are used as
      suffixes to the test method name formed by the user-provided method. For
      the method nm.sp.Foo.name, if there are three testx constructs in the
      'tests' block with ids 'a', 'b', and 'c', the test methods will be
      nm.sp.FooTest.test_name_a, nm.sp.FooTest.test_name_b, and
      nm.sp.FooTest.test_name_c

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

  end Construct receiver;

  Construct category < _oopl_ #:
    The category construct.
  config:

    primary
    Attribute category : id = <required> #:
      The name of the category.

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <_statement_>;

  end Construct category;

  Construct remark < _oopl_ #:
    The remark construct.
  config:

    primary
    Attribute remark : id = <auto> #:
      The name of the remark.

    Attribute comment: : simple;

  end Construct remark;

  Construct native < _oopl_ #:
    The native construct.
  config:

    Attribute location;

    feature
    Attribute position : <pre|post> = post #:
      Is this native block associated with the construct before or after it.
    config:
      FeatureValue pre #:
        This native block is associated with the construct below it.
      FeatureValue post #:
        This native block is associated with the construct above it.
    end Attribute position;

    feature
    Attribute placement : <defn|decl> = defn #:
      Only meaningful in base-languages that make a distinction between
      declaration (signature) and definition (implementation). For example,
      in C++ 'defn' is .h and 'decl' is .cc, whereas in python both 'defn'
      and 'decl' refer to .py, in java both 'defn' and 'decl' refer to .java,
      etc.
    config:
      FeatureValue defn #:
        In C++, this identifies the .cc file.
      FeatureValue decl #:
        In C++, this identifies the .h file.
    end Attribute placement;

    feature
    Attribute level : <cls|nmsp> = cls #:
      Controls whether the code is inserted within a namespace or outside
      of the namespace. For example, in C++ when defining/declaring a class,
      the declaration is wrapped within namespace scopes, and pre/post content
      more appear within the namespace scope before/after the class, or may
      appear outside of the namespace scope before/after the class.
    config:
      FeatureValue cls #:
        When a native block appears before/after a class, this identifies that
        the code is to be inserted within the namespace qualifiers.
      FeatureValue nmsp #:
        When a native block appears before/after a class, this identifies that
        the code is to be inserted outside of the namespace qualifiers.
    end Attribute level;

    primary
    Attribute native : id = <auto> #:
      The name of the native.

    Attribute comment:;
    Attribute scope: : simplex children <_statement_>;

  end Construct native;

  Construct assoc < _oopl_ #:
    The assoc construct.
  config:

    Attribute location;

    feature
    Attribute kind : <cls|lib|std|decl|def> = cls #:
      The kind of association.
    config:
      FeatureValue cls #:
        The assoc is a class (the preferred kind of dependency)
      FeatureValue lib #:
        The assoc is a namespace (all symbols in the namespace are to be
        imported)
      FeatureValue std #:
        The assoc is from the standard library (and thus doesn't need a target).
      FeatureValue decl #:
        The assoc is a class to be declared but not defined.
      FeatureValue def #:
        The assoc is a class to be declared, and its definition imported
        *after* the declaration of the containing class.
    end Attribute kind;

    primary
    Attribute assoc : word = <required> #:
      The name of the assoc.  For c-style includes in C++, one can use a
      value of 'stdlib.h'.
      TODO(wmh): We should introduce a 'name' secondary attribute with
      replacer semantics, instead of having the assoc primary value identify
      the assoc. By having 'name', individual baselangs can vary the value
      (and we reserve the primary value for naming the construct itself in
      situations where it is useful ... we can change the type from word to id
      in that case).

    secondary
    Attribute alias : word = <empty> #:
      The alias by which this dependency is to be known within the baselang
      source file.

    secondary
    Attribute target : str = <empty> #:
      The BUILD target to use for this assoc. If not specified, a default is
      computed based on the assoc and kind.  Use the explicit empty string
      to indicate that no target is needed (useful to break circularities).
      Otherwise, it should be a fully qualified BUILD target.

    Attribute comment:;

  end Construct assoc;

  Construct testx < _oopl_ #:
    The testx construct.

    It would be better if this was called 'test', but we are already using
    'test' as a feature value and a secondary key, and we cannot have a
    primary key and feature value with same text.  We would need to rename
    the feature value if we want to rename this to testx (we *can* have
    the same value used for both primary key and secondary key).
  config:

    primary
    Attribute testx : id = <required> #:
      The name of the testx. Note that one cannot use values like
      '1' or '2' here because they aren't valid ids. Better to use
      a word/phrase more descriptive of what is being tested.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

  end Construct testx;

  Construct resource < _oopl_ #:
    The resource construct.
  config:

    Attribute location;

    primary
    Attribute resource : word = <required> #:
      The name of the resource.

    secondary
    Attribute path : str = <empty> #:
      An explicit bazel target for this assoc. Useful in situations where
      Meta cannot determine the target itself, and in situations where
      a circularity needs to be broken (specify an empty string).
    end Attribute path;

    Attribute comment:;

  end Construct resource;

  Construct command < _oopl_ #:
    The command construct.
  config:

    feature
    Attribute compilation : <implicit|explicit> = explicit #:
      Whether invoking the binary implicitly compiles dependent meta code,
      or whether code needs to be explicitly compiled.
    config:
      FeatureValue implicit #:
        If the command in question has an associated binary (e.g. it is a
        toplevel command), invoking the binary will result in all Meta-level
        software needed by the binary being implicitly recompiled if its
        meta file is newer than its baselang source file.
      FeatureValue explicit #:
        If the command in question has an associated binary (e.g. it is a
        toplevel command), invoking the binary will NOT result in all Meta-level
        software needed by the binary being implicitly recompiled. One must
        recompile the code explicitly.

    feature
    Attribute kind : <inline|named> = inline #:
      Allows us to indicate if a command should generate a method or not.
    config:
      FeatureValue inline #:
        The compiled code does not introduce a lexical scope, so the lines
        in the block flow from previous lines without change.
      FeatureValue named #:
        An instance-level method is defined to implement the block. The method
        is defined on the class within which the 'command' construct was found,
        and accepts one argument of type metax.root.flags.Values representing
        the instantiated flags (and associated Command). Note that only commands
        of kind 'instance' can be invoked outside of the method implementing the
        command construct (blocks of kind 'virtual' or 'scoped' are local to the
        top-level command).

        TODO(wmh): Provide support for returning values.  Although one
        can use 'return' in such blocks, if the block is changed to
        virtual, it will return from the entire surrounding function,
        which isn't usually what is desired. A safer mechanism that works
        for both instance and virtual blocks is preferred.

    primary
    Attribute command : id = <required> #:
      The name of the command.

    secondary
    Attribute aliases : str = <empty> aliases <@> #:
      A comma-separated list of aliases for the command.

    secondary
    Attribute interface: : complex = <empty> children <command|flag|arg> #:
      A comma-separated list of aliases for the command.
    
    Attribute comment:;
    Attribute scope: : simple;

  end Construct command;

  Construct flag < _oopl_ #:
    The flag construct.
  config:

    feature
    Attribute status : <required|optional> = optional #:
      Whether the flag is required or not (most flags are optional).

    primary
    Attribute flag : id = <required> aliases <arg> #:
      The name of the flag.

    secondary
    Attribute aliases : str = <empty> aliases <@> #:
      A comma-separated list of aliases for the flag. If any alias is one char
      long, it can be accessed with '-' or '--', and can be merged togetehr with
      other single-letter flag names (-abc = -a -b -c).

    secondary
    Attribute type : type = any aliases <:> #:
      The metatype of the flag.

    secondary
    Attribute default : expr = <special> aliases <=> #:
      The default value of the flag.
      TODO(wmh): This should have type 'expr', not 'word'.
    end Attribute default;

    Attribute comment:;

  end Construct flag;

  abstract
  Construct _statement_ < _oopl_ #:
    The abstract superconstruct for all constructs that can appear within
    complex blocks representing statement level code.
  config:

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_> ;

  end Construct _statement_;

  Construct block < _statement_ #:
    The block construct.
  config:

    feature
    Attribute kind : <virtual|scoped|named> = virtual #:
      Identifies one of a variety of mutually exclusive kinds of methods.

      TODO(wmh): The fact that executables have a feature attribute named kind',
      combined with us using 'kind to refer to the primary key, is destined to
      pose confusion. Consider renaming one or the other use.
    config:
      FeatureValue virtual #:
        The compiled code does not introduce a lexical scope, so the lines
        in the block flow from previous lines without change.
      FeatureValue scoped #:
        The compiled code introduces a new lexical scope for the block.
        IMPORTANT: Certain baselangs (e.g. python) do not have support for
        lexical blocks, and although lexical scoping can be emulated in
        Meta*, code written in Meta<Python> using scoped blocks may have
        different semantics from what occurs in Meta<C++>, etc.
        TODO(wmh): Does python 3 provide support for this?
      FeatureValue named #:
        An instance-level method is defined to implement the block. The method
        is defined on the class within which the 'command' construct was found,
        and accepts one argument of type metax.root.flags.Values representing
        the instantiated flags (and associated Command). Note that only commands
        of kind 'instance' can be invoked outside of the method implementing the
        command construct (blocks of kind 'virtual' or 'scoped' are local to the
        top-level command).

        TODO(wmh): Provide support for returning values.  Although one
        can use 'return' in such blocks, if the block is changed to
        virtual, it will return from the entire surrounding function,
        which isn't usually what is desired. A safer mechanism that works
        for both instance and virtual blocks is preferred.
    end Attribute kind;

    primary
    Attribute block : id = <auto> #:
      The name of the block.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_> ;

  end Construct block;

  Construct var < _statement_ #:
    The var construct.
  config:

    feature
    Attribute multiplicity : <multi|normal> = normal #:
      Usually 'normal', but when appearing within a 'params' block, 'multi'
      means the variable consumes all remaining args. The type of the var
      dictates whether positional or keyword args are grabbed (for baselangs
      that support the distinction, such as python).

    primary
    Attribute var : id = <required> #:
      The name of the var.

    secondary
    Attribute type : type = any aliases <:> #:
      The metatype of the var.

    secondary
    Attribute provides : id = <empty> aliases <->> #:
      The metatype of the var.

    secondary
    Attribute default : expr = <special> aliases <=> #:
      The default value of the var.  When the var is in a params: block,
      a default value means the param is optional.  When defined in an
      executable block, it provides an explicit value to initialize the
      variable to instead of using a type-specific default.
    end Attribute default;

    Attribute comment:;

  end Construct var;

  Construct loop < _statement_ #:
    The loop construct.
  config:

    primary
    Attribute loop : id = <required> #:
      The name of the loop.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

  end Construct loop;

  BaseLanguage cpp name C++ suffixes <cc|h>;
  BaseLanguage javascript name Javascript suffixes <js>;
  BaseLanguage python name Python suffixes <py>;

end MetaLanguage oopl;
