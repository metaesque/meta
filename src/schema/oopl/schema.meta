MetaLanguage oopl name Oopl parent meta toplevel <namespace|class> #:
  Augmentation and unification of object-oriented programming languages.
config:

  abstract
  Construct _oopl_ clsname OoplConstruct pclsname metax.meta.Construct #:
    @_oopl_: Abstract construct from which all Meta(Oopl) constructs inheret.

    All constructs in Meta(Oopl) inherit from this abstract construct,
    so the Attribute definitions here are available in subconstructs.
    However, note that the existence of an Attribute here does NOT mean it
    is automatically included in the subconstruct ... the subconstruct
    must specify the primary attribute (and any customization of other
    values).
  config:

    feature
    Attribute location : <user|test|meta|usertest> = user #:
      Which class this construct applies to (user, test or meta).

      Many constructs have an associated class, and each user-defined
      class has an associated test-class and meta-class. This feature
      attribute allows one to indicate which class (user, test or meta)
      the construct in question is associated with.  The default is
      the user class.

      Note that the 'usertest' value is not applicable to all sub-constructs. A
      different mechanism for specifying multiple classes is being implemented.

      TODO(wmh): Make this a multi-value attribute and remove 'usertest'.
    config:
      FeatureValue user #:
        Applies to user-provided class (the most common situation).
      FeatureValue test #:
        Applies to the testclass of the class this construct belongs to.

        If the class has location 'test' it is an error to specify location
        value 'test' on a child, as that would require a test class of the
        test class, which is not supported.
      FeatureValue meta #:
        Applies to the metaclass of the class this construct belongs to.

        If the class has location 'meta' it is an error to specify location
        value 'meta' on a child, as that would require a meta class of the
        meta class, whcih is not supported.
      FeatureValue usertest #:
        Applies to both user and test class. Temporary.

        This is only legal in a small number of subconstructs. For example,
        an 'assoc' may be needed in both user and test class.
        TODO(wmh): Remove this option from here and add it in 'assoc'.
    end Attribute location;

    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      Arbitrary multi-line text describing the purpose of the construct.

    secondary
    Attribute config: : complex = <empty> children <Construct> #:
      The complex block that defines/modifies Construct/Attribute instances.

    secondary
    Attribute scope: : complex = <empty> aliases <::> #:
      The collection of subconstructs.

  expand:
    /# Each subclass overrides this method to perform expansion of the construct
    /# associated with the subclass. The code in these implementations are mostly
    /# baselang-agnostic, since they deal with the creation of implicit
    /# Meta-level constructs, moving constructs around, etc. However, some
    /# special-casing is needed based on esoteria of individual baselangs.
    /#
    /# IMPORTANT ISSUES TO KEEP IN MIND:
    /#  - each construct should be expanded exactly once (not counting situations
    /#    where an expandMeta() method is invoked on a construct and it is
    /#    determined that nothing should be done for the instance in question
    /#    (this can happen, for example, when invoking expandMeta() on
    /#    class-level constructs ... if the location is 'meta' or 'test' the
    /#    construct is moved to a different class and the current invocation
    /#    should NOT do any further expansion (expansion will happen when the
    /#    other class is expanded).
    /#  - each construct is reponsible for invoking expandMeta() on its children
    /#  - if an expandMeta() method creates new sub-constructs, whether or
    /#    not the new construct should have expandMeta() invoked on it depends
    /#    on the following:
    /#     - if the new construct is added to a different class or namespace,
    /#       it should NOT need to be immediately expanded, as it will be
    /#       expanded when that other class/namespace is expanded (as long
    /#       as that other class/namespace hasn't already been expanded).
    /#     - if the new construct is added to the same class, and the new
    /#       construct has an expandMeta() defined, one should in most cases
    /#       invoke expandMeta() on that sub-construct at the time it is created.
    /#
    /#  - NamespaceConstruct.expandMeta(), when invoked on a user-defined
    /#    namespace, creates a test namespace, then expands all subconstructs of
    /#    the user-defined namespace (which populates the test namespace with
    /#    various constructs).
    /#     - At the end of this expandMeta(), the test namespace is expanded via
    /#       a call to expandMeta().
    /#     - No construct needs to expand any autogened subconstruct that is
    /#       placed into the test namespace ... it will be expanded when the test
    /#       namespace is expanded.
    /#
    /#  - ClassConstruct.expandMeta(), when invoked on a user-defined namespace,
    /#    creates a metaclass then expands all subconstructs of the user-defined
    /#    class (which populates the metaclass with meta-level constructs,
    /#    and populates the test namespace with test-level constructs).
    /#     - At the end of ClassConstruct.expandMeta(), the metaclass is
    /#       expanded via another call to expandMeta()
    /#     - No construct needs to expand any autogened subconstruct that is
    /#       placed into the metaclass ... it will be expanded when the metaclass
    /#       is expanded.
    /# TODO(wmh): Switch this to be abstract to force children to
    /# define the method.
    print '%s: %sConstruct.expandMeta() should be defined' % (
      self.kindid(), self.kind().capitalize())

  translate:
    /# Each subclass overrides this method to perform compilation of
    /# the construct associated with the subclass. The code in these
    /# implementations should be baselang-agnostic, but may invoke code
    /# on the BaseLanguageOopl subclass stored in the compiler to
    /# perform baselang-specific actions.
    /# TODO(wmh): Switch this to be abstract to force children to
    /# define the method.
    print '%s: %sConstruct.translateMeta() should be defined' % (
      self.kindid(), self.kind().capitalize())

  scope:

    abstract method kind : str;

    method myclass : metax.oopl.ClassConstruct #:
      Dummy implementation of myclass for use in constructs that appear
      within a class construct but which do not maintain a myclass field.
    scope:
      return None
    test:
    end method myclass;

    method myclassIs #:
      Dummy implementation of myclassIs for use in constructs that appear
      within a class construct but which do not maintain a myclass field.
    params:
      var klass : metax.oopl.ClassConstruct;
    scope:
    test:
    end method myclassIs;

  end Construct _oopl_;

  abstract
  Construct _symbol_ < _oopl_ clsname SymbolConstruct #:
    @_symbol_: Abstract superclass of constructs that maintain a symbol table.
    Maps identifiers to sub-constructs accessible at runtime.
  config:
    Attribute location;
    Attribute comment:;
    Attribute config:;
    Attribute scope:;
  scope:

    abstract method kind : str;

    field symbols : metax.c.SymbolTable #:
      The symbols visible from code within the level of this construct.
      For example:
       - namespaces contain the singleton class instances (MetaFoo, MetaBar,
         etc).  They do NOT contain the class names themselves, as not all
         baselangs treat classes as first-class objects.
       - classes contain all method and field names
          - the symboltable of class B should link to the symboltable of
            class A if B is a child of A.
          - if class symbol tables link to parent class symbol tables, does
            that mean that we need to support multiple parents to also support
            'inheriting' from namespaces? We *could* copy parent data into
            symbol tables at time of linking, but this incurs more space
            overhead and makes it more difficult to support dynamic modification
            of classes at runtime within Meta (if symbol tables inherit,
            dynamically adding a field to a class C means it is immediately
            available in subclasses without us having to update symboltables
            other than C).
       - methods contain all params and local vars not within a lexically
         scoped subblock.
       - lexical blocks contain vars introduced within the block

    lifecycle params:
      var uid : str;
      var parent : metax.attr.ComplexBlock;
      var context : metax.c.Context;
      var precount : int = 0;
    super (uid, parent, context, precount)
    scope:
      /# NOTE: The first arg passed to SymbolTable should be a SymbolTable
      /# instance (for classes, for example, it is the SymbolTable associated
      /# with the parent class). At time of construct creation, we do not
      /# necessarily have such a construct, so the parent field of these symbol
      /# tables must be patched up within *Construct.importMeta() when the
      /# inheritance hierarchy is guaranteed to exist.
      self.symbolsIs(metax.c.SymbolTable(self, None))
    end;

    method registerSymbol #:
      Add a symbol to this construct's symbol table.
    params:
      var name : str #:
        The symbol name.
      var construct : Construct #:
        The construct associated with the symbol.
      var note : str = null #:
        Any human-readable notes associated with the symbol.        
    scope:
      table = self.symbols()
      /# print '%s registering symbol %s = %s' % (self.kindfqn(), name, construct.kindfqn())
      table.register(name, construct, source=self, note=note)
    test:
      test.defineClassAndMethods('py')
      method = test.method
      test.iseq([], sorted(test.klass.symbols().allSymbols()))
      test.klass.registerSymbol(method.id(), method)
      test.iseq(['show'], sorted(test.klass.symbols().allSymbols()))
    end method registerSymbol;

    method symbolNamed : Construct #:
      Obtain a symbol within this construct by name.
    params:
      var name : &str #:
        The name of the symbol desired.
      var kind : str = null #:
        If not null, and the symbol identified by 'name' is not of kind 'kind'
        print an error to the metafile.
    scope:
      result = self.symbols().find(name)
      if kind and (not result or result.kind() != kind):
        metafile = self.metafile()
        if result:
          metafile.error(
            'Expecting %s to be of kind %s' % (result.kindfqn(), kind),
            line=result.primary().line())
        else:
          metafile.error(
            'Expecting to find %s %s within %s' %
            (kind or '', name, self.kindfqn()),
            line=self.primary().line())
        result = None
      return result
    test:
      test.defineClassAndMethods('py')
      method = test.method
      test.isnull(test.klass.symbolNamed('show'))
      test.klass.registerSymbol(method.id(), method)
      test.issame(method, test.klass.symbolNamed('show'))
    end method symbolNamed;

    method establishType : Type #:
      Given the name of a variable within a particular scope that has a
      symbol table, establish the type of that variable.

      Returns:
        null if the variable does not exist in the symboltable.
    params:
      var varname : str #:
        Name of variable.
    scope:
      result = None
      table = self.symbols()
      construct = table.find(varname)
      if construct:
        try:
          result = construct.effectiveType()
        except AttributeError as e:
          print 'WARNING: Failed to find effective type for %s (%s): %s' % (
            construct.kindfqn(), construct.__class__.__name__, str(e))
          result = None
      return result
    test:
    end method establishType;

  end Construct _symbol_;    

  Construct namespace < _symbol_ #:
    @namespace: Represents a 'namespace' construct.

    Implementation issues:
     - Each user class has additional implicit classes associatied with it:
        - a meta class
        - a test class
        - a meta class for the test class
        - a test class for the meta class
     - Notes
        - meta classes do not have meta classes
        - test classes do not have test classes
        - If a user class is in nm.sp.Class
           - the associated test class is in nm.sp_test.ClassTest
           - the associated meta class is currently placed in nm.sp.Class__Meta
             (i.e. metaclasses share the same namespace as the user class,
              but test classes do not).
  assocs:
    std assoc re;
    cls assoc metax.fs.BaseFile;
  config:

    primary
    Attribute namespace : xid = <required> #:
      The name of the namespace.

    secondary
    Attribute preports: : simple = <empty> #:
      Lines to insert before any imports within a namespace.

      This can be used, for example, to modify sys.path in python before
      imports are specified.

    secondary
    Attribute testpreports: : simple = <empty> #:
      Lines to insert before any imports within a test namespace.

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <class|behavior|native|field|method>;

    Template python scope:
      >|WARNING: THIS TEMPLATE NOT CURRENTLY USED
      >|# -*- coding: utf-8 -*-
      >|${comment}
      >|${preports}
      >|${imports}
      >|${classes}
      >|${postamble}
    end Template python;

    Template python_test scope:
      >|WARNING: THIS TEMPLATE NOT CURRENTLY USED
      >|# -*- coding: utf-8 -*-
      >|${comment}
      >|${preports}
      >|${imports}
      >|${classes}
      >|${postamble}
      >|
      >|
      >|if __name__ == '__main__':
      >|  metax.test.main()
    end Template python_test;

  expand:
    /# Expand the namespace:
    /#  - Create test namespace
    /#  - Recurse to children.
    metax.c.D.expand.sinfo(self.kindfqn())
    name = self.id()
    fqn = self.fqn()
    parent = self.parent()
    context = self.context()
    children = self.attrval('scope:')

    if fqn.endswith('_test'):
      /# We are expanding the auto-generated test namespace.
      istest = True
      test_name = None
      testspace = None

    else:
      istest = False
      test_name = name + '_test'

      /# TODO(wmh): Create multiple namespaces, one for each part in
      /# the id. This will be a good transition test for doing something
      /# similar for the user namespace.

      /# Create the test namespace
      secondaries = [
        ('comment:', ['Auto-generated test namespace for %s.' % name]),
        ('scope:', [])
      ]
      testpreports_attr = self.attr('testpreports:', default=None)
      if testpreports_attr:
        secondaries.append(('preports:', testpreports_attr.value()))
      testspace = metax.oopl.NamespaceConstruct.NewFromData(
        /# TODO(wmh): Verify that the implicit testspace should share the
        /# same context as the user namespace.
        test_name, context, parent=parent,
        secondaries=secondaries,
        precount=1,
      )
      self.testspaceIs(testspace)
      self.userspaceIs(self)
      testspace.userspaceIs(self)
      testspace.testspaceIs(testspace)
      if output is not None:
        output.append(testspace)

      /# TODO(wmh): If 'name' (aka self.id()) contains dots, we need to
      /# modify the chain of parents
      /#  - find/create NamespaceConstruct instances for each component of
      /#    the id, with proper parent and a new 'scope:' attribute.
      /#  - unregister self from its current parent, register within the
      /#    new parent, and update self.id().

    /# Register this namespace with the FileConstruct so that ClassConstructs
    /# can properly insert themselves into implicit namespaces.
    /#  - we also create a scope block if one does not exist.
    if self.isUser():
      file_construct = self.ancestor('File')
      file_construct.currentIs(self)
      /# print 'Setting current of %s to %s' % (file_construct.kindfqn(), self.kindfqn())

    /# Invoke expandMeta() on child constructs.
    /#  - we make a copy of children so that we do NOT expand the classes
    /#    added to children by calls to child.expandMeta().
    user_children = list(children)
    for child in user_children:
      /# All constructs within namespace should have a namespace field
      /# within which we can cache the namespace.
      child.namespaceIs(self)

      /# Some child classes need to be expanded now, while others should NOT
      /# be expanded now because they will be expanded later (expanding a
      /# class twice can cause problems).
      expand = True

      /# If the child is a class
      /#  - if we are processing a user-level namespace:
      /#      - the class is either a 'user' class, a 'metauser'
      /#        class or a 'testuser' class.
      /#  - if we are processing a test namespace:
      /#      - the class is either an auto-generated test class associated
      /#        with a user class, or is a user-provided test class.
      /#  - It is important to set variant before invoking expandMeta.
      if child.kind() == 'class':
        if istest:
          /# We are in a autogened testspace.
          /#
          /# The testspace is not expanded until after the user namespace has
          /# been expanded, which means all user classes have been expanded
          /# and the various autogenerated classes have been created. Since
          /# ClassConstruct.expandMeta() sets the 'variant' field of the
          /# autogenerated fields, we can use the variant to distinguish
          /# between autogenerated classes and user-specified test classes.
          /#  - autogen test classes will have variant 'test'
          /#  - user-provided test classes will have variant 'testuser'
          testvariant = child.variant()
          if testvariant == 'test':
            /# auto-generated test class associated with user class.
            pass
          elif testvariant == 'metatest':
            /# autogened metaclass for autogened testclass of user class.
            pass
          elif testvariant == 'testuser':
            /# user-provided test class.
            pass
          elif testvariant == 'testmeta':
            /# autogened testclass for autogened metaclass of user class.
            pass
          else:
            child.write()
            raise metax.c.Error('Unhandled testvariant "%s"' % testvariant)
        else:
          self._setClassVariant(child)

      /# Expand the child (class, etc.)
      if expand:
        child.expandMeta()

    if testspace:
      /# The testspace variable is defined only if we are in the user
      /# namespace and have finished expanding the user code base.  By
      /# invoking expandMeta() on testspace we ensure that any constructs
      /# added to that namespace are properly expanded next.
      testspace.expandMeta()

      if output is not None:
        output.append(testspace)
    metax.c.D.expand.end()

  import:
    metax.c.D.imports.sinfo(self.id())

    /# For namespaces, importMeta is primarily a means to invoke
    /# ClassConstruct.importMeta(), which does more heavy lifting. However,
    /# this method is also where we register each class within the namespace
    /# in the symboltable of the namespace.
    table = self.symbols()
    assert table.construct() is self
    scope, children = self.attrpair('scope:')
    for child in children:
      child.importMeta()

      /# CODETANGLE(highlevel_symbols): For namespaces, what resides in the
      /# symboltable are the names of classes within the namespace, and the
      /# names of other namespaces that have been specified as required.
      /#  - highlevel symbols for classes = class ids (which represent the
      /#    metaclass).
      /#  - baselang symbols for classes = singleton instance of metaclass,
      /#    at least in baselangs without first-class classes).
      /#  - We are currently implementing high-level semantics.
      if child.isClass():
        if not child.isMeta():
          table.register(child.id(), child, source=self)
    metax.c.D.imports.end()

  translate:
    /# Namespace compilation code.
    /#  - compile all classes into separate files
    /#  - for languages that are namespace-primary (e.g. Python), create a
    /#    file representing the namespace (aka module)
    /#  - create a BUILD file containing all targets for building the classes
    /#    in the namespace, and for building the namespace itself.
    metax.c.D.translate.sinfo(self.kindfqn())

    fqn = self.id()
    metac = self.compiler()
    baselang = self.baselang()
    metafile = self.metafile()
    scope_sep = metax.c.Context.Tokens()['scope_sep']
    nameparts = fqn.split(scope_sep)
    nmspbase = nameparts[-1]
    fs = metac.fs()

    /###
    /# Process the scope.  Children include:
    /#   class
    /#   native
    /#   static method (in the future)
    /#   static field (in the future)
    scope, children = self.attrpair('scope:')
    triples = []
    blds = []
    test_classes = []
    namespace_primary = baselang.config('namespace_primary')
    for child in children:
      basefiles = child.translateMeta()
      if len(basefiles) == 0:
        /# We are to ignore this child.
        continue
      assert len(basefiles) == 2
      basefile, bld = basefiles
      if child.kind() == 'class':
        triples.append((child, basefile, bld))
        if child.isTestCase():
          test_classes.append(child)
      if bld is not None:
        /# print '%s = %d' % (basefile.subpath(), len(basefile.contents()))
        assert bld.subpath().endswith('.bld'), bld.subpath()
        blds.append(bld)

    /# Perform baselang-specific namespace processing.
    /#  - instantiate the template representing a namespace in the baselang.
    /#  - most languages do not have syntax for defining a namespace in
    /#    aggregate, but python does.
    /#  - if a baselang doesn't have a namespace-specific syntax, it should
    /#    simply not define a Template in the 'namespace' construct.
    basel = baselang.id()
    if basel == 'python':
      basefiles = self.compilePython(kind='merge', triples=triples)
      bld = basefiles[-1]
      assert bld.subpath().endswith('.bld'), bld.subpath()
      blds.append(bld)

    /# Create the BUILD file
    bfqn = fqn + scope_sep + 'BUILD'
    buildpath = metac.basePath(bfqn)
    contents = baselang.buildPreambleText()
    for bld in blds:
      contents += bld.contents()
    if self.isTest() and not baselang.config('namespace_primary'):
      /# For baselangs that are NOT namespace_primary, the leaf-level
      /# namespace target ('//nm/sp_test:sp_test') is implemented as a
      /# test_suite that invokes each of the per-class test targets.
      /# On the other hand, in namespace_primary languages we do something
      /# different (see the NamespaceConstruct.compilePython.__init__.bld()
      /# method).
      build = {
        'name': nmspbase,
        'tests': [':%s' % k.id() for k in test_classes]}
      contents += '\n' + baselang.formatBuildRule('test_suite', build) + '\n'

    buildfile = metax.fs.BaseFile(buildpath, contents, metafile=metafile)
    metafile.registerFile(buildfile)

    /# TODO(wmh): Now that namespaces are nested within namespaces, determine
    /# whether this should be returning something meaningful!
    return [None, None]

    metax.c.D.translate.end()

  compile:

    metax.c.D.compile.sinfo(self.id())
    /# TODO(wmh): Implement this.
    /# - In python
    /#   - create .pyc file to detect syntax errors
    /#   - can we create optimized .par file?
    /#   - do we generate implicit binaries or invoke 'bazel build' on
    /#     py_binary build targets?
    /# - In Javascript
    /#   - Invoke 'bazel build' on js_closure_binary targets
    /# - In C++
    /#   - Invoke 'bazel build' on cc_binary targets
    scope, children = self.attrpair('scope:')
    for child in children:
      child.compileMeta()
    metax.c.D.compile.end()

  scope:

    meta
    method TestifyName : str #:
      Convert a namespace name to a testspace name.
    params:
      var name : str #:
        relative or fully qualified name of namespace to make a test version of.
    scope:
      return name + '_test'
    end method TestifyName;

    meta
    method UntestifyName : str #:
      Convert a testspace name to a namespace name.
    params:
      var name : str #:
        Relative or fully qualified name of testspace name.
    scope:
      assert name.endswith('_test')
      return name[:-5]
    end method UntestifyName;

    field namespace : metax.oopl.NamespaceConstruct #:
      The parent namespace of this namespace. It is not called parentspace
      or something similar because we need it to match the naming expectations
      of Class.namespace, etc. ... all constructs that can appear within
      a namespace are expected to have a 'namespace' field that represents
      their parent.

    field testspace : metax.oopl.NamespaceConstruct #:
      The NamespaceConstruct instance representing the test namespace associated
      with this namespace.
       - if self is a user namespace, testspace is initialized in expandMeta
         to a new namespace
       - if self is a test namespace, testspace is self
       - note that metaclasses and userclasses share the same namespace.

    field userspace : metax.oopl.NamespaceConstruct #:
      The NamespaceConstruct instance representing the user namespace associated
      with a test namespace.
       - if self is a user namespace, userspace is self
       - if self is a test namespace, userspace is the namespace from which
         it was generated.

    field types : @map<str,TypeWrapper> #:
      Maps a type string whose base is a relative class to TypeWrapper
      instance.

    lifecycle params:
      var id : str;
      var parent : metax.attr.ComplexBlock;
      var context : Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      /# This was an experiment performed on 2017/12/30 to see if we could
      /# get namespaces expanded out so that nm.sp is two namespaces instead
      /# of one. Ran into a few issues:
      /#  - when we do this work in the constructor, code in parseComplexBlock
      /#    after our rejiggering attempts to invoke registerConstruct()
      /#    with the FileConstruct parent (the one we were trying to remap).
      /#  - constructor terminator code starts failing with
      /#       E43: Parsing namespace cards1 but found terminator for namespace demo.cards1
      /#
      /# I'm going to experiment with an alternative solution in which we do
      /# the expansion in NamespaceConstruct.expandMeta() instead.
      if False:
        self.createImplicitParents(id, parent, context)
    end;

    method isNamespace : bool scope:
      return True

    method createImplicitParents : any #:
      An experiment in creating namespace parents. As of 2017/12/30 it is NOT
      being used.  Left in place in case the explorations about implementing
      in expandMeta() don't work out.
    params:
      var id : str;
      var parent : metax.attr.ComplexBlock;
      var context : Context;
    scope:
      if '.' in id:
        /# We perform some implicit work here to create a hierarchy of
        /# NamespaceConstruct instances.
        parts = id.split('.')
        final_nmsp = parts.pop()

        /# The only time we should find a '.' in a namespace id is when
        /# the normal parsing flow of MetaFile.parseConstruct finds
        /# a namespace in a meta source file with nested id.
        /# In such a situation, its parent should be a FileConstruct.
        filecons = parent.parent()
        assert filecons.kind() == 'File'

        /# We need to verify the existence of N-1 ancestor namespaces if there
        /# are N parts in the 'id'. If any ancestor namespace does not already
        /# exist, it is created, inheriting from an appropriate scope: block.
        /#
        /# As an example, suppose id is nm.sp2.sub, and that nm.sp1 is already
        /# registered (so 'nm' already exists), but neither 'sp2' nor 'sub'
        /# are registered.
        /#  - we first find the pre-existing 'nm' within the passed in parent
        /#    block
        /#  - we obtain the 'scope:' block of 'nm'
        /#  - we look for 'sp2', and since it is not present, we create it,
        /#    specifying the block we just looked in as its parent. A scope:
        /#    block is created as part of the creation of 'sp2'.
        /#  - we obtain the 'scope:' block of 'sp2'
        /#  - we are now at the final namespace 'sub', which was what this
        /#    method was invoked to create.  The super call has currently
        /#    set its id to 'nm.sp2.sub', and its parent to the FileConstruct
        /#    scope:.  We update the id to be 'sub', and the parent to be the
        /#    scope: block on 'sp2'
        parent_construct = filecons
        parent_scope = parent
        print 'scope of filecons path: %s' % parent_scope.path()
        for pid in parts:
          child = parent_scope.cons(pid, default=None)
          if child:
            /# Found a pre-existing ancestor namespace
            assert child.kind() == 'namespace'
            parent_construct = child
          else:
            /# There is no ancestor namespace with given name in its parent,
            /# so we create it.
            parent_construct = metax.oopl.NamespaceConstruct.NewFromData(
              pid, context, parent=parent_scope,
              secondaries=[('scope:', [])])
          print 'cons path %s' % parent_construct.path()
          parent_scope = parent_construct.attr('scope:', default=REQUIRED)
          print 'scope path %s' % parent_scope.path()

        /# Now we process the final_nmsp by updating self's id and parent.
        self.idIs(final_nmsp)
        self.parentIs(parent_scope)
        print 'final nmsp path is %s' % self.path()
        print 'HERE with %s vs %s' % (id, self.fqn())
    test:
    end method createImplicitParents;

    method variant : str #:
      One of 'user' or 'test', indicating which namespace this is.
    scope:
      result = 'user' if self.userspace() is self else 'test'
      return result
    test:
    end method variant;

    method isUser : bool #:
      True if this namespace is a user-defined namespace.
    scope:
      return self.variant() == 'user'
    test:
    end method isUser;

    method isTest : bool #:
      True if this namespace is a testspace.
    scope:
      return self.variant() == 'test'
    test:
    end method isTest;

    method registerType #:
      Register a type with this namespace for use in making relative
      types absolute.
    params:
      var wtype : TypeWrapper;
    scope:
      key = wtype.wrappedRaw()
      if key in self._types:
        raise metax.c.InternalError(
          'Reregistering wrapped type %s in %s' % (key, self.id()))
      self._types[key] = wtype
    end method registerType;

    method getType : TypeWrapper #:
      Obtain a previously cached typed
    params:
      var reltypestr : str;
    scope:
      return self._types.get(reltypestr, None)
    end method getType;

    method compilePython : vec<BaseFile> #:
      Compile this namespace into python. Creates __init__.py

      Returns:
       0) basefile : BaseFile
         The __init__.py file
       1) bldfile : BaseFile
         The .__init__.bld file
    params:
      var kind : str = 'merge' #:
        Legal values are:
          merge: merge all class files into __init__.py
          import: import all class files into __init__.py
      var triples : vec<tuple<metax.oopl.ClassConstruct,BaseFile,BaseFile>> = null #:
        Each element is a triple containing a class construct, the
        BaseFile containing the class code, and a BaseFile containing
        the .bld fragment.
    scope:
      fqn = self.id()
      metac = self.compiler()
      baselang = self.baselang()
      metafile = self.metafile()
      variant = self.variant()
      scope_sep = metax.c.Context.Tokens()['scope_sep']
      nameparts = fqn.split(scope_sep)
      nmspbase = nameparts[-1]
      fs = metac.fs()
      /# TODO(wmh): How to establish the actual width?
      width = 80 - 0
      basesuffix = baselang.suffix()
      fqn += scope_sep + '__init__'

      /# comments : vec<str>
      /#   Documentation for the namespace.
      comment_attr, comment = self.attrpair('comment:', default=None)
      comment = baselang.formatComment(comment, width=width)

      /# preports : vec<str>
      /#   This is arbitrary baselang code that should appear before anything
      /#   else in the namespace.  Used to modify path, perform special actions
      /#   like modifying encoding type, etc.
      preports_attr = self.attr('preports:', default=None)
      preports = baselang.simpleToBase(preports_attr)

      /# prelines: vec<str>
      /#   The total set of lines added before classes in the merged
      /#   namespace.
      prelines = ['# -*- coding: utf-8 -*-'] + comment + preports

      /# classes : vec<str>
      /#   The baselang code for importing the classes.
      scope = self.attr('scope:')
      if kind == 'merge':
        mapfile = metax.c.MapFile(
          metac.basePath(fqn, prefix='.', suffix=basesuffix + '.map'),
          fs.realpath(fs.abspath(metafile.path())),
          [])
        all_lines, targets = self._mergeClassesPython(
          triples, mapfile, prelines)
      elif kind == 'import':
        all_lines, targets = self._importClassesPython(triples)
      else:
        raise metax.c.Error(
          'NamespaceConstruct.compilePython: Invalid kind "%s"' % kind)

      /# IMPORTANT: We are currently NOT using the Template constructs
      /# in the namespace construct for python.  They should either
      /# be removed, or we should move to a mechanism whereby we do use
      /# them.  The difficulty is in getting the line numbers from the
      /# mapfile initialized by _mergeClassesPython() to reflect reality,
      /# but it would certainly be possible with a bit of effort.
      if self.isTest():
        all_lines.extend([
          '',
          '',
          "if __name__ == '__main__':",
          "  metax.test.main()"
        ])

      else:
        /# Experimenting with the introduction of a 'Meta()' method in each
        /# user namespace. TODO(wmh): Why did I introduce this???

        /# CODETANGLE(implicit_objectmeta)
        if False:
          all_lines.append('')
          all_lines.append('')
          all_lines.append('def Meta():')
          all_lines.append('  return metax.root.MetaObject')

      basefile = metax.fs.BaseFile(
        metac.basePath(fqn, suffix=basesuffix),
        '\n'.join(all_lines) + '\n', metafile=metafile, mapfile=mapfile)
      metafile.registerFile(basefile)

      /# Create the .__init__.bld file:
      bldpath = metac.basePath(fqn, prefix='.', suffix='.bld')
      istest = self.isTest()
      if False:
        /# Useful during debugging.
        print bldpath
        print '  Targets:'
        for target in targets:
          print '    ' + target

      rule, build_data = baselang.createBuildFragment(
        self, targets, test=istest,
        name=nmspbase, src='__init__.py')
      if istest:
        /# Bazel expects a py_test with name 'cards_test' to have its source
        /# in 'cards_test.py', but in our case it is in '__init__.py'. We
        /# can fix this by adding a 'main' target.
        build_data['main'] = '__init__.py'
      bldfile = None
      if rule is not None:
        fragment = baselang.formatBuildRule(rule, build_data)
        bldfile = metax.fs.BaseFile(bldpath, '\n' + fragment + '\n', metafile=metafile)
        metafile.registerFile(bldfile)

      /# Ensure that all package directories have a __init__.py file.
      pqn = ''
      for base in nameparts[:-1]:
        if pqn: pqn += scope_sep
        pqn += base
        subpath = fs.join(metac.basePath(pqn), '__init__.py')
        initpath, _ = fs.subfilePath(subpath)
        if not fs.exists(initpath):
          initfile = metax.fs.BaseFile(subpath, '', metafile=metafile)
          metafile.registerFile(initfile)

      return basefile, bldfile
    test:
    end method compilePython;


    method _setClassVariant : str #:
      Set the variant field of a class construct.
    params:
      var child : Construct #:
        The child of this namespace whose variant is to be set.
    scope:
      /# We are in the user-provided namespace. The class construct
      /# is one of:
      /#   user:
      /#     a standard user-provided class
      /#   testuser:
      /#     a user-provided class to put in the autogened test namespace
      /#   metauser:
      /#     a user-provided metaclass
      location = child.attrval('location', default=metax.c.LOOKUP)
      variant = 'user'
      if location != 'user':
        variant = location + variant
      child.variantIs(variant)
      return variant
    test:
    end method _setClassVariant;

    method _mergeClassesPython : tuple<vec<str>,vec<str>> #:
      Generate the lines in a namespace file by merging all class files.

      Returns:
        0. The list of lines in the namespace file
        1. The list of build targets needed by the namespace.
    params:
      var triples : vec<tuple<metax.oopl.ClassConstruct,BaseFile,BaseFile>> #:
        Each element is a triple containing a class construct, the
        BaseFile containing the class code, and a BaseFile containing
        the .bld fragment.
      var mapfile : MapFile #:
        The merged mapfile across all base files.
      var prelines : vec<str> #:
        The list of lines appearing before imports in the namespace
        (e.g. comment, preports, etc.)
    scope:
      debug = 0

      /# TODO(wmh): Move elsewhere
      impre = re.compile(
        r'import\s+(?P<import>\S+)'
        r'(?: as (?P<alias>\S+))?'
        r'(?:\s*#\s*target=(?P<target>\S+))?')

      /# TODO(wmh): Make these less fragile. Any changes to the 'End Imports'
      /# or 'Start Harness' lines in templates will raise an Error.
      end_start = '##########  End Imports  ##########\n'
      start_end = '########## Start Harness ##########\n'

      fqn = self.id()

      /# chunks contains (offset, lines) pairs
      chunks = []

      /# The class iniitalization lines.
      clinit_lines = []

      /# imports : vec<str>
      /#  - Accumulates all the import lines from individual classes, to be
      /#    inserted at the top of the namespace file. Preserves order of
      /#    imports (based on first time seen), hence the vec instead of set.
      imports = []
      /#  - Individual import statements may have ' # target=' comments
      /#    specifying associated targets. These are extracted.
      targets = set()
      for klass, basefile, bldfild in triples:
        /# We merge all of the class files into the __init__.py.
        /#  - if we are defining namespace nm.sp, we need to find all
        /#    references to nm.sp.<class> and replace them with <class>
        /#    (alternatively, we can ensure that nm.sp is available within
        /#    nm.sp).
        /#      - IMPORTANT: replacing nm.sp.<class> with <class> is
        /#        non-trivial, as we do NOT want to replace <class> within
        /#        strings, only when it is an actual class reference. Better
        /#        to get 'nm.sp.<class>' working within <class>. Disabling
        /#        replacement for now.
        /#  - the per-class file maps need to be merged and modified into
        /#    .__init__.py.map
        r = re.compile(
          r'([^a-zA-Z0-9_])%s\.([a-zA-Z0-9_]+)' % re.escape(fqn))
        /# DISABLED 2017-12-23 as flawed (replaces occurences in strings,
        /# which breaks metax.root.Object.Resource(..., fqn='...').
        /# contents = r.sub(r'\1\2', basefile.contents().rstrip())
        contents = basefile.contents().rstrip()

        /# We check if the last line is an invocation of Meta__Initialize().
        /#  - if so, we remove it from end of contents and add it to clinit_lines
        /#  - by inserting all such calls at the bottom of the namespace file,
        /#    all classes in the namespace are defined before any class
        /#    initialization occurs, which means the class initializers can
        /#    rely on all other classes in the namespace.
        ridx = contents.rfind('\n')
        last_line = contents[ridx+1:]
        if last_line.endswith('.Meta__Initialize()'):
          contents = contents[:ridx]
          clinit_lines.append(last_line)

        istestcase = klass.isTestCase()
        submapfile = basefile.mapfile()

        /# All python class files are required to have a line containing
        /# end_start.
        start_index = contents.find(end_start)
        if start_index == -1:
          raise metax.c.Error('Failed to find "%s" in\n%s' % (end_start, contents))
        start_index += len(end_start)
        assert contents[start_index-1] == '\n'
        import_lines = contents[:start_index-1].split('\n')
        start_removed = len(import_lines)
        for line in import_lines:
          /# Parse the import line (into import and target).
          /#  - May need to generalize to support
          /#      'from nm.sp import X as Y'
          /#  - The order in which imports appear is sometimes critically
          /#    important, so we maintain the order (based on when first seen).
          if line and line[0] == '#': continue
          m = impre.match(line)
          if m:
            impline = 'import %s' % m.group('import')
            alias = m.group('alias')
            if alias:
              impline += ' as ' + alias
            if impline not in imports:
              imports.append(impline)
            target = m.group('target')
            if target and target != 'None':
              targets.add(target)
          else:
            raise metax.c.Error('Not currently supporting imports of form "%s"' % line)

        if debug > 3:
          print '#' * 80
          print 'Removed from start'
          sys.stdout.write(contents[:start_index])
          print '-' * 80

        /# All python test class files are required to have a line containing
        /# start_end.
        if istestcase:
          /# The class in question is a test class, so we require it to have
          /# the end_start and start_end lines.
          end_index = contents.rfind(start_end)
          if end_index == -1:
            raise metax.c.Error('Failed to find "%s" in\n%s' % (start_end, contents))
          assert contents[end_index] == '#', (
            'Expecting index %d of contents to be "#" not "%s"' %
            (end_index, contents[end_index-5:end_index+5]))
          end_removed = contents[end_index:].count('\n')
          if debug > 3:
            print '#' * 80
            print 'Removed from end'
            print contents[end_index:]
            print '=' * 80
          /# By decrementing end_index to position ourselves on the newline,
          /# we ensure that when we split the resulting content into lines,
          /# we do not introduce a spurious newline at the end.
          end_index -= 1
          assert contents[end_index] == '\n'
        else:
          end_index = len(contents)
          end_removed = 0

        lines = contents[start_index:end_index].split('\n')
        chunks.append((start_removed, lines, submapfile))

        if debug > 2:
          print '#' * 80
          print contents
        if debug > 1:
          print '-' * 80
        if debug:
          fs = self.compiler().fs()
          print '%-25s: removed %d start lines and %d end lines leaving %d lines' % (
            fs.basename(basefile.subpath()), start_removed, end_removed, len(lines))
        if debug > 1:
          submapfile.serialize()

      /# We add some special importation code to ensure that one can access all
      /# classes within the namespace fully-qualified (by default, python does
      /# not add 'sp' to 'nm' until after 'nm.sp' has been parsed).
      all_lines = prelines + sorted(imports)
      try:
        my_index = all_lines.index('import ' + fqn)
        /# We need to add some lines of code after myindex to ensure the module
        /# is available fully qualified. It is important that this special
        /# code occur before we import any namespaces within this namespace,
        /# so that they too have access to the fully qualified namespace (so
        /# we cannot insert the special code at the end of all_lines).
        new_lines = []
        new_lines.append('try:')
        new_lines.append('  import ' + fqn)
        new_lines.append('except ImportError:')
        new_lines.append('  pass')
        parent_nmsp, base_nmsp = fqn.rsplit('.', 1)
        new_lines.append(
          "if not getattr(%s, '%s', None):" % (parent_nmsp, base_nmsp))
        if 'import sys' not in new_lines:
          new_lines.append('  import sys')
        new_lines.append('  %s = sys.modules[__name__]' % fqn)
        n = len(all_lines)
        my_index += 1
        all_lines = all_lines[:my_index-1] + new_lines + all_lines[my_index:]
        assert len(all_lines) == n + len(new_lines) - 1
      except ValueError:
        pass

      /# Now obtain the merged collection of lines, and associated mapfile.
      /#  - starts with the sorted list of imports
      /#  - we add the (stripped) lines for each class in sequence. The
      /#    final mapfile adds the contents of the associated submapfile with
      /#    the following adjustments to baseline nums in the submapfile
      /#     - subtract 'removed' lines
      /#     - add current length of 'all_lines'
      for removed, lines, submapfile in chunks:
        mapfile.addSubFile(submapfile, len(all_lines) - removed)
        all_lines.extend(lines)

      /# We add the class initialization calls here.
      all_lines.append('')
      all_lines.append('# Class initialization methods')
      all_lines.extend(clinit_lines)

      parts = fqn.split('.')
      mytarget = '//%s:%s' % (fqn.replace('.', '/'), parts[-1])
      targets.discard(mytarget)

      return (all_lines, sorted(targets))
    test:
    end method _mergeClassesPython;

    method _importClassesPython : tuple<vec<str>,vec<str>> #:
      Generate the lines in a namespace file by importing class files.

      Returns:
        0. The list of lines in the namespace file
        1. The list of build targets needed by the namespace.
    params:
      var triples : vec<tuple<metax.oopl.ClassConstruct,BaseFile,BaseFile>> = null #:
        Each element is a triple containing a class construct, the
        BaseFile containing the class code, and a BaseFile containing
        the .bld fragment.
    scope:
      classes = []
      targets = []
      for klass, basefile, bldfild in triples:
        /# We are to import each class file into __init__.py
        /#  - this is currently problematic. Suppose we have classes A and B
        /#    and nm/sp/__init__.py contains
        /#      from .A import *
        /#      from .B import *
        /#    then the following:
        /#      import nm.sp.A
        /#    will yield the *module* nm.sp.A (the class is at nm.sp.A.A).
        /#    Need to learn more about how to import symbols, the use
        /#    of __all_, relative vs absolute imports, etc.
        classes.append('from .%s import *' % klass.id())
        targets.append(':' + klass.id())
      return (classes, targets)
    test:
    end method _importClassesPython;

  end Construct namespace;
  abstract
  Construct _classic_ < _symbol_ clsname ClassicConstruct #:
    @_classic_: Abstract parent of all constructs that appear within a class.

    Includes field, method, lifecycle, behavior, entry and class.

    Note that there are various constructs that can appear within the 'scope:'
    of a class that are NOT subclasses of ClassicConstruct, including remark,
    category and native (they are more general, and do not need a 'myclass'
    field).
  config:

    Attribute location;

    feature
    Attribute kind : <instance|static> = instance #:
      Each ${kind} comes in a variety of levels.
    config:
      FeatureValue instance #:
        The ${kind} is defined on instances of the class.
      FeatureValue static #:
        The ${kind} is defined within the scope of the class but does not
        reside in the instance or metaclass (and is not inherited into
        child classes).                                             
    end Attribute kind;

    Attribute comment:;
    Attribute config:;
    Attribute scope:;

  scope:

    field myclass : metax.oopl.ClassConstruct #:
      The class this construct belongs to.

    abstract method kind : str;

    postx
    method changeParent #:
      Move myself out of my current parent into the new parent.
    params:
      var new_parent : metax.attr.ComplexBlock #:
        The parent to move this construct into.
      var position : str = null #:
        The name of some construct in the new parent preceeded by '+'
        (insert after) or '-' (insert before).  If the position is '+' or
        null, insert at end.  If the position is '-', insert at beginning.
    super (new_parent, position=position)
    scope:
      oldklass = self.myclass()
      klass = new_parent.parent().ancestor('class', proper=False)
      self.myclassIs(klass)
      /# print '**** NOTE: Changed parent of %s which changes class from %s to %s' % (self.fqn(), oldklass.fqn() if oldklass else None, klass.fqn())
    end method changeParent;

    method updateClass : tuple<metax.oopl.ClassConstruct,bool> #:
      Decide if this construct needs to be moved to an auto-generated class,
      and if so, move it.

      SideEffects:
        The myclass. field is updated.

      Returns:
        0. The class of the construct after the move (may or may not change).
        1. True if the construct was moved to a different class, false if not.
    scope:
      myclass = self.ancestor('class')
      if myclass is None:
        /# This particular instance of the classic construct is NOT within a
        /# class (e.g. directly within a namespace).
        return (None, False)

      metafile = myclass.metafile()
      assert myclass is not None
      variant = myclass.variant()
      moved = False
      autogen = myclass.autogenInfo()

      if variant in ('user', 'testuser'):
        /# This is the only variant within which we pay attention to the
        /# 'location' feature attribute:
        /#   - fields with location 'test' are moved to the test class
        /#   - fields with location 'meta' are moved to the meta class.
        /# TODO(wmh): For other variants, if the location is explicitly
        /# provided and different from the default, report a warning/error?
        location = self.attrval('location')

        if location == 'user':
          /# Everything is where it should be
          pass

        elif location == 'test':
          /# Move this construct to the test class
          testclass = myclass.testclass()
          moved = True
          if autogen['test']:
            assert testclass is not None
            testscope = testclass.attr('scope:')
            self.changeParent(testscope)
            myclass = self.myclass()
            assert myclass is testclass
          else:
            assert testclass is None
            metafile.error(
              'Cannot specify test %s when test class is disabled' %
              self.kindfqn(),
              line=self.primary().line())

        elif location == 'meta':
          /# Move this field to the meta class
          metaclass = myclass.metaclass()
          moved = True
          if autogen['meta']:
            assert metaclass is not None
            metascope = metaclass.attr('scope:')
            self.changeParent(metascope)
            myclass = self.myclass()
            assert myclass is metaclass
          else:
            assert metaclass is None
            metafile.error(
              'Cannot specify meta %s when meta class is disabled' %
              self.kindfqn(),
              line=self.primary().line())

        self.myclassIs(myclass)

      else:
        /# If this construct is already in a non-user class, the myclass
        /# field should already be initialized.
        /#  - TODO(wmh): Verify this is always true (and if not, fix it,
        /#    either here or upstream).
        /#  - NOTE(wmh): As of 2017/12/04 the above hypothesis is proved
        /#    incorrect ... classes with location 'test' have variant 'testuser'
        /#    and myclass is not initialized.
        /# print 'HERE with %s and %s and %s' % (self.fqn(), self.myclass(), myclass.fqn())
        assert self.myclass() is myclass

      return myclass, moved
    test:
    end method updateClass;

  end Construct _classic_;

  Construct class < _classic_ #:
    @class: Represents a 'class' construct.

    The userclass, testclass and metaclass fields are set in expandMeta:

                                            class
                   -----------------------------------------------------------
       variant     user  under       test            meta
       -------     ----  -----       ----            ----
       user        Name  null        NameTest        Name__Meta
       test        Name  Name        null            NameTest__Meta
       testmeta    Name  Name__Meta  null            null
       testuser    null  null        null            null
       meta        Name  Name        Name__MetaTest  null
       metatest    Name  NameTest    null            null
       metauser    null  null        null            null

     TODO(wmh): We should probably support test classes on metauser classes
     (e.g. create a testclass for metauser classes).
  config:

    Attribute location;

    feature
    Attribute visibility : <public|private> = public #:
      The visibility of the class.
    config:
      FeatureValue public #:
        The class is visible everywhere.
      FeatureValue private #:
        The class is only visible to other classes in same namespace.
        TODO(wmh): Should this be package instead of private?
    end Attribute visibility;

    feature
    Attribute autogen : <std|nometa|notest|nometanotest> = std #:
      Controls which auto-generated classes are generated.
      TODO(wmh): This should be a regexp-defined attribute of the form:
        '^(?:[+-](?:meta|test))+$'
      with the default being '+meta+test'
    config:
      FeatureValue std #:
        If the class has location=user
         - a metaclass is generated
         - a testlass is generated
        If the class has location=meta
         - a testclass is generated
        If the class has location=test
         - a metaclass is generated
      FeatureValue nometa #:
        No meta class is generated
      FeatureValue notest #:
        No test class is generated
      FeatureValue nometanotest #:
        No test class is generated
    end Attribute autogen;

    feature
    Attribute presence : <concrete|abstract> = concrete #:
      Dictates whether this class can be instantiated or not.
    config:
      FeatureValue abstract #:
        One cannot create instances of an abstract class, but other classes
        can inherit from it.
      FeatureValue concrete #:
        A class of which instances can be created.
    end Attribute presence;

    feature
    Attribute span : <general|specific> = general #:
      Whether the class should be defined in all base languages or only those
      with a scope block.
    config:
      FeatureValue specific #:
        The compiler does not generate a class for baselangs without a scope
        block.
      FeatureValue general #:
        The compiler reports a warning if the class is being compiled into
        a baselang and does not have a scope block for that baselang.
    end Attribute span;

    primary
    Attribute class : id = <required> #:
      The name of the class.

    secondary
    Attribute parent : word = metax.root.Object aliases <<> #:
      The parent class.  If multiple parents are needed, use the block-valued
      parent: construct.  This is an xid, optionally preceeded by '^' to
      indicate that the referenced class was not generated by Meta and
      that it is fully qualified as-is.

    secondary
    Attribute testparent : word = <special> aliases <<<> #:
      The parent class of the test class associated with this user class. This
      is an xid, optionally preceeded by '^' to indicate that the referenced
      class was not generated by Meta and that it is fully qualified as-is.
      Alternatively, it can be the value '<special>', which indicates that the
      default testparent should be heuristically determined (if a TestCase class
      exists in the same namespace, it is used, otherwise metax.test.TestCase
      is used).

    secondary
    Attribute metaparent : word = <special> aliases <<<<> #:
      The parent metaclass of the metaclass associated with this user class.
      This is an xid, optionally preceeded by '^' to indicate that the
      referenced class was not generated by Meta and that it is fully qualified
      as-is. Alternatively, it can be the value '<special>', which indicates
      that the default metaparent should be heuristically determined. This
      attribute is necessary in situations where a class is inheriting from a
      class defined outside of Meta that has a metaclass.

    secondary
    Attribute associations: : complex = <empty> aliases <assocs:> #:
      The collection of assoc and resource instances needed by this class.
    children <assoc|resource|remark>;

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <lifecycle|method|field|native|category|remark|command>;

    secondary
    Attribute flags: : complex = <empty> children <flag> #:
      The collection of flags used by this class.

    Template python scope:
      >|${imports}
      >|##########  End Imports  ##########
      >|${preclass}
      >|
      >|
      >|class ${class}(${parentspec}):
      >|  ${comment}
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|${postclass}
    end Template python;

    Template python_test scope:
      >|${imports}
      >|##########  End Imports  ##########
      >|${preclass}
      >|
      >|
      >|class ${class}(${parentspec}):
      >|  ${comment}
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|${postclass}
      >|########## Start Harness ##########
      >|
      >|
      >|if __name__ == '__main__':
      >|  metax.test.main()
    end Template python_test;

    Template javascript #:
      How to define javascript classes using ES2015 class sytnax and goog.module().
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
      https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide
    scope:
      >|${overview}
      >|goog.module('${fqcn}');
      >|goog.module.declareLegacyNamespace();
      >|${imports}
      >|${preclass}
      >|
      >|${comment}
      >|class ${class}${parentspec} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|}
      >|${postclass}
    end Template javascript;

    Template javascript_test #:
      How to define javascript test classes using ES2015 class sytnax.
    scope:
      >|${overview}
      >|goog.module('${fqcn}');
      >|goog.setTestOnly('${fqcn}');
      >|goog.module.declareLegacyNamespace();
      >|${imports}
      >|${preclass}
      >|
      >|${comment}
      >|class ${class}${parentspec} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|}
      >|${postclass}
    end Template javascript_test;

    Template cpp_decl scope:
      >|#ifndef ${namespace_under}_${class}_h
      >|#define ${namespace_under}_${class}_h 1
      >|
      >|${imports}
      >|
      >|${namespace_spec}
      >|${preclass}
      >|
      >|${comment}
      >|class ${class}${parentspec} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|};
      >|${postclass}
      >|
      >|${end_namespace}
      >|
      >|${imposts}
      >|#endif // ${namespace_under}_${class}_h
    end Template cpp_decl;

    Template cpp_defn scope:
      >|#include "${header}"
      >|${imports_local}
      >|
      >|${namespace_spec}
      >|${preclass_local}
      >|${scope}
      >|${postclass_local}
      >|
      >|${end_namespace}
      >|${imposts_local}
    end Template cpp_defn;

    Template cpp_test_decl scope:
      >|#ifndef ${namespace_under}_${class}_h
      >|#define ${namespace_under}_${class}_h 1
      >|
      >|${imports}
      >|
      >|${namespace_spec}
      >|${preclass}
      >|
      >|${comment}
      >|class ${class}${parentspec} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|};
      >|${postclass}
      >|
      >|${end_namespace}
      >|
      >|#endif // ${namespace_under}_${class}_h
    end Template cpp_test_decl;

    Template cpp_test_defn scope:
      >|#include "${header}"
      >|${imports_local}
      >|
      >|${namespace_spec}
      >|${preclass_local}
      >|
      >|${scope}
      >|
      >|${postclass_local}
      >|
      >|${end_namespace}
      >|${imposts_local}
      >|
      >|
      >|int main(int argc, char* argv[]) {
      >|  ::testing::InitGoogleTest(&argc, argv);
      >|  return RUN_ALL_TESTS();
      >|}
    end Template cpp_test_defn;

  expand:
    /# Expansion depends on variant
    /#  - user:
    /#     - create test class, meta class, test metaclass and meta testclass.
    /#        - test class: nm.sp_test.ClassTest
    /#        - meta class: nm.sp.Class__Meta
    /#        - test class for metaclass: nm.sp.Class__MetaTest
    /#        - meta class for testclass: nm.sp_test.ClassTest__Meta
    /#     - expand children
    /#  - meta or test or metatest or testmeta or metauser:
    /#     - expand children
    /#  - testuser:
    /#     - if we are currently in the user namespace
    /#        - move the class into the test namespace
    /#        - DO NOT expand children, do not create initializer, etc.
    /#     - else (we are in the testspace)
    /#       - expand children
    metax.c.D.expand.sinfo('%s variant %s' % (self.kindfqn(), self.variant()))

    name = self.id()
    fqn = self.fqn()
    variant = self.variant()
    baselang = self.baselang()
    basel = baselang.id()
    metafile = self.metafile()
    metac = metafile.compiler()
    context = self.context()
    namespace = self.namespace()
    incnmsp = namespace.fqn() == 'metax.c'

    /# We first parse the parent specification into self.parentclasses().
    /#  - TODO(wmh): Support 'parents:' in addition to 'parent' (along
    /#    with 'testparents:' and 'metaparents:')
    /#  - It is important that we initialized parentclasses() before
    /#    moving on to variant-specific functionality because some of
    /#    that code needs to call metaClassInfo() which relies on
    /#    parentclasses() being initialized.
    /#  - This is somewhat problematic because it means that user-provided
    /#    test classes will execute this code twice (once when expanding the
    /#    class within the user namespace, and again when it is expanded
    /#    in the test namespace).
    self.initParentClasses()

    newclasses = []
    metaclass = None
    proceed = None

    scope, children = self.attrpair('scope:', default=None)
    span = self.attrval('span')
    presence = self.attrval('presence')
    autogen = self.autogenInfo()

    if not scope and span != 'specific' and presence != 'abstract':
      if self.isErrorClass():
        /# It is common for error classes to not need a scope. We create
        /# a dummy empty scope.
        /# TODO(wmh): There are probably other examples of classes not
        /# needing scopes ... do we want to generalize, or is this the only
        /# case that is commonly without a scope?
        children = []
        scope = metax.attr.ComplexBlock(
          self, 'scope:', children, line=self.primary().line())
        self.registerAttribute(scope)
        /# TODO(wmh): By inserting this scope, canonicalization will produce
        /# the scope unless we somehow mark it as implicit and avoid
        /# printing implicit attributes during canonicalization.
        proceed = True
      else:
        metafile.error('The concrete general %s has no scope' % self.kindfqn())
        proceed = False

    if not scope and span == 'specific':
      /# This class is only defined for baselangs that provide a scope, and
      /# no scope is present, so we remove the class entirely.
      /#  - TODO(wmh): Is complete removal the right approach? Or should we
      /#    introduce a 'disabled' field in class constructs instead?
      self.parent().unregisterConstruct(self)
      proceed = False

    elif variant is None:
      raise metax.c.Error('ClassConstruct.expandMeta: invoked before variant set')

    elif variant == 'user':
      /# We are in the user-provided class.
      /# userclass = self.userclass()
      /# testclass = self.testclass()
      /# metaclass = self.metaclass()

      /# We disallow user-level classes from starting or ending with
      /# 'Meta' because:
      /#   - <Class>Meta represents the metaclass of <Class>
      /#   - Meta<Class> represents the singleton instance of <Class>Meta
      /#   - we don't want to introduce conflicts between user-defined
      /#     classes starting/ending with 'Meta' and the above symbols.
      /# CODE TANGLE: meta-disallowed
      if name.endswith('Meta') and not incnmsp:
        metafile.warning(
          'User-level class "%s" should not end with "Meta"' % name,
          line=self.primary().line())
      if name.startswith('Meta') and not incnmsp:
        metafile.info(
          'User-level class "%s" should not start with "Meta"' % name,
          line=self.primary().line())

      testspace, testblock, testname, testparent = self.testClassInfo()
      if autogen['test']:
        /# Create the auto-generated test class
        /#  - we also explicitly create an initializer, as we need to pass in
        /#    a special name parameter.
        /#  - TODO(wmh): verify there isn't a race-condition here if
        /#    the special TestCase class is defined with location 'test' in
        /#    user code. Does it need to appear BEFORE the classes it is
        /#    meant to affect?
        testclass = metax.oopl.ClassConstruct.NewFromData(
          /# TODO(wmh): Verify that test class should share same context as
          /# user class.
          testname, context, parent=testblock,
          features=[('location', 'test')],
          secondaries=[
            ('parent', testparent),
            /# TODO(wmh): Test classes can have metaclasses ... what should
            /# the metaparent of the testclass be?
            /# ('metaparent', '?'),
            ('assocs:', []),
            ('comment:', ['Auto-generated test class for ' + fqn]),
            ('scope:', [])
          ],
          precount=1)

        /# Create the auto-generated metaclass for the auto-generated testclass
        if metax.c.Compiler.IMPL['metatestclass']:
          metatestname = metax.oopl.ClassConstruct.MetaifyName(testname)
          metatestblock = testblock
          metatestparent = metax.oopl.ClassConstruct.MetaifyName(testparent)
          metatestparent2 = metax.oopl.ClassConstruct.MetaifyName('metax.test.TestCase')
          /# print 'For %s\n  %s\n  %s' % (self.kindfqn(), metatestparent, metatestparent2)
          metatestclass = metax.oopl.ClassConstruct.NewFromData(
            /# TODO(wmh): Verify that metatest class should share same context as
            /# user class.
            metatestname, context, parent=metatestblock,
            features=[('location', 'meta')],
            secondaries=[
              ('parent', metatestparent),
              ('comment:',
               ['Auto-generated meta class for auto-generated test class ' + testclass.fqn()]),
              ('scope:', []),
            ],
            position='-' + testname,
            precount=1,
            primary_line=self.primary().line(),
          )
        else:
          metatestclass = None
      else:
        testclass = None
        metatestclass = None

      /# Create the auto-generated meta class
      if autogen['meta']:
        metaclass = self.generateMetaClass()
        metaname = metaclass.id()

        if not metax.c.Compiler.IMPL['testmetaclass']:
          /# There is very little benefit to creating an auto-generated test
          /# class associated with the auto-generated meta-class of a user
          /# class. Rather, methods defined on metaclasses can have their test
          /# methods defined on the auto-generated test class of the user
          /# class. This makes things conceptually simpler without loss of
          /# generality.
          testmetaclass = None
        else:
          /# Create the auto-generated testclass for the auto-generated metaclass
          testmetaname = metax.oopl.ClassConstruct.TestifyName(metaname)
          testmetablock = testblock
          testmetaparent = testparent
          testmetaclass = metax.oopl.ClassConstruct.NewFromData(
            /# TODO(wmh): Verify that test class should share same context as
            /# user class.
            testmetaname, context, parent=testmetablock,
            features=[('location', 'test')],
            secondaries=[
              ('parent', testmetaparent),
              ('comment:',
               ['Auto-generated test class for auto-generated meta class %s.' %
                metaclass.fqn()]),
              ('scope:', []),
            ],
            precount=1)
      else:
        metaclass = None
        testmetaclass = None

      /# Move/copy assoc constructs to test/meta classes.
      assocs_attr, assocs = self.attrpair('associations:', default=None)
      if assocs_attr:
        test_assocs = testclass.attr('associations:') if testclass else None
        meta_assocs = metaclass.attr('associations:') if metaclass else None
        /# NOTE(wmh): Important to iterate over list(assocs) because we may
        /# modify 'assocs' by moving constructs to test_assocs or meta_assocs.
        for dep in list(assocs):
          /# Each dep is either 'assoc' or 'resource'. Both constructs
          /# have a 'location' field that indicates where the construct
          /# belongs. The 'assoc' location is special in that 'usertest'
          /# is also meaningful.
          /# TODO(wmh): implement this as a multi-valued feature value
          /# instead).
          akind = dep.kind()
          if akind == 'remark': continue
          aloc = dep.attrval('location')

          if aloc == 'user':
            /# Things are fine just as they are.
            pass
          elif aloc == 'test':
            if test_assocs:
              dep.changeParent(test_assocs)
            else:
              metafile.error(
                'Cannot specify location test for construct %s when '
                'testclass disabled' % kind,
                line=dep.primary().line())
          elif aloc == 'meta':
            if meta_assocs:
              dep.changeParent(meta_assocs)
            else:
              metafile.error(
                'Cannot specify location meta for construct %s when '
                'metaclass disabled' % kind,
                line=dep.primary().line())
          elif aloc == 'usertest':
            if akind == 'resource':
              metafile.error(
                'resource constructs do not support location %s' % aloc,
                line=dep.primary().line())
            else:
              /# This is a special case ... we need the construct to stay
              /# in the user class but also appear in the test class. We
              /# clone and register.
              if test_assocs:
                testdep = dep.clone(test_assocs)
                /# TODO(wmh): Consider deleting the 'location' attribute
                /# from testdep, but it is actually fine as-is (not used
                /# in translateMeta()) and may serve a useful purpose.
                test_assocs.registerConstruct(testdep)
              else:
                metafile.error(
                  'Cannot specify location usertest for construct %s when '
                  'testclass disabled' % kind,
                  line=dep.primary().line())

          else:
            raise metax.c.InternalError('Invalid assocs child kind %s' % kind)

      /# Initialize class fields of user class
      self.userclassIs(self)
      self.underclassIs(None)
      self.testclassIs(testclass)
      self.metaclassIs(metaclass)

      /# Initialize class fields of test class
      if testclass:
        testclass.variantIs('test')
        testclass.userclassIs(self)
        testclass.underclassIs(self)
        testclass.testclassIs(None)
        testclass.metaclassIs(metatestclass)
        testclass.namespaceIs(testspace)
        /#newclasses.append(testclass)

      /# Initialize class fields of meta class
      if metaclass:
        metaclass.variantIs('meta')
        metaclass.userclassIs(self)
        metaclass.underclassIs(self)
        if metax.c.Compiler.IMPL['testmetaclass']:
          metaclass.testclassIs(testmetaclass)
        else:
          /# We are not generating test clases for metaclasses of userclasses,
          /# and are instead adding test methods for meta-methods to the
          /# testclass of the userclass.
          metaclass.testclassIs(testclass)
        metaclass.metaclassIs(None)
        metaclass.namespaceIs(namespace)
        newclasses.append(metaclass)

      /# Initialize class fields of metatest class
      if metatestclass:
        metatestclass.variantIs('metatest')
        metatestclass.userclassIs(self)
        metatestclass.underclassIs(testclass)
        metatestclass.testclassIs(None)
        metatestclass.metaclassIs(None)
        metatestclass.namespaceIs(testspace)
        /#newclasses.append(metatestclass)

      /# Initialize class fields of testmeta class
      if testmetaclass:
        testmetaclass.variantIs('testmeta')
        testmetaclass.userclassIs(self)
        testmetaclass.underclassIs(metaclass)
        testmetaclass.testclassIs(None)
        testmetaclass.metaclassIs(None)
        testmetaclass.namespaceIs(testspace)
        /#newclasses.append(testmetaclass)

      if autogen['meta']:
        self.generateImplicitMeta()

      /# We not recurse if there isn't any scope.
      proceed = True if scope else False

    elif variant == 'testuser':
      /# We are in a user-provided test class
      /#  - the class is moved into the test scope.
      /#  - no further class-level expansion is needed (but child
      /#    constructs need expanding).
      /#  - the location is 'test', and stays as test even when we move
      /#    to the test namespace (used to determine what the receiver
      /#    should be).
      if namespace.variant() == 'user':
        /# We are expanding the user-provided test class within the
        /# user namespace.  Move to the testspace and do NOT do any
        /# further expansion of the class (it will be done when the
        /# testspace is expanded).
        testspace = namespace.testspace()
        testblock = testspace.attr('scope:')
        /# If an explicit user-provided test class named 'TestCase' exists
        /# in a namespace, then all implicitly generated test classes in
        /# the namespace will inherit from this class. In order for this
        /# to work, the TestCase class needs to appear at the top of the
        /# testspace.
        position = '-' if self.id() == 'TestCase' else None
        self.changeParent(testblock, position=position)
        proceed = False
      else:
        /# We are expanding the user-provided test class now that it has
        /# been moved to the testspace ... full expansion is needed.
        proceed = True

        /# We need to generate a metaclass for the user-provide testclass.
        /# - note that this is NOT guarded by Compiler.IMPL['metatestclass']
        /#   because this is an explicit test class, not an implicit one,
        /#   and we always support meta fields/methods on explicit test
        /#   classes because such classes are often providing a test version
        /#   of a user-class, and should have all the same functionality as
        /#   those user-classes.
        metatestclass = self.generateMetaClass()
        metatestclass.variantIs('metatestuser')
        metatestclass.namespaceIs(namespace)
        metatestclass.initParentClasses()
        self.metaclassIs(metatestclass)
        newclasses.append(metatestclass)

    elif variant == 'metatestuser':
      /# The auto-generated meta class of a user-defined test class.
      proceed = True

    elif variant == 'metauser':
      /# We are in a user-provided meta class
      /#  - this looks exactly like a normal class except that the receiver
      /#    is 'meta'
      /#  - stays in same namespace
      proceed = True

    elif variant in ('test', 'meta', 'testmeta', 'metatest'):
      /# A class with any of these variants does not require any class-level
      /# expansion (they were expanded when the underlying user
      /# class was encountered)

      if variant == 'test':
        self.generateImplicitMeta()

      proceed = True

    else:
      raise metax.c.Error('Unknown class variant ' + variant)

    if proceed is None:
      raise metax.c.InternalError('Failed to initialize proceed')

    elif proceed:
      /# We are to perform actual expansion on this class.

      /# Invoke expandMeta() on child constructs.
      /#  - we make a copy of children so that we do NOT expand the implicit
      /#    children added to children by calls to child.expandMeta().
      if children is None:
        children = []
      for child in list(children):
        child.myclassIs(self)
        child.expandMeta()

      if output is not None:
        output.extend(newclasses)

      /# If this class has any packed fields, we generate
      /#  - a method for obtaining all unpacked values
      /#  - a getter for the pack field itself???
      /#  - a method for setting all packed fields???
      packed = self.packed()
      if packed:
        recsepstr = 'self.'  # TODO(wmh): Fix this ... use baselang.receiverStr(method, style='base', sep=True)
        stmtend = ''
        for pack in packed:
          rawpack = '_' + pack
          packmap = packed[pack]
          lines = []
          lines.append('value = %s%s%s' % (recsepstr, rawpack, stmtend))
          /# fields with pack are sorted ascending by bit position within pack.
          fnames = sorted(packmap, key=lambda f: packmap[f][0])
          tlist = []
          for fld in fnames:
            start_bit, bits, signed = packmap[fld]
            mask = (1 << bits) - 1
            if signed:
              halfval = 1 << (bits-1)
              lines.append(
                '%s = (value & 0x%x) - %d%s' % (fld, mask, halfval, stmtend))
            else:
              lines.append('%s = value & 0x%x%s' % (fld, mask, stmtend))
            lines.append('value >>= %d%s' % (bits, stmtend))
            tlist.append('int' if signed else 'uint')
          lines.append('return (%s)%s' % (', '.join(reversed(fnames)), stmtend))
          /# TODO(wmh): Make this a tuple of ints and uints according to whether
          /# each field above is signed or unsigned.
          anytype = metax.c.Type.Instance('tuple<%s>' % ','.join(reversed(tlist)))
          spreader = metax.oopl.MethodConstruct.NewFromData(
            '%sSpread' % pack, context, parent=scope,
            features=[],
            secondaries=[
              (':', anytype),
              ('scope:', lines)
            ])
          spreader.myclassIs(self)

      context = self.context()
      initializer = self.initializer()

      if initializer:
        if basel == 'javascript':
          use_es2015_classes = baselang.config('use_es2015', False)
          if not use_es2015_classes:
            /# In Javascript, if one is defining classes by explict function
            /# definition, the initializer needs to be the first construct
            /# generated.  However, if ES2015 classes are used, it does not
            /# need to be first.
            for i, child in enumerate(list(children)):
              if child is initializer:
                if i != 0:
                  children.pop(i)
                  children.insert(0, initializer)
                break
      else:
        /# If there is no explicit initializer, we define one.
        /#  - In javascript, required if not using ES2015 classes, since
        /#    the initializer function is what actually defines the class.
        /#  - useful in other languages because we often need to insert
        /#    implicit field initialization code.
        /#     - we can optimize unnecessary initializers out of the code
        /#       in translateMeta().
        /#  - the metafile line number is set to -1 because there is no
        /#    actual meta code associated with this implicit initializer.
        initname = baselang.initializerName(self)
        secondaries = []

        /# TODO(wmh): Need a cleaner way of determining whether a test class
        /# does NOT inherit from metax.test.TestCase.
        if variant == 'user' or (variant == 'testuser' and self.id() != 'TestCase'):
          /# We need to ensure that we accept the same args as the parent, and
          /# pass those args up via super(). For meta and test classes the
          /# param list is not user-provided (so we don't provide params
          /# for them here either), but for user classes we must pass args
          /# up to parent.
          /#
          /# An implementation that works for all baselangs relies on Meta
          /# implicitly compiling all .meta files needed in order to have
          /# a complete transitive understanding of the inheritance hierarchy
          /# dictated by the source .meta files.  That will give us
          /# ClassConstruct instances for every ancestor, and allow us to
          /# establish the exact signature of the initializer.
          /#
          /# As a stop-gap implementation that will work only for Python,
          /# we add some *arg,**kwds delegation.
          /#
          /# TODO(wmh): Get this working in all baselangs.  Note that the
          /# alternative is to require that a lifecycle construct (and
          /# associated scope:) always be explicitly defined in user classes,
          /# and leave it up to the user to properly delegate up the
          /# stack.
          secondaries.append((':', metax.c.Type.Instance('void')))
          if basel == 'python':
            params = metax.oopl.ExecutableConstruct.CreateParams(
              [
                {'var': 'args',
                 'features': [('multiplicity', 'multi')],
                 'secondaries': [(':', metax.c.Type.Instance('vec'))]},
                {'var': 'kwds',
                 'features': [('multiplicity', 'multi')],
                 'secondaries': [(':', metax.c.Type.Instance('map'))]},
              ],
              context)
            secondaries.append(('params:', params))
            super_expr = metax.c.ExprParser.StrExpr('(args, kwds)')
            secondaries.append(('super', super_expr))
          elif basel == 'cpp':
            /# TODO(wmh): How do we invoke the parent constructor with
            /# all the same args?
            pass
          else:
            raise metax.c.Error('Not yet handling implicit initializers for %s' % basel)

        secondaries.append(('scope:', [], -1))
        initializer = metax.oopl.MethodConstruct.NewFromData(
          initname, context, parent=scope,
          features=[('kind', 'initializer')],
          secondaries=secondaries,
          primary_line=-1,
          position='-')

        /# print 'WARNING: created implicit %s (%s)' % (initializer.fqn(), self.isTest())
        /# initializer.write()
        self.registerInitializer(initializer)

        /# In situations where we have classes like:
        /#    class Error < metax.root.Error;
        /#    class InternalError < Error;
        /# note that the termcode for both of the above is 1. After inserting
        /# the implicit initializer, it is not very readable to terminate with
        /# just a semicolon, so we upgrade the termcode. Similarly, we insert
        /# an empty line before such constructs in the interests of readability.
        if self.termcode() == 1:
          self.termcodeIs(3)
        if self.precount() == 0:
          self.precountIs(1)

      /# Perform auto-generation of serializers, sizers, etc.
      if self.isUser():
        /# For now, we do not generate these methods for test or meta classes,
        /# but we may want to...
        if not metac.importlist() and not self.isErrorClass():
          /# For now, we do not generate these methods for classes found
          /# during importMeta.
          /# TODO(wmh): Determine whether the above optimization is safe, or
          /# if there are situations where it is important for such methods to
          /# be autogened for dependended-on classes too.
          self._autogenAll()

      if self.isTest():
        /# There are two different kinds of classes that can appear within a
        /# testspace, those that inherit from metax.test.TestCase and those
        /# that do not. For the former, the initializer of such classes should
        /# never have an explicit params: or 'super' specified, and an
        /# implicit params: containing a single 'var meta__name : &str' is to
        /# be added (and passed up via an auto-inserted 'super (meta__name)'.
        /# However, the latter kind of class can have an initializer with
        /# arbitrary signature and is not modified by this code. The difficult
        /# part here is in answering the question of whether the class
        /# inherits from metax.test.TestCase or not. For now, we use a
        /# crude and limiting heuristic ... if the class name has 'TestCase'
        /# anywhere in it, or ends in 'Test', we assume it inherits from
        /# metax.test.TestCase, otherwise it does not.
        /#
        /# TODO(wmh): When we get fully parsing of the inheritance hierarchy
        /# implemented, we can replace this heuristic with a real subclass
        /# test.
        if 'TestCase' in name or metax.oopl.ClassConstruct.IsTestName(name):
          /# We assume this class inherits from metax.test.TestCase and thus
          /# needs a special params
          params = initializer.attr('params:', default=None)
          if params is not None:
            metafile.error(
              'testclass initializer %s (assumed to inherit from metax.test.TestCase) should not specify params:' %
              initializer.fqn())
          else:
            /# We add an explicit 'super' and 'params:' attributes.
            fauxfile = metax.c.MetaFile(
              '/faux/faux.meta', metac, '(meta__name)\n')
            super_expr = metax.c.ExprParser(fauxfile).parse()
            super = metax.attr.ExprAttribute(initializer, 'super', super_expr)
            /# Create a 'params:' attribute.
            params = metax.oopl.ExecutableConstruct.CreateParams(
              [{'var': 'meta__name',
                'secondaries': [
                  /# TODO(wmh): In order to get unittesting in C++ working
                  /# with gtest, I needed to make the meta__name arg be
                  /# optional because the TEST_F macro relies on there
                  /# being a constructor that takes no arguments. This
                  /# means that the name of the test method is NOT being
                  /# passed (at least not via the constructor). We can fix
                  /# this by introducing a TEST_M macro that invokes the
                  /# constructor with the method name (after which we could
                  /# remove the default value below).
                  (':', metax.c.Type.Instance('&str')), ('=', metax.c.Expr('str', '""', '""'))]},
                  /# TODO(wmh): In Meta, we need a baselang-independent
                  /# mechanism for initializing a variable to the empty
                  /# value of its type (e.g. "" for string, [] for vec,
                  /# {} for map, etc.). Consider introducing the
                  /# meta-level pseudovar 'empty'. Then we could do:
                  /#   method f : int params:
                  /#     var s : str = empty;
                  /#     var v : vec = empty;
                  /#     var m : map = empty;
              ],
              context)
            initializer.registerAttribute(
              super, position='+' + initializer.primary().key())
            initializer.registerAttribute(params, position='-super')
      else:
        /# The class does NOT inherit from metax.test.TestCase and its
        /# initializer has whatever signature the user specified.
        pass

      if self.isMeta():
        /# For metaclasses, regardless of whether an initializer was
        /# explicitly provided or not, there should never be an explicit
        /# params: attribute. Instead, this code implicitly defines a
        /# 'params:' attribute of a pre-determined signature, and an
        /# associated 'super' attribute to call up the inheritance chain. The
        /# only meta class that does NOT get this implicit treatment is
        /# metax.root.ObjectMetaRoot, which is the special parent of all
        /# meta-defined metaclasses. If a user defines a metaclass with a
        /# parent that is not a subclass of metax.root.ObjectMetaRoot, it is
        /# their responsibility to have the parent initializer accept the same
        /# signature.

        params = initializer.attr('params:', default=None)
        if self.fqn() == 'metax.root.ObjectMetaRoot':
          /# This is the sole exception to implicit params: ... we leave
          /# the class exactly as-is.
          pass
        elif params is not None:
          print '#' * 70
          print 'HERE with %s = %s' % (self.kindfqn(), self.variant())
          initializer.write()
          print '#' * 70
          metafile.error(
            'metaclass initializer %s should not specify params:' %
            initializer.fqn(),
            line=initializer.primary().line())
        else:
          /# Currently, metaclass initializers in all baselangs must have
          /# the same signature:
          /#   var name : &str #:
          /#     The name of the class being created
          /#   var bases : &vec<class> #:
          /#     The parent classes of the class
          /#   var symbols : &map #:
          /#     The symbols available within the class.
          /# This signature may need to evolve as more baselangs are added
          /# and we see how the metaclass support in those baselangs
          /# interact with the mandates of Meta.
          /#
          /# All metaclasses should inherit from metax.root.ObjectMetaRoot,
          /# which expects the above params, so we invoke super().

          /# Create a 'params:' attribute
          params = metax.oopl.ExecutableConstruct.CreateParams(
            [
              {'var': 'name',
               'secondaries': [(':', metax.c.Type.Instance('&str'))]},
              {'var': 'bases',
               'secondaries': [(':', metax.c.Type.Instance('&#vec<class>'))]},
              {'var': 'symbols',
               'secondaries': [(':', metax.c.Type.Instance('&#map'))]},
            ],
            context)

          /# Create a 'super' attribute
          if True:
            /# Explicit creation
            super_expr = metax.c.Expr(
              'plist', '(name, bases, symbols)', 
              [
                metax.c.Expr('var', 'name', 'name'),
                metax.c.Expr('var', 'bases', 'bases'),
                metax.c.Expr('var', 'symbols', 'symbols')
              ]
            )
          else:
            /# Indirect and slow creation
            fauxfile = metax.c.MetaFile(
              '/faux/faux.meta', metac, '(name, bases, symbols)\n')
            super_expr = metax.c.ExprParser(fauxfile).parse()
          super = metax.attr.ExprAttribute(initializer, 'super', super_expr)

          iscope = initializer.attr('scope:', default=None)
          if iscope:
            initializer.registerAttribute(super, position='-scope:')
            initializer.registerAttribute(params, position='-super')
          else:
            metafile.error('Missing scope', line=initializer.primary().line())

      if True:
        /# TODO(wmh): Disable this when we go production!
        self.validate()
        metax.c.D.expand.info(
          'Validated %s (%s)' % (self.kindfqn(), self.variant()), level=2)

      /# Register this class with the compiler.
      metac.registerClass(self)

      /# Compute dependencies for this class!
      self.registerDependencies()

      /# Sub-expansions
      /#  - if we are processing a user class, the code above creates four
      /#    autogened classes (metaclass, testclass, metatestclass and
      /#    testmetaclass).
      /#  - The first of these (metaclass) resides in the same namespace as
      /#    the user class, and needs to be explicitly expanded.
      /#  - The rest of the autogened classes reside in the testspace associated
      /#    with the namespace that the user class belongs to, so we do NOT
      /#    need to expand them here (they will be expanded when the testspace
      /#    is expanded at the end of NamespaceConstruct.expandMeta().
      for cls in newclasses:
        cls.expandMeta()

    metax.c.D.expand.end()

  import:
    /# Link this class with all of its ancestor classes, now that all dependent
    /# metafiles have been transitively parsed, expanded and imported.
    metax.c.D.imports.sinfo(self.id())

    metafile = self.metafile()
    metac = metafile.compiler()

    /# Establish the ClassConstruct instances of parents
    /#  - initialize self.parentclasses[i]['class']
    /#  - add entry to parent_construct.childclasses() for self
    /#  - patch up the parent() field in self.symbols() table.
    parentclasses = self.parentclasses() or []
    for index, parent_info in enumerate(parentclasses):
      fqn = parent_info['metafqn']
      parent_class = metac.classes().get(fqn, None)
      if parent_class is None:
        /# This can mean various things:
        /#  - the parent class was not defined within Meta
        /#  - the parent class is incorrectly specified by the user
        /#  - there is a bug in Meta
        if not parent_info.get('external', False):
          /# print 'PARENT INFO: %s' % str(parent_info)
          metafile.warning(
            'Failed to import parent %s for %s' % (fqn, self.fqn()),
            line=self.primary().line())
        else:
          /# The parent is defined in the baselang, not in Meta. We create
          /# an ExternalClassConstruct instance to represent it.
          parent_class = metax.oopl.ExternalClassConstruct(
            /# Passing null context poses problems, so passing self's
            /# context even though it isn't entirely accurate.
            parent_info['id'], None, self.context(), precount=0)
          parent_info['class'] = parent_class
          parent_class.childclasses()[self.id()] = self
      else:
        /# We have successfully identified a ClassConstruct for the parent.
        parent_info['class'] = parent_class
        parent_class.childclasses()[self.id()] = self
        if index == 0:
          /# For now, there is only one parent symbol table, but we should
          /# probably allow SymbolTable to have arbitrary numbers of parents.
          symbols = self.symbols()
          assert symbols.parent() is None
          symbols.parentIs(parent_class.symbols())
        
    /# We now recurse down to constructs within the class so that they can
    /# update any state that relies on full resolution of the class
    /# inheritance change.
    scope, children = self.attrpair('scope:')
    for child in children:
      child.importMeta()

    metax.c.D.imports.end()
  translate:
    /# Baselang-independent class compilation code.
    /#
    /# Notes:
    /#
    /#  - There are three separate ClassConstruct instances associated with
    /#    every user-specified class: 1) the user class, 2) a test class,
    /#    3) a meta class. Each of these is compiled separately.
    /#
    /#  - A class with name nm.sp.Ex has the following associated files:
    /# 
    /#     1a. class definition
    /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$defn
    /#         where $defn is the baselang-specific suffix for definitions.
    /# 
    /#     1b. line map for class definition
    /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.$defn.map
    /#         defining the mapping from line numbers in source .meta file and
    /#         line numbers in
    /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$defn.
    /# 
    /#     2a. class declaration
    /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$decl
    /#         where $defn is the baselang-specific suffix for declarations.
    /#         Most languages, $decl == $defn, but in languages likes C++
    /#         they differ.
    /# 
    /#     2b. line map for class declaration
    /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.$decl.map
    /#         defining the mapping from line numbers in source .meta file and
    /#         line numbers in
    /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$decl.
    /# 
    /#     3.  build fragment for class
    /#           <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.bld
    /#         containing a bazel ${basel}_library rule defining how
    /#         to compile the class and listing all deps (other Bazel targets),
    /#         and all data (aka resources).
    /# 
    /# Actions:
    /#
    /#  - identify all dependencies that need importing (assocs plus implicit
    /#    dependencies like parent classes, baselang std library, etc.)
    /#     - produce baselang specific import syntax for these dependencies
    /#
    /#  - create the BUILD fragment representing the class
    /#    (in <<repository_path>>/<metalang>/<baselang>/nm/sp/.Ex.bld)
    /# 
    /#  - compile all class-level constructs to obtain the contents of the class,
    /#    writing baselang text to BaseStream instances and populating the
    /#    ClassConstruct instance with relevant data identified during child
    /#    processing (symbol tables, etc.)
    /#
    /#  - initialize a VarSet and instantiate the baselang class Template to
    /#    create <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$defn (and,
    /#    where needed,
    /#    <<repository_path>>/<metalang>/<baselang>/nm/sp/Ex.$decl). The same
    /#    VarSet should be used to instantiate all source files associated with
    /#    the class, and all baselangs use the same variable names in their
    /#    templates.
    /#
    /# Returns:
    /#   The list of BaseFile instances created. This is normally null, since
    /#   most constructs do not produce files.  However, claseses and namespaces
    /#   do.
    metax.c.D.translate.sinfo(self.kindfqn())

    metac = self.compiler()
    context = self.context()
    baselang = self.baselang()
    basel = baselang.id()
    metafile = self.metafile()
    consinfo = context.consinfo('class')
    namespace = self.namespace()
    fs = metac.fs()
    decl_is_separate = baselang.id() == 'cpp'
    variant = self.variant()
    suppress = self.suppress()

    /# TODO(wmh): How to establish the actual width?
    width = 80 - 0

    /###
    /# Process the scope. Subconstructs include:
    /#   field
    /#   method/initializer/finalizer/lifecycle/function
    /#   native
    /#   category
    extralines = self.extralines()
    streams = metafile.streams()
    /# Streams used within classes:
    /#   decl:
    /#     For classes that have a distinction between declaration and
    /#     definition, this represents the declaration (public interface).
    /#     For classes without a distinction between declaration and
    /#     definition, this is unused (all code is written to 'defn' below).
    /#   defn: 
    /#     For classes that have a distinction between declaration and
    /#     definition, this represents the definition of the class (actual
    /#     implementation). For classes without a distinction, this is where
    /#     all code is written.
    /#   decl-pre:
    /#     This represents code to be inserted before the class declaration,
    /#     but which is still associated with the class. Not needed in
    /#     baselangs without distinction between decl/defn, or for which it
    /#     makes no sense to insert code before the class declaration.
    /#   defn-pre:
    /#     This represents code to be inserted before the class definition,
    /#     but which is still associated with the class. For languages without
    /#     a distinction between decl/defn, this is where all such code is
    /#     written (i.e. decl-pre not used in such languages)
    /#   decl-post:
    /#     This represents code to be inserted after the class declaration,
    /#     but which is still associated with the class. Not needed in
    /#     baselangs without distinction between decl/defn, or for which it
    /#     makes no sense to insert code after the class declaration.
    /#   defn-post:
    /#     This represents code to be inserted after the class definition,
    /#     but which is still associated with the class. For languages without
    /#     a distinction between decl/defn, this is where all such code is
    /#     written (i.e. decl-post not used in such languages)
    /#   decl-pre-nmsp:
    /#     This represents code to be inserted before the class declaration,
    /#     but which is still associated with the class. Not needed in
    /#     baselangs without distinction between decl/defn, or for which it
    /#     makes no sense to insert code before the class declaration.
    /#   defn-pre-nmsp:
    /#     This represents code to be inserted before the class definition,
    /#     but which is still associated with the class. For languages without
    /#     a distinction between decl/defn, this is where all such code is
    /#     written (i.e. decl-pre not used in such languages)
    /#   decl-post-nmsp:
    /#     This represents code to be inserted after the class declaration,
    /#     but which is still associated with the class. Not needed in
    /#     baselangs without distinction between decl/defn, or for which it
    /#     makes no sense to insert code after the class declaration.
    /#   defn-post-nmsp:
    /#     This represents code to be inserted after the class definition,
    /#     but which is still associated with the class. For languages without
    /#     a distinction between decl/defn, this is where all such code is
    /#     written (i.e. decl-post not used in such languages)
    snames = []
    for placement in ('defn', 'decl'):
      snames.append(placement)
      for position in ('pre', 'post'):
        sname = placement + '-' + position
        snames.append(sname)
        snames.append(sname + '-nmsp')
    streams.initStreams(*snames)

    scope, children = self.attrpair('scope:')
    for construct in children:
      construct.translateMeta()
    decl_segments = streams.stream('decl')
    defn_segments = streams.stream('defn')
    decl_post_segments = streams.stream('decl-post')

    /# parentspec: str
    /#   the baselang syntax needed to define all parents (extends/implements)
    parentspec = baselang.formatParentSpec(self)

    /# Now process dependencies into targets and imports
    imports, targets = baselang.formatDependencies(self)

    /# preclass: vec<str>
    /#   baselang code associated with a class definition but appearing
    /#   before the class.
    preclass = []
    prelines = extralines.get('pre', {}).get('decl', None)
    if prelines:
      preclass.extend(prelines)

    /# postclass: vec<str>
    /#   - baselang code associated with a class declaration but appearing
    /#     after the class.
    /#   - extra-lines may contain native code.
    /#      - TODO(wmh): Consider replacing extra_lines with decl-post now
    /#        that it exists!
    postclass = []
    if decl_post_segments:
      postclass.extend(decl_post_segments)
    /# TODO(wmh): Clean up the confusion about decl vs defn in languages that
    /# don't make a distinction.  Note that varset var 'postclass' is for
    /# declaration, and 'postclass-local' is for definition for langs that
    /# care, and 'postclass' is used for langs that don't care.
    postlines = extralines.get('post', {}).get('defn', None)
    if postlines:
      postclass.extend(postlines)

    /# preamble: vec<str>
    /#   Lines of text within class scope before user-provided scope.
    preamble = []

    /# postamble: vec<str>
    /#   Lines of text within class scope after user-provided scope.
    postamble = []

    /# comment: vec<str>
    /#   potentially multi-line string  representing documentation
    /#   associated with the class as a whole.
    /#
    /#   Note that formatClassComment() also modifies suppress, providing a
    /#   way for 'Meta:suppress <label>' syntax within a class or method
    /#   comment block to be added to a @fileoverview, method or BUILD target.
    /#
    /#   Note that by passing in a default value, we do not need to deal
    /#   with inserting a 'pass' in an empty class in Python.
    comment_attr = self.attr('comment:', default=None)
    comment = baselang.formatClassComment(
      comment_attr, suppress=suppress, default=['Undocumented.'])

    /# Create the VarSet of variables.
    varset = metax.c.VarSet()
    varset.addVar('imports', imports)
    varset.addVar('preclass', preclass)
    varset.addVar('preamble', preamble)
    varset.addVar('fqcn', self.fqn())
    varset.addVar('namespace', namespace.id())
    varset.addVar('class', self.id(), attribute=self.primary())
    varset.addVar('parentspec', parentspec)
    varset.addVar('comment', comment, attribute=comment_attr)
    varset.addVar('scope', defn_segments, attribute=scope)
    varset.addVar('postamble', postamble)
    varset.addVar('postclass', postclass)
    /# varset.show()

    /# TODO(wmh): Is there a better way of providing baselang-specific
    /# augmentation of varsets?  By putting the code in BaseLanguage, we
    /# hide the code away from user modification.
    /#  - what we really want is multi-dispatch on construct and baselang
    /#  - could define augmentPythonVarset, augmentJavascriptVarset, etc.
    /#    in each construct class?
    baselang.augmentVarset(self, varset)

    /# Instantiate the template using the varset
    has_decl = False
    istestcase = self.isTestCase()
    basesuffix = baselang.suffix()
    template_name = baselang.id()
    if istestcase: template_name += '_test'
    if baselang.config('definition_separate'):
      /# For baselangs with two files per class, we print out the
      /# definition using the same flow as in other baselangs, and
      /# handle the declaration file specially.
      template_name += '_defn'
      has_decl = True

    /# Create the defn base file and associated mapfile
    template = consinfo.templateNamed(template_name)
    segment = metax.c.BaseSegment(self.primary())
    fqn = self.fqn()
    segment.instantiate(template, varset, self.kind(), fqn)

    mapfile = metax.c.MapFile(
      metac.basePath(fqn, prefix='.', suffix=basesuffix + '.map'),
      fs.realpath(fs.abspath(metafile.path())), [])
    contents = []
    segment.flattenLines(contents, mapfile, strip_special=True)
    basesubpath = baselang.classSubPath(self)
    basefile = metax.fs.BaseFile(
      basesubpath, '\n'.join(contents) + '\n',
      metafile=metafile, mapfile=mapfile)
    metafile.registerFile(basefile)

    /# If the baselang separates definition from declaration, do declaration.
    if has_decl:
      template_name = template_name.replace('_defn', '_decl')
      template = consinfo.templateNamed(template_name)
      segment = metax.c.BaseSegment(self.primary())
      fqn = self.fqn()
      declsuffix = baselang.suffix(location='decl')

      varset.setValue('scope', decl_segments)

      segment.instantiate(template, varset, self.kind(), fqn)
      mapfile = metax.c.MapFile(
        metac.basePath(fqn, prefix='.', suffix=declsuffix + '.map'),
        fs.realpath(fs.abspath(metafile.path())), [])
      contents = []
      segment.flattenLines(contents, mapfile, strip_special=True)
      basesubpath = baselang.classSubPath(self, location='decl')
      basefile = metax.fs.BaseFile(
        basesubpath, '\n'.join(contents) + '\n',
        metafile=metafile, mapfile=mapfile)
      metafile.registerFile(basefile)

    /# Create the .bld BUILD fragment
    /#  - until we can find a way to implement python namespaces in terms
    /#    of per-class files, we do NOT create .bld files for each class
    /#    in python
    bldfile = None
    if basel != 'python':
      bldpath = metac.basePath(fqn, prefix='.', suffix='.bld')
      if False:
        /# Useful during debugging.
        print bldpath
        self.showDependencies()
        print '  Targets:'
        for target in targets:
          print '    ' + target
      rule, build_data = baselang.createBuildFragment(
        self, sorted(targets), test=istestcase)
      if rule is not None:
        fragment = baselang.formatBuildRule(rule, build_data)
        bldfile = metax.fs.BaseFile(bldpath, '\n' + fragment + '\n', metafile=metafile)
        metafile.registerFile(bldfile)

    metax.c.D.translate.end()
    return [basefile, bldfile]

  compile:
    metax.c.D.compile.sinfo(self.id())
    /# TODO(wmh): Implement this.
    /# - In python
    /#   - Handle per-class Entry points (but since Python is namespace-centric),
    /#     it may be handle in NamespaceConstruct.compileMeta() instead.
    /# - In Javascript
    /#   - Handle per-class Entry points.
    /# - In C++
    /#   - Handle per-class Entry points.
    scope, children = self.attrpair('scope:')
    for child in children:
      child.compileMeta()
    metax.c.D.compile.end()

  scope:
    meta
    method TestifyName : str #:
      Convert a class name to a testclass name.
    params:
      var name : str #:
        relative or fully qualified name of class to make a Test version of.
    scope:
      return name + 'Test'
    end method TestifyName;

    meta
    method UntestifyName : str #:
      Convert a testclass name to a userlass name.
    params:
      var name : str #:
        relative or fully qualified name of testclass name.
    scope:
      assert name.endswith('Test')
      return name[:-4]
    end method UntestifyName;

    meta
    method IsTestName : bool #:
      Check if a name is a testclass name
    params:
      var name : str;
    scope:
      return name.endswith('Test')
    end method;

    meta
    method MetaifyName : str #:
      Convert a class name to a metaclass name.
    params:
      var name : str #:
        relative or fully qualified name of class to make a Meta version of.
    scope:
      return name + 'Meta'
    end method MetaifyName;

    meta
    method MetaInstifyName : str #:
      Convert a class name to a metaclass instance name.
      TODO(wmh): Can we make this an instance method, or is it used in 
      situations where an instance isn't avialable?
    params:
      var name : str #:
        relative or fully qualified name of class to make a Meta version of.
    scope:
      parts = name.split('.')
      parts[-1] = 'Meta' + parts[-1]
      return '.'.join(parts)
    end method MetaInstifyName;

    meta
    method UnmetaifyName : str #:
      Convert a metaclass name to a userclass name.
    params:
      var name : str #:
        relative or fully qualified name of metaclass to obtain userclass for
    scope:
      assert name.endswith('Meta')
      return name[:-4]
    end method UnmetaifyName;

    meta
    method UnmetainstifyName : str #:
      Convert a metaclass instance name to a userclass name.
    params:
      var name : str #:
        relative or fully qualified name of metaclass to obtain userclass for
    scope:
      parts = name.split('.')
      assert parts[-1].startswith('Meta')
      parts[-1] = parts[-1][4:]
      return '.'.join(parts)
    end method UnmetainstifyName;

    meta
    method IsMetaName : bool #:
      Check if a name is a metaclass name
    params:
      var name : str;
    scope:
      return name.endswith('Meta')
    end method;

    meta
    method IsMetaInstName : bool #:
      Check if a name is a metaclass name
    params:
      var name : str;
    scope:
      parts = name.split('.')
      return parts[-1].startswith('Meta')
    end method;

    meta
    method CanonicalizeClassName : str #:
      Canonicalize a class name, handling various special syntaxes.
       - Return null if name is 'void'
       - Fully qualified relative names unless prefixed with '^'

      Returns:
        Fully qualified class name (in meta syntax, not baselang syntax).
    params:
      var name : str #:
        The meta-level class name.
      var namespace : metax.oopl.NamespaceConstruct = null #:
        The namespace within which the class type resides.
    scope:
      if name[0] == metax.c.Context.Tokens()['explicit_class_indicator']:
        /# A class that starts with '^' is a verbatim request from user.
        fqn = name[1:]
      elif name == 'void':
        fqn = None
      else:
        if '.' not in name:
          /# We have a relative class name ... prepend the namespace.
          if namespace is None:
            raise metax.c.Error('No namespace provided: cannot qualify "%s"' % name)
          fqn = namespace.id() + metax.c.Context.Tokens()['scope_sep'] + name
        else:
          fqn = name
      return fqn
    test:
      _, _, context, _ = self.cachedInfo()
      CanonicalizeClassName = metax.oopl.ClassConstruct.CanonicalizeClassName
      test.iseq('object', CanonicalizeClassName('^object'))
      test.iseq(
        'demo.cards1.Card', CanonicalizeClassName('demo.cards1.Card'))
      namespace = metax.oopl.NamespaceConstruct.NewFromData(
        'demo.cards1', context)
      test.iseq(
        'demo.cards1.Card',
        CanonicalizeClassName('Card', namespace=namespace))
      test.raises(metax.c.Error, CanonicalizeClassName, 'Card')
    end method CanonicalizeClassName;

    field fields : @vec<metax.oopl.FieldConstruct> #:
      The list of field constructs in this class. Maintains order in which
      fields are defined. Use self.symbols() to obtain fields by name.

    field packed : map<str,map<str,tuple<int,int>>> #:
      Maps names of special 'packed' fields to field name to tuple
      (starting bit position, num bits).

    field namespace : metax.oopl.NamespaceConstruct #:
      The namespace this class belongs to.

    field parentclasses : vec<map> #:
      A parsed version of the 'parent' (or 'parents:') attribute.
      Each element is for a different parent (currently focusing on single
      parents, but will want to extend in the future).  The element contains:
        raw: str
          The raw parent string as found in the meta source code.
        fqn: str
          The fully qualified name of the parent class in baselang syntax
        metafqn: str
          The fully qualified name of the parent class in meta syntax
        external: bool
          True if the parent class is NOT defined within Meta. Somewhat
          redundant relative to 'class' except that this can be determined
          earlier in parsing than the class can be.
        class: ClassConstruct
          The ClassConstruct instance representing the parent. Is null for
          all classes until ClassConstruct.importMeta() is invoked, and is
          always null for a parent not defined in Meta.

    field childclasses : @map<str,metax.oopl.ClassConstruct> #:
      Maps class ids to ClassConstruct, for those classes that inherit
      directly from this class.

    field underclass : metax.oopl.ClassConstruct #:
      The ClassConstruct that this class is based upon.

    field testclass : metax.oopl.ClassConstruct #:
      The auto-generated test class associated with this class. This is set
      for user classes and for auto-generated metaclasses of userclasses,
      and is null for all other variants.

    field metaclass : metax.oopl.ClassConstruct #:
      The auto-generated meta class associated with this class. This is set
      for user classes and auto-generated test classes of userclasses, and is
      null for all other variants.

    field userclass : metax.oopl.ClassConstruct #:
      The user class.
      See class comment for details on what value this takes on.

    field variant : str #:
      Indicates the class variant.  Legal values are:
        user: the user defined class
        test: the implicitly generated test class associated with a user class
        meta: the implicitly generated meta class associated with a user class
        metatest: the implicit metaclass of an implicit test class for a user class
        testmeta: the implicit testclass of an implicit meta class for a user class
        testuser: a user-provided test class
        metauser: a user-provided meta class
        testmetauser: an implicit metaclass for a user-provided test class
        metatestuser: an implicit testclass for a user-provided meta class
        null: not yet initialized

    field resources : @map #:
      Maps resource names to absolute paths to resource, for resources
      defined in the 'associations' attribute of this class.

    field deps : @map #:
      The dependencies of this class.  Maps fully-qualified name to map
      containing:
        kind: str
          One of 'std', 'cls', 'lib', etc.
        target: str
          The bazel target to use for the dependency.
        fqn: str
          The fully qualified name of the dependency
        reason: str
          Why the dependency exists.
        abbrev: str (optional)
          The name by which the import is known locally.

    field initializer : metax.oopl.MethodConstruct #:
      The initializer associated with this ClassConstruct.

    field clinit : metax.oopl.MethodConstruct #:
      The method initializing the static fields of this class.  Often null.

    field extralines : @map<str,vec<str>> #:
      Maps <position> to <placement> to list of strings, where
       - <position> is one of 'pre', 'prenmsp', 'post', 'postnmsp'
       - <placement> is one of 'defn' or 'decl'
       - the list represents baselang text to appear
         - pre: before class within namespace
         - prenmsp: before class before namespace
         - post: after class within namespace
         - postnmsp: after class after namespace

      The most common keys are post/defn, because native constructs in namespace
      scope appearing after a class are by default associated with the class
      above them (post) and refer to class definition (defn). For languages like
      C++ that have both a header file and source file, 'defn' refers to .cc and
      'decl' refers to 'h'.
    end field extralines;

    field suppress : @map #:
      Maps suppress commands to strings explaining why the error is being
      suppressed.

    method kind : str scope:
      return 'class'

    method isClass : bool scope:
      return True

    method __repr__ : str scope:
      return '<%s>' % self.kindfqn()

    method showDebug : any #:
      Write out some state of this class useful during debugging.
    scope:
      fp = sys.stdout
      fp.write('%s: %s\n' % (self.kindfqn(), self.variant()))
      for ckind, construct in (
        ('underclass', self.underclass()),
        ('testclass', self.testclass()),
        ('metaclass', self.metaclass()),
        ('userclass', self.userclass()),
        ('initializer', self.initializer()),
      ):
        fp.write('  %-12s: %s\n' % (ckind, construct.kindfqn() if construct else 'null'))
      fields = self.fields()
      if fields:
        fp.write('  fields:\n')
        for field in fields:
          fp.write('    %s\n' % field.kindfqn())

    test:
    end method showDebug;

    method isUser : bool #:
      True if this class is a user class.
    params:
      var full : bool = false #:
        If true, a user-provided test class or meta class also applies.
    scope:
      variant = self.variant()
      if full:
        result = variant in ('user', 'testuser', 'metauser')
      else:
        result = variant == 'user'
      return result
    test:
    end method isUser;

    method isTest : bool #:
      True if this class is a test class.
    scope:
      return self.variant() in ('test', 'testmeta', 'testuser')
    test:
    end method isTest;

    method isTestCase : bool #:
      True if this class inherits from metax.test.TestCase.

      TODO(wmh): I suspect this method is being used for two mutually exclusive
      purposes and it needs to be cleaned up.
       1. Does this class inherit from metax.test.TestCase.
           - this includes autogenerated test classes and namespace specific
             testcase classes
       2. Is this class one that will be instantiated in the testsuite.
          - this includes autogenerated test classes but does NOT include
            namespace specific testcase classes.
    scope:
      /# There are two different kinds of classes in the test namespace:
      /# those that are to be instantiated as part of the test harness, and
      /# those that are service classes used indirectly (not directly) by
      /# the test harness.
      /#
      /# Note that the distinction is NOT as simple as "does the class inherit
      /# from metax.test.TestCase", because namespace-specific TestCase classes
      /# inherit from this class but are NOT classes to be tested (instead,
      /# they are superclasses of classes to be tested).
      result = False
      name = self.id()
      underclass = self.underclass()
      if underclass:
        username = underclass.id()
        if name == metax.oopl.ClassConstruct.TestifyName(username):
          result = True
      return result
    test:
    end method isTestCase;

    method isMeta : bool #:
      True if this class is a meta class.
    scope:
      return self.variant() in ('meta', 'metatest', 'metauser', 'metatestuser')
    test:
    end method isMeta;

    method addDependency #:
      Add a dependency on this class.
    params:
      var fqn : str #:
        The fully-qualified name of the dependency.
      var kind : str #:
        One of 'std', 'cls', 'lib', etc.
      var reason : str #:
        Why the dependency exists.
      var target : str = '<auto>' #:
        The bazel target associated with the dependency. If it is null,
        no target is generated.  If it is '<auto>', the standard target
        associated with fqn is used.
      var alias : str = null #:
        The name by which the dependency is to be referenced locally.
    scope:
      if target == '<auto>':
        if kind == 'std':
          target = None
        else:
          target = self.baselang().nameToBuildTarget(fqn, lib=kind=='lib')

      deps = self.deps()
      if fqn in deps:
        info = deps[fqn]
        if info['kind'] != kind:
          print '**** WARNING: for %s dep %s has kind %s vs %s' % (
            self.kindfqn(), fqn, kind, info['kind'])
        if info['target'] != target and kind != 'std':
          /# CODETANGLE(std_target): note that registerDependencies passes
          /# in a target for 'std' even though target isn't needed. But
          /# other calls to addDependency (like in OoplPython.autogenPrint)
          /# do not bother with a target since 'std' assocs by definition
          /# do not need one.  Can we clean this up so we don't need to 
          /# make the test against 'std' above?
          print '**** WARNING: for %s dep %s has target %s vs %s' % (
            self.kindfqn(), fqn, target, info['target'])
        /# TODO(wmh): Do we need to validate alias?
      else:
        dep = {'fqn': fqn, 'kind': kind, 'target': target, 'reason': reason}
        if alias:
          dep['alias'] = alias
        deps[fqn] = dep
        metafile = self.metafile()
        if target:
          metafile.registerDependentClass(fqn)
          /# print 'Adding %s as dependency of %s' % (fqn, metafile.path())
        else:
          /# print 'NOT adding %s as dependency of %s' % (fqn, metafile.path())
          pass
    test:
    end method addDependency;

    method showDependencies #:
      Print out the dependencies of this class.
    params:
      var fp : ostream = out #:
        Where to write output.
    scope:
      deps = self.deps()
      fp.write('%s dependencies\n' % self.kindfqn())
      for fqn in sorted(deps):
        info = deps[fqn]
        alias = info.get('alias', None)
        alias_str = '(%s) ' % alias if alias else ''
        fp.write('  %-40s : %-10s = %-40s %s[%s]\n' % (
          fqn, info['kind'], info['target'], alias_str, info['reason']))
    test:
    end method showDependencies;

    method validate #:
      Perform consistency checks on this construct to ensure that the
      various fields are internally consistent.

      IMPORTANT: This method is not meant to be used in production code,
      but rather is meant to be inserted during debugging. It can be
      expensive to execute.
    scope:
      meta = self.__class__

      /# The variant should be determined by the values of userclass,
      /# underclass, testclass and metaclass.
      userclass = self.userclass()
      underclass = self.underclass()
      testclass = self.testclass()
      metaclass = self.metaclass()
      variant = self.variant()
      autogen = self.autogenInfo()

      kfqn = self.kindfqn()

      if testclass is not None:
        assert meta.IsTestName(testclass.id())
      if metaclass is not None:
        assert meta.IsMetaName(metaclass.id()), '%s does not have proper Meta name (%s)' % metaclass.id()

      if variant == 'user':
        assert userclass is self
        assert underclass is None
        if autogen['test']:
          if not self.isErrorClass():
            assert testclass is not None
            assert testclass.userclass() is self
        else:
          assert testclass is None

        if autogen['meta']:
          assert metaclass is not None, 'Expecting metaclass for %s (%s)' % (kfqn, self.isErrorClass())
        else:
          assert metaclass is None

      elif variant == 'test':
        assert userclass is not None
        assert userclass.testclass() is self
        assert underclass is userclass
        assert testclass is None
        if metax.c.Compiler.IMPL['metatestclass']:
          assert metaclass is not None
          assert metaclass.underclass() is self
        else:
          assert metaclass is None

      elif variant == 'testmeta':
        assert userclass is not None
        assert userclass.metaclass() is underclass
        assert testclass is None
        assert metaclass is None

      elif variant == 'testuser':
        assert userclass is None
        /# TODO(wmh): These may need updating
        assert underclass is None
        assert testclass is None
        assert metaclass is not None

      elif variant == 'meta':
        assert userclass is not None
        assert userclass.metaclass() is self
        assert underclass is userclass
        assert metaclass is None
        assert testclass is not None
        if metax.c.Compiler.IMPL['testmetaclass']:
          assert testclass.underclass() is self
        else:
          assert testclass.underclass() is self.underclass()

      elif variant == 'metatest':
        assert userclass is not None
        assert userclass.testclass() is underclass
        assert testclass is None
        assert metaclass is None

      elif variant == 'metauser':
        /# TODO(wmh): These may need updating
        if False:
          for cn, c in (('user', userclass), ('under', underclass), ('test', testclass), ('meta', metaclass)):
            if c:
              print '%s = %s' % (cn, c.kindfqn())
            else:
              print '%s = %s' % (cn, c)
        if True:
          assert userclass is None
          assert underclass is None
          assert testclass is None
          assert metaclass is None

    test:
    end method validate;

    method testClassInfo : tuple<metax.oopl.NamespaceConstruct,metax.attr.ComplexBlock,str,str> #:
      Obtain test class information.

      Returns:
       0) NamespaecConstruct
         The namespace within which the test class is to be added
       1) ComplexBlock
         The scope within the namespace within which the test class is to be added.
       2) str
         The (relative) name of the test class
       3) str
         The name of the parent of the test class (relative or absolute).
    scope:
      namespace = self.namespace()
      userblock = namespace.attr('scope:')
      testspace = namespace.testspace()
      testblock = testspace.attr('scope:') if testspace else None
      testparent = self.attrval('testparent', default=metax.c.LOOKUP)
      if testparent == '<special>':
        /# If there is a TestCase class defined within testblock, we use
        /# that as the parent, else we use metax.test.TestCase
        testcase_in_test = testblock.cons('TestCase', default=None) if testblock else None
        testcase_in_user = userblock.cons('TestCase', default=None)
        if (
          testcase_in_test or
          (testcase_in_user and testcase_in_user.attrval('location') == 'test')
        ):
          testparent = 'TestCase'
        else:
          testparent = 'metax.test.TestCase'
        /# print '**** HERE!!! %s = %s' % (self.kindfqn(), testparent)
      testname = metax.oopl.ClassConstruct.TestifyName(self.id())
      assert testspace is not None
      return (testspace, testblock, testname, testparent)
    end method testClassInfo;

    method metaClassInfo : tuple<metax.oopl.NamespaceConstruct,metax.attr.ComplexBlock,str,str> #:
      Obtain the meta namespace and metaclass name.

      Returns:
       0) NamespaceConstruct
         The namespace within which the meta class is to be added
       1) ComplexBlock
         The scope within the namespace within which the meta class is to be added.
       2) str
         The (relative) name of the meta class
       3) str
         The name of the parent of the meta class (relative or absolute).
    scope:
      metaspace = self.namespace()
      metablock = metaspace.rawattr('scope:') if metaspace else None
      metaparent = self.attrval('metaparent', default=metax.c.LOOKUP)

      if metaparent == '<special>':
        /# We did not find an explicit metaparent, so we compute it dynamically:
        /#  - if the parent of the userclass is meta-defined, that parent
        /#    has an auto-generated metaclass and the parent of this class
        /#    should be that class.
        /#  - if the parent of the userclass is not meta-defined, we use
        /#    metax.root.ObjectMetaRoot
        /#     - this assumes the non-meta parent does not have a metaclass
        /#       of its own (if it does, the user will need to provide
        /#       that nonmeta metaclass explicitly via metaparent)
        /#     - TODO(wmh): Rewrite root.meta as root.meta2, and use namespace
        /#       metaxy.root (we cannot use 'meta' because we are using
        /#       that as the receiver variable of metaclass methods).
        parentdata = self.parentclasses()[0]
        if parentdata.get('external', False):
          /# nonmeta class
          /#metaparent = ClassConstruct.MetaifyName('metax.root.ObjectMetaRoot')
          metaparent = 'metax.root.ObjectMetaRoot'
        else:
          /# TODO(wmh): Update this to use parentdata['class'] when we've
          /# implemented importMeta().
          metaparent = metax.oopl.ClassConstruct.MetaifyName(parentdata['metafqn'])
        /# print '******* HERE with %s and %s and %s' % (self.fqn(), metaparent, parentdata)
      else:
        /# print '**** FOR %s found explicit metaparent %s' % (self.kindfqn(), metaparent)
        pass

      /# TODO(wmh): Delete following when we are using root.meta2
      /# if metaparent == 'metax.root.Object__Meta':
      /#   metaparent = 'metax.root.ObjectMetaClass'

      metaname = metax.oopl.ClassConstruct.MetaifyName(self.id())
      assert metaspace is not None

      return (metaspace, metablock, metaname, metaparent)
    end method metaClassInfo;

    method autogenInfo : map #:
      Establish which autogenerated classes should and should not be produced.
    scope:
      /# TODO(wmh): Extend to support testmeta and metatest
      result = {'test': True, 'meta': True}
      autogen = self.attrval('autogen')
      if autogen != 'std':
        if 'notest' in autogen:
          result['test'] = False
        if 'nometa' in autogen:
          result['meta'] = False

      /# Some additional logic:
      /# - classes inheriting from Error are considered implicitly nometa
      /#   and notest if they have no scope: or only 0-1 constructs in scope:
      if self.isErrorClass():
        scope, lines = self.attrpair('scope:', default=None)
        if scope is None or len(lines) < 2:
          result['test'] = False
          result['meta'] = False

      return result
    test:
    end method autogenInfo;

    method suppressInfo : tuple<vec<str>,vec<str>> #:
      Parses the suppress() map to identifies two sets of suppression
      lists, local and global.  The local list is suitable for inclusion
      in (for example, using javascript, @fileoverview @suppress), while
      the global list is suitable for inclusion in a BUILD target rule
      (for example, using javascript, in the 'suppress' attribute of a
      closure_js_library target).
    scope:
      suppress = self.suppress() or {}
      local_list = []
      global_list = []
      for key in sorted(suppress):
        if key == key.upper():
          global_list.append(key)
        else:
          local_list.append(key)
      return (local_list, global_list)
    test:
    end method suppressInfo;

    method isErrorClass : bool #:
      True if this class inherits from metax.root.Error.
    scope:
      /# TODO(wmh): Need a 'is subclass of' mechanism in Meta. In the interim,
      /# this is heuristic in nature.
      result = False
      if self.id().endswith('Error'):
        result = True
      else:
        pcs = self.parentclasses()
        if pcs:
          if pcs[0]['id'].endswith('Error'):
            result = True
      return result
    test:
    end method isErrorClass;

    method typeOfSelf : Type #:
      Return the meta Type of 'self' for this class (or 'this' if dothis True)
    params:
      var dothis : bool = false #:
        If True, type 'this' instead of 'self'.  The hope is that we can make
        'self' be &<class>, and keep 'this' as '#*<class>' but languages may
        be inconsistent in their treatment of the type of receiver objects ...
        we'll see.
      var isconst : bool = false #:
        If True, return the version of the type in which the object is const.
    scope:
      if dothis:
        tstr = '#*%s%s' % ('#' if isconst else '', self.fqn())
      else:
        tstr = '&%s%s' % ('#' if isconst else '', self.fqn())
      result = metax.c.Type.Instance(tstr)
      return result
    end method typeOfSelf;

    method initParentClasses : vec #:
      Establish the parent classes of this class.
    scope:
      /# TODO(wmh): Why not add this as a lazy: block of parentclasses?

      parentclasses = []
      /# parents_attr, parents = self.attrpair('parents:', default=None)
      parents_attr = None
      if parents_attr is None:
        namespace = self.namespace()
        metafile = self.metafile()
        parent_attr, parent = self.attrpair('parent', default=metax.c.LOOKUP)
        fqn, metafqn = self.baselang().formatClassType(
          metafile, parent, namespace)

        /# fqn will be None if parent is 'void'
        if fqn:
          parts = metafqn.split('.')
          pdata = {
            'raw': parent,
            'fqn': fqn,
            'id': parts[-1],
            'metafqn': metafqn,
            'class': None}
          if parent[0] == metax.c.Context.Tokens()['explicit_class_indicator']:
            pdata['external'] = True
          parentclasses.append(pdata)
        else:
          /# For the special case of 'no parent', we have the choice of
          /#  1) adding a pdata in which 'fqn' is 'void'
          /#  2) returning an empty vector.
          /# Both require special casing, but #2 is more accurate, so that's
          /# what we do.
          pass
      else:
        /# TODO(wmh): Support multiple inheritance.
        pass
      self.parentclassesIs(parentclasses)
    test:
    end method initParentClasses;

    new
    method ancestors : vec<metax.oopl.ClassConstruct> #:
      Obtain the ancestors of this class (does NOT include self).
      TODO(wmh): Need to support ancestors that are outside Meta.
       - create a special ExternalClassConstruct subclass of ClassConstruct?
    scope:
      result = []
      klass = self
      while klass is not None:
        parentclasses = klass.parentclasses()
        if parentclasses:
          parent_info = parentclasses[0]
          klass = parent_info['class']
          if klass is None:
            raise metax.c.Error('Should never reach here')
          else:
            result.append(klass)
        else:
          klass = None
      result.reverse()
      return result
    test:
    end method ancestors;

    method parentclass : metax.oopl.ClassConstruct #:
      Obtain a parent class by index in superclass list.

      NOTE: Until ClassConstruct.importMeta() is invoked on this class,
      this method will return null.
    params:
      var index : int = 0 #:
        The index in self.parentclasses() of desired parent.
    scope:
      parentclasses = self.parentclasses()
      if index < len(parentclasses):
        result = parentclasses[index]['class']
      else:
        /# TODO(wmh): Raise exception?
        result = None
      return result
    test:
    end method parentclass;

    method idfqn : str #:
      Return id or fqn depending on whether this class is in same nmsp as parent.

      WARNING: Should only be invoked after ClassConstruct.importMeta() has
      been invoked!
    scope:
      parent = self.parentclass()
      pspace = parent.namespace() if parent else None
      if pspace and pspace.fqn() == self.namespace().fqn():
        result = self.id()
      else:
        result = self.fqn()
      return result
    test:
    end method idfqn;

    method registerPacked #:
      Register a packed field
    params:
      var field : str #:
        The id of the field being packed.
      var pack : str #:
        The name of the pack field.
      var bits : int #:
        The number of bits the field takes up.
      var signed : bool = false #:
        If true, the field is to be treated as a signed int rather than
        an unsigned int.
    scope:
      packed = self.packed()
      if packed is None:
        packed = {}
        self.packedIs(packed)
      pdata = packed.setdefault(pack, {})
      if field in pdata:
        raise metax.c.InternalError('This is borked')
      /# Obtain the fields in bit-position order.
      if pdata:
        keys = sorted(pdata, key=lambda k: pdata[k][0])
        last_bit, last_size, _ = pdata[keys[-1]]
        start_bit = last_bit + last_size
      else:
        start_bit = 0
      result = (start_bit, bits, signed)
      pdata[field] = result
      return result
    test:
    end method registerPacked;

    method _autogenAll #:
      Autogenerate various methods on this class.
    scope:
      baselang = self.baselang()
      baselang.autogenStr(self)
      baselang.autogenPrint(self)
      baselang.autogenWrite(self)
      baselang.autogenSize(self)
    test:
    end method _autogenAll;

    method registerDependencies #:
      Populate the 'deps' field by adding explicit and implicit dependencies to
      this class.
    scope:
      baselang = self.baselang()
      basel = baselang.id()
      metaclass = self.metaclass()
      namespace = self.namespace()
      assocs = self.attrval('associations:', default=metax.c.EMPTY)
      istest = self.isTest()

      /# Parent imports
      parent_classes = self.parentclasses()
      if parent_classes:
        parentdata = parent_classes[0]
        if not parentdata.get('external', False):
          pfqn = parentdata['metafqn']
          self.addDependency(pfqn, 'cls', 'parent')

      /# Explicit imports
      for dep in assocs:
        /# dep can be either 'assoc' or 'resource'
        akind = dep.kind()
        if akind == 'resource':
          self.registerResource(dep)
        elif akind == 'assoc':
          /# assoc
          aid = dep.id()
          aloc = dep.attrval('location', default=metax.c.LOOKUP)
          akind = dep.attrval('kind', default=metax.c.LOOKUP)
          alias = dep.attrval('alias', default=metax.c.LOOKUP)

          if self.variant() == 'testuser':
            /# We do not filter out any assocs if we are in an explicit test
            /# class.  Do we want to warn if aloc isn't the default?
            pass
          elif istest and 'test' not in aloc:
            continue
          elif 'user' not in aloc:
            continue

          if akind == 'std':
            fqn = aid
          else:
            fqn = metax.oopl.ClassConstruct.CanonicalizeClassName(
              aid, namespace=namespace)

          atarget = dep.attrval('target', default=None)
          /#print '*** HER with %s' % atarget

          if atarget is None:
            /# TODO(wmh): If akind is 'std' we could set atarget to null, but we
            /# would need to still register the dependency. Currently, we handle
            /# setting target to null in Oopl*.formatDependency instead.
            /# CODETANGLE(std_target)
            atarget = baselang.nameToBuildTarget(fqn)
          else:
            atarget = atarget.asStr(unquote=True)
          if atarget:
            self.addDependency(
              fqn, akind, 'in assocs', alias=alias, target=atarget)

      /# Implicit imports
      if metaclass is not None:
        /# This is a user-defined user-level class.  Each such class defines
        /# a 'meta' method that returns the singleton instance of the
        /# metaclass describing the class.
        mfqn = metaclass.fqn()
        if basel == 'javascript':
          /# TODO(wmh): Clean up the special-casing in javascript ... the current
          /# implementation is too messy!
          /#  - the nm.sp.FooMeta module exports both nm.sp.FooMeta and nm.sp.MetaFoo
          /#  - if one wants to import either nm.sp.FooMeta or nm.sp.MetaFoo,
          /#    special code must be generated in OoplJavascript.formatDependency.
          /#  - when importing nm.sp.MetaFoo, one uses assoc kind 'cls' even
          /#    though MetaFoo is an instance of FooMeta, not a class.
          metaclass_instname = metax.oopl.ClassConstruct.MetaInstifyName(self.id())
          mifqn = '.'.join(mfqn.split('.')[:-1] + [metaclass_instname])
          self.addDependency(
            mifqn, 'cls', 'implicit import in ClassConstruct.translateMeta()')
        else:
          self.addDependency(
            mfqn, 'cls', 'implicit import in ClassConstruct.translateMeta()')

        /# Every class depends on metax.root.ObjectMeta.
        /# TODO(wmh): Determine if this can be commented out now that the
        /# other 'implicit_objectmeta' reference is commented out.
        self.addDependency(
          /# CODETANGLE(implicit_objectmeta)
          'metax.root.ObjectMeta', 'cls', 'every class depends on ObjectMeta')

      /# If this class is a test class, we always import:
      /#  - the class it tests.
      /#  - metax.test (for metax.test.main()) ... in python
      if self.isTest():
        underclass = self.underclass()
        if underclass:
          /# All implicit test classes will have underclass set, but
          /# explicit user-provided test classes will not.
          ufqn = underclass.fqn()
          self.addDependency(
            ufqn, 'cls', 'implicit import in ClassConstruct.translateMeta()')

          if basel == 'javascript':
            tsfqn = 'goog.testing.testSuite'
            self.addDependency(
              tsfqn, 'cls', 'implicit import in ClassConstruct.translateMeta()',
              target=None)

          /# In python, the metax.test module is needed because metax.test.main()
          /# is invoked to start the test suite.
          if basel == 'python':
            self.addDependency(
              'metax.test', 'lib', 
              'implicit import of metax.test so metax.test.main() is available',
              target=None)
        else:
          /# Means we have an explicit user-provided test class.
          pass
    test:
    end method registerDependencies;

    method generateMetaClass : metax.oopl.ClassConstruct #:
      Create a metaclass associated with this class.

      May be applied to user-level or test-level classes.
    scope:
      name = self.id()
      fqn = self.fqn()
      context = self.context()
      metaspace, metablock, metaname, metaparent = self.metaClassInfo()
      metaclass = metax.oopl.ClassConstruct.NewFromData(
        /# TODO(wmh): Verify that meta class should share same context as
        /# user class.
        metaname, context, parent=metablock,
        features=[('location', 'meta')],
        secondaries=[
          ('parent', metaparent),
          /# We are not expanding the resulting class, so we don't bother
          /# ('testparent', testmetaparent),
          ('assocs:', []),
          ('comment:', ['Auto-generated meta class for %s.' % fqn]),
          ('scope:', []),
        ],
        position='-' + name,
        precount=1)
      return metaclass
    test:
    end method generateMetaClass;

    method generateImplicitMeta : metax.oopl.MethodConstruct #:
      Generate a 'meta' method for this class.
    scope:
      result = None
      /# TODO(wmh): Once confident that the generation of this method is
      /# working properly in all baselangs, some optimizations can be
      /# performed:
      /#  - the method does NOT need to be defined in every python class ...
      /#    we can simply define it in metax.root.Object as:
      /#      def meta(self):
      /#        return self.__class__
      /#    (assuming we continue to set the __metaclass__ of every class
      /#    in Python ... if we do not, we will need to continue to define
      /#    meta() in each class).
      name = self.id()
      fqn = self.fqn()
      scope = self.attr('scope:', default=None)
      baselang = self.baselang()
      context = self.context()
      metaclass = self.metaclass()
      if metaclass is None:
        /# TODO(wmh): Determine when this is an error, and when this is working
        /# as intended!
        if metax.c.Compiler.IMPL['metatestclass']:
          raise metax.c.InternalError(
            'Must initialize metaclass of %s before invoking '
            'generateImplicitMeta().' % fqn)
        else:
          /# Do not generate a 'meta' method.
          scope = None

      if scope:
        /# We do not create a 'meta' method if there is no explicit scope:
        /# in the class.  This deals with the common case of someting like
        /#   class Error < metax.root.Error;
        /# and also situations where no metaclass exists for the class.
        /#
        /# However, this may pose problems in other situations ... we can
        /# reconsider how to handle this if it is an issue. Added because
        /# NewFromData() was failing when parent=None and position!=null.

        /# Define an implicit method named 'meta' that returns the
        /# singleton instance of the metaclass defining this class.
        /#  - if metaclasses have been disabled, the method should return null.
        /# TODO(wmh): When statement-level constructs exist, define this
        /# method in Meta<*>:
        metaclass_instname = metax.oopl.ClassConstruct.MetaInstifyName(name)
        test_body = ["%s noop" % metax.c.Context.Tokens()['remark']]
        if baselang.id() == 'python':
          test_body.append('pass')
        meta_body = baselang.metaMethodBody(metaclass_instname, metaclass)

        /# We need to establish whether the 'meta' method is defined on an
        /# ancestor or not. Once we have full hierarchy info we can establish
        /# this directly, but for now the following heuristic:
        /#  - if fqn is metax.root.Object, inheritance new
        /#  - if fqn is metax.root.ObjectMetaRoot, inheritance new
        /#  - if fqn is metax.test.TestCase, inheritance new
        /#  - if class does not inherit from any of the above, inheritance new
        /#  - otherwise inheritance override
        if fqn in (
          'metax.root.Object',
          'metax.root.ObjectMetaRoot',
          'metax.test.TestCase'
        ):
          inheritance = 'new'
        else:
          inheritance = 'override'
        features = [
          ('inheritance', inheritance),
          ('autogen', 'notest'),
        ]
        secondaries = [
          /# We use * instead of & because we want to support the conditional
          /# inclusion of metaclasses.
          ('returns', metax.c.Type.Instance('*metax.root.ObjectMetaRoot')),
          ('scope:', meta_body),
          ('test:', test_body)
        ]

        result = metax.oopl.MethodConstruct.NewFromData(
          'meta', context, parent=scope, precount=1,
          features=features, secondaries=secondaries,
          primary_line=-1, position='+')

      return result
    test:
    end method generateImplicitMeta;

    method registerResource #:
      Register a resource.
    params:
      var resource : Construct #:
        The reource construct to register.
    scope:
      metafile = self.metafile()
      metac = self.compiler()
      fs = metac.fs()
      baselang = metac.baselang()

      /# Establish the path storing the resource.
      path_attr, subpath_expr = resource.attrpair('path', default=metax.c.LOOKUP)
      subpath = fs.expandvars(subpath_expr.asStr(unquote=True))

      src_path = fs.join(fs.dirname(metafile.path()), subpath)
      if not fs.exists(src_path):
        metafile.error(
          '%s does not exist' % src_path, line=resource.primary().line())
      else:
        klass = resource.ancestor('class')
        assert klass is self

        /# Create a filename that encodes the class name and the resource name.
        resname = resource.id()
        class_name = klass.id()
        /# CODETANGLE(resource_dir): See metax.root.Object.Resource.
        filename = '%s_%s' % (class_name, resname)

        /# Establish the path within the generated python code hierarchy from
        /# which we will symlink to the src path. It has to be in the same
        /# hierarchy as the generated code for bazel to be happy.
        namespace = self.namespace()
        dest_dir = fs.join(
          /# CODETANGLE(resource_dir)
          metac.repositoryPath(), metac.basePath(namespace.fqn()),
          metax.c.RESOURCES_SUBDIR)
        dest_base = fs.basename(dest_dir)
        dest_path = fs.join(dest_dir, filename)

        if not fs.exists(dest_dir):
          fs.makedirs(dest_dir, 0755)
        target = fs.join(dest_base, filename)

        /# print 'src_path %s' % src_path
        /# print 'dest_path %s' % dest_path
        /# print 'target %s' % target

        /# Create the symlink from src_path to dest_path.
        if not fs.lexists(dest_path):
          print 'NOTE: Linking %s to %s' % (src_path, dest_path)
          fs.symlink(src_path, dest_path)
        else:
          /# The file already exists ... verify it is a symlink and points where
          /# it should.
          if fs.islink(dest_path):
            curr_src_path = fs.readlink(dest_path)
            if curr_src_path != src_path:
              /# It does not point where it should. For now, we report an error and tell
              /# the user how to fix the problem (by removing the incorrect symlink). We
              /# may want to automatically do this in the future (but we want to avoid
              /# deleting an important file while doing
              metafile.error(
                'Resource %s is stored in\n'
                '  %s\nwhich currently links to\n'
                '  %s\ninstead of\n'
                '  %s\nRemove\n'
                '  %s\n'
                'and reinvoke metac to proceed.' %
                (resname, dest_path, curr_src_path, src_path, dest_path),
                line=resource.primary().line())
          else:
            metafile.warning(
              'Resource %s is stored in\n'
              '  %s\n'
              'which is currently a non-symlink when it should be a symlink to\n'
              '  %s\n'
              'You can remove\n'
              '  %s\n'
              'and reinvoke metac to clean up.' %
              (resname, dest_path, src_path, dest_path),
              line=resource.primary().line())

        /# Store a mapping from resource name to target for use in
        /# createBuildFragment().
        self.resources()[resname] = target
    end method registerResource;

    method registerInitializer #:
      Register an initializer with this class.
    params:
      var initializer : metax.oopl.MethodConstruct;
    scope:
      /# TODO(wmh): it is very possible that the MethodConstruct instance
      /# will never be properly GCed because of all the circular links.
      /# Implement __del__ on Construct, and/or start using weakptrs in
      /# some places.  Relevant because we are tromping any pre-existing
      /# initializer and hoping the old instance gets GCed ... it may not!
      current = self.initializer()
      if current:
        current.myclassIs(None)
      self.initializerIs(initializer)

      if initializer:
        initcls = initializer.myclass()
        if initcls and initcls is not self:
          raise metax.c.Error(
            '%s already has initializer %s and now %s' %
            (self.fqn(), initcls.kindfqn(), initializer.kindfqn()))
        initializer.myclassIs(self)
    test:
    end method registerInitializer;

    method registerStaticInitializer #:
      Register a static initializer with this clas.
    params:
      var initializer : metax.oopl.MethodConstruct #:
        The method defining the static initializer.
        TODO(wmh): Not all baselangs implement static initializers via
        methods (e.g. Java). This will need to be generalized.
    scope:
      self.clinitIs(initializer)
    test:
    end method registerStaticInitializer;

    meta
    method CreateAssocs : metax.attr.ComplexBlock #:
      Create a 'associations:' attribute given assoc info.
    params:
      var assoclist : vec<map> #:
        Each element is a map containing:
          id: str
          features : vec<tuple<str,str>>
          secondaries : vec<tuple<str,any>>
          termcode : int
      var context : Context;
    scope:
      assocs = metax.attr.ComplexBlock(None, 'associations:', [])
      for assocdata in assoclist:
        assoc = metax.oopl.AssocConstruct.NewFromData(
          assocdata['id'], context, parent=assocs,
          features=assocdata.get('features', None),
          secondaries=assocdata.get('secondaries', None),
          termcode=assocdata.get('termcode', 1))
      return assocs
    test:
      _, schema, context, compiler = test.cachedInfo()

      assocs = metax.oopl.ClassConstruct.CreateAssocs([], context)
      test.iseq('associations:', assocs.key())
      test.iseq([], assocs.value())

      assocs = metax.oopl.ClassConstruct.CreateAssocs(
        [
          {'id': 'sys', 'features': [('kind', 'std')]},
          {'id': 'code', 'features': [('kind', 'std'), ('location', 'test')]},
          {'id': 'nm.sp.Class',
           'features': [('kind', 'cls')],
           'secondaries': [
             ('target',
              metax.c.Expr(
                'str', '"//faux@nm.sp:Class"', '"//faux@nm.sp:Class"'))]},
        ],
        context)
      test.iseq('associations:', assocs.key())
      test.iseq(
        ['std assoc sys;\n',
         'std test assoc code;\n',
         'cls assoc nm.sp.Class target "//faux@nm.sp:Class";\n'],
        [assoc.asStr() for assoc in assocs.value()])
    end method CreateAssocs;

  end Construct class;

  Construct field < _classic_ #:
    @field: The field construct.
  config:

    feature
    Attribute access : <ro|rw|rwx|raw> = ro #:
      Which accessors are public (the others are protected).

      TODO(wmh): This mechanism is somewhat limited. If we could specify,
      for each accessor, whether or not it is to be generated, and its
      visibility, that would be best.

      Suppose we use
        r = getter
        w = setter
        x = reffer
        i = adj
        @ = the field itself
        $ = element-of

      We could specify a particular accessor with:
        +r = getter is public
        -r = getter is private
        #r = getter is protected
        ~r = getter is package
        !r = getter is not generated
      
      And the complete set could be:
        +r+w
        +r-w-x
        etc.
      
      However, the above would require a different mechanism for defining
      feature values. Two possibilities:
       1. the set of feature values is
            r +r -r #r ~r !r
            w +w -w #w ~w !w
            x +x -x #x ~x !x
            i +i -i #i ~i !i
          and this feature key allows multiple values separated by ''.
          (note that 'r' is shorthand for '+r').  We may also want to
          add support for abbrevs for the complete value (e.g. 'raw'
          is an alias for '!r!w!x!i').
       2. we add support for regexp-based feature values:
            ([@+#~!-]?[rwxi])+
          (we could add special abbrevs to this regexp ... 'raw' means
           '!r!w!x!i+@' ... but mapping those abbrevs to their actual
           semantics would need to be hardcoded into the implementation
           rather than being specified in the schema file unless we provide
           remapping syntax).
    config:
      FeatureValue ro #:
        The getter is public, setter is protected, no other accessors.
      FeatureValue rw #:
        The getter and setter are public, no other accessors.
      FeatureValue rwx #:
        The getter, setter and reffer are public, no other accessors.
      FeatureValue raw #:
        No accessors are generated.
    end Attribute access;

    feature
    Attribute visibility : <tmppublic|tmpprivate> = tmpprivate #:
      The visibility of the field.

      TODO(wmh): This attribute is temporary. It is subsumed by the 
      multi-valued version of 'access', and code should start migrating
      away from the use of this field.  Hence the 'tmp' prefix on
      legal values.
    config:
      FeatureValue tmppublic #:
        The field itself (as opposed to its accessors) is public.
      FeatureValue tmpprivate #:
        The field itself (as opposed to its accessors) is private.
    end Attribute visibility;

    feature
    Attribute status : <required|optional> = required #:
      Whether this field is optional.
    config:
      FeatureValue required #:
        The field is always defined
      FeatureValue optional #:
        The field does not take up any space if it is not set or has
        default value.
    end Attribute status;

    feature
    Attribute ownership : <owned|unowned> = unowned #:
      Whether this field is optional.
    config:
      FeatureValue owned #:
        The class instance is responsible for cleaning up this field.
        In UML diagrams, this marks composition.
      FeatureValue unowned #:
        The class instance is not responsible for cleaning up this field.
        In UML diagrams, this marks aggregation.
    end Attribute ownership;

    Attribute location;
    Attribute kind;

    feature
    Attribute inheritance : <new|override> = override #:
      Whether the accessors are defined in parents or not.
      TODO(wmh): We need to be able to specify this on a per-accessor
      basis. This can be done by moving the 'access' feature attribute to
      a more robust implementation, and/or by adding a feature key on
      the 'accessor' construct.

      The 'accessor' construct can be used to override this value on an
      individual basis.
    config:
      FeatureValue new #:
        The accessors are not defined in a parent class.
      FeatureValue override #:
        The accessors are defined in a parent class.
    end Attribute inheritance;

    primary
    Attribute field : id = <required> #:
      The name of the field.

    secondary
    Attribute type : type = <required> aliases <:> #:
      The metatype of the field.

    secondary
    Attribute default : expr = <empty> aliases <=> #:
      The default value of the field.  If not provided, a type-specific
      default is used:
        int     0
        uint    0
        real    0.0
        bool    false
        *<any>  null 
        @vec    []
        @map    {}
    end Attribute default;

    secondary
    Attribute pack : word = <empty> #:
      Indicates that this field is to be packed into the named field
      (optionally at the specified bit position).

    secondary
    Attribute role : str = <empty> #:
      The role name to add to UML class diagrams to identify how the field
      participates with this class. Only meaningful for fields of class type.
      Note that there will not be a role label on the side of the link connected
      to the class within which the field resides unless the class of which the
      field is an instance has a reciprocal field linking to an instance, and
      specifies a 'role' attribute.  Multiplicity is establish by the type
      of the field (is it a vec/map/etc?)

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <accessor>;

    Template python_get scope:
      >|${decorator}
      >|def ${field}(${receiver?}): ${scope}

    Template python_set scope:
      >|${decorator}
      >|def ${field}Is(${receiver?, }value): ${scope}

    Template python_ref scope:
      >|${decorator}
      >|def ${field}Ref(${receiver?}): ${scope}


  expand:
    /# Expand the field
    /#  - produce accessor methods (getter, setter, reffer, etc.)
    /#    in appropriate class depending on level.
    /#  - leave the field construct in the user class no matter what
    /#    (translateMeta can decide whether to ignore or not on a per-baselang
    /#    basis).
    metax.c.D.expand.sinfo(self.kindfqn())

    myclass, moved = self.updateClass()
    /# D.expand.info('moved = %s' % moved)

    if moved:
      /# We only expand fields if we haven't moved the field to a different
      /# class (if we have moved it, it will be expanded later when that
      /# class is expanded).
      metax.c.D.expand.info('moved (no further expansion)', level=2)
    else:
      name = self.id()
      fqn = self.fqn()
      if myclass:
        clsname = myclass.id()
        fqcn = myclass.fqn()
        namespace = myclass.namespace()
      else:
        clsname = None
        fqcn = None
        namespace = self.ancestor('namespace')
      nmspfunc = lambda: namespace
      baselang = self.baselang()
      metafile = self.metafile()
      context = self.context()

      kind = self.attrval('kind')
      scope, accessors = self.attrpair('scope:', default=None)
      pack = self.attrval('pack')
      tmpvis = self.attrval('visibility')
      typeattr, type = self.attrpair('type', default=metax.c.LOOKUP)
      select = self.attrval('access')
      if type is None:
        metafile.error('Must provide a type', line=self.primary().line())
        return
      isconst = type.isBaseConst()

      /# We establish the receiver to use for accessors
      /#  - use the receiver dictated by the baselang so that we don't
      /#    incur inefficiencies introducing a variable unlikely to be used
      /#    by the user
      /#  - HOWEVER, when user defines accessors in field scope:, they
      /#    need to know which variable to use to reference the receiver.
      /#    We need to either be consistent, document inconsistencies, or
      /#    auto-insert receiver variables as needed.
      /#  - Note that some baselangs do not have a specific receiver variable
      /#    (e.g. Python and Perl), in which case we use the meta-level
      /#    receiver variable.
      if myclass:
        location = 'test' if myclass.isTest() else ('meta' if myclass.isMeta() else 'user')
        receiver_code = (
          baselang.receiverStr(
            self, style='base', location=location, myclass=myclass))
        if kind == 'static':
          receiver_code += baselang.config('staticsep')
        else:
          receiver_code += baselang.config('selfsep')
        /# print '%s = %s [%s]' % (self.kindfqn(), receiver_code, kind)
      else:
        receiver_code = ''

      /# print 'FieldConstruct.expandMeta: %s' % fqn

      /# Register this field with the class.
      if myclass:
        myclass.fields().append(self)

      /# Establish the rawfield of this field
      /# CODETANGLE(fieldinit):
      tokens = metax.c.Context.Tokens()
      packinfo = None
      if pack:
        tbase = type.base()
        tparams = type.params()
        if tbase not in ('int', 'uint') or len(tparams) != 1:
          metafile.error('Invalid packed field', line=typeattr.line())
        else:
          signed = tbase == 'int'
          bits = int(tparams[0])
          packinfo = myclass.registerPacked(name, pack, bits, signed)
        rawfield = tokens['field_prefix'] + pack + tokens['field_suffix']
      elif tmpvis == 'tmppublic':
        rawfield = name
      else:
        rawfield = tokens['field_prefix'] + name + tokens['field_suffix']
      self.rawfieldIs(rawfield)
      stmtend = baselang.config('stmtend')

      /# Establish the default accessor code.
      /#  - also establishes the legal set of accessor ids.
      /#  - TODO(wmh): Must generalize this to all baselangs. Defined
      /#    a 'initBodyMap' behavior.
      field_code = '%s%s' % (receiver_code, rawfield)
      bodymap = {}
      if packinfo:
        /# print '%s = %s' % (name, packinfo)
        start_bit, bits, signed = packinfo
        maxval = (1 << bits) - 1
        mask = '0x%x' % maxval
        smask = '0x%x' % (maxval << start_bit)
        if signed:
          halfval = (1 << (bits-1))
          bodymap['get'] = [
            'return ((%s >> %d) & %s) - %d%s' %
            (field_code, start_bit, mask, halfval, stmtend)]
          bodymap['set'] = [
            '%s = (%s & ~%s) | ( (value + %d) << %d )%s' %
            (field_code, field_code, smask, halfval, start_bit, stmtend)]
        else:
          bodymap['get'] = [
            'return (%s >> %d) & %s%s' %
            (field_code, start_bit, mask, stmtend)]
          bodymap['set'] = [
            '%s = (%s & ~%s) | ( value << %d )%s' %
            (field_code, field_code, smask, start_bit, stmtend)]
        bodymap['ref'] = ['raise Error("cannot ref packed field")']
      else:
        bodymap['get'] = ['return %s%s' % (field_code, stmtend)]
        bodymap['ref'] = ['return %s%s' % (field_code, stmtend)]
        /# See ../../README.md section 'Accessors' for discussion of setter
        /# return values. Currently having setters return void. 'return %s%s' %
        /# (receiver_code, stmtend)
        bodymap['set'] = ['%s = value%s' % (field_code, stmtend)]
      bodymap['format'] = []
      bodymap['write'] = []
      bodymap['size'] = []

      /# Determine if there are any explicit accessors.
      lazylines = None
      if scope:
        for accessor in accessors:
          acc = accessor.id()
          if acc not in bodymap:
            metafile.error(
              'Invalid accessor %s' % acc, attribute=accessor.primary())
          else:
            acclines = accessor.attrval('scope:', default=None)
            lazy_attr, lazylines = accessor.attrpair('lazy:', default=None)
            if acclines is not None:
              if lazylines is not None:
                metafile.error(
                  'accessor %s should specify only scope or lazy, not both' %
                  accessor.id(), line=lazy_attr.line())
              bodymap[acc] = acclines
            elif lazylines is not None:
              /# We process the lazylines after we've created a getter method
              /# below.
              pass

      /# Establish which accessors to generate
      /#  - TODO(wmh): Improve on this by making the 'access' attribute
      /#    a multi-valued field.
      genacc = {}
      if select == 'raw':
        /# By definition of 'raw', there are no accessors for raw fields.
        genacc['get'] = False
        genacc['set'] = False
        genacc['ref'] = False
      else:
        /# We generate accessors. However, if the field has const type,
        /# we don't generate a setter or reffer.
        genacc['get'] = True
        genacc['set'] = not isconst
        genacc['ref'] = False  # disabling for now # not isconst

      /# The line number in the metafile at which the field is defined. It
      /# is used for:
      /#  - indicating the (faux) metafile line number of the accessor method
      /#  - indicating the (faux) metafile line number of the accessor scope
      primary_line = self.primary().line()
      dest_scope = self.parent()

      /# Getter
      if genacc['get']:
        features = [('optimization', 'inline')]
        if kind != 'instance':
          features.append(('kind', kind))
        getname = name + ':get'
        getter_return = baselang.accessorType(
          type, 'get', namespace_function=nmspfunc)
        getter = metax.oopl.MethodConstruct.NewFromData(
          getname, context,
          features=features + [('mutability', 'const')],
          secondaries=[
            (':', getter_return),
            ('scope:', bodymap['get'], primary_line),
          ],
          primary_line=primary_line)
        getter.myclassIs(myclass)
        metax.c.D.expand.info('Created getter ' + getter.fqn(), level=2)

        if lazylines:
          /# The getter (and reffer?) have lazy lines, so we need to
          /# generate some additional code to replace getter scope:.
          newlines = []
          /# TODO(wmh): Compile a var construct to assign an value to
          /# a result var?
          resvar = '__meta_result'
          recstr = baselang.receiverStr(getter, sep=True)
          rawvar = '%s%s' % (recstr, rawfield)
          newlines.append('%s = %s' % (resvar, rawvar))

          /# TODO(wmh): Make this a baselang method.
          if baselang.id() == 'python':
            if type.isValue():
              newlines.append('if not %s:' % resvar)
            else:
              newlines.append('if %s is None:' % resvar)
            for i in range(0, len(lazylines)-1):
              newlines.append('  ' + lazylines[i])
            lazyend = lazylines[-1][:3]
            if lazyend != '-> ':
              metafile.error(
                'Expecting lazy: block of accessor to end with line starting "-> " not "%s"' % 
                (lazyend), line=lazy_attr.line())
            resval = lazylines[-1][3:]
            newlines.append('  %s = %s' % (resvar, resval))
            newlines.append('  %s = %s' % (rawvar, resvar))
            /# TODO(wmh): This can easily be obtained for all baselangs
            /# by compiling a 'return' construct.  See the getter code
            /# in Compiler._expandField() for an example.
            newlines.append('return ' + resvar)
            gscope = getter.attrval('scope:')
            del gscope[:]
            gscope.extend(newlines)
          else:
            raise Error('Not yet handling lazy in %s' % baselang.id())
      else:
        getter = None

      /# Define the setter
      /#  - See ../../README.md section 'Accessors' for a discussion about
      /#    setter return types. Setters return void.
      /#  - We don't define a setter if the field is const.
      if genacc['set']:
        setret = 'void'
        setname = name + 'Is:set'
        setter = metax.oopl.MethodConstruct.NewFromData(
          setname, context,
          features=features,
          secondaries=[
            (':', metax.c.Type.Instance(setret)),
            ('scope:', bodymap['set'], primary_line),
          ],
          primary_line=primary_line)
        params = metax.oopl.ExecutableConstruct.CreateParams(
          [
            {'var': 'value',
             'secondaries': [
               ('type', baselang.accessorType(
                 type, 'setarg', namespace_function=nmspfunc))]},
          ], context)
        setter.registerAttribute(params, position='-scope:')
        setter.myclassIs(myclass)
        metax.c.D.expand.info('Created setter ' + setter.fqn(), level=2)
      else:
        setter = None

      /# Define the reffer
      /#  - we don't define a reffer if the field is const.
      if genacc['ref']:
        refname = name + 'Ref:ref'
        reffer = metax.oopl.MethodConstruct.NewFromData(
          refname, context,
          features=features,
          secondaries=[
            ('returns', baselang.accessorType(
              type, 'ref', namespace_function=nmspfunc)),
            ('scope:', bodymap['ref'], primary_line),
          ],
          primary_line=primary_line)
        reffer.myclassIs(myclass)
        metax.c.D.expand.info('Created reffer ' + reffer.fqn(), level=2)
      else:
        reffer = None

      /# We insert all accessor methods after the field construct.
      /#  - by inserting reffer, then setter, then getter, we end up
      /#    putting them in the order getter, setter, reffer.
      /#  - we also register the accessors in the symbol table of
      /#    myclass.
      position = '+' + name
      if reffer:
        dest_scope.registerConstruct(reffer, position=position)
        if myclass:
          myclass.registerSymbol(reffer.id(), reffer)
      if setter:
        dest_scope.registerConstruct(setter, position=position)
        if myclass:
          myclass.registerSymbol(setter.id(), setter)
      if getter:
        dest_scope.registerConstruct(getter, position=position)
        if myclass:
          myclass.registerSymbol(getter.id(), getter)

      /# QUESTION: Do we register rawfield or field?
      /#  - From a practical perspective, it is cleaner to register rawfield,
      /#    as that would allow us to register the getter with the :get suffix
      /#    (but doing so means we have to map user-provided field names to
      /#    raw names when resolving -> provide references).
      /#  - From a conceptual perspective, it depends on whether symbols in
      /#    the symbol-table represent what is actually visible to the
      /#    baselang, or whether the symboltable stores conceptual symbols
      /#    that get mapped down to baselang representations later.
      /#   
      /#  - Symbols are conceptual names:
      /#    + implementing -> provide semantics is easy
      /#    + in namespace, conceptual symbols would be classnames (baselang
      /#      symbols would require us using the MetaFoo singleton instance,
      /#      at least in languages without first-class classes). Being able
      /#      to refer to classes instead of metaclasses is intuitive, and
      /#      makes it viable for us to define the auto-generator for 
      /#        /mem/<metafile>/<namespace>/<class>/<method>
      /#      to be "show the symbol table of the current construct", which
      /#      is pretty convenient.
      /#    + we get to use a high-level receiver string instead of the
      /#      receiver varying from baselang to baselang (admittedly though,
      /#      there is still the 'self'/'meta'/'test' ambiguity).
      /#    - fields use field id not rawfield, at getter needs to be suffixed with :get
      /#    - we need to define a means of mapping high-level symbols to
      /#      baselang level.
      /#    - The most intuitive "conceptual" name for a field is its id.
      /#      The most intuitive "conceptual" name for a getter is its id.
      /#      There is an inherent conflict here that is resolved if we use
      /#      the rawname for fields.
      /#  - Symbols are baselang names:
      /#    + no need to perform high-level-to-baselang mapping of symbols,
      /#      since the symbols are already in baseang syntax.
      /#
      /#  - The current implementation is to have the symbol table store
      /#    conceptual names.  We can revisit if we find problems with this.
      /# CODETANGLE(highlevel_symbols):
      if myclass:
        myclass.registerSymbol(name, self)

      if scope:
        self.accessorsIs(scope.map())

    metax.c.D.expand.end()

  translate:

    /# Field compilation code.
    /#  - for languages (like Python and javascript) that define fields in
    /#    initializers, there is nothing to do in FieldConstruct.translateMeta(),
    /#    since it is all handled in the initializer, which has been populated in
    /#    FieldConstruct.expandMeta.
    /#  - for languages (like C++ and Java) for which there is an explicit syntax
    /#    for defining fields, we generate appropriate code here.
    metax.c.D.translate.sinfo(self.kindfqn())

    baselang = self.baselang()
    metafile = self.metafile()
    streams = metafile.streams()

    /# TODO(wmh): Perform as much work here as possible before calling
    /# baselang.formatBaseField().  In particular, check if the field is
    /# optional, packed, etc.
    select_attr, select = self.attrpair('access', default=metax.c.LOOKUP)
    status_attr, status = self.attrpair('status', default=metax.c.LOOKUP)
    location_attr, location = self.attrpair('location', default=metax.c.LOOKUP)
    kind_attr, kind = self.attrpair('kind', default=metax.c.LOOKUP)
    pack_attr, pack = self.attrpair('pack', default=metax.c.LOOKUP)
    inheritance_attr, inheritance = self.attrpair(
      'inheritance', default=metax.c.LOOKUP)
    type_attr, type = self.attrpair('type', default=metax.c.LOOKUP)
    /# TODO(wmh): Should we LOOKUP default?
    default_attr, default = self.attrpair('default', default=None)
    comment_attr, comlines = self.attrpair('comment:', default=None)

    rem = baselang.config('rem') + ' '
    clines = []
    clines.append('')
    clines.append('%sfield %s : %s' % (rem, self.id(), type))
    if comlines:
      k = len(comlines) - 1
      while k > 0 and not comlines[k].strip():
        k -= 1
      for i in range(0, k+1):
        clines.append(rem + '  ' + comlines[i])
    lines = clines[:]
    lines.extend(baselang.formatFieldDefinition(self))

    /# In most languages, the field definition occurs in the merged defn/decl
    /# stream, but in languages with separated decl/defn (at least in C++),
    /# the field definition is written into the declaration stream.
    /# TODO(wmh): Define a method on BaseLanguageOopl for determining which
    /# stream to write field declarations to?
    sname = 'defn'
    if baselang.config('definition_separate'):
      sname = 'decl'
    if lines:
      /# TODO(wmh): Do we need to create a BaseSegment so we have line
      /# numbering? Will need to split apart comment lines and code lines.
      streams.addLines(sname, lines)

    if baselang.id() == 'cpp':
      defn_lines = baselang.formatFieldDefinition(self, defn=True)
      streams.addLines('defn-post', defn_lines)

    metax.c.D.translate.end()

  scope:

    field namespace : metax.oopl.NamespaceConstruct #:
      The namespace this field belongs to. Note that this has been added to
      allow 'field' constructs to appear directly within namespaces. Further
      exploration of the impact of this is needed.

    field rawfield : str #:
      The rawfield name for this field.  This is usually some minor variant
      of self.id(), but for packed fields it can be completely different.

    field packed : tuple<int,int> #:
      Will be null if the field is not packed, otherwise the first integer
      is the lowest bit position in rawfield of this field, and the second
      integer is the number of bits used by the field.

    field accessors : *map<str,metax.oopl.AccessorConstruct> #:
      Maps accessor name to accessor construct. This is just a pointer to
      the map() field of the scope: block of the field.  It is null if there
      is no explicit scope:

  end Construct field;

  Construct accessor < _oopl_ #:
    @accessor: An accessor associated with a field.

    Appears in the 'scope:' block of the 'field' construct.
  config:

    primary
    Attribute accessor : id = <required> #:
      Unlike in almost all other constructs, the set of legal identifiers
      for accessors is predefined. The legal identifiers are:
        get: the getter
        set: the setter
        ref: the reffer
        adj: allows a numeric field to be incremented/decremented by given val.
        print: how to provide human-readable value
        write: how to serialize the field
        TODO(wmh): what other accessors are there?

    secondary
    Attribute lazy: : simple = <empty> children <_statement_> #:
      A block of code used to compute a value for the field on demand. Meta
      provides the wrapper code around this block to check if the field is
      already initialized, and to perform the initialization code if not.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

    secondary
    Attribute test: : simple = <empty> children <_statement_> #:
      A single test block associated with this field. For the field
      nm.sp.Foo.name, the test method is nm.sp.FooTest.test_name.

  scope:
  end Construct accessor;

  abstract
  Construct _executable_ < _classic_ clsname ExecutableConstruct #:
    @Executable: Abstracut superclass of executable constructs.
  config:

    feature
    Attribute presence : <concrete|abstract> = concrete #:
      Dictates whether this method has an implementaton or not.
    config:
      FeatureValue abstract #:
        Subclasses must provide an explicit scope in order to be instantiated.
      FeatureValue concrete #:
        A scope must be provided with this method.
    end Attribute presence;

    feature
    Attribute visibility : <public|private|protected|package> = public #:
      The visibility of the method.
    config:
      FeatureValue public #:
        The method is visible to any class.
      FeatureValue protected #:
        The method is only visible within this class and its subclasses.
      FeatureValue private #:
        The method is only visible within this class itself.
      FeatureValue package #:
        The method is only visible within classes in the same namespace.
    end Attribute visibility;

    feature
    Attribute span : <general|specific> = general #:
      Whether the executable applies to all base languages or only those
      with a scope block.
    config:
      FeatureValue specific #:
        The compiler does not generate a method for baselangs without a scope
        block.
      FeatureValue general #:
        The compiler reports a warning if the method is being compiled into
        a baselang and does not have a scope block for that baselang (and
        defines a method with empty body).
    end Attribute span;

    feature
    Attribute mutability : <mutable|const|immutable> = mutable #:
      Whether the receiver is modified within this method.
    config:
      FeatureValue mutable #:
        The receiver may be modified.
      FeatureValue const #:
        The receiver may not be modified (but objects within this may be)
      FeatureValue immutable #:
        The receiver may not be modified, nor any objects linked from it.
    end Attribute mutability;

    feature
    Attribute autogen : <std|notest> = std #:
      Controls whether a test method is auto-generated even when no
      test block exists.
    config:
      FeatureValue std #:
        Auto-generate a test method for the executable.
      FeatureValue notest #:
        No test method is generated
    end Attribute autogen;

    feature
    Attribute extensibility : <extendable|final> = extendable #:
      Whether subclasses can override the method.
    config:
      FeatureValue extendable #:
        Subclasses can override the method.
      FeatureValue final #:
        Subclasses cannot override (or, at least won't be paid attention to
        when receivers are typed of this class as opposed to the subclass).
    end Attribute extensibility;

    feature
    Attribute dispatch : <autodispatch|nonvirtual|virtual> = virtual #:
      How dispatch occurs on this method.
    config:
      FeatureValue autodispatch #:
        Use baselang-specific default
        TODO(wmh): We need a baselang-independent semantics for this! Or it
        needs to be removed.
      FeatureValue nonvirtual #:
        Which implementation of this method is to be invoked at a particular
        callsite is determined based on the static type of the receiver as
        opposed to the dynamic type.
      FeatureValue virtual #:
        Which implementation of this method is to be invoked at a particular
        callsite is determined based on the dynamic type of the receiver as
        opposed to the static type.
    end Attribute dispatch;

    feature
    Attribute optimization : <outline|inline> = outline #:
      Whether the executable should be considered for optimization
      via inlining. Accessors are always marked as inlined.
    config:
      FeatureValue outline #:
        The executable is not marked as inlineable.
      FeatureValue inline #:
        The executable is marked as inlineable.
    end Attribute optimization;

    feature
    Attribute inheritance : <new|override|prex|postx|superx> = new #:
      How inheritance behaves for this method.

      TODO(wmh): Determine whether this is the right place for prex/postx/superx
      or whether they should be separated into a different feature attribute.

      TODO(wmh): Determine whether the default should be 'override' or 'new'.
    config:
      FeatureValue new #:
        The method is not defined in a parent, and is defined newly here.
      FeatureValue override #:
        The method overrides an inherited definition by completing replacing
        functionality.
      FeatureValue prex #:
        The method extends an inherited definition by always invoking its
        parent implementation (with same args) after doing class-specific actions.
      FeatureValue postx #:
        The method extends an inherited definition by always invoking its
        parent implementation (with same args) before doing class-specific actions.
      FeatureValue superx #:
        The method extends an inherited definition by always invoking its parent
        implementation (with same args) somewhere within its method body, via
        the special META_SUPER syntax.
    end Attribute inheritance;

    Attribute location;

    feature
    Attribute kind : <instance|static|cls|closure|initializer|finalizer> = instance #:
      Identifies one of a variety of mutually exclusive kinds of methods.

      TODO(wmh): The fact that executables have a feature attribute named kind',
      combined with us using 'kind to refer to the primary key, is destined to
      pose confusion. Consider renaming one or the other use.
    config:
      FeatureValue instance #:
        A ${kind} defined on a class having a receiver object typed of that
        class.
      FeatureValue static aliases <function> #:
        A method that does not contain a receiver (e.g. a static method when
        defined at class scope is a function). However, a function can appear
        in more places ... at namespace level, within methods, etc.
        TODO(wmh): Is 'static' just an alias for 'function'?
      FeatureValue cls #:
        This is a special case for handling an issue in Python between metaclasses
        and @classmethods.  It indicates that the method should have a @classmethod
        decorator. It would be preferable to define such methods as having
        location 'meta', but in Meta that puts the method in the metaclass instead
        of being an @classmethod method.  Python does not treat @classmethods
        entirely as methods on the metaclass, which breaks things, hence the need
        for this special case.  This value should be considered an implementation
        detail and NOT used in user-level code, as it does not have a correlate in
        most other baselangs. It is used internally by Meta when @classmethods
        are needed to implement some higher-level meta concept.
      FeatureValue closure #:
        A function that has access to the variables in the scope within which
        it is lexically defined.
      FeatureValue initializer aliases <init> #:
        Called a constructor in most languages ... the method that initializes
        state of an instance.
      FeatureValue finalizer #:
        Called a destructor in some languages, cleans up state before an object
        is freed up (either explicitly or implicitly).
    end Attribute kind;

    secondary
    Attribute alias : word = <empty> #:
      Alternative names for this entity. Although singular, it can be a
      comma-separate list of identifiers. For example, a method may have
      id 'perimeter' and alias 'circumference', in which case both are legal.
      TODO(wmh): Make this an idlist instead of word!

    secondary
    Attribute params: : complex = <required> children <var> #:
      The parameters of this method.

    secondary
    Attribute super : expr = <empty> #:
      The args to pass to parent implementation when prex/postx/superx.

    secondary
    Attribute returns : type = void aliases <:> #:
      The return type of the method.  The returns: complex block allows
      one to document the return type and to define thrown exceptions.

    secondary
    Attribute returns: : type = void aliases <->:> #:
      A block that specifies the return type and thrown exceptions.
    children <return|throw>;

    secondary
    Attribute pres: : complex = <empty> children <pre> #:
      Preconditions

    secondary
    Attribute posts: : complex = <empty> children <post> #:
      Preconditions

    secondary
    Attribute test: : simple = <empty> children <_statement_> #:
      A single test block associated with this method. For the method
      nm.sp.Foo.name, the test method is nm.sp.FooTest.test_name.

    secondary
    Attribute tests: : complex = <empty> children <testx> #:
      Allows multiple tests to be defined. The ids of each testx are used as
      suffixes to the test method name formed by the user-provided method. For
      the method nm.sp.Foo.name, if there are three testx constructs in the
      'tests' block with ids 'a', 'b', and 'c', the test methods will be
      nm.sp.FooTest.test_name_a, nm.sp.FooTest.test_name_b, and
      nm.sp.FooTest.test_name_c

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

  expand:
    /# Expand the executable
    /#  - if level is meta, move method to metaclass
    /#  - if level is test, move method to testclass
    /#  - currently, we do NOT recurse to children, as the children in scope: are
    /#    either lines (simple block) or statement level constructs that do not
    /#    need expansion.
    metax.c.D.expand.sinfo('%s (%s)' % (self.kindfqn(), self))

    myclass, moved = self.updateClass()
    /# D.expand.info('moved = %s' % moved)

    if moved:
      /# We only expand methods if we haven't moved the method to a different
      /# class (if we have moved it, it will be expanded later when that
      /# class is expanded).
      metax.c.D.expand.info('moved (no further expansion)', level=2)

      /# TODO(wmh): In Python, due to some unfortunate ways that metaclasses
      /# interact with @classmethod, we need to provide a @classmethod
      /# implementation of meta methods within the userclass, which means
      /# we need to create some wrapper method.
      /#  - How to establish whether the current method is a meta method
      /#    within user scope?
      /#  - Do we have the @classmethod method defined on the userclass
      /#    call the meta method, or vice-versa?
      /#  - How do we handle class variables vs meta variables?
      pass

    else:
      metafile = self.metafile()
      context = self.context()
      fqn = self.fqn()
      variant = myclass.variant()
      baselang = self.baselang()

      kind = self.attrval('kind')
      span = self.attrval('span')
      scope = self.attrval('scope:', default=None)
      autogen = self.attrval('autogen')

      if span == 'specific' and scope is None:
        /# This method does not apply to the current baselang, so we remove
        /# it entirely.
        self.parent().unregisterConstruct(self)

      else:
        /# If this is an initializer, record it with the class.
        if kind == 'initializer':
          myclass.registerInitializer(self)

        /# Establish the receiver variable to use.
        rec = baselang.receiverStr(self, style='meta')

        /# We register this executable as a symbol within its class.
        /#  - TODO(wmh): Think more carefully about how symbols should be
        /#    handles for meta and test classes.
        if variant == 'user':
          myclass.registerSymbol(self.id(), self)

        /# TODO(wmh): In python, due to some unfortunate ways that metaclasses
        /# interact with @classmethod, we need to provide a @classmethod
        /# implementation of meta methods within the userclass (it delegates to
        /# the implementation in the metaclass).
        /#  - How do we establish if this is a meta-method within a user
        /#    class? (

        /# We expand 'test:' and 'tests:' blocks in methods within classes of
        /# the following variants:
        /#   user
        /#   meta
        /#   metauser ???
        /# We do NOT expand test blocks in
        /#   test      (test classes do not have tests)
        /#   testmeta  (test classes do not have tests)
        /#   metatest  (meta classes of test classes do not have tests)
        /#   testuser  (test classes do not have tests)

        testclass = myclass.testclass()
        if (
          (variant in ('user', 'meta'))
          and testclass
          and autogen != 'notest'
          /# TODO(wmh): Find a better way to identify auto-generated methods!
          and not self.id().startswith('metax')
        ):
          /# Define one (or more) test methods within the test class
          /# associated with the class this method is defined within.
          testscope = testclass.attr('scope:')
          testattr, testlines = self.attrpair('test:', default=None)
          testsattr, testxes = self.attrpair('tests:', default=None)

          /# The code below creates one or more entries in testdata based on
          /# data in testattr and testsattr.
          /#  - if neither a test: nor tests: block is found, we create one
          /#    test method printing "test not yet implemented".
          /#  - if test: and tests: are both defined, it is an error
          /#  - if test: is defined, create one test method
          /#  - if tests: is defined, create one test method for each testx
          /#    construct in tests:
          /#  - each element of testdata contains:
          /#      name : str
          /#        The name of the test method
          /#      features : vec<tuple<str,str>>
          /#        The key/value features in order
          /#      secondaries : vec<tuple<str,str>>
          /#        The key/value secondary attributes (except scope:)
          /#      scope : vec<str> or vec<Construct>
          /#        The value to assign to the scope: of the test method.
          /#  - some general observations about feature and secondary attributes
          /#    of test methods:
          /#     - feature attributes are almost always:
          /#        - level instance
          /#        - location user
          /#        - visibility public
          /#        - presence concrete
          /#        - mutability mutable
          /#        - extensibility extendable
          /#        - dispatch autodispatch
          /#        - inheritance new
          /#       (which are the default values for all of these feature attrs,
          /#        so feature attributes are rarely needed).
          /#     - secondary attributes are almost always:
          /#        - no params
          /#        - return type void
          /#        - no tests
          /#        - no super
          /#        - no comment
          /#        - no config
          /#      (e.g. no secondaries are needed)
          testdata = []
          testbase = metax.oopl.ExecutableConstruct.TestifyName(self.id())
          /# TODO(wmh): Generalize to all baselangs
          if testbase == 'test___init__':
            testbase = metax.oopl.ExecutableConstruct.TestifyName(myclass.id())

          voidtype = metax.c.Type.Instance('void')

          if variant == 'meta' or kind == 'initializer':
            /# For meta classes and initializer, we do not produce a warning
            /# message.
            missing_message = None
          else:
            /# TODO(wmh): disabling temporarily
            missing_message = None
            /# missing_message = '%s does not yet have a unittest' % fqn

          if testattr and testsattr:
            metafile.error(
              'Cannot define both test: and tests:', attribute=testsattr)

          elif testattr:
            /# We have a single test, which is usually a simple block (but
            /# may be a complex block of <*>ed).
            if testattr.isComplexBlock():
              /# testlines is a misnomer ... it is really a list of Construct,
              /# not lines.
              metafile.error(
                'Not yet handling complex test: blocks', attribute=testattr)
            else:
              /# Simple block of lines.
              if len(testlines) == 0:
                testlines = baselang.emptyBlockCode(
                  None, message=missing_message)
                
              testdata.append({
                'name': testbase,
                'features': [],
                'secondaries': [],
                'scope': testlines,
                'line': testattr.line(),
              })

          elif testsattr:
            /# We have one or more testx constructs.
            for testx in testxes:
              testname = testbase + '_' + testx.id()
              tscope, testlines = testx.attrpair('scope:', default=None)
              if testlines is None or len(testlines) == 0:
                testlines = baselang.emptyBlockCode(
                  None, message=missing_message)
              testdata.append({
                'name': testname,
                'features': [],
                'secondaries': [],
                'scope': testlines,
                'line': tscope.line() if tscope else -1,
              })

          else:
            /# Neither 'test:' nor 'tests:' was defined.
            /#  - we add an empty test block for non-abstract methods.
            presence = self.attrval('presence', default=metax.c.LOOKUP)
            if presence == 'concrete':
              testdata.append({
                'name': testbase,
                'features': [],
                'secondaries': [],
                'scope': baselang.emptyBlockCode(
                  None, message=missing_message),
              })

          for testinfo in testdata:
            secondaries = testinfo['secondaries']
            assert 'scope:' not in [p[0] for p in secondaries]
            tscope = testinfo['scope']
            assert tscope is not None
            secondaries.append(('scope:', tscope, testinfo.get('line', -1)))
            unittest = metax.oopl.MethodConstruct.NewFromData(
              testinfo['name'], context, parent=testscope,
              features=testinfo['features'],
              secondaries=secondaries,
              /# Add at end of test scope. Since we are processing methods
              /# in order, the test methods will have the same order.
              position=None)
            unittest.myclassIs(testclass)

    metax.c.D.expand.end()
  translate:
    /# Executable compilation code.
    /#  - format the signature
    /#  - format the comment
    /#  - insert auto-generated preamble (initialize fields, super calls, typechecking)
    /#  - insert user-provided code (or implicit stub)
    /#  - insert postamble
    metax.c.D.translate.sinfo(self.kindfqn())

    attrkind = self.attrval('kind')
    presence = self.attrval('presence')
    optimization = self.attrval('optimization')
    returntype = self.attrval('returns')
    self.returntypeIs(returntype)

    /# modifiers : vec<str>
    /#   The modifiers to add before the class
    modifiers = []

    /# scope_lines : vec<str>
    /#   The lines making up the executable body.
    /# preamble : vec<str>
    /#   The lines of baselang text to insert within scope before user code.
    /# postamble : vec<str>
    /#   The lines of baselang text to insert within scope after user code.
    /# retamble : str or null
    /#   The line to add to the very end of the method (return).
    scope_attr, scope_lines, preamble, postamble, retamble, comment, params_str = (
      self.methodInfo())

    /# postmethod : vec<str>
    /#   The lines of baselang text to insert after scope.
    postmethod = []

    if scope_lines is None:
      /# This method is not to be generated.
      pass

    else:
      myclass = self.myclass()
      baselang = self.baselang()
      metafile = self.metafile()
      rem = baselang.config('rem')
      comment_attr = attribute=self.attr('comment:', default=None)

      /# Establish the baselang-level name of the method.
      if attrkind == 'initializer':
        execname = baselang.initializerName(self)
      else:
        /# We currently have some hackery in place around getter method ids,
        /# which are the same as the underlying field. To avoid having the
        /# field and getter conflict, we add a special ':get' to the getter
        /# in FieldConstruct.expandMeta() and a special clause in
        /# ExprParser.ID_RE.  We remove it here.
        /#
        /# To make it less hacky, the following code is sufficiently general
        /# to convert <name>:get to <name>, <name>Is:set to <name>Is, and
        /# <name>Ref:ref to <name>Ref. In particular, it strips off a suffix
        /# of the form ':(get|set|ref)$'.
        execname = self.id()
        m = metax.c.ExprParser.ID_RE.match(execname)
        if m and m.group(3):
          /# print '***** HERE with %s' % execname
          execname = (m.group(1) or '') + m.group(2)

      /# Establish baselang syntax for method return type.
      return_str = baselang.typeToBase(returntype, class_construct=myclass)

      /# Create the VarSet of variables.
      varset = metax.c.VarSet()
      varset.addVar('modifiers', modifiers)
      varset.addVar('method', execname, attribute=self.primary())
      varset.addVar('fqn', myclass.fqn())
      varset.addVar('class_base', myclass.id())
      varset.addVar('params', params_str)
      varset.addVar('returns', return_str)
      varset.addVar('comment', comment, comment_attr)
      varset.addVar('preamble', preamble)
      varset.addVar('scope', scope_lines, attribute=scope_attr)
      varset.addVar('postamble', postamble)
      varset.addVar('postmethod', postmethod)

      if metax.oopl.ExecutableConstruct.IsTestName(execname):
        varset.addVar(
          'method_base', metax.oopl.ExecutableConstruct.UntestifyName(execname))

      /# Allow baselangs to modify the varset
      /#  - they may modify 'preamble'
      baselang.augmentVarset(self, varset)
      if preamble:
        /# This must be the last line in the preamble in order for
        /# base-to-meta line numbers to be correct!
        preamble.append('%s User-provided code follows.' % rem)

      /# This should be empty if the scope is NOT being inlined.
      /# Currently the code only supports inlining for definition_separate
      /# baselangs.
      inline = ''
      has_decl = False
      has_defn = True
      if baselang.config('definition_separate'):
        /# For baselangs with two files per class, we print out the
        /# declaration using the same flow as in other baselangs, and handle
        /# the definition file specially.
        has_decl = True
        if presence == 'abstract':
          has_defn = False

        if scope_lines:
          /# If this is an accessor being defined, we want to inline the code.
          /# If it is a single line, we do so more concisely than we otherwise
          /# would.
          if optimization == 'inline' and len(scope_lines) == 1:
            if rem not in scope_lines[0]:
              /# Until we can test whether this method is an accessor or not,
              /# we must avoid lines with comments if we want to put the
              /# text on a single line ending with '}'.
              inline = ' { %s }' % scope_lines[0]
          else:
            /# TODO(wmh): Allow any number of lines!
            pass

      template_name = baselang.establishTemplateName(self, defn=True)
      /# print 'Here with %s = %s' % (self.kindfqn(), template_name)

      streams = metafile.streams()
      consinfo = self.context().consinfo(self.kind())

      /# Add a return line if one has been identified.
      if retamble:
        /# It is critical that these line be the very last in postamble.
        /# TODO(wmh): If the user-provided content unambiguously invokes
        /# a return statement before end-of-method, we do NOT need to
        /# insert these implicit lines.
        postamble.extend(retamble)

      /# The normal action is to write the method to 'defn'
      /#  - the only time we do not do this is if the baselang has a
      /#    separation between decl and defn and the method is inlined
      /#    (in which case we put it only in decl, not in defn). Note
      /#    that this logic is C++-centric, but the distinction
      /#    between defn and decl is probbably C++ specific too.
      if has_defn and (not has_decl or not inline):
        template = consinfo.templateNamed(template_name)
        segment = metax.c.BaseSegment(None)
        segment.instantiate(template, varset, self.kind(), self.fqn())
        streams.addSegment('defn', segment)

      if has_decl:
        /# This baselang has different syntax for declaring a method and
        /# defining it (in separate files). We've already written the
        /# definition to the 'defn' stream, and now we write the declaration
        /# to the 'decl' stream.
        template_name = baselang.establishTemplateName(self, defn=False)
        template = consinfo.templateNamed(template_name)
        segment = metax.c.BaseSegment(None)

        /#varset.addVar('inline', inline, attribute=scope)
        if not inline:
          inline = ';'
        varset.addVar('inline', inline)

        dummy = []
        params_str_decl = baselang.formatParams(self, dummy, decl=True)
        varset.setValue('params', params_str_decl)

        segment.instantiate(template, varset, self.kind(), self.fqn())
        streams.addSegment('decl', segment)

    metax.c.D.translate.end()

  scope:

    field namespace : metax.oopl.NamespaceConstruct #:
      The namespace this method belongs to. Only really needed for methods
      defined directly within namespace scope. 
      TODO(wmh): Consider whether there is a different way to handle this, so
      we aren't wasting a slot in every instance when few need it. For
      example, mark this field optional?

    field returntype : Type #:
      The return type of this Executable. Represents a cached version of
      the 'returns' or 'returns:' attributes.
      NOTE: Initialized in translateMeta(), not available before then.

    field params : *map #:
      A parsed representation of the 'params:' attribute.  Contains:
        attr: Attribute
          The params attribute
        data: vec<map>
          name: str
          type: Type
          default: any (optional)
          provides: str (optional)
          comment: vec<str>
        fields: map
          maps (high-level) field names to parameter names, for all fields
          that are to be initialized directly from a parameter (i.e. via
          the 'provides' syntax).
        varvec: map
          name: str
            The name of the catch-all vec-based param
          comment: vec<str>
        varmap: map
          name: str
            The name of the catch-all map-based param
          comment: vec<str>

    meta
    method TestifyName : str #:
      Obtain the test method naem corresponding to a user method.
    params:
      var name : str;
    scope:
      /# CODETANGLE(methtest)
      return 'test_' + name
    end method TestifyName;

    meta
    method IsTestName : bool #:
      Check if a name is a test.
    params:
      var name : str;
    scope:
      /# CODETANGLE(methtest)
      return name.startswith('test_')
    end method;

    meta
    method UntestifyName : str #:
      Obtain the user method name corresponding to a test method name.
    params:
      var name : str;
    scope:
      assert name.startswith('test_')
      return name[5:]
    end method UntestifyName;

    private
    method methodInfo
    returns tuple<metax.attr.ComplexBlock,vec<str>,vec<str>,vec<str>,vec<str>,str> #:
      Obtain various aspects of the method:

      Returns:
       0) scope_attr: metax.attr.ComplexBlock
            The scope block. This may be null (but does not imply anything
            by itself ... see 'scope' below for null-ness).
       1) scope: vec<str>
            The baselang lines in the user-provided scope. If this is None,
            we are NOT to generate anything for the executable (and all other
            return values are ignored).
       2) preamble: vec<str>
            The baselang lines in the scope before user content.
       3) postamble: vec<str>
            The baselang lines in the scope after user content.
       4) retamble: vec<str>
            The return line for the method.
       4) comment: vec<str>
            The baselang comment associated with the method.
       5) params: str
            The baselang syntax for declaring params.
    scope:

      if self.kind() != 'method':
        /# lifecycle and behavior should be expanded away, no?
        print '%s in %s' % (self.kindfqn(), self.parentConstruct().kindfqn())
        print '@' * 70
        self.write()
        print '@' * 70
        raise metax.c.Error('Expecting only methods not %s' % self.kindfqn())

      metac = self.compiler()
      myclass = self.myclass()
      metafile = self.metafile()
      baselang = self.baselang()
      /# TODO(wmh): How to establish the actual width?
      width = 80 - 0
      scope_lines = None

      scope_attr, _ = self.attrpair('scope:', default=None)
      if scope_attr is None:
        scope_lines = []
        span = self.attrval('span')
        presence = self.attrval('presence')
        /# No 'scope:' is present.

        if span == 'specific':
          /# We do not expect a scope, and are to NOT generate a method.
          scope_lines = None

        elif presence == 'abstract':
          /# This is handled when emptyBlockCode() is invoked below.
          pass

        elif (
          /# It is common for test classes to not have initializers and to
          /# instead have 'setup' blocks.
          self.myclass().variant() == 'user'
        ):
          if metac.cli().implicit_scopes:
            /# If --implicit_scopes is specified, we are to generate a dummy
            /# scope block rather than report a warning.
            scope_lines = baselang.emptyBlockCode(self)
          else:
            metafile.warning(
              '%s is general but missing scope<%s>' %
              (self.kindfqn(), baselang.suffix()[1:]),
              line=self.primary().line())
      elif scope_attr.isSimpleBlock():
        /# We strip empty lines in case the user has added spurious emptiness.
        /# This is needed because BaseFile() expects final content to never
        /# have blank lines at the end, and raises an exception if found.
        scope_lines = baselang.simpleToBase(
          scope_attr, strip_empty=True, replace_receiver=True)
      else:
        /# TODO(wmh): Compile the meta-level statement constructs.
        scope_lines = []

      if scope_lines is None:
        /# We've established that we should not generate this method.
        params = None
        comment = None
        preamble = None
        postamble = None
        retamble = None
      else:
        preamble = []
        postamble = []
        retamble = None
        attrkind = self.attrval('kind')
        inheritance = self.attrval('inheritance')
        calls_super = False

        /# Handle inheritance (prex and postx).
        if attrkind == 'initializer':
          /# Various special functionality is generated in initializers:
          /#  - invocation of parent initializers (default postx semantics)
          /#  - implicit initialization of fields not explicitly initialized
          /#    in scope_lines.

          /# TODO(wmh): Currently, we are assuming that iniitalizers always
          /# have inheritance 'postx', but we probably want to generalize
          /# this.
          /# TODO(wmh): IMPORTANT: In oopl/schema.meta, the 'lifecycle'
          /# construct has defined 'Attribute inheritance = postx', but
          /# the '= postx' does not appear to be overriding the '= new'
          /# defined up in _executable_.
          calls_super = True
          if inheritance == 'superx':
            /# This is a request to NOT generate the super code ... it is
            /# up to the user to perform the call themselves.
            pass
          else:
            baselang.superCode(self, preamble)
            /# We do NOT invoke baselang.initCode() here because we need to do
            /# formatParams() first, as it may add code to 'preamble' to define
            /# a new receiver variable (one that is used in initCode()).
        else:
          /# TODO(wmh): Check whether the super method has a void return
          /# value (in which case return_var should be null).
          /# TODO(wmh): If return_var is not null, we should add a return
          /# statement to the end of the method (either as guaranteed last line
          /# of postamble or a special retamble value).
          /# TODO(wmh): Define a OoplBaseLanguage.returnCode() method for
          /# generating return code given a particular variable or expression.
          returntype = self.returntype()
          if returntype is None:
            raise metax.c.InternalError('returntype is uninitialized')
          return_var = None if returntype.isVoid() else 'meta__super'
          if inheritance == 'postx':
            baselang.superCode(self, preamble, return_var=return_var)
            calls_super = True
          elif inheritance == 'prex':
            baselang.superCode(self, postamble, return_var=return_var)
            calls_super = True
          elif inheritance == 'superx':
            calls_super = True
          if calls_super and return_var:
            /# TODO(wmh): How to guarantee that this is always the last
            /# line of output?
            if retamble:
              metafile.error(
                'Found multiple return statements',
                line=self.primary().line())
            else:
              /# TODO(wmh): This needs to be made baselang-specific (define a
              /# OoplBaseLanguage.returnCode() behavior).
              /# TODO(wmh): If the user-provided code provides a 'return'
              /# statement that is guaranteed to be executed by end-of-method,
              /# we do NOT need to insert this line.
              /# TODO(wmh): Consider making this a list of lines instead of
              /# a single line.
              retamble = ['return ' + return_var]

          if len(scope_lines) == 0:
            scope_lines = baselang.emptyBlockCode(self)

        /# Obtain params and comment.
        params = baselang.formatParams(self, preamble)
        comment = baselang.formatMethodComment(self, width=width)

        /# Now add implicit field initialization code to the preamble.
        if attrkind == 'initializer':
          baselang.initCode(self, preamble)

          /# Initializers are candidates for being optimzied away. If the
          /# following are all true, we do not need to define the initializer:
          /#  - scope_lines is empty
          /#  - postamble is empty
          /#  - preamble is empty or contains only a super() call.
          if (
            False and
            not scope_lines
            and not postamble
            and (
              not preamble
              /# TODO(wmh): Testing for 'super(' is baselang specific. Generalize
              /# this code.
              or (len(preamble) == 1 and preamble[0].startswith('super('))
            )
          ):
            msg = '%s has been optimized away' % self.kindfqn()
            /#print 'NOTE: ' + msg
            metafile.info(msg, line=self.primary().line())

            /# Setting scope_lines to None means "do not generate method".
            scope_lines = None
            /# Remove the initializer from the class.
            /#  - TODO(wmh): Is there any reason to keep the initializer
            /#    construct around?  We could use a different field to
            /#    indicate that it has been optimized out, rather than
            /#    killing it.
            myclass.registerInitializer(None)

      return scope_attr, scope_lines, preamble, postamble, retamble, comment, params
    end method methodInfo;

    method isTestCase : bool #:
      True if this method is defined within a class that is a test case
      and looks like a test method.
    scope:
      return (
        self.myclass().isTestCase()
        and metax.oopl.ExecutableConstruct.IsTestName(self.id()))
    test:
    end method isTestCase;

    meta
    method CreateParams : metax.attr.ComplexBlock #:
      Create a 'params:' attribute given var info.
    params:
      var varlist : vec<map> #:
        Each element is a map containing:
          var: str
          features : vec<tuple<str,str>>
          secondaries : vec<tuple<str,any>>
          termcode : int
      var context : Context;
    scope:
      params = metax.attr.ComplexBlock(None, 'params:', [])
      for vardata in varlist:
        var = metax.oopl.VarConstruct.NewFromData(
          vardata['var'], context, parent=params,
          features=vardata.get('features', None),
          secondaries=vardata.get('secondaries', None),
          termcode=vardata.get('termcode', 1))
      return params
    test:
      Type = metax.c.Type

      _, schema, context, compiler = test.cachedInfo()

      params = metax.oopl.ExecutableConstruct.CreateParams([], context)
      test.iseq('params:', params.key())
      test.iseq([], params.value())

      params = metax.oopl.ExecutableConstruct.CreateParams(
        [
          {'var': 'name',
           'secondaries': [('type', metax.c.Type.Instance('int'))]},
          {'var': 'age',
           'secondaries': [
             (':', metax.c.Type.Instance('int')),
             ('=', metax.c.Expr('int', '77', 77))]},
          {'var': 'rest', 'features': [('multiplicity', 'multi')],
           'secondaries': [(':', metax.c.Type.Instance('vec'))]},
        ],
        context)
      test.iseq('params:', params.key())
      test.iseq(
        ['var name type int;\n',
         'var age : int = 77;\n',
         'multi var rest : vec;\n'],
        [v.asStr() for v in params.value()])
    end method CreateParams;

    method parsedParams : map #:
      Parse the 'params:' attribute.

      Returns:
        See the 'params' field for details.
    params:
      var force : bool = false #:
        If true, recompute params even if already pre-computed.
    scope:
      result = self.params()
      if result is None or force:
        metafile = self.metafile()
        params = self.attr('params:', default=None)
        data = []
        fields = {}
        result = {'attr': params, 'data': data}
        if params:
          for var in params.value():
            name = var.id()
            provides_attr, provides = var.attrpair(
              'provides', default=metax.c.LOOKUP)
            /# If 'provides' is given, should not specify 'type', 'multiplicity'
            /# or 'comment:' (but can specify 'default')
            missing = None if provides else metax.c.LOOKUP
            typeattr, type = var.attrpair('type', default=missing)
            multattr, multiplicity = var.attrpair(
              'multiplicity', default=missing)
            comattr, comlines = var.attrpair('comment:', default=None)
            default = var.attrval('default', default=metax.c.LOOKUP)

            if provides:
              myclass = self.myclass()
              field = myclass.symbolNamed(provides)
              if not field:
                metafile.error(
                  'Failed to find field %s in %s' %
                  (provides, myclass.kindfqn()),
                  line=provides_attr.line())
              elif field.kind() != 'field':
                metafile.error(
                  'Expecting %s to be of kind field not %s' %
                  (field.kindfqn(), field.kind()),
                  line=provides_attr.line())
              else:
                if typeattr:
                  metafile.error(
                    'Cannot specify both provides and type',
                    line=typeattr.line())
                if comattr:
                  /# TODO(wmh): Look into whether there is any utility in
                  /# allow such a comment. For example, explaining what
                  /# the default value associated witht the 'provides' means
                  /# (something that doesn't make sense to put in the field
                  /# comment in all cases).
                  metafile.info(
                    'Not currently using var comment (using field comment instead)',
                    line=comattr.line())
                if multattr:
                  metafile.error(
                    'Cannot specify both provides and multiplicity',
                    line=multattr.line())
                /# We obtain type and comment from the field.
                typeattr, type = field.attrpair('type', default=missing)
                comattr, comlines = field.attrpair('comment:', default=None)

                /# We record a mapping from field to param name for use in
                /# BaseLanguageOopl.initCode()
                fields[provides] = name

            if multiplicity == 'multi':
              traw = type.raw()
              if traw.startswith('vec'):
                varvec = {'name': name}
                if comlines:
                  varvec['comment'] = comlines
                result['varvec'] = varvec
              elif traw.startswith('map'):
                varmap = {'name': name}
                if comlines:
                  varmap['comment'] = comlines
                result['varmap'] = varmap
              else:
                metafile.error(
                  'Invalid type %s for multi var %s' % (traw, name),
                  line=typeattr.line())
            else:
              item = {'name': name, 'type': type}
              if provides:
                item['provides'] = provides
              /# CODETANGLE(special_expr): TODO(wmh): Decide whether <special>
              /# is indicated by an Expr with value() None, or by an Expr that
              /# is None. Depending on which is decided, default below is either
              /# never None, or never '<special>'.
              if default is not None and default != '<special>':
                item['default'] = default
              if comlines:
                item['comment'] = comlines
              data.append(item)
        if fields:
          result['fields'] = fields
        self.paramsIs(result)
      return result
    test:
    end method parsedParams;

  end Construct _executable_;

  Construct method < _executable_ #:
    @method: The method construct.
  config:

    Attribute presence;
    Attribute visibility;
    Attribute span;
    Attribute mutability;
    Attribute autogen;
    Attribute extensibility;
    Attribute optimization;
    Attribute dispatch;
    Attribute inheritance;
    Attribute location;
    Attribute kind;

    primary
    Attribute method : id = <required> #:
      The name of the method.

    Attribute alias;

    Attribute params:;
    Attribute super;
    Attribute returns;
    Attribute returns:;
    Attribute pres:;
    Attribute posts:;
    Attribute test:;
    Attribute tests:;

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

    Template python scope:
      >|
      >|${modifiers}
      >|def ${method}${params}:
      >|  ${comment}
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
    end Template;

    Template javascript scope:
      >|
      >|${comment}
      >|${method}${params} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|};
      >|${postmethod}
    end Template;

    Template javascript_oldstyle scope:
      >|
      >|${comment}
      >|${method_prefix}${method} = function${params} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|};
      >|${postmethod}
    end Template;

    Template javascript_test_oldstyle scope:
      >|
      >|${comment}
      >|function ${method}() {
      >|  ${scope}
      >|}
    end Template;

    Template cpp_decl scope:
      >|
      >|${comment}
      >|${modifiers? }${returns? }${method}${params}${inline}
    end Template cpp_decl;

    Template cpp_defn scope:
      >|
      >|${returns? }${class_base}::${method}${params}${initlist} {
      >|  ${preamble}
      >|  ${scope}
      >|  ${postamble}
      >|}
    end Template cpp_defn;

    Template cpp_decl_test scope:
      >|// No decl code needed for ${method}
    end Template cpp_decl_test;

    Template cpp_defn_test scope:
      >|
      >|TEST_F(${class_base}, ${method}) {
      >|  ${scope}
      >|}
    end Template cpp_defn_test;

  import:
    /# Look up the inheritance chain for a method with the same name.
    /#  - allows us to enforce 'new'/'override' semantics
    /#  - allows us to implement 'super var' semantics in parameters by being
    /#    able to identify the types of params from their parent equivalents
    name = self.id()
    metax.c.D.imports.sinfo(name)

    myclass = self.myclass()
    if myclass:
      parentclass = myclass.parentclass()
      if parentclass is not None:
        psymbols = parentclass.symbols()
        super_method = psymbols.find(name)
        if super_method:
          self.supermethodIs(super_method)
          attrkind = self.attrval('kind')
          if attrkind == 'initializer':
            /# Knowing the parent initializer will be useful for many purposes.
            pass
          else:
            /# TODO(wmh): methods from behaviors are not showing up as being
            /# overridden.
            if name != 'meta':
              /# print '  In %s found parent definition %s' % (self.kindfqn(), super_method.kindfqn())
              pass

      /# Now initialize the symbol table of the method.
      /#  - for methods with simple blocks, we only have access to the params
      /#  - for methods with complex blocks, we have all vars specified at
      /#    top-level within the method as well.
      params = self.attrval('params:', default=None) or []
      for i, pvar in enumerate(params):
        self.registerSymbol(pvar.id(), pvar, note='From param #%d' % (i+1))

      scope = self.attr('scope:', default=None)
      if scope:
        if scope.isComplexBlock():
          /# TODO(wmh): Do we add all top-level 'var' constructs now? A variable
          /# cannot be used until declared in most baselangs, so pre-populating
          /# the symbol table is problematic unless we add an 'inactive' field
          /# that allows us to indicate when a symbol is and is not active.
          pass
        else:
          /# TODO(wmh): We could do some heuristic analysis of the baselang
          /# source code fairly easily. Or, if we have access to a
          /# statement-level parser for each baselang, we can identify all
          /# variable declarations.
          pass
    else:
      /# If myclass is None, we have a method (including accessor) defined
      /# at namespace level.
      pass
    
    metax.c.D.imports.end()

  scope:

    field supermethod : metax.oopl.MethodConstruct #:
      The method being overridden in an ancestor by this definition. Will be
      null if no ancestor defines the method (it will also always be null before
      importMeta() has been invoked on this instance).

    method isMethod : bool scope:
      return True

  end Construct method;

  Construct lifecycle < _executable_ #:
    @lifecycle: A merging of initializer/finalizer/copy&move-semantics/etc.

    Most of the attributes of lifecycle apply to the initializer
    implicitly generated by lifecycle. The other implicit methods
    (finalizer, cloner, mover, setup, teardown, etc.) do not take
    params and have pre-defined semantics in other ways.

    Note that lifecycle does not support the 'inheritance' feature
    attribute because inheritance semantics is predefined for all
    generated methods.
  config:

    Attribute presence;
    Attribute visibility;
    Attribute span;
    Attribute mutability;
    Attribute autogen;
    Attribute extensibility;
    Attribute dispatch;
    Attribute inheritance = postx;
    Attribute location;
    Attribute kind;

    primary
    Attribute lifecycle : id = <auto> #:
      The name of the lifecycle.

    Attribute params:;
    Attribute super;
    Attribute returns;
    Attribute returns:;
    Attribute pres:;
    Attribute posts:;
    Attribute test:;
    Attribute tests:;

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex aliases <init:|::> children <_statement_> #:
      The initializer block.

    secondary
    Attribute clinit: : simplex = <empty> #:
      A static field initialization block. Invoked exactly once for each class,
      unlike the metaclass initializer, which is invoked N+1 times if the class
      has N descendent classes.

    secondary
    Attribute finalize: : simplex = <empty> aliases <::> #:
      A finalizer block for cleaning up the object before garbage
      collection.

    secondary
    Attribute metainit: : simplex = <empty> #:
      An block found within a user-level lifecycle defining a meta-class
      initializer. Convenience mechanism so that we can define everything in
      a single lifecycle instead of having a user lifecycle, test lifecycle
      and meta lifecycle.  A location=meta lifecycle is implicitly created
      and the metainit: block is moved to the scope: of this new lifecycle.

    secondary
    Attribute metafinalize: : simplex = <empty> #:
      An block found within a user-level lifecycle defining a meta-class
      finalizer. Convenience mechanism so that we can define everything in a
      single lifecycle instead of having a user lifecycle, test lifecycle and
      meta lifecycle. A location=meta lifecycle is implicitly created and the
      metafinalize: block is moved to the finalize: of this new lifecycle.

    secondary
    Attribute setup: : simplex = <empty> #:
      This may appear in an instance-level lifecycle or a test-level
      lifecycle. In both cases, it defines a setup method for the test
      class.

    secondary
    Attribute clsetup: : simplex = <empty> #:
      This may appear in an instance-level lifecycle or a test-level lifecycle.
      In both cases, it defines a class-level setup method for the test class.

    secondary
    Attribute teardown: : simplex = <empty> #:
      This may appear in an instance-level lifecycle or a test-level
      lifecycle. In both cases, it defines a teardown method for the test
      class.

    secondary
    Attribute clteardown: : simplex = <empty> #:
      This may appear in an instance-level lifecycle or a test-level lifecycle.
      In both cases, it defines a class-level teardown method for the test
      class.
  expand:
    /# Expand the lifecycle
    /#  - move to testclass or metaclass if location indicates such
    /#  - create initializer method based on params, scope and most other attrs.
    /#  - create finalizer method based on 'finalize:'
    /#  - create baselang-specific setup/teardown methods based on 'setup:'
    /#    and teardown: (and location).
    /#     - if location is 'user', setup and teardown to not make sense except
    /#       in the very special case of defining metax.test.TestCase
    /#     - if location is 'meta', setup and teardown do not make sense

    /# Move to testclass or metaclass if appropriate
    myclass, moved = self.updateClass()

    metax.c.D.expand.sinfo(
      '%s in %s variant %s location %s moved %s metaclass %s' %
      (self.kindfqn(), myclass.kindfqn(), myclass.variant(),
       self.attrval('location'), moved, myclass.metaclass()))
    /# if False and myclass.id() == 'TestCase':
    /#   myclass.showDebug()

    if moved:
      /# We only expand lifecycles if we haven't moved the lifecycle to a
      /# different class (if we have moved it, it will be expanded later when
      /# that class is expanded).
      metax.c.D.expand.info('moved (no further expansion)', level=2)
    else:
      /# A 'lifecycle' construct is a generalization of an initializer, and
      /# can thus be found in every class.
      /#  - when used within a test class that inherits from
      /#    metax.test.TestCase, the 'setup:' and 'teardown:' block attributes
      /#    correspond to the baselang-specific and location-specific
      /#    setUp and tearDown methods.
      /#  - the setup*/teardown* attributes do not make sense for user-defined
      /#    classes (at normal or meta level, even if they are service test
      /#    classes)
      /#  - the setup/teardown attributes do make sense (and are common) for
      /#    lifecycles with location 'test'. They are also common in
      /#    lifecycles appearing in user-defined test classes, but only if the
      /#    test class inherits from metax.test.TestCase, not if it is a
      /#    service test class that doesn't inherit from metax.test.TestCase.
      /#  - setup is invoked before each test method is executed, teardown is
      /#    invoked after each test method is executed.
      /#  - clsetup is invoked once before any of the test methods within a
      /#    testcase are invoked, and clteardown is invoked once after all
      /#    of the testmethods within a testcase have been invoked.
      /#
      /# Some reminder notes about Meta and unittests (and how lifecycles
      /# interact)
      /#  - Most baselangs that support xUnit testing will have a root
      /#    TestCase class with setup-each, teardown-each, setup-once and
      /#    teardown-once methods (exact names depend on baselang) and a
      /#    constructor that accepts a string representing the name of the
      /#    method to test.
      /#  - Meta defines metax.test.TestCase which inherits from this
      /#    baselang-specific root TestClass, and whose initializer has a
      /#    method-name arg passed to the parent.
      /#  - For user-defined class <C>, we implicitly create <C>Test which is
      /#    a subclass of metax.test.TestCase, whose initializer accepts a
      /#    method name that is passed to its parent.
      variant = myclass.variant()
      baselang = self.baselang()
      metafile = myclass.metafile()

      /# Create an initializer method.
      /#  - initializer name is determined by baselang.initializerName()
      /#  - insert just before the lifecycle construct.
      /#  - the test method(s) should use the name of the class, NOT the
      /#    baselang-specific initname (this allows us to ensure that
      /#    the initializer unittest can be accessed by a baselang-independent
      /#    name.
      initname = baselang.initializerName(myclass)
      position = '-' + self.id()
      context = self.context()
      class_scope = myclass.attr('scope:', default=metax.c.REQUIRED)
      scope = self.attr('scope:', default=None)

      features = []
      for fkey in (
        'presence', 'visibility', 'mutability', 'extensibility', 'dispatch',
        /# The location attribute of the generated initializer method will
        /# not be used, but we include it for readability purposes. May
        /# want to consider introducing a 'ignore' value to 'location' that
        /# we can set it to instead of taking the value from the lifecycle.
        'location',
        /# The inheritance feature attribute defaults to 'postx' for
        /# lifecycle constructs, and the code currently assumes this value
        /# always.  However, it is often useful to allow initialization of
        /# values before invoking the parent.  Supporting this in C++
        /# and Java will result in some inefficiency, but should be possible.
        /# There are also times where we want to be able to disable calls
        /# to the parent constructor in python (e.g. when we are inheriting
        /# from an old-school class), in which case superx is useful.
        'inheritance',
      ):
        fval = self.attrval(fkey, default=None)
        if fval is not None:
          features.append((fkey, fval))
      secondaries = []
      for skey in (
        'returns', 'returns:', 'comment:', 'params:', 'super',
        'pres:', 'posts:', 'scope:', 'test:', 'tests:',
      ):
        secondary = self.attr(skey, default=None)
        if secondary is not None:
          secondaries.append(secondary)

      if scope:
        /# IMPORTANT: On 2018/11/26, code was changed to always create an
        /# explicit initializer, even if a scope block does not exist. This
        /# may break existing code, but the benefits (I think) outweight the
        /# breakage.

        /# We create an explicit initializer, and copy over many of the
        /# attributes from the lifecycle to the initializier.
        features.append(('kind', 'initializer'))
        primary_line = self.primary().line()
        initializer = metax.oopl.MethodConstruct.NewFromData(
          initname, context, parent=class_scope,
          features=features,
          primary_line=primary_line,
          position=position)
        /# Now move all the secondary attributes from the lifecycle to the
        /# initializer.
        for secondary in secondaries:
          secondary.changeParent(initializer)
        myclass.registerInitializer(initializer)

        /# Now expand the newly created initializer (to move the test attribute,
        /# etc.)
        initializer.expandMeta()
      else:
        /# raise Error('This code block is disabled/deprecated')

        /# IMPORTANT: If there is no scope block, we do NOT create an
        /# initializer construct here, which means the code in
        /# ClassConstruct.expandMeta() for creating a default initializer will
        /# be exercised.
        /#
        /# HOWEVER, if any of the feature or secondary attributes of 'lifecycle'
        /# that would be moved to the initializer are present, we warn the
        /# programmer that they will be ignored.
        /#
        /# TODO(wmh): Certain feature attributes in this list should probably
        /# be except from warnings (like location).
        if features:
          fvals = [pair[1] for pair in features]
          try:
            fvals.remove('test')
          except ValueError:
            pass
          if fvals:
            metafile.warning(
              '%s has no scope but has features that will be dropped when '
              'implicit initializer is created: %s' %
              (self.kindfqn(), ' '.join(fvals)),
              line=self.primary().line())
        if secondaries:
          skeys = [sec.key() for sec in secondaries]
          try:
            skeys.remove('comment:')
          except ValueError:
            pass
          if skeys:
            /# TODO(wmh): if --implicit_scope, we should be generating the
            /# scope instead of complaining about it being missing. Easy to
            /# implement, as it is always an empty block.
            metafile.warning(
              '%s has no scope but has secondaries that will be dropped when '
              'implicit initializer is created: %s' %
              (self.kindfqn(), ' '.join(skeys)))

      /# Create a finalizer method if there is a 'finalize' attribute in this
      /# lifecycle.
      /#   - TODO(wmh): Determine if there is something that can be done about
      /#     __del__ problems in Python within Meta. Note that __del__ is the
      /#     mirror of __new__, NOT of __init__. See
      /#       http://www.algorithm.co.il/blogs/programming/python-gotchas-1-__del__-is-not-the-opposite-of-__init__/
      finalize_attr, finalize_lines = self.attrpair('finalize:', default=None)
      if finalize_attr is not None:
        finalname = baselang.finalizerName(myclass)
        finalizer = metax.oopl.MethodConstruct.NewFromData(
          finalname, context, parent=class_scope,
          features=[],
          secondaries=[('scope:', finalize_lines)],
          primary_line=finalize_attr.line())
        /# Remove 'finalize:' from self so that if we print out constructs after
        /# expansion, the state is properly reflected.
        self.unregisterAttribute(finalize_attr)
        /# TODO(wmh): Define registerFinalizer!
        /#myclass.registerFinalizer(finalizer)

      /# Handle the 'clinit' block.
      /#  - create a Meta__Initialize method whose body is the scope of clinit:
      /#  - invoke the method after the class is defined.
      clinit_attr, clinit_lines = self.attrpair('clinit:', default=None)
      if clinit_attr is not None:
        /# TODO(wmh): Generalize to all baselangs
        if baselang.id() == 'python':
          clinit_lines.insert(0, 'cls = %s' % myclass.id())
        elif baselang.id() == 'cpp':
          clinit_lines.insert(0, 'auto* cls = %s;' % myclass.id())
        else:
          metafile.error(
            'Not yet supporting clinit: for baselang %s' % baselang.id(),
            line=clinit_attr.line())
        /# We create a Meta__Initialize() method.
        clinit = metax.oopl.MethodConstruct.NewFromData(
          'Meta__Initialize', context, parent=class_scope,
          features=[('kind', 'static')],
          secondaries=[('scope:', clinit_lines)],
          primary_line=clinit_attr.line(),
          position='+' + initname)
        myclass.registerStaticInitializer(clinit)

      /# Handle meta-level secondary attributes:
      /#  - if this is a user class, move the meta-specific blocks to an
      /#    implicitly created lifecycle with location 'meta'
      meta_attrs = {}
      meta_attr_list = (('metainit', 'scope'), ('metafinalize', 'finalize'))
      for attr, canattr in meta_attr_list:
        block = self.attr(attr + ':', default=None)
        if block:
          if ((variant == 'metauser') or (variant == 'meta')):
            metafile.warning(
              'For explicit meta lifecycles use scope: and finalize: not metainit: or metafinalize:',
              line=self.primary().line())
          else:
            /# This is a user-level lifecycle ... we remember the block so we
            /# can move it to an implicitly created lifecycle with location eta.
            meta_attrs[attr] = block
      if meta_attrs:
        /# We create a location=meta lifecycle construct and recursively
        /# expand it.
        /# TODO(wmh): Verify a meta lifecycle doesn't already exist!
        meta_lifecycle = metax.oopl.LifecycleConstruct.NewFromData(
          context.autoId(), context, parent=class_scope,
          features=[('location', 'meta')])
        for attrbase, canattr in meta_attr_list:
          attr = meta_attrs.get(attrbase)
          if attr:
            key = canattr + ':'
            parent = attr.parent()
            parent.unregisterAttribute(attr)
            attr.keyIs(key)
            attr.litkeyIs(key)
            meta_lifecycle.registerAttribute(attr)
        /# TODO(wmh): Should we pass output into this call to expandMeta?
        meta_lifecycle.expandMeta()

      /# Handle test-level secondary attributes:
      /#  - if this is a user class, move the blocks to an implicitly
      /#    created lifecycle with location 'test'
      /#  - if this is a test class, create baselang-specific setup/teardown
      /#    methods depending on which of 'setup', 'clsetup', 'teardown' and
      /#    'clteardown' exists as attributes on this lifecycle.
      test_attrs = {}
      test_attr_list = ('setup', 'clsetup', 'teardown', 'clteardown')
      for attr in test_attr_list:
        block = self.attr(attr + ':', default=None)
        if block:
          if (
            (variant == 'testuser') or
            (variant == 'test') or
            (variant == 'user' and myclass.id() == 'TestCase')
          ):
            /# We are processing a test class, so we generate special methods
            /# within this class scope.
            tinfo = baselang.config(attr)
            tname = tinfo['name']
            tlevel = tinfo.get('level', 'instance')
            tkind = None
            if tlevel == 'static':
              tkind = 'static'
              features.append(('kind', 'static'))
            elif tlevel == 'meta':
              tkind = 'cls'
            features = []
            if tkind:
              features.append(('kind', tkind))
            if tkind != 'static':
              features.append(
                ('inheritance', 'prex' if 'teardown' in attr else 'postx'))

            tmethod = metax.oopl.MethodConstruct.NewFromData(
              tname, context, parent=class_scope,
              features=features,
              secondaries=[('scope:', block.value())],
              primary_line=block.line())
            tmethod.myclassIs(myclass)
            tmethod.expandMeta()
          else:
            /# This is a user-level lifecycle ... we remember the block so we
            /# can move it to an implicitly created lifecycle with location test.
            test_attrs[attr] = block
      if test_attrs:
        /# We create a location=test lifecycle construct and recursively
        /# expand it.
        /# TODO(wmh): Verify a test lifecycle doesn't already exist!
        test_lifecycle = metax.oopl.LifecycleConstruct.NewFromData(
          context.autoId(), context, parent=class_scope,
          features=[('location', 'test')])
        for attrbase in test_attr_list:
          attr = test_attrs.get(attrbase)
          if attr:
            attr.changeParent(test_lifecycle)

        /# TODO(wmh): Should we pass output into this call to expandMeta?
        test_lifecycle.expandMeta()
    metax.c.D.expand.end()
  translate:
    pass
  scope:
  end Construct lifecycle;

  Construct behavior < _executable_ #:
    @behavior: An executable defined on a collection of receivers.
  assocs:
    std assoc collections;
    std assoc copy;
  config:

    Attribute presence;
    Attribute visibility;
    Attribute span;
    Attribute mutability;
    Attribute autogen;
    Attribute extensibility;
    Attribute optimization;
    Attribute dispatch;
    Attribute inheritance;
    Attribute location;
    Attribute kind;

    primary
    Attribute behavior : id = <required> #:
      The name of the behavior.

    Attribute alias;

    Attribute params:;
    Attribute super;
    Attribute returns;
    Attribute returns:;
    Attribute pres:;
    Attribute posts:;
    Attribute test:;
    Attribute tests:;

    Attribute comment:;
    Attribute config:;
    Attribute scope: : complex children <receiver>;

  expand:
    /# Expand the behavior into a collection of methods defined on
    /# classes identified by the 'receiver' constructs within the behaviors
    /# scope.
    name = self.id()
    baselang = self.baselang()
    context = self.context()
    comment_lines = self.attrval('comment:', default=None)
    params_attr, params = self.attrpair('params:', default=None)
    returns_attr, mtype = self.attrpair('returns', default=None)
    parent_block = self.parent()
    location = self.attrval('location')

    if False:
      print '#' * 70
      print self.kindfqn()
      self.write()

    fkey_order = (
      'visibility', 'span', 'level', 'nature', 'mutability', 'kind',
      'dispatch')
    default_feature_map = {}
    for fkey in fkey_order:
      fattr, fval = self.attrpair(fkey, default=None)
      if fval is not None:
        default_feature_map[fkey] = fval

    scope, receivers = self.attrpair('scope:', default=None)
    for receiver in receivers:

      /# IMPORTANT: we want to support the receiver id being a fqn, but that
      /# is rather complicated:
      /#  - we would need to import *before* expand
      /#  - we could be modifying code in other .meta files within this metafile.
      /#  - this may not be practical.
      clsname = receiver.id()

      feature_map = copy.copy(default_feature_map)
      presence = receiver.attrval('presence', default=None)
      if presence is not None:
        feature_map['presence'] = presence

      /# scope may be null if receiver is abstract
      receiver_scope, receiver_lines = receiver.attrpair(
        'scope:', default=None)
      if receiver_scope is None:
        receiver_lines = baselang.emptyBlockCode(receiver)
        receiver_linenum = receiver.primary().line()
      else:
        receiver_linenum = receiver_scope.line()

      /# test can definitely be null.
      receiver_test, test_lines = receiver.attrpair(
        'test:', default=None)

      /# Find the class_construct matching 'clsname'
      /#  - TODO(wmh): This needs to be generalized to support classes
      /#    in a different namespace than the behavior.
      /#  - Easily accomplished because we have access to the entire
      /#    hierarchy by fqn.
      if location == 'meta':
        receiver_class = parent_block.cons(
          metax.oopl.ClassConstruct.MetaifyName(clsname), default=None)
      else:
        receiver_class = parent_block.cons(clsname, default=None)
      if receiver_class is None:
        print 'ERROR: Failed to find %s in %s' % (clsname, parent_block.parent().fqn())
      else:
        /# feature attributes
        features = []
        for k in fkey_order:
          if k in feature_map:
            features.append((k, feature_map[k]))
        /# secondary attributes
        secondaries = []
        if mtype:
          /# We set the return type of the method.
          secondaries.append((':', mtype))
        if comment_lines:
          secondaries.append(('#:', comment_lines))
        if params_attr:
          /# Note that we cannot just move 'params:' because there can be
          /# multiple receivers, each needing the params: attribute.
          params_copy = params_attr.clone(None)
          secondaries.append(('params:', params_copy))
        secondaries.append(('scope:', receiver_lines, receiver_linenum))
        class_scope = receiver_class.attr('scope:', default=metax.c.REQUIRED)
        /# method creation
        method = metax.oopl.MethodConstruct.NewFromData(
          name, context, parent=class_scope, features=features,
          secondaries=secondaries, primary_line=receiver.primary().line())
        method.myclassIs(receiver_class)
        assert method.primary().line() == receiver.primary().line()

        /# Create a test method if a 'test' attribute exists
        if receiver_test:
          receiver_test_class = receiver_class.testclass()
          if receiver_test_class is None:
            print (
              'WARN: Compiler._expandNamespaceScope on %s: Failed to find '
              '%s in %s test block' %
              (self.kindfqn(),
               clsname + 'Test', test_block.parent().kindfqn()))
          else:
            class_test_scope = receiver_test_class.attr(
              'scope:', default=metax.c.REQUIRED)
            test_secondaries = [
              ('scope:', test_lines, receiver_test.line())
            ]
            test_method = metax.oopl.MethodConstruct.NewFromData(
              'test_' + name, context, parent=class_test_scope,
              secondaries=test_secondaries,
              primary_line=receiver.primary().line())

  translate:
    return (None, None)
  scope:

    field namespace : NamespaceConstruct #:
      The namespace this class belongs to.

  end Construct behavior;

  Construct receiver < _oopl_ #:
    @receiver: A class (or class tuple) that a behavior is defined on.
  config:

    feature
    Attribute presence : <<concrete|abstract> = concrete config:
      FeatureValue abstract #:
        The method is marked abstract (no scope).
      FeatureValue concrete #:
        A scope is required.
    end Attribute presence;

    primary
    Attribute receiver : id = <required> #:
      The name of the receiver. May be fqcn or clsname.

    secondary
    Attribute test: : simple = <empty> children <_statement_> #:
      A single test block associated with this method. For the method
      nm.sp.Foo.name, the test method is nm.sp.FooTest.test_name.

    secondary
    Attribute tests: : complex = <empty> children <testx> #:
      Allows multiple tests to be defined. The ids of each testx are used as
      suffixes to the test method name formed by the user-provided method. For
      the method nm.sp.Foo.name, if there are three testx constructs in the
      'tests' block with ids 'a', 'b', and 'c', the test methods will be
      nm.sp.FooTest.test_name_a, nm.sp.FooTest.test_name_b, and
      nm.sp.FooTest.test_name_c

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

  scope:
  end Construct receiver;

  Construct category < _oopl_ #:
    @category: A virtual grouping of constructs within a parent.

    TODO(wmh): Decide whether this class should inherit from ClassicConstruct
    or just provide the same interface
     - note that duck typing won't work if we implement Meta in Meta<C++>
     - the concern here is that category constructs could be legal at other
       levels (namespace, method, etc.) and having CategoryConstruct be a
       subclass of ClassicConstruct is misleading and wasteful in those
       situations (although ClassicConstruct defines few fields currently,
       I expect its state to grow significantly).

    TODO(wmh): Decide whether this construct is even worth the complexities it
    imposes.
     - need to ensure uniqueness of all symbols defined transitively down
       all nested categories (pretty easy to do by registering every
       non-category child of a category with the namespace/class/method the
       category is residing in).
  config:

    primary
    Attribute category : id = <required> #:
      The name of the category.

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <_statement_>;


  expand:
    /# Expand the field
    /#   - produce accessor methods (getter, setter, reffer, etc.)
    /#    in appropriate class depending on level.
    /#  - leave the field construct in the user class no matter what
    /#    (translateMeta can decide whether to ignore or not on a per-baselang
    /#    basis).
    metax.c.D.expand.sinfo(self.kindfqn())

    /# We want the effect to be the same as if the category construct
    /# wasn't present, while still maintaining the grouping provided
    /# by categories.
    /#  - construct ids must be unique across entire nested category
    /#    hierarchy

    /# TODO(wmh): Note that we cannot just move the child constructs up
    /# to the top-level, as this will lose the grouping provided by category.
    /# But we do need to maintain uniqueness, so each class (and any other
    /# consstruct that supports categories) should maintain a 'symbol_closure'
    /# field for aggregating constructs across the category hierarchy.

    scope = self.attrval('scope:', default=None)
    if scope:
      for child in scope:
        child.expandMeta(output=output)

    metax.c.D.expand.end()
  translate:
    /# Field compilation code.
    /#  - generate
    /#  - for languages that are namespace-primary (e.g. Python), create a
    /#    file representing the namespace (aka module)
    /#  - create a BUILD file containing all targets for building the classes
    /#    in the namespace, and for building the namespace itself.
    metax.c.D.translate.sinfo(self.kindfqn())
    scope = self.attrval('scope:', default=None)
    if scope:
      for child in scope:
        child.translateMeta(output=output)
    metax.c.D.translate.end()
  scope:
  end Construct category;

  Construct remark < _oopl_ #:
    @remark: A comment as a construct.
  config:

    primary
    Attribute remark : id = <auto> #:
      The name of the remark.

    Attribute comment: : simple;
  expand:
    metax.c.D.expand.sinfo(self.kindfqn())
    /# No expansion needed.
    metax.c.D.expand.end()
  translate:
    metax.c.D.translate.sinfo(self.kindfqn())
    /# TODO(wmh): Write a baselang comment here!
    metax.c.D.translate.end()
  scope:
  end Construct remark;

  Construct native < _oopl_ #:
    @native: A means of dumping raw base-language code into a compilation stream.
  config:

    Attribute location;

    feature
    Attribute position : <pre|post> = post #:
      Is this native block associated with the construct before or after it.
    config:
      FeatureValue pre #:
        This native block is associated with the construct below it.
      FeatureValue post #:
        This native block is associated with the construct above it.
    end Attribute position;

    feature
    Attribute placement : <defn|decl> = defn #:
      Only meaningful in base-languages that make a distinction between
      declaration (signature) and definition (implementation). For example,
      in C++ 'defn' is .h and 'decl' is .cc, whereas in python both 'defn'
      and 'decl' refer to .py, in java both 'defn' and 'decl' refer to .java,
      etc.
    config:
      FeatureValue defn #:
        In C++, this identifies the .cc file.
      FeatureValue decl #:
        In C++, this identifies the .h file.
    end Attribute placement;

    feature
    Attribute level : <cls|nmsp> = cls #:
      Controls whether the code is inserted within a namespace or outside
      of the namespace. For example, in C++ when defining/declaring a class,
      the declaration is wrapped within namespace scopes, and pre/post content
      more appear within the namespace scope before/after the class, or may
      appear outside of the namespace scope before/after the class.
    config:
      FeatureValue cls #:
        When a native block appears before/after a class, this identifies that
        the code is to be inserted within the namespace qualifiers.
      FeatureValue nmsp #:
        When a native block appears before/after a class, this identifies that
        the code is to be inserted outside of the namespace qualifiers.
    end Attribute level;

    primary
    Attribute native : id = <auto> #:
      The name of the native.

    Attribute comment:;
    Attribute scope: : simplex children <_statement_>;

  expand:
    /# For native blocks within namespace scope, the native construct
    /# is attached to the preceeding class construct
    parent_construct = self.parentConstruct()
    if parent_construct.kind() == 'namespace':
      /# native blocks within namespace scope are added to either the
      /# 'pre' or 'post' key of the 'extralines' field of the nearest
      /# 'class' construct in a particular direction.
      baselang = self.baselang()
      rem = baselang.config('rem')
      comment_attr, commlines = self.attrpair('comment:', None)
      scope_attr, scope = self.attrpair('scope:', default=None)

      /# These feature attributes help us determine which class construct to
      /# find (the 'position' feature is either 'pre' or 'post', indicating
      /# whether we are looking for the class below or above this native
      /# construct), which class variant is desired (the 'location' feature
      /# is 'user', 'test' or 'meta'), and which file variant is desired
      /# (the 'placement' feature is 'defn' or 'decl').
      position = self.attrval('position')
      placement = self.attrval('placement')
      level = self.attrval('level')

      parent = self.parent()
      block = parent.value()
      index = block.index(self)
      class_construct = None
      metafile = self.metafile()

      if scope is None:
        /# This native block does not apply to the baselang in question.
        direction = None

      elif position == 'pre':
        /# This native block is associated with the class BELOW it, and
        /# is written into that class' premap field.
        direction = 'below'
        n = len(block)
        while index < n-1:
          index += 1
          cons = block[index]
          if cons.kind() == 'class':
            class_construct = cons
            break
      elif position == 'post':
        /# This native block is associated with the class ABOVE it, and
        /# is written into that class' postmap field.
        direction = 'above'
        while index > 0:
          index -= 1
          cons = block[index]
          if cons.kind() == 'class':
            class_construct = cons
            break
      else:
        raise metax.c.InternalError('Invalid position "%s"' % position)

      if direction is None:
        pass
      elif not class_construct:
        metafile.error(
          'Failed to find a class %s %s' % (direction, self.fqn()),
          line=self.primary().line())
      else:
        /# Now we check the 'location' attribute to see if the code is
        /# to be put in the test class or meta class instead.
        target_class = None
        locattr, location = self.attrpair('location', default=metax.c.LOOKUP)
        /# TODO(wmh): Fix this issue with attrpair ... if we need to LOOKUP,
        /# then locattr will by definition not have a proper line number
        /# in the meta source file.  We should fall back to some default
        /# (the primary attribute line number, for example).

        if location == 'user':
          /# We are good as-is
          target_class = class_construct
        elif location == 'test':
          /# The test class may be disabled or otherwise missing.
          testclass = class_construct.testclass()
          if testclass is None:
            metafile.error(
              'native block requests placement in non-existent test class',
              line=self.primary().line())
          else:
            target_class = testclass
        elif location == 'meta':
          /# The meta class may be disabled or otherwise missing.
          metaclass = class_construct.metaclass()
          if metaclass is None:
            metafile.error(
              'native block requests placement in non-existent meta class',
              line=self.primary().line())
          else:
            target_class = metaclass
        else:
          metafile.error(
            'Unknown location %s' % location, line=self.primary().line())

        /# Write the native lines to the appropriate location.
        if target_class:
          lines = []
          if comment_attr or scope:
            lines.append('')
          baselang.simpleToBase(comment_attr, output=lines, comment=True)
          baselang.simpleToBase(scope_attr, output=lines)
          segment = metax.c.BaseSegment(scope_attr, chunks=lines)
          /# print '**** HERE with %s for %s(%s) and %s,%s' % (self.kindfqn(), target_class.kindfqn(), id(target_class), position, placement)
          extralines = target_class.extralines().setdefault(position, {}).setdefault(placement, [])
          extralines.append(segment)
  translate:
    /# verbatim dump
    parent_construct = self.parentConstruct()
    if parent_construct.kind() == 'class':
      metafile = self.metafile()
      baselang = self.baselang()
      streams = metafile.streams()
      scope = self.attr('scope:', default=None)
      if scope:
        precount = self.precount()
        /# We adjust metaline down by precound so that an error on line
        /# precount corresponds to scope.line() ... e.g. the blank lines
        /# inserted should not break line mapping.
        metaline = scope.line() - precount
        lines = []
        for i in range(0, precount):
          lines.append('')
        baselang.simpleToBase(scope, output=lines)
        segment = metax.c.BaseSegment(scope, metaline=metaline, chunks=lines)
        streams.addSegment('defn', segment)
    return (None, None)

  scope:

    field namespace : NamespaceConstruct #:
      Every construct that can appear in a namespace must have a
      namespace field.  Not really needed for Native.

  end Construct native;

  Construct assoc < _oopl_ #:
    @assoc: An association/dependency of a class.
  config:

    Attribute location;

    feature
    Attribute kind : <cls|lib|std|decl|def> = cls #:
      The kind of association.
    config:
      FeatureValue cls #:
        The assoc is a class (the preferred kind of dependency)
      FeatureValue lib #:
        The assoc is a namespace (all symbols in the namespace are to be
        imported)
      FeatureValue std #:
        The assoc is from the standard library (and thus doesn't need a target).
      FeatureValue decl #:
        The assoc is a class to be declared but not defined.
      FeatureValue def #:
        The assoc is a class to be declared, and its definition imported
        *after* the declaration of the containing class.
    end Attribute kind;

    primary
    Attribute assoc : word = <required> #:
      The name of the assoc.  For c-style includes in C++, one can use a
      value of 'stdlib.h'.
      TODO(wmh): We should introduce a 'name' secondary attribute with
      replacer semantics, instead of having the assoc primary value identify
      the assoc. By having 'name', individual baselangs can vary the value
      (and we reserve the primary value for naming the construct itself in
      situations where it is useful ... we can change the type from word to id
      in that case).

    secondary
    Attribute alias : word = <empty> #:
      The alias by which this dependency is to be known within the baselang
      source file.

    secondary
    Attribute target : str = <empty> #:
      The BUILD target to use for this assoc. If not specified, a default is
      computed based on the assoc and kind.  Use the explicit empty string
      to indicate that no target is needed (useful to break circularities).
      Otherwise, it should be a fully qualified BUILD target.

    Attribute comment:;

  scope:
  end Construct assoc;

  Construct testx < _oopl_ #:
    @testx: A construct allowing multiple test methods to be assigned to a method.

    It would be better if this was called 'test', but we are already using
    'test' as a feature value and a secondary key, and we cannot have a
    primary key and feature value with same text.  We would need to rename
    the feature value if we want to rename this to testx (we *can* have
    the same value used for both primary key and secondary key).
  config:

    primary
    Attribute testx : id = <required> #:
      The name of the testx. Note that one cannot use values like
      '1' or '2' here because they aren't valid ids. Better to use
      a word/phrase more descriptive of what is being tested.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

  scope:
  end Construct testx;

  Construct resource < _oopl_ #:
    @resource: A non-code (aka data) dependency of a class.
  config:

    Attribute location;

    primary
    Attribute resource : id = <required> #:
      The name of the resource.
      This is intentionally an id to avoid allowing '.', since we want to be
      able to treat dots as indicators of fqns in Object.Resource.

    secondary
    Attribute path : str = <empty> #:
      An explicit bazel target for this assoc. Useful in situations where
      Meta cannot determine the target itself, and in situations where
      a circularity needs to be broken (specify an empty string).
    end Attribute path;

    Attribute comment:;

  scope:
  end Construct resource;

  Construct command < _classic_ #:
    @command: A CLI script (if toplevel) or subcommand.
  config:

    feature
    Attribute compilation : <implicit|explicit> = explicit #:
      Whether invoking the binary implicitly compiles dependent meta code,
      or whether code needs to be explicitly compiled.
    config:
      FeatureValue implicit #:
        If the command in question has an associated binary (e.g. it is a
        toplevel command), invoking the binary will result in all Meta-level
        software needed by the binary being implicitly recompiled if its
        meta file is newer than its baselang source file.
      FeatureValue explicit #:
        If the command in question has an associated binary (e.g. it is a
        toplevel command), invoking the binary will NOT result in all Meta-level
        software needed by the binary being implicitly recompiled. One must
        recompile the code explicitly.

    feature
    Attribute kind : <inline|named> = inline #:
      Allows us to indicate if a command should generate a method or not.
    config:
      FeatureValue inline #:
        The compiled code does not introduce a lexical scope, so the lines
        in the block flow from previous lines without change.
      FeatureValue named #:
        An instance-level method is defined to implement the block. The method
        is defined on the class within which the 'command' construct was found,
        and accepts one argument of type metax.root.flags.Values representing
        the instantiated flags (and associated Command). Note that only commands
        of kind 'instance' can be invoked outside of the method implementing the
        command construct (blocks of kind 'virtual' or 'scoped' are local to the
        top-level command).

        TODO(wmh): Provide support for returning values.  Although one
        can use 'return' in such blocks, if the block is changed to
        virtual, it will return from the entire surrounding function,
        which isn't usually what is desired. A safer mechanism that works
        for both instance and virtual blocks is preferred.

    primary
    Attribute command : id = <required> #:
      The name of the command.

    secondary
    Attribute aliases : str = <empty> aliases <@> #:
      A comma-separated list of aliases for the command.

    secondary
    Attribute interface: : complex = <empty> children <command|flag|arg> #:
      A comma-separated list of aliases for the command.

    secondary
    Attribute binary : str = <empty> #:
      Only relevant for top-level command constructs. Specifies the binary to
      use when the default is not suitable.
    
    Attribute comment:;
    Attribute scope: : simple;

  expand:
    /# Expand the entry.
    /#
    /# Create a meta method on the class within which the entry is found
    /# representing the code to execute for this entry point. This involves
    /# compiling all 'flag', 'arg' and 'command' subconstructs of the
    /# 'interface:' attribute, and the code in scope:, into a collection of lines
    /# that represent the body of the to-be-added meta method.
    /#
    /# TODO(wmh): This code is invoked on every command defined in any
    /# transitively included meta source file, which is unnecessary (we only
    /# need to generate the entry method for metafiles that have specificly
    /# been requested to be compiled.
    metax.c.D.expand.sinfo(self.kindfqn())

    metafile = self.metafile()
    streams = metafile.streams()
    klass = self.ancestor('class')
    metaclass = klass.metaclass()
    metaclass_scope = metaclass.attr('scope:', default=metax.c.REQUIRED)
    userclass = metaclass.underclass()
    assert userclass is not None
    class_scope = userclass.attr('scope:', default=metax.c.REQUIRED)

    command_kind = self.attrval('kind')
    context = metaclass.context()
    metafile = self.metafile()
    baselang = self.baselang()
    rem = baselang.config('rem')

    /# For the top-level command within a class, we pass the comment of the
    /# command on as the comment of the method.
    comment_lines = self.attrval('comment:', default=None)
    if comment_lines is None:
      comment_lines = [
        'Auto-generated entry point for %s' % klass.fqn()]

    scope_attr, command_list = self.attrpair('scope:', default=None)
    if scope_attr and scope_attr.isComplexBlock():
      /# This is the old style, in which the scope: block contains
      /# commands, flags, args and 'block'.
      subconstructs = command_list[:]

      /# Find the 'block:' within the subconstructs, if one exists.
      block = None
      for child in subconstructs:
        kind = child.kind()
        if kind == 'block':
          if block is None:
            block = child
          else:
            raise metax.c.Error('Found multiple blocks: %s vs %s' % (block.kindfqn(), child.kindfqn()))
      if block:
        blines = block.attrval('scope:', default=metax.c.REQUIRED)
        primary_line = block.primary().line()
      else:
        blines = []
        primary_line = -1
    else:
      /# This is the new style, in which scope: is simple and contains only
      /# the code for the command.  All flags, args and subcommands are in
      /# the 'interface' construct.
      subconstructs = []
      block = scope_attr
      blines = command_list or []
      primary_line = self.primary().line()

    /# We add the constructs in the 'interface:' block to the beginning of
    /# subconstructs (when we are fully migrated, subconstructs will just
    /# contains the interface: block).
    interface_scope = self.attrval('interface:', default=None)
    if interface_scope:
      subconstructs = interface_scope + subconstructs

    command_code = []
    special_default_command = '__default__'

    def VarName(names, start=1, end=None):
      if end is None:
        end = len(names)
      result = '_'.join(names[start:end])
      if result:
        result += '_'
      result += 'command'
      return '_' + result

    /# Establish the level of command construct.
    clist = []
    cnames = []
    cmd = self
    while cmd.kind() == 'command':
      clist.insert(0, cmd)
      cnames.insert(0, cmd.id())
      cmd = cmd.parentConstruct()
    level = len(clist) - 1
    toplevel = level == 0
    indent = '  ' * level
    sub_var = 'meta__names[%d]' % (level + 1)

    command_fullname = VarName(cnames)
    if toplevel:
      parent_fullname = None
    else:
      parent_fullname = VarName(cnames, end=-1)

    if toplevel:
      streams.initStreams('command_init', 'command_body')
      /# TODO(wmh): Determine why the following produces a problem in
      /# importMeta() when we specify ('metax.cli', 'lib', ...). This yields
      /# class path .../metax/.cli.py (instead of metax/cli/__init__.py) and
      /# thus a null meta path. Note that it is not strictly sufficient
      /# to import metax.cli.Command ... also need Flag and Arg and Values.
      /# Works fine for Python, but may not for other baselangs.
      metaclass.addDependency(
        'metax.cli.Command', 'cls', 'needed for entry point')

      /# Now create the executable binary that calls into this entry point.
      compilation = self.attrval('compilation')
      self.createExecutableBinary(auto=compilation == 'implicit')

    command_init = streams.stream('command_init')
    command_body = streams.stream('command_body')

    /# print '*** For %s found %s lines in body before start' % (self.kindfqn(), len(command_body))

    /# We need to add code to command_init to create a new
    /# metax.cli.Command instance.
    self.generatePython(command_fullname, parent_fullname, command_init)

    special_receiver = 'the%s' % klass.id()
    if blines:
      clines = self.attrval('comment:', default=None) or []

      if command_kind == 'named':
        /# We create a method to implement this block.
        if self.id() == special_default_command:
          metafile.error(
            'The default command cannot be named',
            line=block.primary().line())
        else:
          methname = command_fullname

          /# Generate the method call locally.
          command_body.append('%s%s.%s()' % (indent, special_receiver, methname))

          /# Create the method that does the actual work.
          /#  - note that although the toplevel MetaxEntry method is
          /#    a meta method (and thus defined on the meta class),
          /#    named blocks are generated as instance methods on
          /#    the underlying user class.
          method = metax.oopl.MethodConstruct.NewFromData(
            methname, context, parent=class_scope,
            features=[],
            secondaries=[
              ('#:', clines or None),
              ('scope:', blines),
            ],
            primary_line=primary_line)

      else:
        /# We write the contents of the block into command_code.
        /# TODO(wmh): Should use BlockConstruct.translateMeta() if possible!
        /# TODO(wmh): Is there a way to force a new lexical scope in
        /# python3 within a method, so that a variable defined inside
        /# the lexical scope does not affect its value outside that scope?
        for line in clines:
          /# TODO(wmh): Generalize to all baselangs.
          command_code.append(indent + rem + ' ' + line)
        for line in blines:
          command_code.append(indent + line)
        command_body.extend(command_code)

    /# Now parse the scope
    subcmds = []
    args = []
    default_encountered = False
    has_optargs = False
    for child in subconstructs:
      kind = child.kind()

      if kind == 'flag':
        /# Generate flag code in command_init.
        child.generatePython(command_fullname, command_init)
        if child.isArg():
          cdef = child.attr('default', default=None)
          if cdef is not None:
            has_optargs = True

      elif kind == 'command':
        if len(subcmds) == 0:
          /# This is the first subcommand ... insert an initial block that
          /# never gets executed (avoids special case code latter).
          command_body.append('')
          if True:
            command_body.append("%sif cli.rest and cli.rest[0].startswith('help'):" % indent)
            command_body.append("%s  meta__command.help(full='ful' in cli.rest[0])" % indent)
          else:
            command_body.append('%sif False:\n' % indent)
            command_body.append('%s  pass' % indent)
        elif default_encountered:
          /# We previously encountered the special default command, which
          /# must occur after all other commands, so the current one is
          /# in error.
          /# TODO(wmh): Use a less hacky mechanism here.
          metafile.error(
            'The special %s command must occur last' %
            special_default_command, line=child.primary().line())
          break

        subcmds.append(child)
        command_body.append('')
        if child.id() == special_default_command:
          command_body.append('%selse:' % indent)
          default_encountered = True
        else:
          command_body.append(
            "%selif %s == '%s':" % (indent, sub_var, child.id()))
        /# We encode within the baselang output stream some information about
        /# where within the .meta file the upcoming code block resides.
        cscope = child.attr('scope:', default=None)
        if cscope:
          command_body.append(
            '%s  %s ^METAFILE^ %s' % (indent, rem, metafile.path()))
          command_body.append(
            '%s  %s ^METALINE^ %s:command %d' %
            (indent, rem, child.fqn(), cscope.line()))
        /# We recursively expand the child command construct, which will write
        /# lines into the command_body and command_init streams.
        child.expandMeta()

      elif kind == 'block':
        pass
      else:
        raise metax.c.Error(
          'Unexpected child %s of %s' % (child.kindid(), self.kindfqn()))

    if subcmds:
      if default_encountered:
        /# A default command was encountered, so a final 'else has been
        /# generated.
        pass
      else:
        /# There were subcommands, so we close the if ... elif ... block
        /# with an error if command is unknown.
        command_body.append('')
        command_body.append('%selse:' % indent)
        command_body.append(
          indent + "  print 'ERROR: Unrecognized command \"%s\"' % " + sub_var )

    if (not subcmds or toplevel) and not has_optargs:
      /# There were no subcommands or optional args (or, alternatively, this 
      /# is the top-level command). In either case, we want to add a
      /# 'catch-all' arg.
      /#  - for non-toplevel commands, if there were any 'arg' constructs
      /#    specified within this command, they are assumed to constitute all
      /#    desired args.
      /#  - as a convenience, if no args are specified, we defined a
      /#    multi-valued 'rest' arg that consumes all subsequent args.
      /#  - TODO(wmh): Consider removing this special arg when we have args
      /#    working properly as constructs ... abide by exactly what the
      /#    user wants. May still need it for toplevel though.
      command_init.append('%s.newArg(' % command_fullname)
      command_init.append("  'rest', multi=True, summary='Leftover args.')")

    if toplevel:
      command_init.append('cli = None')
      command_init.append('instcmd = None')
      command_init.append('if argv:')
      command_init.append(
        '  instcmd = %s.instantiate(argv, start=True)' % command_fullname)
      command_init.append('  if instcmd:')
      command_init.append('    cli = instcmd.asValues()')
      /#command_init.append('    if cli.verbose and cli.verbosity == 0: cli.verbosity = 1')
      /#command_init.append('    elif cli.verbosity > 0 and not cli.verbose: cli.verbose = True')
      command_init.append('return (%s, instcmd, cli)' % command_fullname)

      /# Create the MetaxCLI method, which returns a metax.cli.Command instance.
      cmd_method_name = metax.c.METAX_CMD_NAME
      cmd_params = metax.oopl.ExecutableConstruct.CreateParams(
        [{'var': 'argv',
          'secondaries': [
            (':', metax.c.Type.Instance('&vec<str>')),
            ('#:', ['The list of command line args (including executable)']),
            ('=', metax.c.Expr('var', 'null', 'null')),
          ]},
        ],
        context)
      cmd_method = metax.oopl.MethodConstruct.NewFromData(
        cmd_method_name, context, parent=metaclass_scope,
        /# We do not bother setting location because we are creating the
        /# method within the metaclass (location is only relevant during
        /# expansion and we are skipping that step by defining in metaclass
        /# directly).
        secondaries=[
          (':', metax.c.Type.Instance('metax.cli.Command')),
          ('#:', ['Create Command instance for %s.' % klass.fqn()]),
          ('params:', cmd_params),
          ('scope:', command_init),
        ])
      cmd_method.myclassIs(klass)

      /# Insert code that creates and instantiates a metax.cli.Command instance.
      command_preamble = []
      command_preamble.append('# Parse the command line args')
      command_preamble.append(
        '%s, meta__command, cli = %s.%s(argv=meta__args)' %
        (command_fullname, klass.id(), cmd_method_name))
      command_preamble.append('if meta__command is None:')
      command_preamble.append('  return')
      command_preamble.append('meta__names = meta__command.names()')
      /# TODO(wmh): Add metax.c as a dependency so it is imported early and
      /# will therefore work in bazel.
      if False:
        command_preamble.append('import metax.c')
        command_preamble.append('metax.c.Compiler.Initialize()')
        command_preamble.append('metax.root.Object.Init(cli=cli)')
      command_preamble.append('')

      /# We create the entry method.
      /#  - it can be either a 'meta' method or a 'static' method
      /#  - originally it was implemented as 'meta', but that precludes certain
      /#    functionality from being used (aspects of the class are not yet
      /#    defined within the code in the metaclass is executed).
      /#  - as of 2018-11-07, it is a static method instead.
      if False:
        /# meta method defined on meta-class
        features = []
        entry_pscope = metaclass_scope
      else:
        /# static method defined on class
        features = [('kind', 'static')]
        entry_pscope = class_scope

      method_name = metax.c.METAX_ENTRY_NAME
      body = command_preamble + command_body
      params = metax.oopl.ExecutableConstruct.CreateParams(
        [{'var': 'meta__args',
          'secondaries': [
            (':', metax.c.Type.Instance('&vec<str>')),
            ('#:', ['The list of command line args (including executable)']),
          ]},
         {'var': 'meta__parent',
          'secondaries': [
            (':', metax.c.Type.Instance('metax.root.Command')),
            ('#:', ['A parent command. Usually null.']),
            ('=', metax.c.Expr('var', 'null', 'null')),
          ]},
         /# TODO(wmh): meta__kwds is currently unused ... delete it?
         {'var': 'meta__kwds', 'features': [('multiplicity', 'multi')],
          'secondaries': [
            (':', metax.c.Type.Instance('map')),
            ('#:', ['Catchall arg for special-casing.']),
          ]},
        ],
        context)
      entry_method = metax.oopl.MethodConstruct.NewFromData(
        method_name, context, parent=entry_pscope,
        /# We do not bother setting location because we are creating the method
        /# within the metaclass (location is only relevant during expansion and
        /# we are skipping that step by defining in metaclass directly).
        features=features,
        secondaries=[
          (':', metax.c.Type.Instance('int')),
          ('#:', comment_lines),
          ('params:', params),
          ('scope:', body),
        ])
      entry_method.myclassIs(klass)

    metax.c.D.expand.end()
  translate:
    /# Translate.  Write baselang comment.
    metax.c.D.translate.sinfo(self.kindfqn())
    /# This is currently a noop, as we form a 'method' in expandMeta and
    /# rely on MethodConstruct.translateMeta() to do its thing.
    metax.c.D.translate.end()
  scope:

    method generatePython #:
      Generate python code that will create a metax.cli.Command
      instances representing this command construct.
    params:
      var command_var : str #:
        The name of the variable storing a metax.cli.Command instance
        that is to contain the Flag instance.
      var parent_var : str #:
        The name of the parent.  Is null if this is the top-level construct.
        Note that top-level construct does not necessarily mean top-level
        Command instance (depends on value of 'parent' in the generated code).
      var output : &vec<str> #:
        Where to write output.
    scope:
      indent = ''
      toplevel = parent_var is None

      aliases = self.attrval('aliases', default=None)

      if toplevel:
        /# We are at top-level, so we need to create a Command directly.
        creation_cmd = 'metax.cli.Command'
      else:
        /# We are not at top-level, so we can create a subcommand using
        /# newCommand() on the parent.
        creation_cmd = '%s.newCommand' % parent_var

      summary, desc = self.splitComment()
      output.append("%s%s = %s(" % (indent, command_var, creation_cmd))
      output.append("%s  '%s'," % (indent, self.id()))
      /# Removed 2018-10-29 as part of cli cleanup.
      /# if toplevel:
      /#   output.append('%s  parent=meta__parent,' % indent)
      if aliases:
        /# the 'aliases' attribute of 'command' is of type 'str' so it is
        /# an Expr with kind 'str'.
        aval = aliases.asStr(unquote=True)
        output.append("%s  aliases='%s'," % (indent, aval))
      output.append(
        "%s  summary='%s'," % (indent, summary.replace("'", "\\'")))
      lines = desc.split('\n')
      if len(lines) == 0:
        output.append("%s  desc='')" % indent)
      elif len(lines) == 1:
        output.append(
          "%s  desc='%s')" %
          (indent, desc.replace('\n', '\\n').replace("'", "\\'")))
      else:
        output.append("%s  desc=(" % indent)
        last = lines.pop()
        for line in lines:
          output.append("%s    '%s\\n'" % (indent, line.replace("'", "\\'")))
        output.append("%s    '%s'))" % (indent, last.replace("'", "\\'")))
    end method generatePython;

    method createExecutableBinary : any #:
      Create the simple executable stub that calls into a class-specific entry
      point. Generated by top-level 'command' constructs.
    params:
      var auto : bool = false #:
        If true, invocations of the binary should auto-compile meta code.
    scope:
      metafile = self.metafile()
      klass = self.ancestor('class')
      metac = klass.compiler()
      fs = metac.fs()
      nmsp = klass.namespace()
      
      /# Establish the binary to use.
      binaryexpr = self.attrval('binary')
      python_binary = binaryexpr.asStr(unquote=True) or metac.Config()['python']

      /# Create the content of the binary file.
      cmdlines = [
        /# TODO(wmh): Use some template that is user-customizable
        '#!%s' % python_binary,
        'import metastrap',
        'metastrap.Setup(%s)' % ('auto=True' if auto else ''),
        /# TODO(wmh): How to allow for binary-specific imports?
        /# Most scripts do not need metagae, but those that interact with
        /# WAE may. And metagae is a wmh-ism, not a meta-ism!
        '#import metagae',
        'import sys',
        'import %s' % nmsp.fqn(),
        'try:',
        '  %s.%s(sys.argv)' % (klass.fqn(), metax.c.METAX_ENTRY_NAME),
        'except Exception:',
      ]
      if False:
        cmdlines.extend([
          '  import cStringIO',
          '  import traceback',
          '  compiler_class, command, cli = metastrap.ImportMeta()',
          '  import metax.c',
          '  metax.c.Compiler.Initialize()',
          "  metac = metax.c.Compiler(metal='oopl', basel='python')",
          '  metax.c.Compiler.CurrentIs(metac)',
          '  text = traceback.format_exc()',
          '  ifp = cStringIO.StringIO(text)',
          "  baselang = metac.metalang().baselangNamed('python')",
          '  metac.filterMetaOutput(baselang=baselang, ifp=ifp, debug=False)',
        ])
      else:
        cmdlines.append('  metastrap.RecoverMeta(None)')

      /# Create the file:
      /#  - for now, we place it in the namespace subdir of the repository
      /#  - we could put it in a class subdir, but we do not need class subdirs
      /#    for anything else currently ... maybe later.
      cmdpath = metac.basePath(nmsp.fqn() + '.' + self.id())
      cmdfile = metax.fs.BaseFile(
        cmdpath, '\n'.join(cmdlines) + '\n',
        metafile=metafile, mapfile=None, mode=0755)
      metafile.registerFile(cmdfile)

      /# Now we make a symlink from oopl/bin/<id> to the above cmdpath.
      /#  - if the symlink file already exists
      /#     - if it is not a symlink, raise exception
      /#     - if it does not link to the same thing as we expect, report warning, do nothing
      /#     - if it does link to same thing as we expect, do nothing
      /#  - else create ite.
      /#  - we do the same thing for any aliases of the command.
      linkdir = fs.join(metac.repositoryPath(), 'bin')
      if not fs.exists(linkdir):
        fs.makedirs(linkdir, 0755)

      basenames = [self.id()]
      aliases = self.attrval('aliases', default=None)
      if aliases:
        aval = aliases.asStr(unquote=True).split(',')
        basenames.extend(aval)

      for basename in basenames:
        linkpath = fs.join(linkdir, basename)
        relpath = fs.join('..', cmdpath)

        if fs.exists(linkpath):
          if not fs.islink(linkpath):
            raise metax.c.Error('Expecting %s to be a symlink to %s' % (linkpath, relpath))
          currpath = fs.readlink(linkpath)
          f1 = fs.realpath(currpath)
          f2 = fs.realpath(relpath)
          if False and f1 != f2:
            /# TODO(wmh): This is giving spurious warnings and is thus disabled.
            /# May be useful sometimes, in which case it needs fixing.
            metafile.warning(
              'For %s we have\n  %s\n  %s' % (linkpath, f1, f2),
              line=self.primary().line())
        else:
          linkfile = metax.fs.BaseFile(
            linkpath, None, metafile=metafile, mapfile=None,
            link=cmdfile)
          metafile.registerFile(linkfile)
    test:
    end method createExecutableBinary;

  end Construct command;

  Construct flag < _oopl_ #:
    @flag: A commmand-line flag (or positional arg)
  config:

    feature
    Attribute status : <required|optional> = optional #:
      Whether the flag is required or not (most flags are optional).

    primary
    Attribute flag : id = <required> aliases <arg> #:
      The name of the flag.

    secondary
    Attribute aliases : str = <empty> aliases <@> #:
      A comma-separated list of aliases for the flag. If any alias is one char
      long, it can be accessed with '-' or '--', and can be merged togetehr with
      other single-letter flag names (-abc = -a -b -c).

    secondary
    Attribute type : type = any aliases <:> #:
      The metatype of the flag.

    secondary
    Attribute default : expr = <special> aliases <=> #:
      The default value of the flag.
      TODO(wmh): This should have type 'expr', not 'word'.
    end Attribute default;

    Attribute comment:;

  expand:
    /# Expand the flag (nothing to do).
    metax.c.D.expand.sinfo(self.kindfqn())
    /# I don't believe we ever use this, right?
    raise metax.c.Error('Should never get here')
    metax.c.D.expand.end()
  translate:
    /# Translate.  Write baselang comment.
    metax.c.D.translate.sinfo(self.kindfqn())
    /# I don't believe we ever use this, right?
    raise metax.c.Error('Should never get here')
    metax.c.D.translate.end()
  scope:

    method isArg : bool #:
      True if this instance is a positional arg
    scope:
      /# TODO(wmh): When construct aliases are working properly we can check
      /# whether the kind is 'arg'.
      return self.id().startswith('arg_')
    test:
    end method isArg;

    method generatePython #:
      Generate python code that will create a metax.cli.Flag
      instances representing this flag construct.
    params:
      var command_var : str #:
        The name of the variable storing a metax.cli.Command instance
        that is to contain the Flag instance.
      var output : &vec<str> #:
        Where to write output.
    scope:
      indent = ''
      metac = self.compiler()
      baselang = metac.baselang()
      aliases = self.attrval('aliases', default=None)
      type = self.attrval('type', default=None) or metax.c.Type.Instance('str')
      default = self.attrval('default', default=None)
      if default is None:
        baselang_default = 'None'
      else:
        baselang_default = baselang.formatExpr(default, type, self)
      /#if default is None:
      /#  default = baselang.defaultValue(type)
      summary, desc = self.splitComment()

      /# Establish if this is a flag or arg.
      /#  - TODO(wmh): When aliases for primary constructs are working,
      /#    we can distinguish between flag and arg by the construct kind.
      /#  - For now, if the id starts with 'arg_', it is an arg and we
      /#    strip the prefix.
      name = self.id()
      primary = self.primary()
      /# The 'flag' construct has 'arg' as an alias for the primary key.
      /# If 'arg' was specified, we know to generate an arg vs a flag.
      isarg = primary.litkey() == 'arg'

      /# Clean up type issues
      typestr = type.raw()
      if typestr.startswith('vec<'):
        typestr = typestr.replace('vec<', 'list<')

      /# Generate the code.
      output.append(
        "%s%s.new%s(" % (indent, command_var, 'Arg' if isarg else 'Flag'))
      /# baselang_default = baselang.metabaseValue(default)
      output.append(
        "%s  '%s', mytype='%s', default=%s," % (
          indent, name, typestr, baselang_default))
      if aliases:
        aval = aliases.asStr(unquote=True)
        output.append("%s  aliases='%s'," % (indent, aval))
      if summary:
        output.append(
          "%s  summary='%s'," % (indent, summary.replace("'", "\\'")))
      if desc:
        output.append(
          "%s  desc='%s'," %
          (indent, desc.replace('\n', '\\n').replace("'", "\\'")))
      if isarg and typestr.startswith('list<'):
        output.append("%s  multi=True," % indent)
      output.append("%s)" % indent)
    test:
    end method generatePython;

  end Construct flag;

  abstract
  Construct _statement_ < _oopl_ clsname StatementConstruct #:
    @_statement_: abstract superconstruct for all statement constructs

    These are constructs in Meta(Oopl)* those that can appear within
    complex blocks representing statement level code.
  config:

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_> ;

  scope:
  end Construct _statement_;

  Construct block < _symbol_ #:
    @block: A meta-level means of introduce lexical scoping.

    One common use of this construct is to move from Meta(Oopl)* to Meta<X>
    within a complex method block.
  config:

    feature
    Attribute kind : <virtual|scoped|named> = virtual #:
      Identifies one of a variety of mutually exclusive kinds of methods.

      TODO(wmh): The fact that executables have a feature attribute named kind',
      combined with us using 'kind to refer to the primary key, is destined to
      pose confusion. Consider renaming one or the other use.
    config:
      FeatureValue virtual #:
        The compiled code does not introduce a lexical scope, so the lines
        in the block flow from previous lines without change.
      FeatureValue scoped #:
        The compiled code introduces a new lexical scope for the block.
        IMPORTANT: Certain baselangs (e.g. python) do not have support for
        lexical blocks, and although lexical scoping can be emulated in
        Meta*, code written in Meta<Python> using scoped blocks may have
        different semantics from what occurs in Meta<C++>, etc.
        TODO(wmh): Does python 3 provide support for this?
      FeatureValue named #:
        An instance-level method is defined to implement the block. The method
        is defined on the class within which the 'command' construct was found,
        and accepts one argument of type metax.root.flags.Values representing
        the instantiated flags (and associated Command). Note that only commands
        of kind 'instance' can be invoked outside of the method implementing the
        command construct (blocks of kind 'virtual' or 'scoped' are local to the
        top-level command).

        TODO(wmh): Provide support for returning values.  Although one
        can use 'return' in such blocks, if the block is changed to
        virtual, it will return from the entire surrounding function,
        which isn't usually what is desired. A safer mechanism that works
        for both instance and virtual blocks is preferred.
    end Attribute kind;

    primary
    Attribute block : id = <auto> #:
      The name of the block.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_> ;

  expand:

    metax.c.D.expand.sinfo(self.kindfqn())
    print 'HERE in %s.expandMeta()' % self.kindfqn()
    metax.c.D.expand.end()

  translate:

    metax.c.D.translate.sinfo(self.kindfqn())
    /# I don't believe we ever use this, right?
    print 'HERE in %s.translateMeta()' % self.kindfqn()
    metax.c.D.translate.end()

  scope:
  end Construct block;

  Construct var < _statement_ #:
    @var: A variable declaration (used in parameters and complex method blocks).
  config:

    feature
    Attribute multiplicity : <multi|normal> = normal #:
      Usually 'normal', but when appearing within a 'params' block, 'multi'
      means the variable consumes all remaining args. The type of the var
      dictates whether positional or keyword args are grabbed (for baselangs
      that support the distinction, such as python).

    primary
    Attribute var : id = <required> #:
      The name of the var.

    secondary
    Attribute type : type = any aliases <:> #:
      The metatype of the var.

    secondary
    Attribute provides : id = <empty> aliases <->> #:
      The metatype of the var.

    secondary
    Attribute default : expr = <special> aliases <=> #:
      The default value of the var.  When the var is in a params: block,
      a default value means the param is optional.  When defined in an
      executable block, it provides an explicit value to initialize the
      variable to instead of using a type-specific default.
    end Attribute default;

    Attribute comment:;

  scope:

    field implicitType : Type #:
      The implicit type of this var based on, for example, the type of the
      value specified in a default attribute.  May be (and usually is) null.

    method kind : str scope:
      return 'var'
    test:
      varcons = metax.c.VarConstruct('age', None, test.context())
      test.iseq('var', varcons.kind())
    end;

    method effectiveType : Type #:
      The type of this var.
    scope:
      result = self.attrval('type')
      if result.isAny():
        implicit = self.implicitType()
        if implicit:
          result = implicit
      return result
    end method effectiveType;

  end Construct var;

  Construct loop < _statement_ #:
    @loop: A generalization of all looping syntax.
  config:

    primary
    Attribute loop : id = <required> #:
      The name of the loop.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <_statement_>;

  scope:
  end Construct loop;

  BaseLanguage cpp name C++ suffixes <cc|h>;
  BaseLanguage javascript name Javascript suffixes <js>;
  BaseLanguage python name Python suffixes <py>;

scope:

  class ExternalClassConstruct < metax.oopl.ClassConstruct #:
    A class defined external to Meta, in baselang-space.

    There are admittedly a massive number of unused fields declared and
    initialized by inheriting from ClassConstruct, but there will presumably be
    a relatively small number of classes, never mind non-meta classes, so I'm
    assuming it won't be an issue. Enterprise scale may need a different
    solution (eg. ClassInterface above ClassConstruct and
    ExternalClassConstruct)
  scope:

    lifecycle params:
      var id : str;
      var parent : metax.oopl.ClassConstruct;
      var context : Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.variantIs('baselang')
      /# TODO(wmh): We could do baselang introspection (for those languages
      /# supporting it) to initialize fields like parentclasses(), deps(),
      /# testclass(), namespace(), fields(), etc.  For now, we do not do so.
      self.parentclassesIs([])
    end;

    method parentclass : metax.oopl.ClassConstruct #:
      Obtain a parent class by index in superclass list.

      NOTE: Until ClassConstruct.importMeta() is invoked on this class,
      this method will return null.
    params:
      var index : int = 0 #:
        The index in self.parentclasses() of desired parent.
    scope:
      /# TODO(wmh): We could use baselang introspection to obtain the
      /# actual parent class of this baselang class, and dynamically
      /# create a new ExternalClassConstruct.
      return None
    test:
    end method parentclass;

  end class ExternalClassConstruct;


  abstract
  class BaseLanguageOopl < metax.meta.BaseLanguageConstruct #:
    The abstract superclass of all base languages in Meta(Oopl).

    The following config variables should be given values in subclasses via
    self.updateConfigs():
      namespace_primary : bool
        true if this baselang treats namespaces as primary (e.g. does not have
        per-class source files). ex. python is namespace_primary. javascript
        can be either namespace_primary or not. C++ and Java are not
        namespace_primary.
      definition_separate : bool
        true if this baselang has a separate source file for declarations.
        ex: C++ is definition_separate, while python, javascript and java are
        not.
      rem : str
        The character sequence used to start a one-line comment.
        TODO(wmh): Must add endrem for those languages that do not have a
        comment syntax for one-line comments (e.g. CSS has no such thing, so
        some OOPL may also).
      self : str
        The variable used to refer to the receiver within instance methods.
      cls : str
        The variable used to refer to the receiver within class methods.
      selfsep : str
        What separates the receiver variable from a method invocation.
        Ex. In Java and Python, this is '.', while in C++ and Perl it is '->'.
      staticsep : str
        What separates the class and method/field for static references.
        Ex. In Java and Python, this is '.', while in C++ and Perl it is '::'.
      stmtend : str
        What character(s) end statements in this baselang.
        ex: In python, this is empty.  In C++, Java and Javscript it is ';'.

      setup : map
        name : str
          The name of the method used to initialize a test before invoking
          a test method.
        level : str
          One of 'user', 'meta' or 'static'. Note that this is really a mixture
          of the 'location' and 'kind' attributes within a field, but is a
          more concise shorthand.
      teardown : map
        same as setup but represents the method used to cleanup after a test
        method has been run.
      clsetup : map
        same as setup but represents the method used to initialize an entire
        TestCase instance before invoking the tests on it.
      clteardown : map
        same as setup but represents the method used to cleanup an entire
        TestCase instance after invoking all tests on it.
  scope:

    field metatypes : map #:
      Maps meta-level primitive/native types to base-lang information
      about those types. Some metatypes require a parameter (e.g. int<32>,
      real<64>), in which case the value is a recursive map ... this is
      determined by whether key 0 exists with value True or not). The value
      maps contain:
        base: str or two-tuple of str
          The base-language base type associated with the metatype.
          For Java, two base types are provided, raw and boxed.
        default: str or None
          This should always be a string, not a python int or bool or anything
          else. This is the base-language syntax to use for a meaningful
          default value for variables of the specified meta (and base) type.
          If None, it means there is no meaningful default value for the type
          in question.
    end field metatypes;

    static
    field SpecialRE : regexp #:
      A regexp to apply to each line in comment blocks. A matching line is
      a request to suppress some Meta (or base-lang) warning.

    static
    field PseudoVars : map<@str,metax.c.Type> #:
      This static field has the same keys as BaseLanguageOopl.SPECIALS and its
      children, but instead of the value being a baselang representation of the
      meta identifier specified by the key, the value here is the Type instance
      that the value is an instance of.

    static
    field Templates : map<@str,pair<@str,metax.c.Type>> #:
      Keys are native types, values are tuples of two-tuples, specifying
      the allowed template args (conceptual-name, type). An empty tuple
      means an arbitrary number of template args are allowed, and they will
      be named 'T1', 'T2', etc. and have type any.

    lifecycle clinit:
      cls.SpecialREIs(re.compile(
        r'^(?P<indent>\s*)Meta:(?P<action>[a-zA-Z0-9_<>]+):\s*(?P<text>.*)'))

      cls.PseudoVarsIs({
        /# TODO(wmh): With the advent of TypeWrapper, should we have these be
        /# TypeWrapper instances whose underlying type is the fqcn of the actual
        /# class?
        'out': metax.c.Type.Instance('meta.ostream'),
        'err': metax.c.Type.Instance('meta.ostream'),
        'in': metax.c.Type.Instance('meta.istream'),
        /# TODO(wmh): What is the type of null in Meta??
        'null': metax.c.Type.Instance('meta.Null'),
        'nan': float,
        'self': metax.c.SELF,
        'test': metax.c.SELF,
        'this': metax.c.SELF,
        'false': metax.c.Type.Instance('bool'),
        'true': metax.c.Type.Instance('bool'),
      })

      /# TODO(wmh): Change to std::any
      any = metax.c.Type.Instance('any')
      cls.TemplatesIs({
        'vec': (('TV', any),),
        /# NOTE: In C++, we need the map key to be 'std::string' (rather than
        /# std::string* or std::string&) if we are using std::string to
        /# implement 'str' (will be better when we move to IStr). It is possible
        /# that javascript instead expects *str ... TBD. Note also that
        /# std::string_view helps here.
        'map': (('TK', metax.c.Type.Instance('@str')), ('TV', any)),
        'pair': (('T1', 'any'), ('T2', any)),
        /# NOTE: An entry in Templates() that is empty implies any number of
        /# params, each with default any.
        'tuple': tuple(), 
      })
    end lifecycle;

    method metabase : any #:
      Obtain base-lang info for a given (base) metatype.

      If you want to convert an arbitrary meta-level type to a baselang,
      use typeToBase() instead. This method is lower-level.

      Returns:
        Returns a dict if kind is null
        Returns a string if kind is 'base' or 'default'
        Returns null if mtypestr or params is invalid.
    params:
      var mtypestr : str #:
        A primitive or native meta-type (usually without any prefixes,
        although in special situations certain prefixed types may also have
        info).  One of the keys in self.__class__.METATYPES
      var param : str = null #:
        For types like 'int' and 'real', a numeric param is allowed. If None,
        and one is required, 32 is used.
      var kind : str = 'base' #:
        If None, returns the entire dict, else returns the value of key
        'kind' within the base dict.  Keys are: base, default.
      var metatypes : map = null #:
        Where to find the metatype info.  If None, uses self.metatypes()
    scope:
      if metatypes is None:
        metatypes = self.metatypes()
      baseinfo = metatypes.get(mtypestr, None)
      /# print 'metabase: mtypestr=%s param=%s kind=%s baseinfo=%s' % (mtypestr, param, kind, baseinfo)
      if not baseinfo:
        /# The given mtypestr is not a hardcoded meta type ... return None
        result = None
      else:
        if 0 in baseinfo:
          /# This metatype accepts a (numeric) param. If one is given, we find the
          /# closest integer in baseinfo equal-greater the specified param. If one
          /# is not given, we use the info from baseinfo[None].
          if param is None:
            arg = None
          else:
            arg = int(param)
            while arg < 65 and arg not in baseinfo:
              arg += 1
            if arg > 64:
              raise metax.c.Error('Invalid type %s<%d>' % (mtypestr, arg))
              return None
          baseinfo = baseinfo[arg]
        if kind is None:
          result = baseinfo
        elif kind in ('base', 'boxed'):
          result = baseinfo['base']
          if isinstance(result, tuple):
            result = result[0] if kind == 'base' else result[1]
          elif kind == 'base':
            pass
          else:
            result = None
        elif kind == 'default':
          result = baseinfo['default']
        else:
          raise metax.c.Error('Invalid kind %s' % kind)
      return result
    end method metabase;

    method metabaseValue : str #:
      Obtain the baselang representation of a meta-level value (for example,
      the attr value of a 'default' attribute of 'var', etc.)
    params:
      var value : any #:
        TODO(wmh): The value should probably always be an Expr, but currently
        the type of 'default' in 'var', 'field' and 'flag' is 'word' instead
        of 'expr'.
    scope:
      if isinstance(value, str):
        /# This is old-school ... should be removed in favor of Expr.
        /#  - support converting 'true', 'false', 'null', etc. to baselang
        /#    representations, but does not properly handle string literals,
        /#    list literals, hash literals, method invocations, or any of the
        /#    other things that Expr handles.
        result = self.pseudovars().get(value, value)
      elif isinstance(value, metax.c.Expr):
        raise metax.c.Error('Not yet handling Expr ... may need to define a behavior')
      else:
        raise metax.c.Error('Unknown type %s of value in metabaseValue' % type(value))
      return result
    test:
      ooplpy = test.cachedInfo(basel='python')[0]
      oopljs = test.cachedInfo(basel='javascript')[0]
      ooplcc = test.cachedInfo(basel='cpp')[0]

      for metaval, py, js, cc in (
        ('true', 'True', 'true', 'true'),
        ('false', 'False', 'false', 'false'),
        ('null', 'None', 'null', 'nullptr'),
        ('out', 'sys.stdout', '?', 'std::cout'),
        ('err', 'sys.stderr', '?', 'std::cerr'),
        ('in', 'sys.stdin', '?', 'std::cin'),
      ):
        test.iseq(py, ooplpy.metabaseValue(metaval))
        test.iseq(js, oopljs.metabaseValue(metaval))
        test.iseq(cc, ooplcc.metabaseValue(metaval))
    end method metabaseValue;

    method typeToBase : str #:
      Convert a metatype to a string representation of its base-language
      equivalent.
    params:
      var metatype : Type #:
        The metatype to convert.
      var class_construct : metax.oopl.ClassConstruct = null #:
        If specified, the class within which the type is being defined.
        Some baselangs cannot support fully-qualified references to the
        class currently being defined, and this allows such fully-qualified
        types to be localized.
      var value : any = null #:
        If present, the value being assigned to the variable of type 'metatype'.
        Used, for example, if metatype is 'str' (rather than '&str' or '*str')
        to heuristically decide between '&str' or '*str'.
      var defqn : bool = false #:
        If true, convert fully-qualified class-based types to class-name only.
        Used to support situations where the fully-qualified name poses
        problems in the baselang.
      var debug : bool = false #:
        If true, enable debugging.
    scope:
      defqn = False

      cls = self.__class__
      if debug:
        print 'In BaseLanguageOopl.typeToBase with metatype=%s' % (
          metatype.raw() if metatype else None)

      if metatype is None:
        result = 'METATYPE is NONE'

      elif not metatype.isValid():
        result = metatype.raw()
        if result.startswith('{#') and result.endswith('#}'):
          result = result[2:-2].replace('_', ' ')
        if debug:
          print '  type is invalid'

      else:
        params = metatype.params()

        /# Obtain the core metatype
        metabase = metatype.base() or '?'
        if metabase == 'str':
          /# The 'str' type is unusual in that *str and &str exist in
          /# METATYPES as separate entities, so we add those annotations in.
          if metatype.isPtr():
            metabase = '*' + metabase
          elif metatype.isRef():
            metabase = '&' + metabase
          elif metatype.isValue():
            metabase = '@' + metabase

        /# Check if the metabase type is a known metatype (e.g. in METATYPES).
        numeric = metatype.numericParam() or None
        basetype = self.metabase(metabase, param=numeric if params else None)
        scope_sep = metax.c.Context.Tokens()['scope_sep']

        if debug:
          print '  metabase=%s basetype=%s numeric=%s isptr=%s isref=%s' % (
            metabase, basetype, numeric, metatype.isPtr(), metatype.isRef())

        if basetype:
          /# We've found a mapping from meta-level to base-level.

          if numeric:
            /# We've obtained a primitive type
            result = basetype
          else:
            /# We set up a default mapping from parameter name to type, in case
            /# we have a metatype that does not specify all of the types.
            param_map = {}
            param_pairs = cls.Templates().get(metabase, [])

            if False:
              print '-' * 70
              print metatype
              print basetype
              print param_pairs
              print params

            np = len(params) if params else 0

            if param_pairs:
              /# This type has a certain number of parameters that can be
              /# provided (defaults are supported for parameters not given).
              /# TODO(wmh): Add support for empty pairs meaning arbitrary numbers of params
              if len(param_pairs) == 0:
                raise metax.c.Error('Not yet supporting arbitrary template params')
              else:
                for i in range(0, len(param_pairs)):
                  pkey, defmtype = param_pairs[i]
                  if i < np:
                    mtype = params[i]
                  else:
                    mtype = defmtype
                  param_map[pkey] = self.typeToBase(
                    /# TODO(wmh): Should some variant of 'value' be passed down?
                    mtype, class_construct=class_construct, defqn=defqn)
                /# print 'PARAM PAIRS for %s: %s = %s [%s]' % (metabase, param_pairs, param_map, basetype)
            result = basetype % param_map
        else:
          /# The metatype is not native/primitive, so it must be a class.
          if defqn:
            if metabase == 'metax.root.ObjectMetaRoot':
              /# TODO(wmh): Fix this hackery!
              result = metabase
            else:
              result = metabase.split(scope_sep)[-1]
          else:
            result = metabase

          /# The base part may be prefixed by EXTERNAL_CLASS_INDICATOR to
          /# indicate a non-meta class.
          if result[0] == metax.c.Type.EXTERNAL_CLASS_INDICATOR:
            result = result[1:]

        /# In javascript, we cannot (for some reason I really want to address)
        /# refer to the fully-qualified name of the class from within the
        /# class itself. Instead, we must use the non-qualified class name.
        if class_construct:
          nmspfqn = class_construct.namespace().fqn()
          /#print 'HERE with %-30s and %s' % (nmspfqn, result)
          if result == class_construct.fqn():
            result = result.split('.')[-1]
          elif False and result.startswith(nmspfqn):
            result = result.split('.')[-1]

        result = self._annotateBaseType(metatype, result)

      if debug:
        print '  result is "%s" for "%s"' % (result, metatype.raw())

      return result
    test:
      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      oopljs, _, _, _ = test.cachedInfo(basel='javascript')
      ooplcc, _, _, _ = test.cachedInfo(basel='cpp')

      cc_any = metax.oopl.OoplCpp.CC_ANY
      cc_str = metax.oopl.OoplCpp.CC_STR
      cc_strview = metax.oopl.OoplCpp.CC_STRVIEW
      cc_str_value = metax.oopl.OoplCpp.CC_STR_VALUE

      oomap = {
        'py': ooplpy.typeToBase,
        'js': oopljs.typeToBase,
        'cc': ooplcc.typeToBase,
      }

      for item in (
        {'type': 'int', 'py': 'int', 'js': '!number', 'cc': 'int32_t'},
        {'type': '*demo.cards2.Card',
         'py': 'demo.cards2.Card',
         'js': '?demo.cards2.Card',
         'cc': 'demo::cards2::Card*',
        },
        {'type': 'any', 'py': 'any', 'js': '?*', 'cc': cc_any + '*'},
        {'type': '*any', 'py': 'any', 'js': '?*', 'cc': cc_any + '*'},
        {'type': '&any', 'py': 'any', 'js': '!*', 'cc': cc_any + '&'},
        {'type': '@any', 'py': 'any', 'js': '!*', 'cc': cc_any},
        {'type': 'str', 'py': 'str', 'js': '?string', 'cc': cc_strview},
        {'type': '*str', 'py': 'str', 'js': '?string', 'cc': cc_strview},
        {'type': '&str', 'py': 'str', 'js': '!string', 'cc': cc_strview},
        {'type': '@str', 'py': 'str', 'js': '!string', 'cc': cc_strview},
        {'type': '&*str', 'py': 'str', 'js': '?string', 'cc': cc_strview},
        {'type': '@vec',
         'py': 'list',
         'js': '!Array.<?*>',
         'cc': 'std::vector<%s*>' % cc_any,
        },
        {'type': '@map',
         'py': 'dict',
         'js': '!Object.<!string,?*>',
         'cc': 'std::map<%s,%s*>' % (cc_strview, cc_any),
        },
        {'type': 'ostream',
         'py': 'file', 'js': '?Object', 'cc': 'std::ostream*',
        },
        {'type': '*#nm.sp.A',
         'py': 'nm.sp.A', 'js': '?nm.sp.A', 'cc': 'const nm::sp::A*',
        },
        {'type': '#*nm.sp.A',
         'py': 'nm.sp.A', 'js': '?nm.sp.A', 'cc': 'nm::sp::A*const',
        },
        {'type': '&nm.sp.A',
         'py': 'nm.sp.A', 'js': '!nm.sp.A', 'cc': 'nm::sp::A&',
        },
        {'type': '&#nm.sp.A',
         'py': 'nm.sp.A', 'js': '!nm.sp.A', 'cc': 'const nm::sp::A&',
        },
        {'type': '@vec<@str>',
         'py': 'list',
         'js': '!Array.<!string>',
         'cc': 'std::vector<%s>' % cc_strview,
        },
        {'type': 'vec<@str>',
         'py': 'list',
         'js': '?Array.<!string>',
         'cc': 'std::vector<%s>*' % cc_strview,
         'debug': False,
        },
        {'type': '#vec<@str>',
         'py': 'list',
         'js': '?Array.<!string>',
         'cc': 'const std::vector<%s>*' % cc_strview,
         'debug': False,
        },
        {'type': '@pair<int,int>',
         'py': 'tuple',
         'js': '!Array.<?*>',
         'cc': 'std::pair<int32_t,int32_t>',
        },
        {'type': '@pair<@map,@str>',
         'py': 'tuple',
         'js': '!Array.<?*>',
         'cc': 'std::pair<std::map<%s,%s*>,%s>' % (cc_strview, cc_any, cc_strview),
        },
      ):
        metastr = item['type']
        try:
          metatype = metax.c.Type.Instance(metastr)
        except metax.c.Error as e:
          self.fail('Type "%s" raises exception: %s' % (metastr, e))
        else:
          debug = item.get('debug', False)
          for bl in sorted(oomap):
            base = oomap[bl](metatype, debug=debug)
            expected = item[bl]
            test.iseq(
              item[bl], base,
              'baselang %s for %s\n  expected: %s\n  computed: %s' %
              (bl, metastr, expected, base))

      test.iseq(
        '?nm.sp.A',
        oopljs.typeToBase(metax.c.Type.Instance('nm.sp.A'), defqn=True))
      test.iseq(
        '?Array.<?nm.sp.A>',
        oopljs.typeToBase(metax.c.Type.Instance('vec<nm.sp.A>'), defqn=True))
    end method typeToBase;

    method _compileExprAttr : tuple<str,Type> #:
      Service routine for compiling an 'expr'-typed attribute.

      Any attribute that is typed as 'expr' can be passed to this method to
      obtain the baselang-specific code representing the expr. Errors are added
      to metafile for various issues (and None returned), otherwise the result
      is baselang code representing the expression.

      Returns:
       0. The baselang code representing the expr. Returns None if exprattr is
          None.
       1. The meta type of the expr.
    params:
      var metafile : MetaFile #:
        Where to report errors.
      var exprattr : metax.attr.ExprAttribute #:
        The expr attribute.  If None, returns None.
      var default : any = null #:
        What to return if exprattr is None
      var legal : vec<str> = null #:
        The enumerable of legal expr kinds allowed.
      var paren : bool = false #:
        If True, the expr is expected to be parenthezied.
      var executable : metax.oopl.ExecutableConstruct = null #:
        The context within which this expr is being compiled.  Used in order
        to establish type of result from type analysis.
      var typecheck : bool = true #:
        If False, do not typecheck.
    scope:
      result = default
      metatype = None
      if exprattr:
        result, metatype = exprattr.getCompilationResults()
        if result is None:
          expr = exprattr.value()
          linenum = exprattr.line()
          data = expr.data()
          if paren and data['kind'] not in ('plist', 'arglist'):
            metafile.error('Expecting parenthesized expr', line=linenum)
          else:
            /# If data represents an arglist, it should only have one element.
            error = False
            while data['kind'] in ('plist', 'arglist'):
              parts = data['expr']
              if len(parts) != 1:
                metafile.error(
                  'Expecting one expr, not %d' % len(parts), line=linenum)
                error = True
              else:
                data = parts[0]
            if not error:
              kind = data['kind']
              if legal and kind not in legal:
                metafile.error('Expecting a callsite or variable, not %s' % kind)
              else:
                /# We record the line number in metafile first.
                metafile.setLineNum(exprattr.line(), STATE_COMPILE)
                /# Compile the expression.
                result, metatype = self.compileExpr(
                  data, metafile, executable=executable)
                /# Cache the compilation results so that subsequent invocations are
                /# fast.  TODO(wmh): How often is the same exprattr compiled? Is
                /# the savings in time (if any) worth the increase in memory?
                exprattr.cacheCompilationResults(result, metatype)
      return result, metatype
    end method _compileExprAttr;

    method compileExpr : tuple<str,Type> #:
      Compile an Expr instance into a baselang.

      Returns:
       0. the baselang code representing the expression
       1. the meta type of the expression.
    params:
      var expr : any #:
        The expr to compile. If it is an Expr, expr.data() should return
        the already-parsed dict.  If it is a dict, that dict is the pre-parsed
        data.
      var metafile : MetaFile #:
        The meta file being parsed/compiled.
      var executable : metax.oopl.ExecutableConstruct = null #:
        The context within which this expr is being compiled.  Used in order
        to establish type of result from type analysis.
        TODO(wmh): This should probably be renamed to symbol_construct of type
        SymbolConstruct ... for vars it will be a MethodConstruct, but for
        fields it will be a ClassConstruct.
      var typecheck : bool = true #:
        If False, do not typecheck, even if executable is provided.
        Useful for disabling certain warnings.
      var indent : str = '' #:
        What to insert before each line (except first??)
    scope:
      lines = ['']
      metatype = self._compileExpr(
        expr, metafile, lines,
        indent=indent, executable=executable, typecheck=typecheck)
      return '\n'.join(lines), metatype
    test:
      def Chk(expected_code, expected_type, pair):
        code, mtype = pair
        test.iseq(expected_code, code)
        if expected_type is None:
          test.isnull(mtype)
        elif isinstance(expected_type, list):
          for i, etype in enumerate(expected_type):
            mt = mtype[i]
            if mt is None:
              test.isnull(mt)
            else:
              test.iseq(etype, mt.raw())
        else:
          test.iseq(expected_type, mtype.raw())

      ooplpy, _, context, compiler = test.cachedInfo(basel='python')
      metafile = metax.c.MetaFile('/faux/path', compiler, '\n')

      expr_true = metax.c.ExprParser(test.metafileFor('true\n')).parse()
      Chk('True', 'bool', ooplpy.compileExpr(expr_true, metafile))

      expr_null = metax.c.ExprParser(test.metafileFor('null\n')).parse()
      Chk('None', 'meta.Null', ooplpy.compileExpr(expr_null, metafile))

      expr_one = metax.c.ExprParser(test.metafileFor('1\n')).parse()
      Chk('1', 'uint', ooplpy.compileExpr(expr_one, metafile))

      expr_var = metax.c.ExprParser(test.metafileFor('apple\n')).parse()
      Chk('apple', None, ooplpy.compileExpr(expr_var, metafile))

      expr_params = metax.c.ExprParser(test.metafileFor('(a, b=1)\n')).parse()
      Chk('(a, b=1)', [None, None], ooplpy.compileExpr(expr_params, metafile))

      expr_list = metax.c.ExprParser(
        test.metafileFor('[false, true, null, 1, a]\n')).parse()
      Chk('[\n  False,\n  True,\n  None,\n  1,\n  a,\n]',
          'vec', ooplpy.compileExpr(expr_list, metafile))

      expr_map = metax.c.ExprParser(
        test.metafileFor("{'a': false, 'b': true, 'c': a}\n")).parse()
      Chk("{\n  'a' : False,\n  'b' : True,\n  'c' : a,\n}", 'map',
          ooplpy.compileExpr(expr_map, metafile))
    end method compileExpr;

    method _compileExpr : Type #:
      Compile an Expr instance into a baselang.

      Returns: Type
        The meta type of the expression.  None if no type could be established.
    params:
      var expr : any #:
        The expr to compile. If it is an Expr, expr.value() is the data. If it
        is a dict, that dict is the pre-parsed data. 
        TODO(wmh): Can this ever be a dict in this new code?
      var metafile : MetaFile #:
        The meta file being parsed/compiled.
      var lines : vec<str>;
      var indent : str = '';
      var executable : metax.oopl.ExecutableConstruct = null #:
        The context within which this expr is being compiled.  Used in order
        to establish type of result from type analysis.
      var typecheck : bool = true #:
        If False, do not typecheck, even if executable is provided.
        Useful for disabling certain warnings.
    scope:
      /# caller should set lineno before invoking _compileExpr!
      lnum = metafile.lnum()
      numerrs = metafile.numErrors()
      metatype = None
      basel = self.id()
      kind = expr.kind()

      if kind == 'num':
        /# The representation of numbers is pretty consistent across languages.
        /# In Meta, the legal syntax for a number matches that in json, which
        /# should be valid in all baselangs.
        /# TODO(wmh): Do we want to support Perl's 100_000 syntax?
        /#
        /# For now, meta literal numbers are valid in all baselangs.
        /# We use the verbatim str value provided by the user (data['str'])
        /# rather than the int/float available in data['expr'] to maintain
        /# scientific notation.
        numval = expr.value()
        lines[-1] += str(numval)

        /# The metatype is int<?>, uint<?>, or real<?>, depending on exact value.
        /# TODO(wmh): We can do a better job of establishing an exact parameter
        /# value. For now, we just return int, uint or double.
        if isinstance(numval, int):
          tstr = 'int' if numval < 0 else 'uint'
        else:
          tstr = 'double'
        if typecheck:
          metatype = metax.c.Type.Instance(tstr)

      elif kind == 'str':
        /# A string literal is always quoted in the Meta source
        /#  - In C++ and Java, strings must always use double quotes.
        /#  - Python and Javascript, double or single quotes are fine (use
        /#    whatever user provided in source.
        /#  - Perl allows interpolation within double quoted strings and
        /#    doesn't do interpolation within single-quoted strings.
        strlit = expr.value()
        if basel in ('cpp', 'java'):
          result = expr.asStr(quote=True, delim='\"')
          /# print '******** basel=%s str expr="%s"' % (basel, result)
        elif basel in ('python', 'javascript'):
          result = expr.asStr(quote=True)
        elif basel == 'perl':
          /# TODO(wmh): Clean this up.
          result = expr.asStr(quote=True)
        else:
          raise metax.c.Error('Provide implementation of str literals in %s' % basel)
        lines[-1] += result
        if typecheck:
          metatype = metax.c.Type.Instance('&str')

      elif kind == 'var':
        /# This is just an identifier.
        /# TODO(wmh): Rename 'var' to 'id'.
        /#
        /# There are some special values that look like identifiers that are to
        /# be treated differently (e.g. self, true, false, null, ...). Any key
        /# in BaseLanguageOopl.PseudoVars() is mapped to an associated value.
        /#
        /# Also, if data contains a 'default' key (another full expr), this
        /# overall expression is presumably part of a parameter list with a
        /# default value, and the compiled version of the default value is added
        /# to the result.
        /#
        /# For a var Expr
        /#   kind: 'var'
        /#   expr: the meta-level variable (an identifier)
        /#   str: the meta-level variable (an identifier)
        varname = expr.value()
        result, metatype = self.analyzeVariable(varname, executable=executable)
        if not metatype and typecheck:
          /# metafile.info('Failed to type var %s' % varname, line=lnum)
          pass

        /# Handle the special 'default' key, which exists for 'var' expressions
        /# with default values.
        default = expr.default()
        if default is not None:
          defcode, deftype = self.compileExpr(
            default, metafile, executable=executable)
          result += '=' + defcode

        lines[-1] += result

      elif kind == 'op':
        /# TODO(wmh): Currently blindly dumping verbatim operators, but we
        /# need to do type analysis on lhs, establish the operators defined on
        /# that type, and map the operator to the baselang specific syntax
        /# (which may or may not be an actual operator).
        metatype = None
        expr = data['expr']

        lhs_code, lhs_type = self.compileExpr(
          expr['lhs'], metafile, executable=executable, typecheck=typecheck)
        rhs_code, rhs_type = self.compileExpr(
          expr['rhs'], metafile, executable=executable, typecheck=typecheck)

        opname = expr['op']
        baselang_syntax = '%(lhs)s %(op)s %(rhs)s'
        lines[-1] += baselang_syntax % (
          {'lhs': lhs_code, 'op': opname, 'rhs': rhs_code})

      elif kind == 'call':
        /# A call site. The value() dict is:
        /#   rec: receiver of call
        /#   subcalls: list of dict
        /#     name: name of method or field to invoke on current receiver.
        /#     field: boolean true means field access (if not present, method call)
        /#     args: list of dict
        /#       same structure as 'data' itself
        val = expr.value()
        rec = val['rec']
        subcalls = val['subcalls']
        subcall_index = 0

        /# Establish the baselang receiver and its type.
        recstr, metatype = self.analyzeVariable(rec, executable=executable)

        /# TODO(wmh): This code is currently broken ... fix it!
        print 'HERE with recstr=%s metatype=%s' % (recstr, metatype)
        print '#' * 70
        print metafile.path()
        print expr
        print executable.kindfqn()
        print executable.primary().line()
        print '#' * 70

        if metatype:
          rec = recstr

        else:
          /# It is possible that 'rec' is the name of a top-level namespace,
          /# and that we are attempting to access some method or field within
          /# a non-local namespace or class.
          filecons = metafile.construct()
          namespace = filecons.symbol(rec)
          if namespace:
            /# TODO(wmh): Define meta!namespace as shorthand for
            /# meta.lang.Namespace, and implement that class. Each namespace
            /# results in an auto-generated singleton class being defined within
            /# the namespace, with a single instance that provides first-class
            /# object status to namespaces. It will also be where namespace-level
            /# variables will be implemented in languages that do not support them
            /# directly.
            construct = namespace
            for i in range(0, len(subcalls)):
              subcall = subcalls[i]
              subvar = subcall['name']
              /# print 'Looking for %s (%s)' % (subvar, subcall)
              /#construct.showSymbols()
              child = construct.symbol(subvar)
              if not child:
                break
              elif child.isnamespace():
                /# we continue iterating thru subcalls.
                construct = child
                subcall_index = i + 1
                rec += '.' + subvar
                pass
              elif child.isclass():
                /# We've reached a point where subsequent subcalls should be
                /# processed as method invocations or field accesses, using
                /# child as the executable.
                subcall_index = i + 1
                executable = child
                rec += '.' + subvar
                /#print 'HERE with %s' % child.kindfqn()
                /#child.showSymbols()
                metatype = child.implicitType()
                /#print subcalls[subcall_index:]
                /#print metatype
                break
              else:
                raise metax.c.Error('Unexpected %s' % child.kindfqn())

          if not metatype and typecheck:
            metafile.warning(
              'Failed to establish a type for receiver "%s"' % recstr, line=lnum)
            global DC
            DC += 1
            if DC > 10:
              raise metax.c.Error('here')
            /# print 'Here with %s and %s' % (executable.kindfqn() if executable else executable, rec)
            if executable:
              executable.showSymbols()

        /#print 'Here with receiver %s : %s' % (rec, metatype)

        /# Now process the cascading call-sites.
        /#  - update what the receiver looks like, in 'rec'
        /#  - maintain the metatype of the receiver
        /#  - typecheck arguments
        for subcall in subcalls[subcall_index:]:
          is_field = subcall.get('field', False)
          argsdata = subcall.get('args', None)

          /# First, we establish the separator that appears between the receiver
          /# and the method/field.
          /#  - almost always '.'
          /#  - in C++ and Perl, is '->' if the receiver is a ptr type
          sep = '.'
          if basel in ('python', 'cpp'):
            /# If metatype is pointer type.
            if False:
              sep = '->'

          /# Establish the field/method name
          /#  - note that for field access, it is the raw field name, which is
          /#    highly discouraged in Meta except for public raw fields.
          /#  - this name may be changed (later, when we do type analysis), if
          /#    the receiver is a native type.
          name = subcall['name']

          /# Now process the args.
          /#  - Each element of argsdata is a dict suitable for passing into a
          /#    recursive call to _compileExpr.
          if is_field:
            /# For a field, there are two possibilities:
            /#  - an arglist with exactly one arg, representing a request to set
            /#    the field to a given value.
            /#  - no arglist, which is a request to get the value of a field.
            /#     - the return value of a getter is the type of the field being
            /#       gotten.
            /#  - note that if the receiver is a native type, no field access
            /#    is allowed (the native interface is method-only).
            if argsdata:
              if len(argsdata) != 1:
                raise metax.c.Error('bad!')
              /# We have a field assignment request.
              /#  - there can be no further subcalls, since we need to return
              /#    a single baselang statement (TODO(wmh): maybe in some
              /#    baselangs we can assign and proceed in the same statement?
              /#    Also, are we sure that we have to return a single statement?
              /#    Maybe that is too limiting (oh ... but this will often be the
              /#    rhs or an arg to a method invocation, so yeah, almost certainly
              /#    needs to be a single statement).
              valcode, valtype = self.compileExpr(
                argsdata[0], metafile, executable=executable)
              callcode = name + ' = ' + valcode

              /# NOTE: Do NOT need to update the current receiver type 'metatype'
              /#  - the return value of a setter (at least one generated by
              /#    Meta) is the receiver, so the return type after is the same
              /#    as the return type before.
              /#  - No updates needed normally, but what if a person overrides a
              /#    getter/setter with an explicit method? (note that if they
              /#    override via the field 'scope' block they have no ability to
              /#    change the return type and self is implicitly returned if they
              /#    don't do it themselves.
              /#  - Overriding of getters via explicit method is disallowed by
              /#    the unique-id-per-scope rule, but one could override fieldIs()
              /#    or fieldRef()
              /#  - TODO(wmh): explicitly disallow overriding of field accessors
              /#    via 'method' constructs!

              /# TODO(wmh): enforce no subcalls after field set elsewhere!

            else:
              /# We have a field access request. No args.
              callcode = name

              /# TODO(wmh): Update the rectype ... the type of the field being
              /# accessed.
              if typecheck:
                /# Note that rectype will be None if no type info was found.
                metatype = self.typecheckField(metafile, metatype, name)

            rec += sep + callcode

          else:
            /# For a method, we just process each arg.
            /#  - Note that meta doesn't require () for no-arg method invocations,
            /#    but baselangs do.
            /#     - In C++, this->f returns a pointer to the function, and
            /#       this->f() invokes the function.
            /#     - In Meta, this!f returns a pointer to the function, and
            /#       this.f (and this.f()) invokes the function.
            args = []
            if argsdata:
              for argdata in argsdata:
                argcode, argtype = self.compileExpr(
                  argdata, metafile, executable=executable)
                args.append(argcode)

            /# Establish the method name/type.
            /#  - note that for field access, it is the raw field name, which is
            /#    highly discouraged in Meta except for public raw fields.
            /#  - we perform type analysis to establish the legality of the given
            /#    name (and to convert native-type names to baselang equivalents)
            name = subcall['name']
            if typecheck and metatype:
              /# We have enough info to do type analysis on the requested
              /# method invocation ... maybe.
              rec, metatype = self.compileMethodInvocation(
                metafile, rec, metatype, name, args)
              /# print 'FOUND return type "%s" [%s]' % (str(metatype), metatype.raw())
            else:
              /# Without typechecking (or without a receiver type), we cannot
              /# handle native-type method renaming, so the following code is
              /# very likely to be incorrect.
              metatype = None
              callcode = name + '(' + ', '.join(args) + ')'
              rec += sep + name + '(' + ', '.join(args) + ')'
            /# TODO(wmh): Update the rectype ... the return type of the method

        lines[-1] += rec

      elif kind == 'hash':
        metatype = self._compileHash(
          expr, metafile, lines,
          indent=indent, executable=executable, typecheck=typecheck)

      elif kind == 'list':
        metatype = self._compileList(
          expr, metafile, lines,
          indent=indent, executable=executable, typecheck=typecheck)

      elif kind == 'plist':
        /# An parenthesized list.
        /# The value is a list of Expr.
        parts = []
        metatype = []
        for argexpr in expr.value():
          argcode, argtype = self.compileExpr(argexpr, metafile, executable=executable)
          parts.append(argcode)
          metatype.append(argtype)
        lines[-1] += '(' + ', '.join(parts) + ')'

      else:
        raise metax.c.Error('Invalid expr kind "%s"' % kind)

      if metafile.numErrors() > numerrs:
        print 'WARNING: Ignoring _compileExpr result due to errors'
        result = None

      return metatype
    test:
      /# Tested in compileExpr().  Do we need more tests?
      pass
    end method _compileExpr;

    method _compileHash : str #:
      Compile a literal hash into python syntax.

      Returns:
        The baselang syntax representing this expr.
    params:
      var expr : Expr #:
        An Expr of kind 'hash'
      var metafile : MetaFile;
      var lines : vec<str> #:
        Where to write the output.
      var indent : str = '';
      var executable : metax.oopl.ExecutableConstruct = null;
      var typecheck : bool = true;
    scope:
      /# The 'indent' variable represents the amount of indentation to put
      /# before the closing '}' and should match the amount of indentation
      /# present on lines[-1] at the beginning of this method.  Each
      /# key/value pair is placed on a separate line indented by subindent.
      assert expr.kind() == 'hash'
      data = expr.value()
      keytypes = []
      valtypes = []
      subindent = indent + '  '
      lines[-1] += '{'
      lines.append(indent)
      for keyexpr, valexpr in data:
        lines[-1] += '  '
        keytype = self._compileExpr(
          keyexpr, metafile, lines,
          indent=subindent, executable=executable, typecheck=typecheck)
        keytypes.append(keytype)
        lines[-1] += ' : '
        valtype = self._compileExpr(
          valexpr, metafile, lines,
          indent=subindent, executable=executable, typecheck=typecheck)
        valtypes.append(valtype)
        lines[-1] += ','
        lines.append(indent)
      lines[-1] += '}'
      /# TODO(wmh): Analyze keytypes and valtypes to determine if there
      /# is consistency amongst them. If the keys are all the same type K,
      /# and the values are all the same type V, we can return type
      /# map<K,V>. If either keytypes or valtypes is multi-typed, we can
      /# use 'any' or a disjunctive type.
      metatype = metax.c.Type.Instance('map')
      return metatype
    test:
      /# Tested in compileExpr().  Do we need more tests?
      pass
    end method _compileHash;

    method _compileList : str #:
      Compile a literal list into python syntax.

      Returns: str
        The baselang syntax representing this expr.
    params:
      var expr : Expr #:
        An Expr of kind 'list'.
      var metafile : MetaFile;
      var lines : vec<str> #:
        Where to write the output.
      var indent : str = '';
      var executable : metax.oopl.ExecutableConstruct = null;
      var typecheck : bool = true;
    scope:
      /# The 'indent' variable represents the amount of indentation to put
      /# before the closing ']' and should match the amount of indentation
      /# present on lines[-1] at the beginning of this method.  Each
      /# value is placed on a separate line indented by subindent.
      assert expr.kind() == 'list'
      data = expr.value()
      valtypes = []
      subindent = indent + '  '
      lines[-1] += '['
      lines.append(indent)
      for valexpr in data:
        lines[-1] += '  '
        valtype = self._compileExpr(
          valexpr, metafile, lines,
          indent=subindent, executable=executable, typecheck=typecheck)
        valtypes.append(valtype)
        lines[-1] += ','
        lines.append(indent)
      lines[-1] += ']'
      /# TODO(wmh): Analyze valtypes to determine if there is consistency
      /# amongst them.  If they are all the same type T, we can return a
      /# metatype of type 'vec<T>', else 'vec<any>' aka 'vec'
      metatype = metax.c.Type.Instance('vec')
      return metatype
    test:
      /# Tested in compileExpr().  Do we need more tests?
      pass
    end method _compileList;

    method analyzeVariable : tuple<str,Type> #:
      Identify the baselang representation for a varname (and its metatype).

      Also handles pseudo vars like 'true', 'self', 'out', etc.

      Returns: tuple<str,Type>
       0. the baselang representation of the variable
       1. the meta-level Type instance of the variable. None means unable to type.
    params:
      var varname : str;
      var executable : metax.oopl.ExecutableConstruct = null;
    scope:
      basestr = self.pseudovars().get(varname, None)
      if basestr:
        /# We have a pseudovar, and basestr is the baselang representation.
        result = basestr
        /# The metatype of this special identifier is stored in
        /# BaseLanguageOopl.PseudoVars(). Note that this code intentionally
        /# assumes the key exists in PseudoVars() as a forcing function to keep
        /# PseudoVars() in sync with pseudovars().
        cls = self.__class__
        metatype = cls.PseudoVars()[varname]
        if metatype is metax.c.SELF:
          /# Special indicator that the type matches that of the receiver.
          if executable:
            myclass = executable.myclass()
            metatype = myclass.typeOfSelf(dothis=(varname=='this'))
          else:
            metatype = None
            /# print 'Warning: no executable - cannot currently identify type of self'
        /# print 'In analyzeVariable, varname=%s basestr=%s metatype=%s' % (varname, basestr, metatype)
      else:
        /# We have a variable reference.  It must be one of the variables
        /# available in the current lexical context.
        result = varname
        metatype = executable.establishType(varname) if executable else None
      return result, metatype
    test:
      def Chk(expected_varname, expected_type, pair):
        varname, mtype = pair
        test.iseq(expected_varname, varname)
        test.iseq(expected_type, mtype.raw())

      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      filec = metax.meta.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.oopl.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.oopl.ClassConstruct.NewFromData(
        'Card', context, parent=namespace.attr('scope:'),
        secondaries=[('scope:', [])])
      method = metax.oopl.MethodConstruct.NewFromData(
        'f', context, parent=klass.attr('scope:'))
      method.myclassIs(klass)

      Chk('True', 'bool', ooplpy.analyzeVariable('true', executable=method))
      Chk('False', 'bool', ooplpy.analyzeVariable('false', executable=method))
      Chk('None', 'meta.Null', ooplpy.analyzeVariable('null', executable=method))
      Chk(metax.c.metax.c.SELF, '&nm.sp.Card', ooplpy.analyzeVariable('self', executable=method))
    end method analyzeVariable;

    method initCode #:
      Write baselang code to initialize all uninitialized fields in preamble
    params:
      var method : metax.oopl.ExecutableConstruct #:
        The method for which super code is desired.
      var output : vec<str> #:
        Where to append lines of baselang code representing the super-call.
    scope:
      metafile = method.metafile()
      stmtend = self.config('stmtend')
      recsepstr = self.receiverStr(method, style='base', sep=True)

      myclass = method.myclass()
      initmap = self.analyzeExecutableForFields(method)
      scope_attr = method.attr('scope:', default=None)
      attrkind = method.attrval('kind')
      basel = self.baselang().id()
      params = method.parsedParams()
      fieldmap = params.get('fields', {})

      for field in myclass.fields():
        fid = field.id()
        metatype = field.attrval('type')
        fkind = field.attrval('kind')

        /# We first see if the field exists in fieldmap
        /#  - if in fieldmap, we have a syntactic request to initialize a field
        /#    from a parameter.
        defval = fieldmap.get(fid, None)
        if defval is None:
          /# TODO(wmh): Should we do LOOKUP on 'default' to get '<special>', or
          /# set it to null here?
          default = field.attrval('default', default=None)
          /# defval_old = self.formatExpr(default, metatype, field)
          if default:
            defval, resmtype = self.compileExpr(
              default, metafile, method, indent='    ')
            /# print '**** HERE with %s = %s' % (field.kindfqn(), defval)
          else:
            defval = self.defaultValue(metatype)
        if fkind == 'static':
          /# Static fields are not initialized in initializers. They are handled
          /# on a per-baselang basis in FieldConstruct.translateMeta(),
          /# *Oopl.formatFieldDefintiion(), etc.
          pass
        elif fid in initmap:
          /# There is an explicit initialization of this field in the
          /# user-provided code, so we do NOT provide a default initialization.
          fval = initmap[fid]
          /# print 'HERE with %s and %s = %s = %s' % (method.fqn(), fid, fval, defval)
          if fval == defval:
            metafile.warning(
              'Explicit initalization of %s to %s not necessary (is default)' %
              (fid, defval), attr=scope_attr)
        elif basel == 'cpp' and metatype.isValue() and not metatype.isPrimitive():
          /# There is no need to initialize the field, because C++ has already
          /# invoked a constructor on the field class to initialize the field
          /# before this method was entered.
          /# print 'Skipping %s = %s' % (field.rawfield(), defval)
          pass
        else:
          code = '%s%s = %s%s' % (recsepstr, field.rawfield(), defval, stmtend)
          output.append(code)

      /# If this class has any packed fields, the underlying packs are
      /# initialized to value 0. Furthermore, a method that efficiently
      /# extracts all values within each pack is auto-generated.
      packed = myclass.packed()
      if packed:
        for pack in packed:
          rawpack = '_' + pack
          code = '%s%s = 0%s' % (recsepstr, rawpack, stmtend)
          output.append(code)
    test:
      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      metafile = test.parserFor('Oopl', '')
      filec = metax.meta.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.oopl.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.oopl.ClassConstruct.NewFromData(
        'Card', context, parent=namespace.attr('scope:'),
        secondaries=[('scope:', [])])
      method = metax.oopl.MethodConstruct.NewFromData(
        '__init__', context, parent=klass.attr('scope:'),
        secondaries=[('scope:', [])])
    end method initCode;

    method analyzeExecutableForFields : map #:
      Analyze an executable (simple) block looking for explicit field references.

      Returns:
        Mapping from fieldname to value.
        Will be empty if the scope: of the executable is complex.
    params:
      var executable : metax.oopl.ExecutableConstruct #:
        The executable for which a receiver is desired.
    scope:
      initmap = {}
      stmtend = self.config('stmtend')

      location = executable.attrval('location')
      scope, lines = executable.attrpair('scope:', default=None)
      initmap = {}

      /# Look for field assignments in the source code.
      /#  - The user is always allowed to refer to receiver by baselang
      /#    syntax ('self.' in python, 'this->' in C++, etc.)
      /#  - The user may also refer to the receiver by a special meta-level
      /#    name, dictated by the 'location' of the method (user, test, meta)
      /#    and which always uses '.' to access methods/state.
      /#     - for location user the variable is self
      /#     - for location test the variable is test
      /#     - for location meta the variable is meta
      if scope and scope.isSimpleBlock():
        recs = set()
        baserec = self.receiverStr(
          executable, style='base', location=location, sep=True)
        recs.add(baserec)
        if baserec == 'this->':
          recs.add('(*this).')
        metarec = self.receiverStr(
          executable, style='meta', location=location, sep=True)
        recs.add(metarec)
        recstr = '|'.join([re.escape(rec) for rec in recs])

        /# print '%-12s  %s = %s' % (self.id(), location, recstr)

        fre = re.compile(
          /# Note that we only consider assignments that are NOT indented,
          /# as they are the only ones guaranteed to always be executed.
          /# For example, if we have the code:
          /#   if some_expr:
          /#     self._debug = True
          /# we cannot assume self._debug is always initialized, so we must
          /# provide a default initialization in the preamble.
          r'^'
          r'(?P<rec_op>' + recstr + ')'
          r'(?:'
          /# Intentionally not looking for statement terminator in case the
          /# value continues on next line (in which case <rawval> won't be
          /# fully correct but will at least detect the field initialization).
          r'(?P<rawfield>[a-zA-Z0-9_]+)\s*=\s*(?P<rawval>.*)'
          r'|'
          /# Intentionally not closing parenthesis in case it continues on
          /# next line (in which case <value> won't be fully correct but will
          /# at least detect the field initialization.
          r'(?P<field>[a-zA-Z0-9_]+)Is\s*\((?P<value>.*)'
          r')')
        for line in lines:
          m = fre.search(line)
          if m:
            /# print m.groupdict()
            rawfield = m.group('rawfield')
            if rawfield:
              /# CODETANGLE(fieldinit): See FieldConstruct.expandMeta(), which
              /# specifies how rawfields are formed from field names. 
              /# TODO(wmh): Generalize this code to use the 'field_prefix' and
              /# 'field_suffix' keys of Context.Tokens(). Make sure to handle
              /# public fields that do not make a difference between rawfield
              /# and field.
              fname = rawfield
              if fname[0] == '_':
                fname = fname[1:]
              fval = m.group('rawval').rstrip(stmtend).rstrip()
            else:
              fname = m.group('field')
              fval = re.sub(r's*\);?\s*$', '', m.group('value'))
            /# print 'LINE: %s [fname=%s fval=%s]' % (line, fname, fval)
            initmap[fname] = fval
      return initmap
    test:
      init_lines = [
        'self._py_js_cc = 1',
        'bob.c = 2',
        'self.pyjsccIs(21)',
        'this->cc = 7;',
        'this->cc2Is(8);',
        'meta._height = 183',
        'meta.weightIs(50);',
      ]

      def Chk(basel, location, expected):
        test.defineClassAndMethods(basel, init_lines=init_lines)
        baselang = test.baselang
        init = test.initializer
        location_attr = init.attr('location')
        assert location_attr.value() == 'user'
        try:
          location_attr.valueIs(location)
          test.iseq(expected, baselang.analyzeExecutableForFields(init))
        finally:
          location_attr.valueIs('user')

      Chk('py', 'user', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk('js', 'user', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk('cc', 'user', {'cc': '7', 'cc2': '8', 'pyjscc': '21', 'py_js_cc': '1'})

      Chk('py', 'meta', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk('js', 'meta', {'pyjscc': '21', 'py_js_cc': '1'})
      Chk('cc', 'meta', {'cc': '7', 'cc2': '8', 'pyjscc': '21', 'py_js_cc': '1'})

    end method analyzeExecutableForFields;

    method defaultValue : str #:
      The default value for a given metatype.
    params:
      var metatype : Type;
    scope:
      if metatype.isPtr():
        default = self.pseudovars()['null']
      elif metatype.isStr():
        /# Special handling.
        default = self.metabase(metatype.raw(), kind='default')
      elif metatype.isRef():
        raise metax.c.Error('No defaults for ref type %s' % metatype.raw())
      else:
        default = self.metabase(metatype.base(), kind='default')
      return default
    test:
      py, _, _, _ = test.cachedInfo(basel='python')
      MetaType = metax.c.Type.Instance
      test.iseq('0', py.defaultValue(MetaType('@int')))
      test.iseq('None', py.defaultValue(MetaType('*int')))
      test.iseq('0.0', py.defaultValue(MetaType('@double')))
      test.iseq('None', py.defaultValue(MetaType('*str')))
      test.iseq('None', py.defaultValue(MetaType('str')))
      test.iseq("''", py.defaultValue(MetaType('&str')))
      test.iseq("''", py.defaultValue(MetaType('@str')))
    end method defaultValue;

    method simpleToBase : vec<str> #:
      Given a SimpleBlock, return the contents converted to
      this baselang.
    params:
      var simple : metax.attr.SimpleBlock #:
        The block to convert. If null, method is a noop.
      var output : vec<str> = null #:
        Where to write output.  If not given, new list is returned.
      var comment : bool = false #:
        If true, each line added to output is preceeded by the baselang
        comment character (and meta comments are not escaped).
      var strip_comments : bool = false #:
        If true, any meta-level comment prefixes are simply removed, rather
        than being replaced with the base-lang comment prefix. Useful when
        obtaining the lines in a 'comment:' attribute in which lines have
        been explicitly (and unnecessarily) quoted.
      var strip_empty : bool = false #:
        If true, empty lines at the beginning and end of the block are
        removed.
      var replace_receiver : bool = false #:
        If true, replace meta-level receiver variables with baselang version.
    scope:
      if output is None:
        output = []
      rem = '' if strip_comments else self.config('rem')
      if simple is None:
        pass
      elif comment:
        /# We are to add the content of simple preceeded by baselang comments.
        if rem:
          rem += ' '
        for line in simple.value():
          output.append(rem + line)
      else:
        /# We perform a small set of rewrites on the user-provided data.
        /#  - '^ */# ' is replaced with baselang comment one-line comment
        /#  - meta-level receiver replaced with baselang receiver.
        /#     - must be careful not to replace things that aren't receivers!
        /#     - to do a truly safe job, will need to parse the baselang,
        /#       but for now we use a heuristic.
        /#  - replace __metafile__ with the absolute path of the .meta file
        /#    that the __metafile__ is found within.
        /#  - IMPORTANT: The replacement of '^ *>|' with '' does NOT occur
        /#    here
        parent = simple.parent()
        if replace_receiver and isinstance(parent, metax.oopl.ExecutableConstruct):
          baserec = self.receiverStr(parent, deref=True)
          metarec = self.receiverStr(parent, style='meta')
          /# This regexp is carefully crafted to avoid grabbing non-receivers:
          /#  - the basics: don't replace inside another variable
          /#  - a bit more subtle: do not replace '.test.var' ... that is NOT
          /#    the 'test' receiver.
          /#  - TODO(wmh): avoid replacing within string literals!
          recre = re.compile(r'(^|[^a-zA-Z0-9_.])%s\.' % metarec)
          replacement = r'\1%s.' % baserec
          /# print 'For %s base=%s meta=%s auto=%s repl=%s' % (parent.kindfqn(), baserec, metarec, parent.autogen(), replacement)
        else:
          recre = None

        comre = re.compile(
          r'^( *)%s( ?)(.*)' % re.escape(metax.c.Context.Tokens()['remark']))
        lines = simple.value()
        s = 0
        e = len(lines)
        if strip_empty:
          while s < e and not lines[s].strip():
            s += 1
          while e > 0 and not lines[e-1].strip():
            e -= 1

        /#metac = metafile.compiler()
        /#fs = metac.fs()
        metafile = simple.parent().metafile()
        metafile_str = "'" + metafile.path() + "'"

        for i in range(s, e):
          line = lines[i]
          line = line.replace('__meta' + 'file__', metafile_str)
          m = comre.match(line)
          if m:
            line = m.group(1) + rem + ('' if strip_comments else m.group(2)) + m.group(3)
          if recre:
            line = recre.sub(replacement, line)
          output.append(line)
      return output
    test:
    end method simpleToBase;

    method formatBuildRule : str #:
      Form a BUILD rule from data.

      Returns:
        A multi-line string representing a BUILD target definition.
    params:
      var rule : str #:
        The name of the BUILD rule to generate.
        Example: cc_library, cc_test, java_test, etc.
      var data : map #:
        See, for example, http://www.bazel.io/docs/be/c-cpp.html.
    scope:
      lines = [rule + '(']
      k = set(data)
      keys = []
      for key in ('name', 'main', 'srcs', 'hdrs', 'data', 'deps', 'tests'):
        if key in data:
          k.remove(key)
          keys.append(key)
      keys.extend(sorted(k))
      for key in keys:
        value = data[key]
        if isinstance(value, basestring):
          lines.append('  %s = "%s",' % (key, value))
        elif isinstance(value, int):
          lines.append('  %s = %d,' % (key, value))
        elif isinstance(value, (list, set)):
          /# TODO(wmh): This is a hack to get meta2 code working while using
          /# root.meta from meta1. When we have root.meta2 implemented we can
          /# remove this hackery
          if key == 'deps' and self.id() == 'python':
            for i in range(0, len(value)):
              m = re.match(r'//meta/([^:]+):.*', value[i])
              if m:
                value[i] = '//meta:%s' % m.group(1)
          /# End hackery

          if len(value) == 0:
            pass
          elif len(value) < 2:
            lines.append(
              '  %s = [%s],' %
              (key, ', '.join(["'%s'" % elem for elem in value])))
          else:
            lines.append('  %s = [' % key)
            for elem in value:
              lines.append('    "%s",' % elem)
            lines.append('  ],')
        else:
          raise metax.c.Error('Invalid build rule data value: %s' % str(value))
      lines.append(')')
      return '\n'.join(lines)
    end method formatBuildRule;

    method nameToBuildTarget : str #:
      Convert a name to BUILD target.
    params:
      var fqn : str #:
        The fully qualified  name to convert to a target.
        If null or empty, returns null.
      var lib : bool = false #:
        If true, the fqn is a namespace, not a class.
    scope:
      if fqn:
        parts = fqn.split(metax.c.Context.Tokens()['scope_sep'])
        if lib:
          last = parts[-1]
        else:
          last = parts.pop()
        target = '//' + '/'.join(parts) + ':' + last
      else:
        target = None
      return target
    test:
    end method nameToBuildTarget;

    method parseComment : tuple<metax.attr.SimpleBlock,map> #:
      Obtain and parse a comment.

      Almost every construct in Meta(Oopl) supports a simple-block 'comment:'
      secondary attribute. This method obtains the SimpleBlock and a parsed
      representation of the lines in it.

      Returns:
       0) The comment SimpleBlock
       1) A map containing:
         user: vec<str>
         returns: vec<str>
         actions: map
    params:
      var construct : Construct = null #:
        The construct whose comment is to be parsed. One of 'construct' or
        'attribute' must be provided.
      var attribute : metax.attr.SimpleBlock = null #:
        The SimpleBlock representing the comment. One of 'construct' or
        'attribute' must be provided.
      var parse_return : bool = false #:
        If true, look for a 'Returns:' section.
    scope:
      /# The comment simple block of an executable has the following structure:
      /#   <comment> ::-
      /#      <text> [<nl> 'Returns:' <return_text>]
      if not attribute:
        if not construct:
          raise metax.c.Error('Must provide either attribute or construct')
        attribute, lines = construct.attrpair('comment:', default=None)
      else:
        lines = attribute.value()

      userlines = []
      retlines = []
      specials = {}

      if lines:
        inret = False
        retstr = 'Returns:'
        prefix = metax.c.Context.Tokens()['remark'] + ' '
        spre = BaseLanguageOopl.SpecialRE()
        metafile = self.metafile()

        for i, line in enumerate(lines):
          if parse_return and line.startswith(retstr):
            t = line[len(retstr):]
            if t:
              /# We have found the 'Returns:' marker, so all subsequent lines
              /# go to retlines instead of userlines.
              metafile.error(
                'No text allowed after "Returns:"',
                line=attribute.line() + i)
              retlines.append(t)
            inret = True
          else:
            /# We remove meta-level comment prefixes from the comment.
            if line.startswith(prefix):
              line = line[len(prefix):]

            /# We check if the line matches a special control line.
            m = spre.match(line)
            if m:
              /# We found a special action line. It is consumed and the data
              /# stored in specials.
              action = m.group('action')
              if action in specials:
                metafile.error(
                  'Invalid repeat of special "%s"' % action,
                  line=attribute.line() + i)
              else:
                specials[action] = m.group('text')
            elif inret:
              retlines.append(line)
            else:
              userlines.append(line)

      data = {'user': userlines, 'special': specials}
      if parse_return:
        data['returns'] = retlines

      return (attribute, data)
    test:
    end method parseComment;

    remark #:
      The following are template methods that subclass must define. Each
      is defined by a behavior.

      accessorType(ftype:Type,acc:str):Type
      augmentVarset(construct:Construct,varset:VarSet)
      autogenStr(construct:ClassConstruct)
      autogenPrint(construct:ClassConstruct)
      autogenWrite(construct:ClassConstruct)
      autogenSize(construct:ClassConstruct):int
      buildPreambleText():str
      classSubPath(klass:ClassConstruct):str
      createBuildFragment(
        construct:Construct,targets:vec<str>,
        test:bool=false,name:str=null,src:str=null)
      emptyBlockCode(method:ExecutableConstruct,message:str=null):vec<str>
      finalizerName(klass:ClassConstruct):str
      formatClassConstruct(
        attribute:SimpleBlock,width:int=80,suppress:map=null):vec<str>
      formatClassType(metafile:MetaFile,cstr:str):str
      formatComment(comment:vec<str>,width:int=80):vec<str>
      formatDependencies(
        class_construct:ClassConstruct,
        triples:vec<tuple<str,str,str>>):tuple<vec<str>,vec<str>>
      formatDependency(
        class_construct:ClassConstruct,
        triples:vec<tuple<str,str,str>>,index:int):tuple<str,str>
      formatFieldDefinition(field:FieldConstruct):vec<str>
      formatMethodComment(construct:ExecutableConstruct,width:int=80):vec<str>
      formatParams(
        executable:ExecutableConstruct,
        preamble:vec<str>,decl:bool=false):vec<str>
      formatParentSpec(
        class_construct:ClassConstruct):tuple<str,tuple<str,str,str>>
      fqnToTarget(fqn)
      initializerName(klass:ClassConstruct):str
      metaMethodBody(metainst:str,metaclass:ClassConstruct):vec<str>
      parseBazelLog(logdata:str,tdata:map,debug:bool=false):any
      processTestOutput(stdout:str,stderr:str,cwd:str,namespace:str,...)
      repl()
      superCode(method:ExecutableConstruct,output:vec<str>,width:int=80):void
      _annotateBaseType(metatype:Type,basetype:str):str
    end;

  end class BaseLanguageOopl;

  class OoplPython < BaseLanguageOopl #:
    Functionality for compiling Meta(Oopl) code into Python.
  assocs:
    std assoc code;
  scope:

    lifecycle params:
      var id : str;
      var parent : metax.attr.ComplexBlock;
      var context : Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('python')
      self.nameIs('Python')
      self.suffixesIs(['py'])

      strptr = {
        'base': 'str', 'default': 'None',
        'format': lambda var: 'self.%s()' % var,
      }
      strref = {
        'base': 'str', 'default': "''",
      }
      self.metatypesIs({
        'bool': {
          'base': 'bool', 'default': 'False',
          'format': lambda var: 'str(' + var + ').lower()',
        },
        'char': {
          'base': 'str', 'default': "''",
          'format': lambda var: var,
        },
        'int': {
          'base': 'int', 'default': '0',
          'format': lambda var: "'%d' % " + var,
        },
        'uint': {
          'base': 'int', 'default': '0',
          'format': lambda var: "'%d' % " + var,
        },
        'real': {
          'base': 'float', 'default': '0.0',
          'format': lambda var: "'%g' % self." + var + '()',
        },
        'double': {
          'base': 'float', 'default': '0.0',
          'format': lambda var: "'%g' % self." + var + '()',
        },
        'float': {
          'base': 'float', 'default': '0.0',
          'format': lambda var: "'%g' % self." + var + '()',
        },
        /# The 'str' type has some special handling.
        /#   *str and str should be the same
        /#   &str should be a version that cannot be null
        /#   @str may be disallowed or will be same as &str.
        /#   (see BaseLanguageOopl.{typeToBase,metabase}).
        'str': strptr,
        '*str': strptr,
        '&str': strref,
        '@str': {'base': 'str', 'default': "''"},
        'string': {'base': 'str', 'default': 'None'},
        'vec': {'base': 'list', 'default': '[]'},
        'map': {'base': 'dict', 'default': '{}'},

        'ostream': {'base': 'file', 'default': 'sys.stdout'},
        'istream': {'base': 'file', 'default': 'sys.stdin'},
        'strstream': {'base': 'file', 'default': 'None'},

        /# TODO(wmh): Need a better means of specifying regexp class in python.
        'regexp': {'base': 're._pattern_type', 'default': 'None'},

        'nulltype': {'base': 'types.NoneType', 'default': 'None'},
        'class': {'base': 'type', 'default': 'None'},
        'method': {'base': 'types.MethodType', 'default': 'None'},
        'function': {'base': 'types.LambdaType', 'default': 'None'},

        /# How to handle 'void' is still being worked out.
        'void': {'base': 'void', 'default': None},

        'pair': {'base': 'tuple', 'default': 'tuple()'},
        'tuple': {'base': 'tuple', 'default': 'tuple()'},
      })

      /# https://docs.python.org/3/reference/lexical_analysis.html#keywords
      self.keywordsIs(
        /# import keyword; keyword.kwlist
        ['and', 'as', 'assert', 'break', 'class', 'continue',
         'def', 'del', 'elif', 'else', 'except', 'exec',
         'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is',
         'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try',
         'while', 'with', 'yield'])

      self.updateConfigs({
        'namespace_primary': True,
        'definition_separate': False,
        'rem': '#',
        'self': 'self',
        'cls': 'cls',
        'selfsep': '.',
        'staticsep': '.',
        'stmtend': '',

        'setup': {'name': 'setUp'},  # https://docs.python.org/2/library/unittest.html#test-cases
        'teardown': {'name': 'tearDown'},
        'clsetup': {'name': 'setUpClass', 'level': 'meta'},
        'clteardown': {'name': 'tearDownClass', 'level': 'meta'},
      })

      self.pseudovarsIs({
        'self': metax.c.SELF,
        'true': 'True',
        'false': 'False',
        'null': 'None',
        'nan': 'metax.root.NaN',
        /# TODO(wmh): Accumulate the values used across various baselangs and
        /# decide what should be used for stdin, stdout and stderr. Using
        /# 'in' and 'out', 'err' may be too ambiguous ... might be more
        /# readable to prefix with 'std' or something else.
        'out': 'sys.stdout',
        'in': 'sys.stdin',
        'err': 'sys.stderr',
      })
    setup:
      baselang, _, context, _ = self.cachedInfo(basel='python')
      self.baselang = baselang
      self.context = context
    end;

  end class OoplPython;

  class OoplJavascript < BaseLanguageOopl #:
    Functionality for compiling Meta(Oopl) code into Javascript

    References:
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
      https://www.nczonline.net/blog/2014/01/21/private-instance-members-with-weakmaps-in-javascript/
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
      http://javascriptissexy.com/oop-in-javascript-what-you-need-to-know/
      http://davidbcalhoun.com/2011/different-ways-of-defining-functions-in-javascript-this-is-madness/
      https://philipwalton.com/articles/implementing-private-and-protected-members-in-javascript/
      https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/

    Important:
      - When generating javascript code for method scope, keep the commentary
        from https://www.sitepoint.com/google-closure-how-not-to-write-javascript/
        in mind.
  assocs:
    std assoc subprocess;
  scope:

    lifecycle params:
      var id : str;
      var parent : metax.attr.ComplexBlock;
      var context : Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('javascript')
      self.nameIs('Javascript')
      self.suffixesIs(['js'])

      /# In javascript, which lacks static typing, this type mapping wouldn't
      /# usually be as important as in languages with static typing. However,
      /# because we are using Google Closure, which enforces static typing
      /# information more stringently than many statically typed languages,
      /# the mapping becomes quite important.
      /#
      /# See
      /#   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
      /#   https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System
      /#   https://developers.google.com/closure/compiler/docs/js-for-compiler
      strptr = {'base': 'string',  'default': 'null' }
      self.metatypesIs({
        'bool':   {'base': 'boolean', 'default': 'false'},
        'char':   {'base': 'str',     'default': "''"   },
        'int':    {'base': 'number',  'default': '0'    },
        'uint':   {'base': 'number',  'default': '0'    },
        'real':   {'base': 'number',  'default': '0.0'  },
        'float':  {'base': 'number',  'default': '0.0'  },
        'double': {'base': 'number',  'default': '0.0'  },
        /# The 'str' type has some special handling.
        /#   *str and str should be the same
        /#   &str should be a version that cannot be null
        /#   @str may be disallowed or will be same as &str.
        /#   (see BaseLanguageOopl.{typeToBase,metabase}).
        'str':    strptr,
        '*str':   strptr,
        '&str':   {'base': 'string',  'default': "''"   },
        '@str':   {'base': 'string',  'default': "''"   },
        'string': {'base': 'String',  'default': 'null' },
        'vec':    {'base': 'Array.<%(TV)s>',   'default': '[]'   },
        /# TODO(wmh): Need to distinguish between map (keys can be anything) and
        /# smap (keys are always strings).  The builtin Map class should be
        /# used instead of Object (and literal {} needs to be handled somehow).
        'map':    {'base': 'Object.<%(TK)s,%(TV)s>',  'default': '{}'   },
        'any':    {'base': '*', 'default': None},

        /# IO in Javascript ... via phantomjs 'fs' module?
        /#   http://phantomjs.org/api/fs/
        'ostream': {'base': 'Object', 'default': 'null'},
        'istream': {'base': 'Object', 'default': 'null'},
        'strstream': {'base': 'Object', 'default': 'null'},

        'regexp': {},

        /# https://www.w3schools.com/js/js_datatypes.asp
        'nulltype': {'base': 'Object', 'default': 'null'},
        'class': {'base': 'Object', 'default': 'null'},
        'method': {'base': 'Function', 'default': 'null'},
        'function': {'base': '(Function|string)', 'default': 'null'},
        /# NOTE(wmh): TestCase.raises() accepts a function, and closure is
        /# insisting it be (Function|string). I can easily imagine other
        /# variations on this, so we may need to generalize or hack.

        /# How to handle 'void' is still being worked out.
        'void': {'base': 'void', 'default': None},

        'pair':    {'base': 'Array.<?*>', 'default': '[]'},
        'tuple':   {'base': 'Array.<?*>', 'default': '[]'},
      })

      /# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Reserved_Words
      self.keywordsIs(
        [
          'break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete',
          'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof',
          'new', 'return', 'switch', 'this', 'throw', 'try', 'typeof', 'var',
          'void', 'while', 'with',
          /# future
          'class', 'enum', 'export', 'extends', 'import', 'super',
          /# future if strict
          'implements', 'interface', 'let', 'package', 'private', 'protected',
          'public', 'static', 'yield',
        ])

      self.updateConfigs({
        'namespace_primary': False,
        'definition_separate': False,
        'rem': '//',
        'self': 'this',
        'cls': 'this',
        'selfsep': '.',
        'staticsep': '.',
        'stmtend': ';',

        'setup': {'name': 'setUp', 'level': 'instance'},  # $CLOSURE_ROOT/library/closure/goog-orig/testing/testcase.js
        'clsetup': {'name': 'setUpPage', 'level': 'instance'},
        'teardown': {'name': 'tearDown', 'level': 'instance'},
        'clteardown': {'name': 'tearDownPage', 'level': 'instance'},

        /# specific to this baselang.
        'use_es2015': True,
      })

      self.pseudovarsIs({
        'self': metax.c.SELF,
        'true': 'true',
        'false': 'false',
        'null': 'null',
        'out': '?',
        'in': '?',
        'err': '?',
      })
    setup:
      baselang, _, context, _ = self.cachedInfo(basel='javascript')
      self.baselang = baselang
      self.context = context
    end;

    test
    method test_typeToBase scope:
      oopljs, _, context, _ = test.cachedInfo(basel='javascript')
      MetaType = metax.c.Type.Instance
      /# TODO(wmh): Decide how to deal with 'str'
      /#  - See notes in README.md in "Implementing interned string support".
      test.iseq('?string', oopljs.typeToBase(MetaType('str')))
      test.iseq('?string', oopljs.typeToBase(MetaType('*str')))
      test.iseq('!string', oopljs.typeToBase(MetaType('&str')))
      test.iseq('!string', oopljs.typeToBase(MetaType('@str')))
    end method;

  end class OoplJavascript;

  class OoplCpp < BaseLanguageOopl #:
    Functionality for compiling Meta(Oopl) code into C++

    Notes on Bazel:
     - For C++, Bazel uses a CROSSTOOL file to specify details about
       the C++ compiler and associated programs used to interact with
       the C++ code.
     - One can provide a custom toolchain, but it is currently non-trivial:
       - About the CROSSTOOL: https://github.com/bazelbuild/bazel/wiki/About-the-CROSSTOOL
       - Building with a custom toolchain: https://github.com/bazelbuild/bazel/wiki/Building-with-a-custom-toolchain
       - Generating C++ crosstool with a Skylark Remote Repository: https://bazel.build/designs/2016/02/16/cpp-autoconf.html
       - Using Skylark remote repositories to auto-detect the C++ toolchain: https://blog.bazel.build/2016/03/31/autoconfiguration.html
       - Yet Another CROSSTOOL Writing Tutorial: https://github.com/bazelbuild/bazel/wiki/Yet-Another-CROSSTOOL-Writing-Tutorial

    Documentation on CROSSTOOL:

  assocs:
    std assoc subprocess;
  scope:

    lifecycle params:
      var id : str;
      var parent : metax.attr.ComplexBlock;
      var context : Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    clinit:
      /# cls.CC_ANY = 'long long'
      cls.CC_ANY = 'void'
      /#cls.CC_STR = 'const std::string'
      /#cls.CC_STR_VALUE = 'std::string'
      cls.CC_STR = 'meta::str'
      cls.CC_STRVIEW = 'meta::strview'
      cls.CC_STR_VALUE = 'meta::str'
      cls.PTR_MAP = {
        'u': 'std::unique_ptr',
        's': 'std::shared_ptr',
        'w': 'std::weak_ptr',
      }
    scope:
      self.idIs('cpp')
      self.nameIs('C++')
      self.suffixesIs(['cc', 'h'])

      /# See
      /#  http://en.cppreference.com/w/cpp/language/types
      strptr = {'base': OoplCpp.CC_STR, 'default': 'nullptr'}
      strref = {'base': OoplCpp.CC_STR, 'default': 'meta::string()'}
      self.metatypesIs({
        'bool': {'base': 'bool', 'default': 'false'},
        'char': {'base': 'char', 'default': "''"},
        'int': {
           #  http://en.cppreference.com/w/cpp/types/integer
           0: True,
           8: {'base': 'int8_t',  'default': '0'},
          16: {'base': 'int16_t', 'default': '0'},
          32: {'base': 'int32_t', 'default': '0'},
          64: {'base': 'int64_t', 'default': '0'},
          None: {'base': 'int32_t', 'default': '0'},
        },
        'uint': {
          0: True,
          7: {'base': 'uint8_t', 'default': '0'},
          15: {'base': 'uint16_t', 'default': '0'},
          31: {'base': 'uint32_t', 'default': '0'},
          63: {'base': 'uint64_t', 'default': '0'},
          None: {'base': 'int', 'default': '0'},
        },
        'real': {
          0: True,
          32: {'base': 'float', 'default': '0.0'},
          64: {'base': 'double', 'default': '0.0'},
          80: {'base': 'long double', 'default': '0.0'},
          None: {'base': 'float', 'default': '0.0'},
        },
        /# The 'str' type has some special handling.
        /#   *str and str should be the same
        /#   &str should be a version that cannot be null
        /#   @str may be disallowed or will be same as &str.
        /#   (see BaseLanguageOopl.{typeToBase,metabase}).
        'str': strptr,
        '&str': strref,
        '*str': strptr,
        '@str': {
          'base': OoplCpp.CC_STR_VALUE, 'default': 'std::string("")'},
        'string': {'base': 'std::string', 'default': 'std::string("")'},
        'vec': {'base': 'std::vector<%(TV)s>', 'default': None},
        'map': {'base': 'std::map<%(TK)s,%(TV)s>', 'default': None},
        'void': {'base': 'void', 'default': None},
        'any': {'base': OoplCpp.CC_ANY, 'default': None},

        'ostream': {'base': 'std::ostream', 'default': 'std::cout'},
        'istream': {'base': 'std::istream', 'default': 'std::cin'},
        'strstream': {'base': 'std::stringstream', 'default': 'std::stringstream()'},

        'regexp': {},

        'nulltype': {'base': 'std::nullptr_t', 'default': 'nullptr'},
        /# TODO(wmh): Change to metax.root.ObjectMetaRoot when we have support
        /# for including required implicit targets implemented.
        /# TODO(wmh): Change 'long long' to 'std::any' when c++17 support available
        /# in bazel.
        'class': {'base': 'metax.root.ObjectMetaRoot', 'default': 'nullptr'},
        /# TODO(wmh): Can we use std::function? Sometimes (e.g.
        /# TestCase.raises()) we do not know the signature ... can std::function
        /# handle varargs?
        'method': {'base': 'void*', 'default': 'nullptr'},
        'function': {'base': 'void*', 'default': 'nullptr'},

        /# How to handle 'void' is still being worked out.
        'void': {'base': 'void', 'default': None},

        'pair': {'base': 'std::pair<%(T1)s,%(T2)s>', 'default': 'std::pair<%(T1)s,%(T2)s>()'},
        'tuple': {'base': 'types.TupleType', 'default': 'tuple()'},
        'map': {'base': 'std::map<%(TK)s,%(TV)s>', 'default': None},
      })

      self.keywordsIs(
        /# http://en.cppreference.com/w/cpp/keyword
        ['alignas', 'alignof', 'and', 'and_eq', 'asm', 'auto', 'bitand', 'bitor',
         'bool', 'break', 'case', 'catch', 'char', 'char16_t', 'char32_t', 'class',
         'compl', 'const', 'constexpr', 'const_cast', 'continue', 'decltype',
         'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
         'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend',
         'goto', 'if', 'inline', 'int', 'long', 'mutable', 'namespace', 'new',
         'noexcept', 'not', 'not_eq', 'nullptr', 'operator', 'or', 'or_eq',
         'private', 'protected', 'public', 'register', 'reinterpret_cast',
         'return', 'short', 'signed', 'sizeof', 'static', 'static_assert',
         'static_cast', 'struct', 'switch', 'template', 'this', 'thread_local',
         'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union',
         'unsigned', 'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while',
         'xor', 'xor_eq'])

      self.updateConfigs({
        'namespace_primary': False,
        'definition_separate': True,
        'rem': '//',
        'self': 'this',
        'cls': 'this',
        'selfsep': '->',
        'staticsep': '::',
        'stmtend': ';',

        /# https://github.com/google/googletest/blob/master/googletest/docs/Primer.md
        'setup': {'name': 'SetUp', 'dispatch': 'virtual'},
        'clsetup': {'name': 'SetUpTestCase', 'level': 'static'},
        'teardown': {'name': 'TearDown', 'dispatch': 'virtual'},
        'clteardown': {'name': 'TearDownTestCase', 'level': 'static'},
      })

      self.pseudovarsIs({
        'true': 'true',
        'false': 'false',
        'null': 'nullptr',
        'out': 'std::cout',
        'in': 'std::cin',
        'err': 'std::cerr',
        'self': metax.c.SELF,
      })
    setup:
      baselang, _, context, _ = self.cachedInfo(basel='cpp')
      self.baselang = baselang
      self.context = context
    end lifecycle;

    method typeToBase : str #:
      Convert a metatype to a string representation of its base-language
      equivalent.
    params:
      var metatype : Type #:
        The metatype to convert.
      var class_construct : metax.oopl.ClassConstruct = null #:
        If specified, the class within which the type is being defined.
        Some baselangs cannot support fully-qualified references to the
        class currently being defined, and this allows such fully-qualified
        types to be localized.
      var value : any = null #:
        If present, the value being assigned to the variable of type 'metatype'.
        Used, for example, if metatype is 'str' (rather than '&str' or '*str')
        to heuristically decide between '&str' or '*str'.
      var defqn : bool = false #:
        If true, convert fully-qualified class-based types to class-name only.
        Used to support situations where the fully-qualified name poses
        problems in the baselang.
      var debug : bool = false;
    scope:
      /# TODO(wmh): This should be a behavior.
      if metatype.isStr():
        result = OoplCpp.CC_STRVIEW
      else:
        result = super(OoplCpp, self).typeToBase(
          metatype, class_construct=class_construct, value=value, defqn=defqn,
          debug=debug)
      return result
    test:
      baselang, _, context, _ = test.cachedInfo(basel='cpp')
      MetaType = metax.c.Type.Instance
      cc_str = metax.oopl.OoplCpp.CC_STR
      cc_strview = metax.oopl.OoplCpp.CC_STRVIEW
      cc_str_value = metax.oopl.OoplCpp.CC_STR_VALUE

      test.iseq('%s' % cc_strview, baselang.typeToBase(MetaType('str')))
      test.iseq('%s' % cc_strview, baselang.typeToBase(MetaType('@str')))
      test.iseq('%s' % cc_strview, baselang.typeToBase(MetaType('&str')))
      test.iseq('%s' % cc_strview, baselang.typeToBase(MetaType('*str')))
    end method typeToBase;

  end class OoplCpp;

  behavior accessorType : Type #:
    The Type to use for a return value or arg of an accessor.

    Suppose a field has type T. What type should its getter, setter and
    reffer return? What is the type of the arg of the setter?
    This method answers those questions.
  params:
    var ftype : Type #:
      The type of the field for which a return type is desired.
    var acc : str #:
      One of 'get', 'set', 'setarg', or 'ref'.
    var namespace_function : function = null #:
      A function accepting no args that returns the namespace within which
      the Type appears.  Used to resolve relative class types.  If resolution
      is needed, it is an error not to provide such a function
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if acc == 'get':
        result = ftype
      elif acc == 'set':
        result = None
      elif acc == 'setarg':
        result = ftype
      elif acc == 'ref':
        result = ftype
      else:
        raise metax.c.Error('Unhandled acc "%s"' % acc)
      return result
    test:
      metatype = metax.c.Type.Instance('*demo.cards1.Card')
      test.iseq(
        metatype, test.baselang.accessorType(metatype, 'get'))
      test.iseq(
        /# TODO(wmh): Decide whether setters return self or not. If they do,
        /# the return type here should be the klass, not None
        None, test.baselang.accessorType(metatype, 'set'))
      test.iseq(
        metatype, test.baselang.accessorType(metatype, 'ref'))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if acc == 'get':
        result = ftype
      elif acc == 'set':
        result = None
      elif acc == 'setarg':
        result = ftype
      elif acc == 'ref':
        result = ftype
      else:
        raise metax.c.Error('Unhandled acc "%s"' % acc)
      return result
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      base = ftype.base() + ftype.paramStr()
      prefix = ftype.prefix()
      strview = metax.c.Type.Instance('@' + OoplCpp.CC_STRVIEW.replace('::', '.'))
      strref = metax.c.Type.Instance('&' + OoplCpp.CC_STRVIEW.replace('::', '.'))
      result = None
      
      res = ''
      if acc == 'get':
        /# if T is primitive, getter is T
        /# If field is @T, getter is &#T
        /# If field is &T, getter is &#T
        /# If field is *T, getter is *#T
        /# If field is **T, getter is *#*#T
        if ftype.isPrimitive():
          result = ftype
        else:
          if ftype.isStr():
            /# We have the 'str' type. Note that 'str' is inherently const so
            /# we do NOT need to prefix the type with '#'.
            /#  get *str returns meta::str (there is a special meta::str instance that represents null)
            /#  get &str returns meta::str (how do we ensure non-null not allowed?)
            /#  get @str returns meta::str copy
            result = strview
          elif ftype.isValue():
            /# The only possible prefixes are '@' and '@#'.
            res = '&#'
          elif ftype.isRef():
            /# The prefix starts with '&', then zero or more '*' each
            /# optionally preceeded by '#', then an optional '#'.
            /# (regexp '^&(?:#?\*)*#?$').  In all cases, we return a reference,
            /# with all pointers being const, and the base value itself
            /# also const.
            numast = prefix.count('*')
            res = '&' + '#*' * numast + '#'
          elif ftype.isPtr():
            /# Just like isRef() except does not start with '&'.
            numast = prefix.count('*')
            res = '#*' * numast + '#'
          else:
            raise metax.c.InternalError('Should never reach this')
          if result is None:
            result = metax.c.Type.Instance(
              res + base, namespace_function=namespace_function)

      elif acc == 'set':
        /# We used to have setters return 'this', but with the concept of
        /# the '..' operator that is no longer needed.
        result = None

      elif acc == 'setarg':
        /# The setter arg type.
        /#  - we very rarely want pass-by-value semantics here (only for
        /#    primitives and 'super-light' class types like 'std::string_view')
        /#  - whether the arg should be const or not depends on whether we
        /#    are copying or moving ... how do we allow the user to specify
        /#    this?
        if ftype.isStr():
          result = strview
        else:
          /# TODO(wmh): We need to add more special-casing here.
          result = ftype

      elif acc == 'ref':
        /# If field is base const (#T, *#T, &#T, etc.), it is an error to
        /# generate a reffer for it.
        /# If field is @T, reffer is &T
        /# If field is &T, reffer is &T
        /# If field is *T, reffer is &*T
        result = None
        if ftype.isStr():
          result = strref
        elif ftype.isBaseConst():
          raise metax.c.Error('Cannot generate reffer for type "%s"' % ftype.raw())
        elif ftype.isValue():
          /# The only possible prefix is '@' (since '@#' is not allowed).
          res = '&'
        elif ftype.isRef():
          /# The prefix starts with '&', then zero or more '*' each
          /# optionally preceeded by '#' (regexp '^&(?:#?\*)*$').
          res = prefix
        elif ftype.isPtr():
          /# The prefix starts with '*' or '#*', then zero or more '*' each
          /# optionally preceeded by '#'. Cannot contain '&' or '@' anywhere.
          res = '&' + prefix
        else:
          raise metax.c.InternalError('Should never reach this')

        if result is None:
          result = metax.c.Type.Instance(
            res + base, namespace_function=namespace_function)
      else:
        raise metax.c.Error('Unhandled acc "%s"' % acc)

      /# print '*** FTYPE %-6s %-20s %-20s %s' % (acc, ftype, result, self.typeToBase(result))

      return result
    test:
      MetaType = metax.c.Type.Instance
      test.iseq(
        'int',
        test.baselang.accessorType(MetaType('int'), 'get').raw())
      test.iseq(
        '&#demo.cards2.Card',
        test.baselang.accessorType(MetaType('&demo.cards2.Card'), 'get').raw())

      test.iseq(
        '#*#ostream',
        test.baselang.accessorType(MetaType('ostream'), 'get').raw())

      /# TODO(wmh): Add more.
    end receiver OoplCpp;

  end behavior accessorType;

  behavior _annotateBaseType : str #:
    Baselang specific metatype conversion to baselang.

    This is a template method invoked within typeToBase.
    Adds ptr/ref/const/etc annotations to a baselang basetype.

    Returns:
      The baselang version of the core part of metatype.
  params:
    var metatype : Type #:
      The meta-level type being converted.
    var basetype : str #:
      The baselang version of the core part of metatype.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      /# In Python:
      /#   @int is int
      /#   &int is not yet supportable
      /#   *int .... do we use meta.lang.Integer (java-like boxing?)
      /#
      /#   @vec is list
      /#   &vec is list
      /#   *vec is list
      /#
      /#   @map is dict
      /#   &map is dict
      /#   *map is dict
      /#
      /#   @str is not allowed (interned does not support copy semantics ... but we could use move semantics?)
      /#   &str is str
      /#   *str is str (implicitly const)
      return basetype
    test:
      baselang = test.baselang
      MetaType = metax.c.Type.Instance

      def Chk(expected, metatype, basetype):
        res = baselang._annotateBaseType(metatype, basetype)
        self.iseq(expected, res)

      Chk('demo.cards1.Card',
          MetaType('*demo.cards1.Card'), 'demo.cards1.Card')
      Chk('demo.cards1.Card',
          MetaType('*demo.cards1.Card'), 'demo.cards1.Card')
      Chk('demo.cards1.Card',
          MetaType('*demo.cards1.Card'), 'demo.cards1.Card')

      Chk('file', MetaType('ostream'), 'file')
      Chk('file', MetaType('&ostream'), 'file')
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# https://developers.google.com/closure/compiler/docs/js-for-compiler#types
      base = metatype.base()
      if metatype.isTemplate():
        result = basetype[1:]
        prefix = None
      elif metatype.isPtr():
        prefix = '?'
      else:
        prefix = '!'

      /# Javascript supports union types like '(Function|string)' [see
      /# http://usejsdoc.org/tags-type.html]. When specifying optional or
      /# required status, use '(?Function|?string)' rather than
      /# '?(Function|string)'.
      if basetype[0] == '(' and basetype[-1] == ')':
        result = (
          '(' +
          '|'.join([prefix + bt for bt in basetype[1:-1].split('|')]) +
          ')')
      else:
        result = prefix + basetype
      return result
    test:
      oopljs, _, context, _ = test.cachedInfo(basel='javascript')

      test.iseq(
        '!number',
        oopljs._annotateBaseType(metax.c.Type.Instance('int'), 'number'))
      test.iseq(
        '?number',
        oopljs._annotateBaseType(metax.c.Type.Instance('*int'), 'number'))
      test.iseq(
        '?Function',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('function'), 'Function'))
      test.iseq(
        '!Function',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('&function'), 'Function'))
      test.iseq(
        '(?Function|?string)',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('function'), '(Function|string)'))
      test.iseq(
        '(!Function|!string)',
        oopljs._annotateBaseType(
          metax.c.Type.Instance('&function'), '(Function|string)'))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      /# In C++
      /#       @int is int
      /#       &int is int&
      /#       *int is int*
      /#
      /#       @vec is std::vector<T>
      /#       &vec is std::vector<T>&
      /#       *vec is std::vector<T>*
      /#
      /#       @map is std::hashmap<K,V>
      /#       &map is std::hashmap<K,V>&
      /#       *map is std::hashmap<K,V>*
      /#
      /#       @str is not allowed (interned does not support copy semantics ... but we could use move semantics?)
      /#       &str is const metax.lib.IStr&
      /#       *str is const metax.lib.IStr*
      /#
      /#         *T is T*
      /#        *#T is const T*
      /#        #*T is T*const
      /#       #*#T is const T*const
      /#        u*T is std::unique_ptr<T>
      /#       u*#T is std::unique_ptr<const T>
      /#       #u*T is const std::unique_ptr<T>
      /#      #u*#T is const std::unique_ptr<const T>
      /#
      /#       u**T is std::unique_ptr<T*>
      /#      u*s*T is std::unique_ptr<std::shared_ptr<T>>
      /#   #u*#s*#T is const std::unique_ptr<const std::shared_ptr<const T>>

      result = basetype.replace('.', '::')

      if metatype.isPtr():
        /# We handle any number of [#][usw]* specs.
        /#  - parts will contain (1 + 3K) elements, where
        /#     - K is the number of '*' chars
        /#     - parts[0] is either '' or '&'
        /#     - parts[1+k] is '#' if ptr const else ''
        /#     - parts[1+k+1] is 'u' or 's' or 'w' or ''
        /#     - parts[1+k+2] is empty except when 1+k+2==n-1 in which case it
        /#       is empty if the base type is not const and is '#' if the
        /#       base type is const.
        prefix = metatype.prefix()
        parts = metax.c.Type.METATYPE_SPLIT.split(prefix)
        /#print '%-30s = %s' % (metatype.raw(), str(parts))

        n = len(parts)
        assert ((n-1)%3) == 0
        k = (n-1) / 3
        isconst = parts[-1] == '#'

        /# We process from the back.
        /#  - we start three back from the end
        i = n - 3
        first = True
        while i > 0:
          ptrconst = parts[i] == '#'
          special = parts[i+1]
          if special:
            /# We have something like u*T or #u*T or #u*#T
            if isconst:
              result = 'const ' + result
            result = OoplCpp.PTR_MAP[special] + '<' + result + '>'
            if ptrconst:
              result = 'const ' + result
          else:
            /# We have something like *T or #*T or #*#T
            result = result + '*'
            if ptrconst:
              result += 'const'
            if isconst and first:
              result = 'const ' + result
          i -= 3
          first = False
        if parts[0] == '&':
          result += '&'
      else:
        if metatype.isPtr():
          /# We have '&T' or '&#T' (anything else has a pointer and is handled
          /# above.
          /# TODO(wmh): Handle rvalue refs!
          result += '*'
        elif metatype.isRef():
          result += '&'
        if metatype.isBaseConst() and not result.startswith('const ') and not metatype.isStr():
          result = 'const ' + result
      return result
    test:
      baselang = test.baselang
      MetaType = metax.c.Type.Instance

      def Chk(expected, metatype, basetype):
        res = baselang._annotateBaseType(metatype, basetype)
        self.iseq(expected, res)

      Chk('nm::sp::A', MetaType('@nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A&', MetaType('&nm.sp.A'), 'nm.sp.A')

      Chk('nm::sp::A*', MetaType('*nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A', MetaType('@nm.sp.A'), 'nm.sp.A')

      Chk('const nm::sp::A*', MetaType('*#nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A*const', MetaType('#*nm.sp.A'), 'nm.sp.A')
      Chk('const nm::sp::A*const', MetaType('#*#nm.sp.A'), 'nm.sp.A')

      Chk('std::unique_ptr<nm::sp::A>',MetaType('u*nm.sp.A'), 'nm.sp.A')
      Chk('std::unique_ptr<const nm::sp::A>',MetaType('u*#nm.sp.A'), 'nm.sp.A')
      Chk('const std::unique_ptr<nm::sp::A>',MetaType('#u*nm.sp.A'), 'nm.sp.A')
      Chk('const std::unique_ptr<const nm::sp::A>',
          MetaType('#u*#nm.sp.A'), 'nm.sp.A')
      Chk('const std::unique_ptr<const nm::sp::A>',
          MetaType('#u*#nm.sp.A'), 'nm.sp.A')

      Chk('nm::sp::A**', MetaType('**nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A*const*', MetaType('*#*nm.sp.A'), 'nm.sp.A')
      Chk('nm::sp::A*const*const', MetaType('#*#*nm.sp.A'), 'nm.sp.A')
      Chk('const nm::sp::A*const*', MetaType('*#*#nm.sp.A'), 'nm.sp.A')

      Chk('const std::weak_ptr<const const std::shared_ptr<'
          'const const std::unique_ptr<const nm::sp::A>>>',
          MetaType('#w*#s*#u*#nm.sp.A'), 'nm.sp.A')

      Chk('std::ostream*', MetaType('ostream'), 'std::ostream')
      Chk('std::ostream&', MetaType('&ostream'), 'std::ostream')

      Chk('const std::string&', MetaType('&str'), 'const std::string')
      Chk('std::string', MetaType('@str'), 'std::string')
    end receiver OoplCpp;

  end behavior _annotateBaseType;

  behavior augmentVarset #:
    Perform baselang-specific modifications of the varset.
  params:
    var construct : Construct;
    var varset : VarSet;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      kind = construct.kind()

      if kind == 'class':
        /# The __metaclass__ attribute of a class specifies the metaclass.
        metaclass = construct.metaclass()
        if metaclass:
          /# Remember that a class may not have a metaclass even if it is
          /# a user class (if autogen=nometa).
          preamble = varset.getValue('preamble')
          preamble.append('__metaclass__ = %s' % metaclass.id())
          variant = construct.variant()
          if variant in ('user', 'test'):
            /# Meta guarantees that for every user-level class nm.sp.Foo, there is
            /# a metaclass nm.sp.FooMeta and a singleton instance of that
            /# metaclass named nm.sp.MetaFoo. In python, since we've defined
            /# Foo.__metaclass__ to be FooMeta, MetaFoo is just Foo.
            postclass = varset.getValue('postclass')
            name = construct.id()
            postclass.append('')

            /# TODO(wmh): Look into the best way to handle this issue.
            /#  - When creating test classes, if we define:
            /#      MetaFooTest = FooTest
            /#    then the testcase infrastructure will invoke the tests on
            /#    the class twice (once via FooTest, once via MetaFootTest).
            /#  - For now, we do not define this variable for test classes,
            /#    and require users to use self.meta() to gain access to
            /#    the metaclass of a testclass.
            /#  - We should consider not defining the MetaFoo variable for
            /#    class Foo in any situation (require use of self.meta()).
            /#  - If Meta implemented its own xUnit infrastructure from
            /#    scratch (so baselangs do not use baselang-specific
            /#    implementations) we would have easy control over this kind
            /#    of issue.
            if variant == 'user':
              /# CODETANGLE(metainst_for_testclass)
              postclass.append(
                '%s = %s' % (metax.oopl.ClassConstruct.MetaInstifyName(name), name))

        /# If this class has a clinit method, invoke it after the class
        /# definition (note that this invocation is actually moved to the
        /# bottom of the namespace within namespace compilation code).
        clinit = construct.clinit()
        if clinit is not None:
          postclass = varset.getValue('postclass')
          postclass.append('%s.%s()' % (construct.id(), clinit.id()))

      elif kind == 'method':
        attrkind = construct.attrval('kind')
        modifiers = varset.getValue('modifiers')
        if attrkind == 'cls':
          modifiers.append('@classmethod')
        elif attrkind == 'static':
          modifiers.append('@staticmethod')
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      kind = construct.kind()
      use_es2015_classes = self.config('use_es2015')

      if kind == 'class':
        namespace = construct.namespace()
        nmsp = namespace.id()
        clsname = construct.id()
        metaname = metax.oopl.ClassConstruct.MetaifyName(clsname)

        /# In Javascript, an initial comment block with @fileoverview allows
        /# one to specify @suppress commands.
        local_list, _ = construct.suppressInfo()
        overview_lines = [' * @fileoverview']
        if local_list:
          overview_lines.append(' * @suppress {%s}' % ','.join(local_list))
        overview = '/**\n' + '\n'.join(overview_lines) + '\n */\n'
        varset.addVar('overview', overview)

        if construct.isTest() and not use_es2015_classes:
          varset.addVar('test_method_restr', '')
          /# We currently are not producing a 'goog.provide' statement in test
          /# classes (because this disables some implicit testing we currently
          /# rely on). However, goog.provide() is what ensures that the
          /# namespace is initialized. We ensure that the namespace is defined.
          /#  - TODO(wmh): There must be a cleaner way of doing this using
          /#    something in goog/base.js (e.g. goog.constructNamespace_) that
          /#    does not disable unittesting (which goog.provide apparently
          /#    does).
          /#  - TODO(wmh): If the top-level namespace is not defined by the
          /#    time this class is imported, closure will complain. I'm not
          /#    clear how to get around that, so the code has been organized
          /#    to ensure that a goog.require() of some class that does
          /#    define the toplevel namespace is present.
          imports = varset.getValue('imports')
          imports.append('')
          nparts = nmsp.split('.')
          for i in range(0, len(nparts)):
            npref = '.'.join(nparts[:i+1])
            if i == 0:
              imports.append('%s = %s || {};' % (npref, npref))
            else:
              imports.append(
                '/** @type {?Object} */ %s;  // find cleaner way' % npref)
              imports.append('%s = %s || {};' % (npref, npref))

        if use_es2015_classes:
          assert clsname == varset.getValue('class')
          underclass = construct.underclass()
          postclass = varset.getValue('postclass')

          /# We look for the (very special) situation where we are defining
          /# a class nm.sp.Foo whose parent is Foo, for some javascript
          /# builtin class (e.g. 'Object', 'Error', etc.). In such situations
          /# the code generated is:
          /#   class Foo extends Foo {...}
          /# which is obviously problematic. We fix this by change it to
          /#   class Foo_ extends Foo {...}
          /# and updating all relevant references to Foo_ instead of Foo.
          parentspec = varset.getValue('parentspec')
          if parentspec == ' extends ' + clsname:
            clsname += '_'
            varset.setValue('class', clsname)

          /# When defining javascript classes using ES2015 syntax (and the
          /# goog.module()), we need to add postamble to the class as follows:
          /#  - all variants (user, test, meta) need to specify the value of the
          /#    special 'exports' variable to the object (or objects) we want to
          /#    make visible to callers who goog.require() the module.
          /#     - for user and test, this is simply
          /#          exports = <classname>;
          /#       but for meta classes, this is:
          /#          exports = {<metainst>, <metaclass>};
          /#  - for meta classes, before setting exports, we need to create
          /#    the singleton Meta<classname> instance of <classname>Meta.
          /#  - for test classes, after setting exports, we need to invoke
          /#    the test-harness infrastructure.
          if construct.isMeta():
            if underclass:
              metaclass_instname = metax.oopl.ClassConstruct.MetaInstifyName(underclass.id())
              /# Create the singleton instance of the metaclass.
              postclass.append(
                "const %s = new %s('%s', [], {});" %
                (metaclass_instname, clsname, construct.id()))

              /# Define the two-valued export.
              postclass.append(
                'exports = {%s, %s};' % (metaclass_instname, clsname))
            else:
              postclass.append('exports = %s;' % clsname)
          else:
            /# For both user and test classes we add a simple one-value 'export'.
            /# TODO(wmh): Is it necessary to make a module for the test class?
            /# Only if we want to allow other test classes to import this test
            /# class, which may indeed be useful.
            postclass.append('exports = %s;' % clsname)

            /# For test classes, we invoke the test machinery.
            if construct.isTest() and underclass:
              postclass.append('')
              postclass.append(
                /# TODO(wmh): For now, passing in the fully-qualified name of
                /# the test class, as opposed to the underlying user class,
                /# but if we can figure out how to change class names in
                /# all baselangs, it might be better to use the userlevel fqn.
                "var tc = new %s('%s');" % (clsname, construct.fqn()))
              postclass.append('tc.runSelfTests();')

      elif kind == 'method':
        dot = metax.c.Context.Tokens()['scope_sep']
        myclass = construct.myclass()
        method_prefix = myclass.fqn()
        kind = construct.attrval('kind')
        if kind == 'instance':
          method_prefix += dot + 'prototype'
        elif kind == 'initializer':
          /# Javascript is a snowflake. In most languages, class nm.sp.Class has
          /# initializer nm.sp.Class.Class, but in javascript it is nm.sp.Class
          /# And while instance methods in Javascript are defined as
          /#   nm.sp.Class.prototype.methname = function ...
          /# the initializer is
          /#   nm.sp.Class = function ...
          method_prefix = dot.join(myclass.fqn().split(dot)[:-1])

          /# postmethod stores the invocation of the goog.inherits()
          if not use_es2015_classes:
            parentinfo = myclass.parentclasses()[0]
            varset.getValue('postmethod').append(
              'goog.inherits(%s, %s);' % (myclass.fqn(), parentinfo['fqn']))

          /# TODO(wmh): Use @name <class>#<method> per
          /#   https://stackoverflow.com/questions/10490713/how-to-document-the-properties-of-the-object-in-the-jsdoc-3-tag-this
          preamble = varset.getValue('preamble')
          baselang = construct.baselang()
          for field in myclass.fields():
            ftype = field.attrval('type', default=metax.c.LOOKUP)
            /# print 'HERE with %s = %s' % (str(ftype), baselang.typeToBase(ftype))

            /# TODO(wmh): See the comment within the scope of
            /# OoplJavascript.formatMethodComment() discussing defqn. We need
            /# to do the same thing here.
            preamble.append(
              '/** @type {%s} */ this.%s;' %
              (baselang.typeToBase(ftype, class_construct=myclass, defqn=True),
              field.rawfield()))

        method_prefix += dot
        varset.addVar('method_prefix', method_prefix)
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      kind = construct.kind()

      if kind == 'class':
        metaclass = construct.metaclass()
        underclass = construct.underclass()
        metafile = construct.metafile()
        streams = metafile.streams()

        namespace = construct.namespace()
        fqn = namespace.id()
        lines = []
        postlines = []

        /# Define the vars related to namespace start/end.
        varset.addVar('namespace_under', fqn.replace('.', '_'))
        for part in fqn.split('.'):
          lines.append('namespace %s {' % part)
          postlines.append('}  // %s' % part)
        varset.addVar('namespace_spec', '\n'.join(lines))
        varset.addVar('end_namespace', list(reversed(postlines)))

        /# The ${header} exists in the defn (.cc) template to include the
        /# header (.h) file.
        varset.addVar('header', construct.fqn().replace('.', '/') + '.h')

        /# Deal with lines of C++ code to be inserted before and after the
        /# namespace specifiers within which the class is defined.
        /#  imports        - C++ code before namespace in header
        /#  imports_local  - C++ code before namespace in source
        /#  imposts        - C++ code after  namespace in header
        /#  imposts_local  - C++ code after  namespace in source
        /#
        /# Note that 'imports' often already has content (all the imports that
        /# are needed by the class), but the other three are usually (always?)
        /# empty/undefined before this code.
        extralines = construct.extralines()
        import_extra = extralines.get('premsp', {}).get('decl', [])
        varset.addVar(
          'imports_local',
          extralines.get('premsp', {}).get('defn', []))
        varset.addVar(
          'imposts_local', 
          extralines.get('postmsp', {}).get('defn', []))
        varset.addVar(
          'imposts',
          extralines.get('postmsp', {}).get('decl', []))

        /# Define preclass (before class) and postclass (after class)
        preclass = varset.getValue('preclass')
        postclass = varset.getValue('postclass')
        preamble = varset.getValue('preamble')
        preclass_defn = []
        postclass_defn = []

        /# Sub-constructs of class may write to the 'decl-post' stream (e.g.
        /# static field constructs write static field definition and
        /# initialization code here). They are to be inserted into the .cc
        /# file outside of the class scope (after it).
        defn_post_segments = streams.stream('defn-post')
        if defn_post_segments:
          postclass_defn.extend(defn_post_segments)

        if construct.isMeta():
          if underclass:
            /# Each metaclass FooMeta associated with userclass Foo should
            /# declare a namespace variable MetaFoo to contain the singleton
            /# instance of FooMeta.
            /#
            /# TODO(wmh): Should MetaFoo be of type *FooMeta or @FooMeta?.
            /# TODO(wmh): Should MetaFoo be a method returning the singleton
            /# instance, rather than a variable? Matches better with Meta's
            /# "everything should be a function" philosophy.
            metaclass_instname = metax.oopl.ClassConstruct.MetaInstifyName(underclass.id())
            postclass.append('')
            postclass.append('// The singleton instance of the metaclass.')
            postclass.append(
              'extern %s* %s;' % (construct.id(), metaclass_instname))
            postclass_defn.append('')
            postclass_defn.append(
              '// Create the singleton instance of the metaclass.')
            postclass_defn.append(
              'static std::vector<metax::root::ObjectMetaRoot*> _bases;')
            postclass_defn.append(
              'static std::map<%s, %s*> _symbols;' %
              (OoplCpp.CC_STR_VALUE, OoplCpp.CC_ANY))
            postclass_defn.append(
              '%s* %s = new %s("%s", _bases, _symbols);' %
              (construct.id(), metaclass_instname, construct.id(),
               construct.fqn()))

        /# If the class has no initializer, but has a parent class, we
        /# explicitly inherit the constructors of the parent.
        if not construct.initializer():
          parentclasses = construct.parentclasses()
          if parentclasses:
            parentclass = parentclasses[0]
            preamble.append(
              'using %s::%s;' % (parentclass['fqn'], parentclass['id']))

        varset.addVar('preclass_local', preclass_defn)
        varset.addVar('postclass_local', postclass_defn)

      elif kind == 'method':
        modifiers = varset.getValue('modifiers')
        assert not modifiers
        mods = []

        /# Visibility
        visibility = construct.attrval('visibility')
        vis = visibility
        mods.append('%s:' % vis)

        /# misc.
        attrkind = construct.attrval('kind')
        if attrkind == 'static':
          mods.append('static')
        elif attrkind == 'initializer':
          /# No return type for initializers.
          varset.setValue('returns', '')
        else:
          /# Virtual or non-virtual dispatch?
          /#  - only valid if not static and not initializer!
          attrkind = construct.attrval('kind')
          if attrkind != 'initializer':
            dispatch = construct.attrval('dispatch')
            if dispatch == 'virtual':
              mods.append('virtual')

        if mods:
          mods.append('')

        modifiers.extend(mods)

        /# Handle constructor initialization list
        /#  - the initlist is part of defn not decl, so instead of adding
        /#    it to $params we define $initlist
        kind = construct.attrval('kind')
        initlist_str = ''
        super_attr = None
        if kind == 'initializer':
          /# The initialization list of C++ constructors is considered, by Meta,
          /# to be part of the params.
          super_attr, super_args = construct.attrpair('super', default=None)
          if super_args:
            init_str, _ = self.compileExpr(
              super_args, construct.metafile(), executable=construct)
            /# TODO(wmh): Fix this. Because ${initlist} appears in the cpp_defn
            /# template on the same line as ${method}, there are two different
            /# variables on the same line with differing attributes, and
            /# BaseSegment.addChunk() only handles one attribute.
            super_attr = None
            myclass = construct.myclass()
            parentclasses = myclass.parentclasses()
            pinfo = parentclasses[0]
            /# TODO(wmh): If the parent class is in the same namespace as
            /# myclass, we should use pinfo['id'] instead of pinfo['fqn']
            initlist_str = ' : %s%s' % (pinfo['fqn'], init_str)
        varset.addVar('initlist', initlist_str, attribute=super_attr)
    test:
    end receiver OoplCpp;

  end behavior augmentVarset;

  behavior autogenStr : str #:
    Auto-generate the human-readable printMeta() method.
      method metaxStr : str;
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:

    receiver OoplPython scope:
      context = klass.context()
      scope = klass.attr('scope:', default=metax.c.REQUIRED)
      metatypes = self.metatypes()
    end receiver OoplPython;

    receiver OoplCpp scope:
    end receiver OoplCpp;

  end behavior autogenStr;

  behavior autogenPrint #:
    Auto-generate the human-readable printMeta() method.

      method printMeta : void params:
        var fp : ostream = out;
        var indent : str = '';
      end;
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:

    receiver OoplPython scope:
      context = klass.context()
      scope = klass.attr('scope:', default=metax.c.REQUIRED)
      metatypes = self.metatypes()

      body = []
      body.append('subindent = indent + "  "')
      body.extend([
        /# IMPORTANT: We do NOT add 'indent' to the beginning of the line
        /# describing the class type, because this code is invoked after a
        /# a field name has already been printed (this only prints the value,
        /# not the entire field).
        "fp.write('%s %%x:\\n' %% id(self))" % klass.id()
      ])

      fields = klass.fields()
      if fields:
        maxlen = max([len(field.id()) for field in fields])
        /# TODO(wmh): We need the complete set of fields as inherited from the
        /# ancestor chain!
        for field in klass.fields():
          mtype = field.attrval('type')
          accs = field.accessors()
          formatter = accs.get('format', None) if accs else None
          minfo = metatypes.get(mtype.raw(), None)
          fstr = field.id().ljust(maxlen)
          format_code = None
          more_code = None
          if formatter:
            /# The user has provided explicit code to use for formatting the
            /# field, so we invoke the format accessor
            format_code = 'fix me'  # invoke receiver.<field>Format()
          elif minfo and 'format' in minfo:
            /# There is an explicit format specified in the base language for
            /# this type.
            format_code = minfo.get('format', None)(field.id())
            body.append(
              "fp.write('%%s  %s = %%s\\n' %% (indent, %s))" %
              (fstr, format_code))
          else:
            /# The field is assumed to be of a class type, so it defines the
            /# printMeta() method. We invoke it.
            body.append("fp.write('%%s  %s = ' %% indent)" % fstr)
            body.append(
              "self.%s().printMeta(fp=fp, indent=subindent)\n" % field.id())

      method = metax.oopl.MethodConstruct.NewFromData(
        'printMeta',
        context,
        parent=scope,
        features=[('autogen', 'notest')],
        secondaries=[
          (':', metax.c.Type.Instance('void')),
          ('#:',['Auto-generated human-readable summary of this object.']),
          ('params:', [
            {'var': 'fp', 'secondaries': [
              (':', metax.c.Type.Instance('ostream')),
              ('=', metax.c.Expr('var', 'out', 'out')),
            ]},
            {'var': 'indent', 'secondaries': [
              (':', metax.c.Type.Instance('str')),
              ('=', metax.c.Expr('str', "''", "''")),
            ]},
          ]),
          ('scope:', body),
        ],
        precount=1,
      )
      assert method.myclass() is klass
      method.expandMeta()
      method.namespaceIs(klass.namespace())

      /# The code above requires standard module 'sys'.
      klass.addDependency('sys', 'std', 'needed by autogened printMeta')

      return method
    test:
      test.defineClassAndMethods('py')
      method = test.baselang.autogenPrint(self.klass)
      method.write(fp=test.fp())
      test.iseqtext("""
        >|method printMeta : void #:
        >|  Auto-generated human-readable summary of this object.
        >|params:
        >|  var fp : ostream = out;
        >|  var indent : str = '';
        >|scope:
        >|  subindent = indent + "  "
        >|  fp.write('Card %x:\\n' % id(self))
        >|end method printMeta;
        >|""",
        test.out())

      preamble = []
      test.iseq(
        "(self, fp=sys.stdout, indent='')",
        test.baselang.formatParams(method, preamble))
      test.iseqvec([], preamble)
    end receiver OoplPython;

    receiver OoplCpp scope:
    end receiver OoplCpp;
 
  end behavior autogenPrint;

  behavior autogenWrite #:
      Auto-generate the machine-readable writeMeta() method.
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:

    receiver OoplPython scope:
      context = klass.context()
      scope = klass.attr('scope:', default=metax.c.REQUIRED)
      metatypes = self.metatypes()

      body = []

      fields = klass.fields()
      if fields:
        for field in klass.fields():
          mtype = field.attrval('type')
          accs = field.accessors()
          /# TODO(wmh): Serialize to protobuf!

      method = metax.oopl.MethodConstruct.NewFromData(
        'writeMeta',
        context,
        parent=scope,
        features=[('autogen', 'notest')],
        secondaries=[
          (':', metax.c.Type.Instance('void')),
          ('#:',['Auto-generated protobuf serializer of this object.']),
          ('params:', [
            {'var': 'fp', 'secondaries': [
              (':', metax.c.Type.Instance('ostream')),
              ('=', metax.c.Expr('var', 'out', 'out')),
            ]},
          ]),
          ('scope:', body),
        ],
        precount=1,
      )
      assert method.myclass() is klass
      method.expandMeta()
      method.namespaceIs(klass.namespace())

      /# The code above requires standard module 'sys'.
      klass.addDependency('sys', 'std', 'needed by autogened writeMeta')

      return method
    end receiver OoplPython;

    receiver OoplCpp scope:
    end receiver OoplCpp;

  end behavior autogenWrite;

  behavior autogenSize #:
      Auto-generate the byte-size calculator. 
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:

    receiver OoplPython scope:
      context = klass.context()
      scope = klass.attr('scope:', default=metax.c.REQUIRED)
      metatypes = self.metatypes()

      body = ['result = 0', 'return result']

      fields = klass.fields()
      if fields:
        for field in klass.fields():
          mtype = field.attrval('type')
          accs = field.accessors()
          /# TODO(wmh): Generate code to sum up the field sizes. 

      method = metax.oopl.MethodConstruct.NewFromData(
        'sizeMeta',
        context,
        parent=scope,
        features=[('autogen', 'notest')],
        secondaries=[
          (':', metax.c.Type.Instance('int')),
          ('#:',['Auto-generated sizeof method for this object.']),
          ('scope:', body),
        ],
        precount=1,
      )
      assert method.myclass() is klass
      method.expandMeta()
      method.namespaceIs(klass.namespace())

      return method
    end receiver OoplPython;

    receiver OoplCpp scope:
    end receiver OoplCpp;

  end behavior autogenSize;

  behavior classPath : str #:
    Obtain the baselang specific path in which a class is stored.
  params:
    var fqn : str #:
      An fqn to convert to a subpath.
    var suffix : str = null #:
      Usually null, in which case the primary suffix for the baselang is used,
      but may be an alternative suffix.
  scope:
    receiver BaseLanguageOopl scope:
      if suffix is None:
        suffix = self.suffix()
      return self.context().compiler().basePath(fqn, prefix='', suffix=suffix)

    receiver OoplPython scope:
      if suffix is None:
        suffix = self.suffix()
      return self.context().compiler().basePath(fqn, prefix='.', suffix=suffix)
  end behavior classPath;

  behavior buildPreambleText : str #:
    The baselang-specific preamble at the top of a BUILD file.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      return ''
    test:
      test.iseq('', test.baselang.buildPreambleText())
    end receiver OoplPython;

    receiver OoplJavascript scope:
      return (
        >|"""load("@io_bazel_rules_closure//closure:defs.bzl", "closure_js_library")
        >|load("@io_bazel_rules_closure//closure:defs.bzl", "closure_js_binary")
        >|load("@io_bazel_rules_closure//closure:defs.bzl", "closure_js_test")
        >|""")
    test:
      test.contains('io_bazel_rules_closure', test.baselang.buildPreambleText())
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      return ''
    test:
      test.iseq('', test.baselang.buildPreambleText())
    end receiver OoplCpp;

  end behavior buildPreambleText;

  behavior classSubPath : str #:
    The path (relative to WORKSPACE dir) of the file that contains the
    definition of a given class.
  params:
    var klass : metax.oopl.ClassConstruct;
    var location : str = 'defn' #:
      One of 'defn' or 'decl'. Only meaningful for baselangs that
      distinguish between declaration and definition.
  scope:
    receiver BaseLanguageOopl scope:
      metac = klass.compiler()
      return metac.basePath(klass.fqn(), suffix=self.suffix())
    end receiver BaseLanguageOopl;

    receiver OoplPython scope:
      /# For class 'nm.sp.Class', the class-specific file is usually written to
      /# nm/sp/Class.<suff>, but for python we hide these files in
      /# nm/sp/.Class.py (i.e. initial '.' before class name).
      /#
      /# TODO(wmh): If we find a way to support per-class files publicly in
      /# python, we can make each class visible by removing this method
      /# and inheriting the parent definition of this method.
      metac = klass.compiler()
      return metac.basePath(klass.fqn(), prefix='.', suffix=self.suffix())
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# In Javascript, when using Google closure, test classes must end in
      /# '_test.js'.
      /#   - TODO(wmh): Test classes are named ClassTest. Do we want to have
      /#     the files be ClassTest_test.js or Class_test.js? For now, we are
      /#     going with the latter (Class_test.js). A better solution would be
      /#     to implement the javascript Unit infrastructure totally in
      /#     Meta without reliance on goog.testing, and remove the requirement
      /#     that test files end in _test.js (unless that is a Bazel requirement
      /#     rather than a goog.testing requirement?)
      if klass.isTest():
        metac = klass.compiler()
        fqn = klass.fqn()
        if fqn.endswith('Test'):
          /# TODO(wmh): By allowing classes with a 'Test' suffix and without
          /# a test suffix, we open ourselves up to a potential file conflict
          /# Suppose we have a user-provided test class 'Blah' and 'BlahTest'
          /# ... they would both write to 'Blah_test.js'. Solutions:
          /#  - do not remove the 'Test' suffix and use BlahTest_test.js
          /#  - do not allow users to define user-provided test classes that
          /#    end with 'Test'.
          fqn = fqn[:-4]
        return metac.basePath(fqn, suffix='_test' + self.suffix())
      else:
        result = super(OoplJavascript, self).classSubPath(klass)
      return result
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      /# In C++, each class contains two files, a .h and a .cc file.
      /# We consider the .h file to be primary, and the .cc file is handled
      /# specially.
      metac = klass.compiler()
      suffix = self.suffix(location=location)
      return metac.basePath(klass.fqn(), suffix=suffix)
    test:
    end receiver OoplCpp;

  end behavior classSubPath;

  behavior createBuildFragment : tuple<str,map> #:
    Create a BUILD fragment for this construct.

    Returns:
     0) str (build rule)
     1) map (key/values in target)
  params:
    var construct : Construct #:
      A class construct.
    var targets : vec<str> #:
      The targets that this construct depends on.
    var test : bool = false #:
      If true, the targets are for the test class associated with the
      construct.
    var name : str = null #:
      The name of the target.  Usually null, in which case the name of
      the construct is used.
    var src : str = null #:
      The src file.  Usually null, in which case it is computed based on
      the construct name.
  scope:

    abstract
    receiver BaseLanguageOopl;

    receiver OoplPython scope:
      kind = construct.kind()

      if kind == 'namespace':
        if name is None:
          name = construct.id().split('.')[-1]
        if src is None:
          src = name + '.py'
        rule = 'py_test' if test else 'py_library'
        build = {
          'name': name,
          'srcs': [src],
          'deps': targets,
          'visibility': ['//visibility:public'],
        }

        /# NOTE: Although ClassConstruct.registerResource() does register
        /# a mapping from resource name to target, in Python we cannot rely
        /# on that mapping containing all per-class resources (if two
        /# different metafiles define different classes in the same namespace,
        /# something we almost certainly need to support, then if we only
        /# parse one of the .meta files, the class resources in the other
        /# .meta file will be missing).  The easy solution is to simply
        /# scan the namespace directory for any files looking like resource
        /# links.
        metac = construct.compiler()
        fs = metac.fs()
        resource_dir = fs.join(
          /# CODETANGLE(resource_dir)
          /# TODO(wmh): Rename to something else that won't conflict
          /# with a sub-namespace named 'resources'.
          metac.repositoryPath(), metac.basePath(construct.fqn()), metax.c.RESOURCES_SUBDIR)
        if fs.exists(resource_dir):
          build['data'] = [
            metax.c.RESOURCES_SUBDIR + '/' + f
            for f in fs.listdir(resource_dir)
          ]

        if kind == 'class':
          /# TODO(wmh): In Python, since we do not have per-class targets,
          /# we need to instead collect all class resources into the
          /# namespace build fragment.  This is problematic if we allow
          /# two different metafiles to define classes in the same namespace
          /# (something we almost certainly need to support) because we would
          /# need to parse all meta files defining a namespace whenever any
          /# .metafile for the namespace is referenced ... or, alternatively,
          /# record per-class resource data on disk so it can be aggregated.
          /#   - we could just scan for symlinks that look like resource links!
          resources = construct.resources()
          data = []
          for resname, respath in resources.iteritems():
            data.append(respath)
          build['data'] = sorted(data)
        if test:
          build['size'] = 'small'

      elif kind == 'class':
        raise metax.c.InternalError(
          'Python should not be create per-class build fragments (yet)')
      else:
        rule = None
        build = None

      return rule, build
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      kind = construct.kind()

      if kind == 'class':
        /# TODO(wmh): Need to add this to the BUILD file:
        /#   load("//closure:defs.bzl", "closure_js_library")
        metac = construct.compiler()
        flags = metac.flags()
        fs = metac.fs()
        baselang = construct.baselang()
        variant = construct.variant()

        _, suppress_list = construct.suppressInfo()
        suppress_set = set(suppress_list)

        if name is None:
          name = construct.id()
        if src is None:
          class_subpath = baselang.classSubPath(construct)
          src = fs.basename(class_subpath)
        if test:
          /# assert ClassConstruct.IsTestName(name)
          rule = 'closure_js_test'
          test_dep = '@io_bazel_rules_closure//closure/library:testing'
          if test_dep not in targets:
            targets.append(test_dep)
        else:
          rule = 'closure_js_library'
        build = {
          'name': name,
          'srcs': [src],
          'deps': targets,
          'visibility': ['//visibility:public'],
        }

        /# We always disable extra requires because ...
        suppress_set.add('JSC_EXTRA_REQUIRE_WARNING')
        /# We always disable nuulable returns ... just because the current
        /# program always uses a non-null value doesn't mean it won't change
        /# in the future.
        suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')

        if test:
          build['size'] = 'small'
          build['testonly'] = 1
          /# For user-provided class C, the auto-generated test class CTest
          /# implicitly includes class C (because tests for C must rely on C,
          /# and it is cumbersome for the user to specify something that is
          /# almost always the case).  HOWEVER, if the initialization of
          /# instances of C occurs within a namespace-specific TestCase class
          /# that CTest inherits from, there is actually no need to include C
          /# in CTest. Closure produces the following error when a goog.require()
          /# is specified that is not actually used:
          /#    ERROR - extra require: 'wmh.games.catan.Hex'
          /#      goog.require('wmh.games.catan.Hex');
          /#      ^
          /#        ProTip: "JSC_EXTRA_REQUIRE_WARNING" or "extraRequire" or
          /#        "legacyGoogScopeRequire" can be added to the `suppress`
          /#        attribute of: //wmh/games/catan_test:HexTest_lib
          /#        Alternatively /** @suppress {legacyGoogScopeRequire} */
          /#        can be added to the source file.
          /#
          /# For now, we suppress JSC_EXTRA_REQUIRE_WARNING within test classes.
          /# TODO(wmh): Verify these are still needed
          /# suppress_set.add('JSC_EXTRA_REQUIRE_WARNING')
          /# suppress_set.add('JSC_MISSING_PROVIDE')

          optmap = {
            'off': 'WHITESPACE_ONLY',
            'low': 'SIMPLE,',
            'avg': 'SIMPLE',
            /# Tests actually run faster with less optimization. In fact, it
            /# might be best to use 'WHITESPACE_ONLY', but that is currently
            /# producing errors.
            'high': 'SIMPLE',
            'max': 'ADVANCED'}
          build['compilation_level'] = optmap[flags.optimize_level]
          build['entry_points'] = [construct.fqn()]

        elif name == 'TestCase':
          /# Special case ... we assume the TestCase class inherits from
          /# metax.test.TestCase, which is marked as testonly because it
          /# relies on
          /#   @io_bazel_rules_closure//closure/library:testing
          /# Any class that relies on a testonly target must also be testonly.
          build['testonly'] = 1
          suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')

        elif variant == 'meta':
          /# A auto-generated meta class.
          /#  - preferably, the definition of the class itself should appear
          /#    first in the goog.provide() list, but this is always alphabetically
          /#    after the instance-of-metaclass variable also provided by this
          /#    file, so we disable JSC_PROVIDES_NOT_SORTED.

          /# TODO(wmh): Verify these are still needed.
          /# suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')
          /# suppress_set.add('JSC_PROVIDES_NOT_SORTED')
          pass

        else:
          /# The code prefers to reference classes by long name (since some
          /# baselangs require it, and shortnames can be ambiguous if two
          /# different classes with the same name in different namespaces are
          /# required within the same class), so although closure would prefer
          /# we define
          /#    const Bar = goog.require('nm.sp2.Bar');
          /#    class Foo extends Bar { ... }
          /#                      ^^^
          /# we will often instead use:
          /#    const Bar = goog.require('nm.sp2.Bar');
          /#    class Foo extends nm.sp2.Bar { ... }
          /#                      ^^^^^^^^^^
          /# which generates the following error. Disabling this should never
          /# introduce any errors.
          if False:
            /# Disabled because it causes 'CR_SUPERFLUOUS_SUPPRESS' which
            /# cannot be disabled (see below).
            suppress_set.add('JSC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME')

          /# The previous suppress, when inserted unilaterally, is sometimes
          /# superfluous if the class does not use the long form of a class
          /# name when specifying a parent (for example when the parent is
          /# javascript Object, etc.).
          if False:
            /# This does not work as advertised ... adding it to the target does
            /# not stop the error from occurring.
            suppress_set.add('CR_SUPERFLUOUS_SUPPRESS')
          /#suppress_set.add('superfluousSuppress')

          /# Normal user-provided class.
          /#  - Suppose a method has a meta return type of 'str' (aka interned
          /#    string). In Meta, there is a "null" interned string instance
          /#    (although exactly what this means differs from baselang to
          /#    baseland ... in C++ it is a special instance of IStr, in Python
          /#    it is None, etc.).
          /#  - For now, we are using javascript 'null' to represent the null
          /#    interned string. This means that the javascript return type of a
          /#    method returning a meta 'str' should be '?string' (string or
          /#    null). However, if a particular method returns a literal string,
          /#    the compiler can tell that it is never null, and by default
          /#    produces an error of the form:
          /#      ERROR - The return type of the function "<somefunc>" is
          /#      nullable, but it always returns a non-null value. Consider
          /#      making the return type non-nullable.
          /#  - We cannot, in general, make the return type '!string' because some
          /#    other method that returns a meta 'str' might return null. For
          /#    the time being, we suppress this error within all closure_js_library
          /#    class build targets.
          /#### suppress_set.add('JSC_NULLABLE_RETURN_WITH_NAME')
          pass

          /# The following is required because in Javascript the <C>Class
          /# singleton instance of <C>MetaClass is defined in <C>MetaClass.js
          /# rather than <C>.js, and <C>.js has to goog.require <C>MetaClass.js
          /# to ensure that <C>Class is available, with no guarantees that the
          /# user will actually use it (and by default closure complains about
          /# extraneous requires).  It would be useful to NOT disable this
          /# warning, but this would require us to move the definition of
          /# <C>Class from <C>MetaClass.js to <C>Class.js (which would result
          /# in there always being a referecnce to <C>MetaClass within <C> to
          /# justify the goog.require.  The downside of this is if we want to
          /# at some point provide some optimizations whereby metaclass are
          /# not included in source code (if noop, not used, etc.), the current
          /# implementation is easy because all metaclass code is in a separate
          /# file, whereas the proposed implementation would scatter it across
          /# <C>.js and <C>MetaClass.js.
          /#### suppress_set.add('JSC_EXTRA_REQUIRE_WARNING')

          /# The following is needed for situations where a circularity exists
          /# between two classes where A needs B and B needs A.  This happens
          /# if in A there is a 'cls assoc B' and in B there is a 'cls assoc A'.
          /# To break this circularity, one must specify a target of "" in one
          /# of the assocs (e.g. 'cls assoc A target ""' in class B), but if
          /# this is done, bazel will complain with:
          /#   file.meta:1 (B.js:10) ERROR - Namespace not provided by any srcs or direct deps of //nm/sp:B.
          /# This error is disabled by CR_NOT_PROVIDED.
          /#
          /# IMPORTANT: We should NOT be inserting this always ... we should
          /# insert only in the special case of a circularity between classes.
          /# TODO(wmh): Figure out how to pass circularity info into this method
          /# so we can conditionally add CR_NOT_PROVIDED.

          /# 20170802: Disabled all of these (for now)
          /# 'CR_NOT_PROVIDED',
          /# Needed because CR_NOT_PROVIDED (above) generates this error.
          /#'CR_SUPERFLUOUS_SUPPRESS',
          /#'superfluousSuppress',

        if suppress_set:
          build['suppress'] = sorted(suppress_set)

      else:
        rule = None
        build = None

      /# print '%s: %s' % (rule, build)
      return rule, build
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if construct.kind() == 'class':
        /# TODO(wmh): Find a better way to handle header files external to Meta.
        /# For now, hacking Any to allow progress on C++ implementation.
        try:
          any_idx = targets.index('//:Any')
        except ValueError:
          pass
        else:
          targets[any_idx] = '//metastrap:Any'

        name = construct.id()
        data = {
          'name': name,
          'srcs': [name + '.cc'],
          'deps': targets,
          'visibility': ['//visibility:public'],
        }
        rule = 'cc_library'
        if test:
          rule = 'cc_test'
          data['size'] = 'small'
          data['srcs'].append(name + '.h')
        else:
          data['hdrs'] = [name + '.h']
        /# The -Iexternal/gtest/include is needed to support gtest.
        data.setdefault('copts', []).append('-Iexternal/gtest/include')

      else:
        rule = None
        data = None
      return rule, data
    test:
      test.defineClassAndMethods('cc')
      test.iseq(
        ('cc_library',
         {
          /# 'copts': ['-Imetastrap', '-Iexternal/gtest/include'],
          'name': 'Card',
          'visibility': ['//visibility:public'],
          'srcs': ['Card.cc'],
          'deps': [],
          'copts': ['-Iexternal/gtest/include'],
          'hdrs': ['Card.h']}),
        test.baselang.createBuildFragment(test.klass, []))
    end receiver OoplCpp;

  end behavior createBuildFragment;

  behavior emptyBlockCode : vec<str> #:
    Returns the lines of baselang code used to represent an empty block.

    In some languages this is an empty list, while others require a special
    syntax (e.g. Python's pass) while others may require some special
    value be returned to satisfy
  params:
    var executable : metax.oopl.ExecutableConstruct #:
      The executable for which empty block code is desired.  May be null,
      in which case the code should assume void return type.
    var message : str = null #:
      If present, the returned value should include code that will
      print out the message on stdout.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      /# TODO(wmh): The returned list should contain code within python for
      /# returning an appropriate dummy-value based on method return type!
      result = []
      if message:
        result.append('print "%s"' % message)

      if executable:
        /# We don't require 'returns' because we are currently calling this
        /# code in BehaviorConstruct.expandMeta() for ReceiverConstruct
        /# instances, which do not define a 'returns' but do define 'presence'.
        /# TODO(wmh): Consider cleaning this up.
        returns = executable.attrval('returns', default=None) if executable else None
        presence = executable.attrval('presence')

        if presence == 'abstract':
          /# No formal mechanism for marking a method abstract in Javascript,
          /# so we raise a runtime error.
          result.append(
            "raise NotImplementedError('%s');" % executable.fqn())
        if returns and not returns.isVoid():
          defval = self.defaultValue(returns)
          result.append('return %s' % defval)

      if not result:
        /# TODO(wmh): It is not sufficient to check if result is empty ... if
        /# it has 20 lines, but all of them are comments or empty, we will need
        /# a 'pass' statement.
        result.append('pass')

      return result
    test:
      test.defineClassAndMethods('py')
      test.iseqvec(['return 0'], test.baselang.emptyBlockCode(test.method2))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      result = []
      if message:
        result.append("console.log('%s');" % message)
      if executable:
        returns = executable.attrval('returns', default=None)
        presence = executable.attrval('presence')
        if presence == 'abstract':
          /# No formal mechanism for marking a method abstract in Javascript,
          /# so we raise a runtime error.
          result.append(
            "throw new Error('NotImplemented: %s');" % executable.fqn())
        elif returns and not returns.isVoid():
          /# Closure will complain if we don't return something from methods with
          /# return types, so we return the default value associated with the
          /# return type.
          defval = self.defaultValue(returns)
          result.append('return %s;' % defval)
      return result
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      result = []
      if message:
        result.append('std::cout << "%s" << std::endl;' % message)
      if executable:
        returns = executable.attrval('returns', default=None)
        presence = executable.attrval('presence')
        if presence == 'abstract':
          /# In C++, abstract methods have no body whatsoever.
          result = None
        elif returns is None:
          pass
        elif returns.isPtr():
          result = ['return nullptr;']
        elif returns.isVoid():
          /# We do not return anything.
          pass
        elif returns.isStr():
          /# Applies only to @str and &str (*str and str are isPtr)
          result.append(
            'return %s;' % self.defaultValue(metax.c.Type.Instance('@str')))
        elif returns.isPrimitive() and not returns.isRef():
          result.append('return %s;' % self.defaultValue(returns))
        else:
          /# For ref and value types, we create a static faux instance of the
          /# (base) return type and return it.
          /# TODO(wmh): Need mechanism for supporting class-based return types
          /# that do not have a default constructor.  Could also be useful in
          /# unittests to have a mechanism for creating dummy instances of each
          /# class, so consider adding syntax for such instances and using it
          /# to generate code here.
          /# TODO(wmh): Some class types will need even more specialized handling.
          /# For example, metatype '&ostream' should return std::cout or std::cerr,
          /# rather than creating a new instance.
          metabase = metax.c.Type.Instance('@' + returns.base())
          result.append('static %s dummy;' % self.typeToBase(metabase))
          result.append('return dummy;')
      return result
    test:
      test.defineClassAndMethods('cc')

      /# We make a copy of test.method2 so that we can change the return type.
      faux_parent = metax.attr.ComplexBlock(None, 'scope:', [])
      method = test.method2.clone(faux_parent)
      return_attr = method.attr('returns')

      /# Now verify various return types.
      for metatype_str, expected in (
        ('int', ['return 0;']),
        ('str', ['return nullptr;']),
        ('*str', ['return nullptr;']),
        ('@str', ['return std::string("");']),
        ('&str', ['return std::string("");']),
        ('nm.sp.A', ['return nullptr;']),
        ('*nm.sp.A', ['return nullptr;']),
        ('@nm.sp.A', ['static nm::sp::A dummy;', 'return dummy;']),
        ('&nm.sp.A', ['static nm::sp::A dummy;', 'return dummy;']),
      ):
        metatype = metax.c.Type.Instance(metatype_str)
        return_attr.valueIs(metatype)
        res = test.baselang.emptyBlockCode(method)
        test.iseq(
          expected, res, 'For "%s" expecting emptyBlockCode\n  %s\nnot\n  %s' % (
            metatype_str, expected, res))
    end receiver OoplCpp;

  end behavior emptyBlockCode;

  behavior establishTemplateName : str #:
    Obtain the name of the template to use to instantiate a method.
  params:
    var executable : metax.oopl.ExecutableConstruct #:
      The executable for which a template is desired.
    var defn : bool = false #:
      If true, obtain the template for the definition, not declaration.
  scope:
    abstract
    receiver BaseLanguageOopl;

    receiver OoplPython scope:
      return self.id()
    test:
      test.defineClassAndMethods('py')
      test.iseq('python', test.baselang.establishTemplateName(test.method))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      result = self.id()
      if not self.config('user_es2015', False):
        /# TODO(wmh): Add support for using oldstyle template if we are not
        /# generating ES2015 classes
        pass
      return result
    test:
      test.defineClassAndMethods('js')
      test.iseq('javascript', test.baselang.establishTemplateName(test.method))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      /# C++ has a distinction between decl and defn, and the output for
      /# testcase methods is quite different than for a normal method.
      result = self.id()
      if defn:
        result += '_defn'
      else:
        result += '_decl'

      if executable.isTestCase():
        result += '_test'

      return result
    test:
      test.defineClassAndMethods('cc')
      method = test.method
      test.iseq(
        'cpp_defn', test.baselang.establishTemplateName(method, defn=True))
      test.iseq(
        'cpp_decl', test.baselang.establishTemplateName(method, defn=False))

      /# We fake up a test class and test method associated with 'method'.
      klass = method.myclass()
      testclass = klass.clone(None)
      testclass.idIs('CardTest')
      testclass.underclassIs(klass)
      testmethod = method.clone(testclass.attr('scope:'))
      testmethod.idIs('test_show')
      testmethod.myclassIs(testclass)
      test.istrue(testclass.isTestCase())
      test.istrue(testmethod.isTestCase())

      /# Verify that we get the test templates for test methods.
      test.iseq(
        'cpp_defn_test',
        test.baselang.establishTemplateName(testmethod, defn=True))
      test.iseq(
        'cpp_decl_test',
        test.baselang.establishTemplateName(testmethod, defn=False))

      /# TODO(wmh): Verify that we do NOT get the test methods for methods in
      /# testcase classes that aren't test methods, and for test methods in
      /# non-testcase classes.
    end receiver OoplCpp;

  end behavior establishTemplateName;

  behavior finalizerName : str #:
    The name of the finalizer for a given class.

    In most baselangs, this is the name of the class. Specific baselangs
    can override this default implementation (e.g. python).
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      return '__del__'
    test:
      test.defineClassAndMethods('py')
      test.iseq('__del__', test.baselang.finalizerName(test.klass))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# According to
      /#   https://stackoverflow.com/questions/20266610/finalizers-for-javascript-objects
      /# There is no support for finalizers in Javascript.
      result = None
      return result
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      return '~' + klass.id()
    test:
      test.defineClassAndMethods('cc')
      test.iseq('~Card', test.baselang.finalizerName(test.klass))
    end receiver OoplCpp;

  end behavior finalizerName;

  behavior formatClassComment : vec<str> #:
    Format the 'comment' of a class.  This differs from the generic
    formatComment() method in that class comments may provide important
    information like fields, etc.

    Returns:
      The list of lines representing legal baselang syntax for a class
      comment/docstr.
  params:
    var attribute : metax.attr.SimpleBlock #:
      The comment attribute. If null, obtained from construct.
    var width : int = 80 #:
      Maximum width allowed.
    var suppress : map = null #:
      Where to write suppress commands (and reasons why).
    var default : vec<str> = null #:
      If present, and the comment is missing or empty, use this value
      as the comment.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if attribute:
        comment = self.simpleToBase(attribute, strip_comments=True)
      else:
        comment = []
      if not comment and default:
        comment.extend(default)
      comment = self.formatComment(comment, width=width)
      return comment
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if attribute:
        _, data = self.parseComment(attribute=attribute)
        construct = attribute.parent()
        visibility = construct.attrval('visibility')

        lines = self.simpleToBase(attribute, strip_comments=True)
        comment = []
        comment.append('/**')
        comment.append(' * %s' % construct.fqn())
        if False:
          comment.append(' * @fileoverview %s' % construct.kindfqn())
          comment.append(' *')
        for line in data['user']:
          comment.append(' *   ' + line)
        comment.append(' * @%s' % visibility)

        specials = data['special']
        suppress_str = specials.get('suppress', None)
        if suppress_str:
          suppress_list = re.split('\s*,\s*', suppress_str.strip())
          if suppress is not None:
            for supvar in suppress_list:
              suppress[supvar] = 'Explicit suppression by user in %s' % construct.kindfqn()
          /# This is the wrong place to add @suppress ... must be in a
          /# @fileoverview at the top of the file.
          /# comment.append(' * @suppress {%s}' % ','.join(sorted(suppress_list)))

        comment.append(' */')
      else:
        comment = []
      return comment
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if attribute:
        comment = self.simpleToBase(attribute, strip_comments=True)
        comment = self.formatComment(comment, width=width)
      else:
        comment = []
      return comment
    test:
    end receiver OoplCpp;

  end behavior formatClassComment;

  behavior formatClassType : tuple<str,str> #:
    Format a string representing a class name into a base fqn and meta fqn.

    Returns:
      0) the baselang fqn.
         The special value 'void' means 'no class'.
      1) the meta-level fqn.
  params:
    var metafile : MetaFile #:
      The metafile being processed (for reporting errors).
    var cstr : str #:
      The class string. Examples include the 'parent' value in class
      constructs and the primary value of 'assoc' constructs. May include
      an initial '^' character.
    var namespace : metax.oopl.NamespaceConstruct #:
      The namespace within which the class type resides.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      metafqn = metax.oopl.ClassConstruct.CanonicalizeClassName(cstr, namespace=namespace)
      if not metafqn:
        raise metax.c.Error('Should always have a class in python')
      basefqn = metafqn
      return basefqn, metafqn
    test:
      _, oopl, _, _ = test.cachedInfo()
      py = oopl.baselangNamed('python')
      construct = test.basics()
      metafile = test.metafile
      test.iseq(('object', 'object'), py.formatClassType(
        metafile, '^object', construct.namespace()))
      test.iseq(
        ('metax.c.MetaFile', 'metax.c.MetaFile'),
        py.formatClassType(metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('nm.sp.MetaFile', 'nm.sp.MetaFile'),
        py.formatClassType(metafile, 'MetaFile', construct.namespace()))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      metafqn = metax.oopl.ClassConstruct.CanonicalizeClassName(cstr, namespace=namespace)
      if not metafqn:
        raise metax.c.Error('Should always have a class in python')
      basefqn = metafqn
      return basefqn, metafqn
    test:
      baselang = test.baselang
      construct = test.basics()
      metafile = test.metafile
      test.iseq(('Object', 'Object'), baselang.formatClassType(
        metafile, '^Object', construct.namespace()))
      test.iseq(
        ('metax.c.MetaFile', 'metax.c.MetaFile'),
        baselang.formatClassType(
          metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('metax.c.MetaFile', 'metax.c.MetaFile'),
        baselang.formatClassType(
          metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('nm.sp.MetaFile', 'nm.sp.MetaFile'),
        baselang.formatClassType(
          metafile, 'MetaFile', construct.namespace()))
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      metafqn = metax.oopl.ClassConstruct.CanonicalizeClassName(cstr, namespace=namespace)
      if metafqn:
        basefqn = metafqn.replace('.', '::')
      else:
        basefqn = None
      return basefqn, metafqn
    test:
      baselang = test.baselang
      construct = test.basics()
      metafile = test.metafile
      test.iseq(('std::string', 'std.string'), baselang.formatClassType(
        metafile, '^std.string', construct.namespace()))
      test.iseq(
        ('metax::c::MetaFile', 'metax.c.MetaFile'),
        baselang.formatClassType(
          metafile, 'metax.c.MetaFile', construct.namespace()))
      test.iseq(
        ('nm::sp::MetaFile', 'nm.sp.MetaFile'),
        baselang.formatClassType(
          metafile, 'MetaFile', construct.namespace()))
    end receiver OoplCpp;

  end behavior formatClassType;

  behavior formatComment : vec<str> #:
    Format a list of strings representing a comment into syntax valid
    in this baselang.

    Returns:
      A modified copy of the input comment.
  params:
    var comment : vec<str> #:
      The list of lines to format. They can be modified in place.
    var width : int = 80 #:
      Maximum width allowed.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if comment is None:
        result = []
      else:
        result = comment[:]
      ncom = len(result)
      if ncom == 0:
        result = []
      elif ncom == 1:
        result[0] = '\"\"\"' + result[0] + '\"\"\"'
      else:
        result[0] = '\"\"\"' + result[0]
        result.append('\"\"\"')
      return result
    test:
      baselang = test.baselang
      comment = baselang.formatComment(['This is a test'])
      test.iseqvec(['\"\"\"This is a test\"\"\"'], comment)
      comment = baselang.formatComment(['This is a test', 'of two lines'])
      test.iseqvec(['\"\"\"This is a test', 'of two lines', '\"\"\"'], comment)
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if comment is None:
        result = []
      else:
        result = comment[:]
      rem = self.config('rem') + ' '
      for i in range(0, len(result)):
        result[i] = rem + result[i]
      return result
    test:
      _, oopl, _, _ = test.cachedInfo()
      js = oopl.baselangNamed('javascript')
      comment = js.formatComment(['This is a test'])
      test.iseqvec(['// This is a test'], comment)
      comment = js.formatComment(['This is a test', 'of two lines'])
      test.iseqvec(['// This is a test', '// of two lines'], comment)
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if comment is None:
        result = []
      else:
        result = comment[:]
      rem = self.config('rem') + ' '
      for i in range(0, len(result)):
        result[i] = rem + result[i]
      return result
    test:
      _, oopl, _, _ = test.cachedInfo()
      cc = oopl.baselangNamed('cpp')
      comment = cc.formatComment(['This is a test'])
      test.iseqvec(['// This is a test'], comment)
      comment = cc.formatComment(['This is a test', 'of two lines'])
      test.iseqvec(['// This is a test', '// of two lines'], comment)
    end receiver OoplCpp;

  end behavior formatComment;

  behavior formatDependencies : tuple<vec<str>,vec<str>> #:
    Analyze dependency data to produce imports and BUILD targets.

    NOTE: It is usually not necessary for subclasses to override this
    method. Instead, they can override formatDependency().  However, in
    some situations it may be easier to override this method entirely.

    Returns:
     0. The collection of baselang source lines importing dependencies
     1. The collection of BUILD targets needed to obtain dependencies.
  params:
    var class_construct : metax.oopl.ClassConstruct #:
      The class for which dependencies are being computed.
  scope:
    receiver BaseLanguageOopl scope:
      /# TODO(wmh): Although it is often possible to handle all dependencies by
      /# iterating over each dependency, there are some situations in some
      /# baselangs where dependencies interact. We may need to go back to a
      /# model where baselangs template formatDependencies() rather than
      /# formatDependency(). For example, javascript has some subtlties around
      /# this.
      deps = class_construct.deps()
      targets = set()
      imports = []
      for fqn in deps:
        import_str, target_str = self.formatDependency(
          class_construct, fqn)
        if import_str:
          imports.append(import_str)
        if target_str:
          targets.update(target_str.split(','))

      /# TODO(wmh): Sort std imports before non-std!
      imports = sorted(imports)

      return (imports, targets)
    end receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      /# Every header file in C++ includes the special metastrap/__Meta__.h
      /# file, which defines all the core types like meta::str, etc.
      class_construct.addDependency(
        'metastrap.__Meta__', 'lib',
        'implicit import in OoplCpp.formatDependencies',
        target='//metastrap:__Meta__')
      imports, targets = super(OoplCpp, self).formatDependencies(
        class_construct)
      return imports, targets

  end behavior formatDependencies;

  behavior formatDependency : tuple<str,str> #:
    Obtain baselang import text and bazel target for a given dependency.

    Returns:
     0. The baselang import text to add for the dependency. May be null.
     1. The bazel target to add for the dependency.
  params:
    var class_construct : metax.oopl.ClassConstruct #:
      The class for which a dependency is being computed.
    var fqn : str #:
      The dependency to format.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      deps = class_construct.deps()
      info = deps[fqn]
      kind = info['kind']
      target = info['target']
      reason = info['reason']
      alias = info.get('alias', None)
      alias_str = ' as %s' % alias if alias else ''

      if kind == 'cls':
        /# Note that 'target' will be class-specific, but Python does not
        /# (currently) have class-specific targets, only namespace targets.
        /# So we convert the class target to a namespace target.
        m = re.match(r'^([^:]+)/([^:]+):(\S+)$', target)
        if not m:
          raise metax.c.Error(
            'Failed to parse target "%s" when looking for namespace' % target)
        target = '%s/%s:%s' % (m.group(1), m.group(2), m.group(2))

        idx = fqn.rfind('.')
        if idx == -1:
          metafile.error('Invalid class type "%s"' % fqn)
          import_str = None
        else:
          import_str = 'import %s%s  # target=%s reason=%s' % (
            fqn[:idx], alias_str, target, reason)

      elif kind == 'lib':
        /# The target identifies a namespace, so we do not need to
        /# modify it.
        import_str = 'import %s%s  # target=%s reason=%s' % (
          fqn, alias_str, target, reason)

      elif kind == 'std':
        import_str = 'import %s%s' % (fqn, alias_str)
      else:
        raise metax.c.Error('Unknown kind "%s"' % kind)

      return import_str, target
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      deps = class_construct.deps()
      info = deps[fqn]
      kind = info['kind']
      target = info['target']

      /# TODO(wmh): If the base name of the class occurs multiple times amongst
      /# all triples, we will need to use alternative names or not produce
      /# shorthand names at all.

      if kind == 'cls':
        /# There are two special-cases that we need to deal with:
        /#   1) nm.sp.FooMeta is a request for the metaclass
        /#   2) nm.sp.MetaFoo is a request for the metaclass instance.
        /# They both reside in module nm/sp/FooMeta.js.
        /#
        /# CODE TANGLE: meta-disallowed
        if metax.oopl.ClassConstruct.IsMetaName(fqn):
          /# A request to import nm.sp.FooMeta.
          /#   const {FooMeta} = goog.require('nm.sp.FooMeta')
          parts = fqn.split('.')
          import_str = "const {%s} = goog.require('%s');" % (parts[-1], fqn)
        elif metax.oopl.ClassConstruct.IsMetaInstName(fqn):
          /# A request to import nm.sp.MetaFoo
          /#   const {MetaFoo} = goog.require('nm.sp.FooMeta')
          parts = fqn.split('.')
          metainst = parts[-1]
          parts[-1] = metax.oopl.ClassConstruct.MetaifyName(
            metax.oopl.ClassConstruct.UnmetainstifyName(metainst))
          import_str = "const {%s} = goog.require('%s');" % (
            metainst, '.'.join(parts))
        else:
          /# We define the assoc basename locally.  Note that if there are any
          /# other assocs in triples with the same basename this will yield an
          /# error ... must fix.
          import_str = "const %s = goog.require('%s');" % (
            fqn.split('.')[-1], fqn)

      elif kind == 'lib':
        /# TODO(wmh): Is there a way to import all classes in a namespace
        /# in Javascript?  Or does Meta need to determine which classes
        /# exist and import them?
        import_str = "goog.require('%s');" % fqn

      elif kind == 'std':
        /# TODO(wmh): Are there any std assocs in Javascript? Maybe the
        /# various modules in phantomjs? http://phantomjs.org/api/
        /#   webpage: http://phantomjs.org/api/webpage/
        /#   child_process: http://phantomjs.org/api/child_process/
        /#   fs: http://phantomjs.org/api/fs/
        /#   system: http://phantomjs.org/api/system/
        /#   webserver: http://phantomjs.org/api/webserver/
        /#
        /# For now, we simply ignore std assocs in javascript.
        import_str = None
      else:
        raise metax.c.Error('Unknown kind "%s"' % kind)

      return (import_str, target)
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      deps = class_construct.deps()

      info = deps[fqn]

      kind = info['kind']
      target = info['target']
      fqn_path = '/'.join(fqn.split('.'))

      if fqn_path == 'void':
        import_str = None

      elif kind == 'cls':
        import_str = '#include "%s.h"' % fqn_path

      elif kind == 'lib':
        /# TODO(wmh): In Python, this means "make all symbols within a namespace
        /# visible in the importing context, prefixed by the basename of the lib.
        /# What do we do in C++?
        import_str = '#include "%s.h"' % fqn_path

      elif kind == 'std':
        import_str = '#include <%s>' % fqn_path.replace('_h', '.h')
        target = None

      elif kind == 'decl':
        /# We are to forward declare the class only.
        raise metax.c.Error('Fix decl in C++')
        
      elif kind == 'def':
        /# We are to forward declare, *and* include the header file *after*
        /# the class definition.
        raise metax.c.Error('Fix def in C++')

      else:
        raise metax.c.Error('Unknown kind "%s"' % kind)

      return (import_str, target)
    test:
      test.defineClassAndMethods('cc')
      klass = test.klass
      klass.addDependency('metax.root.Object', 'cls', 'test1')
      klass.addDependency('demo.cards1.Card', 'lib', 'test2')
      klass.addDependency('ostream', 'std', 'test3')
      test.iseq(
        ('#include "metax/root/Object.h"', '//metax/root:Object'),
        test.baselang.formatDependency(test.klass, 'metax.root.Object'))
      test.iseq(
        ('#include "demo/cards1/Card.h"', '//demo/cards1/Card:Card'),
        test.baselang.formatDependency(test.klass, 'demo.cards1.Card'))
      test.iseq(
        ('#include <ostream>', None),
        test.baselang.formatDependency(test.klass, 'ostream'))
    end receiver OoplCpp;

  end behavior formatDependency;

  behavior formatExpr : str #:
    Convert an Expr to baselang syntax.

    TODO(wmh): FIX THIS!  BaseLanguageOopl.compileExpr() already does this,
    and much better.
  params:
    var value : any #:
      TODO(wmh): In the transitional period where we are switching 'default'
      and various other attributes from type 'word' to type 'expr', the value
      passed to this behavior may be an Expr or a string, and the code should
      handle both.  Once we are fully converted, we can remove the string
      handling code.
    var mtype : Type #:
      The type of the expression.  Only used if value is None, in which case
      the default value associated with this type is used.
    var construct : Construct #:
      A MethodConstruct or FieldConstruct, etc.
  scope:

    receiver BaseLanguageOopl scope:
      if value is None:
        /# CODETANGLE(special_expr): TODO(wmh): Decide whether <special> is
        /# indicated by an Expr with value() None, or by an Expr that is None.
        result = self.defaultValue(mtype)
      elif isinstance(value, basestring):
        result = value
      elif isinstance(value, metax.c.Expr):
        if True:
          metafile = construct.context().metafile()
          executable = construct if isinstance(construct, metax.oopl.ExecutableConstruct) else None
          result, restype = self.compileExpr(value, metafile, executable=executable)
        else:
          kind = value.kind()
          if kind == 'str':
            result = value.value()
            /# CODETANGLE(special_expr): TODO(wmh): Decide whether <special> is
            /# indicated by an Expr with value() None, or by an Expr that is None.
            if result is None:
              result = self.defaultValue(mtype)
          elif kind == 'id':
            result = value.value()
            /# TODO(wmh): Handle pseudovars here!
            /# result = self.pseudovars().get(result, result)
          elif kind == 'num':
            result = value.value()
          else:
            print '*** HERE with %s = %s' % (value, mtype.raw())
            result = 'fix me'
      else:
        raise metax.c.Error('Unknown value type %s for formatExpr' % type(value))
      return result
    end;

  end behavior formatExpr;

  behavior formatFieldDefinition : vec<str> #:
    Obtain the baselang code needed to define this field.
  params:
    var field : metax.oopl.FieldConstruct #:
      The field to format.
    var defn : bool = false #:
      For baselangs that do not distinguish between declaration and definition,
      this arg is ignored. For languages that do care, false (default) means
      generate field declaration code, true means generate field definition
      code.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      /# instance fields are defined in initializers, meta fields are
      /# defined in metaclass initializers, but static fields are defined
      /# here.
      kind = field.attrval('kind')
      if kind == 'static':
        default = field.attrval('default', default=None)
        mtype = field.attrval('type', default=metax.c.LOOKUP)
        /# print '%s : %s = %s' % (field.fqn(), mtype.raw(), default)

        /# TODO(wmh): Replace this with compileExpr() when we are fully
        /# migrated to 'default' always being of type 'expr'.
        basedef = self.formatExpr(default, mtype, field)
        result = ['%s = %s' % (field.rawfield(), basedef)]
      else:
        result = []
      return result
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# Fields are defined in initializers. No field-specific syntax.
      return []
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      result = []
      rawfield = field.rawfield()
      myclass = field.myclass()
      type_attr, metatype = field.attrpair('type', default=metax.c.LOOKUP)
      if metatype.isStr():
        /# The 'str' type should be implementable using:
        /#   const std::string
        /#   std::string_view
        /#   any class that
        /#    - provides the read-only portion of std::string API
        /#    - can support '*str' means nullable
        /#    - can support '&str' means non-nullable
        /#    - does not need to implement '*str' as a pointer to a class
        /#    - does not need to implement '&str' as a ref to a class
        /# Prefixes
        /#  - *str means the string value can be null (but does not necessarily
        /#    mean the instance of the class implementing the string has to
        /#    be null).
        /#  - &str means cannot be null
        /#  - @str means cannot be null and is pass-by-value
        /#  - str means *str (can be null)
        basetype = OoplCpp.CC_STR
      else:
        basetype = self.typeToBase(metatype, class_construct=myclass)
        /# print '****** %-20s %-30s = %s' % (rawfield, metatype, basetype)

      kind = field.attrval('kind')
      kindstr = 'static ' if kind == 'static' else ''
      value = ''
      if defn:
        if kind == 'static':
          if not value:
            value = self.defaultValue(metatype)
          result.append('')
          result.append('// static field %s : %s' % (field.id(), metatype.raw()))
          if value is None:
            code = '%s %s::%s;' % (basetype, myclass.id(), rawfield)
          else:
            code = '%s %s::%s = %s;' % (basetype, myclass.id(), rawfield, value)
          result.append(code)
      else:
        code = 'private: %s%s %s%s;' % (kindstr, basetype, rawfield, value)
        result.append(code)
      return result
    test:
    end receiver OoplCpp;

  end behavior formatFieldDefinition;

  behavior formatMethodComment : vec<str> #:
    Format the 'comment' of an executable.  This differs from the generic
    formatComment() method in that method comments often describe parameters,
    return types, etc. (in baselangs that don't have static typing).

    Returns:
      The list of lines representing legal baselang syntax for a method
      comment/docstr.
  params:
    var construct : metax.oopl.ExecutableConstruct #:
      The construct to format the comment of.
    var width : int = 80 #:
      Maximum width allowed.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      kind = construct.attrval('kind', default=metax.c.LOOKUP)
      params = construct.parsedParams()
      visibility = construct.attrval('visibility', default=metax.c.LOOKUP)
      returns = construct.attrval('returns', default=metax.c.LOOKUP)

      comment_attr, comdata = self.parseComment(
        construct=construct, parse_return=True)
      clines = comdata['user']

      pdata = params['data']
      if pdata:
        if not clines:
          clines.append('No comment provided.')
        if clines[-1]:
          clines.append('')
        clines.append('Args:')
        for param in pdata:
          clines.append('  %s: %s' % (param['name'], str(param['type'])))
          if 'comment' in param:
            for ln in param['comment']:
              clines.append('    ' + ln)

      if comdata['returns']:
        clines.append('')
        clines.append('Returns:')
        clines.extend(comdata['returns'])

      if clines is None:
        clines = []
      lines = self.formatComment(clines, width=width)
      return lines
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      suppress = set()
      lines = []
      lines.append('/**')

      attrkind = construct.attrval('kind')
      is_init = attrkind == 'initializer'
      myclass = construct.myclass()
      comment_attr, comdata = self.parseComment(
        construct=construct, parse_return=True)
      clines = comdata['user']
      if 'suppress' in comdata['special']:
        suppress.update(re.split('\s*,\s*', comdata['special']['suppress']))

      /# Add the user-provided documentation for this executable.
      lines.append(' * %s' % ('initializer' if is_init else construct.fqn()))
      if clines:
        for line in clines:
          lines.append(' *   ' + line)

      /# Add annotations for all parameters.
      params = construct.parsedParams()
      for param in params['data']:
        default = param.get('default', None)
        /# TODO(wmh): As of 2017-12-22, when providing the fully-qualified
        /# name of a type, closure produces the error:
        /#    metax/test/TestCase.js:445: ERROR - Reference to fully qualified import name 'goog.testing.PropertyReplacer' in JSDoc. Please use the short name 'PropertyReplacer' instead.
        /#       * @return {?goog.testing.PropertyReplacer}
        /#                   ^
        /#      ProTip: "JSC_JSDOC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME" or "lintChecks" or "strictModuleChecks" can be added to the `suppress` attribute of:
        /#      //metax/test:TestCase
        /# Adding JSC_JSDOC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME
        /# to the BUILD rule results in a
        /#    ERROR - Build rule (//metax/root:ObjectMetaRoot) contains superfluous suppress codes: CR_SUPERFLUOUS_SUPPRESS, JSC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME
        /#      ProTip: "CR_SUPERFLUOUS_SUPPRESS" or "superfluousSuppress" can be added to the `suppress` attribute of:
        /#      //metax/root:ObjectMetaRoot
        /# And adding "CR_SUPERFLUOUS_SUPPRESS" to the appropriate build target
        /# does NOT work as advertised ... the superfluous error persists.
        /#
        /# I would very much prefer to keep using fqns (not least of which
        /# because using only class names will not work in situations where
        /# a class needs nm.sp1.A and nm.sp2.A), but until
        /# "CR_SUPERFLUOUS_SUPPRESS" is working properly, we set defqn=True
        /# in the call to typeToBase().

        /#basetype2 = self.typeToBase(
        /#  param['type'], class_construct=myclass, defqn=False)
        basetype = self.typeToBase(
          param['type'], class_construct=myclass, defqn=True)
        /#print '%-30s = %-30s = %s' % (param['type'].raw(), basetype2, basetype)

        if default is None:
          lines.append(' * @param {%s} %s' % (basetype, param['name']))
        else:
          defval = default
          lines.append(' * @param {%s} [%s=%s]' % (
            basetype, param['name'], defval))
        pcom = param.get('comment', [])
        for line in pcom:
          lines.append(' *   ' + line)
      if 'varvec' in params or 'varmap' in params:
        lines.append(' * @param {*} varargs')

      /# Annotate the return type
      returns = construct.attrval('returns', default=metax.c.LOOKUP)
      if not returns.isVoid():
        /# See comment above about defqn - we need to do the same thing here.
        baseret = self.typeToBase(returns, class_construct=myclass, defqn=True)
        lines.append(' * @return {%s}' % baseret)
        if 'returns' in comdata:
          for rline in comdata['returns']:
            lines.append(' *   ' + rline)

      /# Record the visibility
      if is_init:
        /# jsdoc does not want us to annotate the visibility of the constructor.
        /# instead, we annotate the visibility of the class itself (done
        /# in OoplJavascript.formatClassConstruct()).
        pass
      else:
        visibility = construct.attrval('visibility', default=metax.c.LOOKUP)
        lines.append(' * @%s' % visibility)

      /# Handle initializer-specific annotations.
      kind = construct.attrval('kind', default=metax.c.LOOKUP)
      if kind == 'initializer':
        myclass = construct.myclass()
        pspec = myclass.parentclasses()[0]
        if False:
          lines.append(' * @constructor')
          /# TODO(wmh): How to declare the fields of a class properly?
          /# Using @property does not appear to work properly.
          /# TODO(wmh): Add an '@extends {class}' line for the parent.
          lines.append(' * @extends {%s}' % pspec['fqn'])

        if myclass.isTestCase():
          /# Meta<Javascript> generates javascript tests within subclasses of
          /# goog.testing.TestCase. However, the test-harness running code
          /# currently relies on some implicit behavior provided by goog.requiring
          /# goog.testing.jsunit.  This implicit behavior breaks if we add a
          /#   goog.provide('<the_test_class>')
          /# but google closure complains about
          /#   "JSC_MISSING_PROVIDE" or "missingProvide"
          /# if such a provide is not given.  For now, we suppress the warning in this
          /# situation, but finding a way to allow test classes to be defined normally
          /# would be best.
          /#
          /# TODO(wmh): Determine if this is still necessary
          /# suppress.add('missingProvide')
          pass

      /# Handle 'new' vs 'override' semantics.
      inheritance = construct.attrval('inheritance', default=metax.c.LOOKUP)
      if inheritance != 'new':
        lines.append(' * @override ')

      /# Suppress requested warnings.
      if suppress:
        lines.append(' * @suppress {%s}' % (','.join(sorted(suppress))))
      lines.append(' */')

      return lines
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      comment_attr, clines = construct.attrpair('comment:', default=None)
      kind = construct.attrval('kind', default=metax.c.LOOKUP)
      params = construct.parsedParams()
      visibility = construct.attrval('visibility', default=metax.c.LOOKUP)
      returns = construct.attrval('returns', default=metax.c.LOOKUP)

      /# TODO(wmh): Fix this ... using formatComment() temporarily.
      if clines is None:
        clines = []
      lines = self.formatComment(clines, width=width)
      return lines
    test:
      test.defineClassAndMethods('cc')
      test.iseqvec(
        ['// This is a test', '// of a multiline comment'],
        test.baselang.formatMethodComment(test.method))
    end receiver OoplCpp;

  end behavior formatMethodComment;

  behavior formatParams : vec<str> #:
    Format the params into baselang code.

    Returns:
      A list of baselang syntax, one element per parameter.
  params:
    var executable : metax.oopl.ExecutableConstruct #:
      The executable containing the params.
    var preamble : vec<str> #:
      Where to write any parameter-related preamble code.
    var decl : bool = false #:
      If true, format for declaration not definition.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      result = []
      kind = executable.attrval('kind')
      if kind == 'static':
        /# No receiver.
        pass
      else:
        rec = self.receiverStr(executable)
        assert rec is not None
        result.append(rec)

      params = executable.parsedParams()
      pdata = params['data']
      if pdata:
        for param in pdata:
          part = param['name']
          if 'default' in param:
            default = self.formatExpr(
              param['default'], param['type'], executable)
            defval = self.pseudovars().get(default, default)
            /# print '%s : %s = %s [%s]' % (param['name'], param['type'].raw(), param['default'], defval)
            part += '=' + defval
          result.append(part)
      if 'varvec' in params:
        result.append('*%s' % params['varvec']['name'])
      if 'varmap' in params:
        result.append('**%s' % params['varmap']['name'])

      return '(%s)' % ', '.join(result)
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      result = []
      rec = self.receiverStr(executable)

      variadics = []
      params = executable.parsedParams()
      pdata = params['data']
      if pdata:
        for param in pdata:
          part = param['name']
          if 'default' in param:
            default = self.formatExpr(
              param['default'], param['type'], executable)
            defval = self.pseudovars().get(default, default)
            /# As of ES2015, default parameters exist in javascript.
            /#   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters
            part += '=' + defval
          result.append(part)
      if 'varvec' in params:
        variadics.append(params['varvec'])
      if 'varmap' in params:
        variadics.append(params['varmap'])
      if variadics:
        result.append('varargs')
        /# http://usejsdoc.org/tags-param.html#multiple-types-and-repeatable-parameters
      return '(%s)' % ', '.join(result)
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      result = []
      rec = self.receiverStr(executable)
      myclass = executable.myclass()

      mutability = executable.attrval('mutability')
      presence = executable.attrval('presence')
      kind = executable.attrval('kind')

      variadics = []
      params = executable.parsedParams()
      pdata = params['data']
      if pdata:
        for param in pdata:
          basetype = self.typeToBase(param['type'], class_construct=myclass)
          part = basetype + ' ' + param['name']
          if 'default' in param:
            if decl:
              /# In C++, default args can be added to declaration or
              /# definition but not both.  Since the default args are part of
              /# the public interface, we assign them in decl not defn.
              default = self.formatExpr(
                param['default'], param['type'], executable)
              defval = self.pseudovars().get(default, default)
              part += ' = ' + defval
          result.append(part)
      if 'varvec' in params:
        variadics.append(params['varvec'])
      if 'varmap' in params:
        variadics.append(params['varmap'])
      if variadics:
        /# http://en.cppreference.com/w/cpp/language/variadic_arguments
        result.append('...')

      result = '(%s)' % ', '.join(result)
      if mutability == 'const' and kind != 'static':
        result += ' const'
      if presence == 'abstract':
        result += ' = 0'

      return result
    test:
      test.defineClassAndMethods('cc')
      method = test.method2
      method.myclass().namespaceIs(test.namespace)
      preamble = []
      test.iseq(
        '(meta::strview a, int32_t b = 1, bool c = false)',
        test.baselang.formatParams(method, preamble, decl=True))
      test.iseq(
        '(meta::strview a, int32_t b, bool c)',
        test.baselang.formatParams(method, preamble))
      test.iseqvec([], preamble)
    end receiver OoplCpp;

  end behavior formatParams;

  behavior formatParentSpec : str #:
    Obtain baselang syntax for how to define parents of a class.

    SideEffect:
      May register additional dependencies in class_construct via
      addDependency().

    Returns:
     0) the baselang syntax for defining the parents
     1) a list of triples containing 0 or more imports to include.
        Each element specifies (metafqn, kind, target) where kind is one of
        'cls' or 'std' or 'lib'.
  params:
    var class_construct : metax.oopl.ClassConstruct;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      parentclasses = class_construct.parentclasses()
      parentdata = parentclasses[0]
      metafqn = parentdata['metafqn']
      basefqn = parentdata['fqn']
      parentspec = basefqn or metafqn
      return parentspec
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      parentclasses = class_construct.parentclasses()
      parentdata = parentclasses[0]
      metafqn = parentdata['metafqn']
      basefqn = parentdata['fqn']
      parentspec = basefqn or metafqn

      /# TODO(wmh): If two different classes with the same name but differing
      /# namespaces are required within a class, we will not be able to
      /# produce the same shortname for both and the following assumption will
      /# be invalidated.  I'd prefer to use the long names always, but that
      /# is posing closure errors (missing require 'metax.root.ObjectMetaRoot',
      /# even though the require is not missing).
      parent_name = parentspec.split('.')[-1]

      /# Closure prefers that if we have introduced a short name for a class via
      /# 'goog.require', that we use the short name over the fully-qualified
      /# name. However, Meta often prefers to do the opposite because:
      /#  - some baselangs require fully qualified names (e.g. Perl)
      /#  - shortnames can be ambiguous if two different classes with the
      /#    same basename but differing namespaces are required within
      /#    the same class
      /#
      /# For example, closure prefers:
      /#    const Bar = goog.require('nm.sp2.Bar');
      /#    class Foo extends Bar { ... }
      /#                      ^^^
      /# But Meta often produces:
      /#    const Bar = goog.require('nm.sp2.Bar');
      /#    class Foo extends nm.sp2.Bar { ... }
      /#                      ^^^^^^^^^^
      /# This can generate a closure error of the form:
      /#   metax/root/ObjectMeta.js:10: ERROR - Reference to fully qualified
      /#   import name 'metax.root.ObjectMetaRoot'. Please use the short name
      /#   'ObjectMetaRoot' instead.
      /#
      /# Disabling this should never introduce any errors ... not sure why
      /# closure is even making a fuss about it.
      if '.' in parent_name:
        raise metax.c.Error('Should never get here')
        /# class_construct.suppress()['JSC_REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME_INCLUDING_SHORT_NAME'] = (
        /#   'Using fqn parent %s' % parent_name)

      /# Form the javascript syntax needed to declare class_construct to be
      /# a child of parent_name.
      parent_spec = ' extends ' + parent_name

      return parent_spec
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      parent_classes = class_construct.parentclasses()
      if parent_classes:
        parent_data = parent_classes[0]
        metafqn = parent_data['metafqn']
        basefqn = parent_data['fqn']

        /# Form the C++ syntax needed to declare class_construct to be
        /# a child of parent_name.
        if not basefqn:
          parent_spec = ''
        else:
          /# TODO(wmh): Generalize ... not always public inheritance.
          parent_spec = ' : public ' + basefqn

      else:
        parent_spec = ''
      return parent_spec
    test:
      test.defineClassAndMethods('cc')
      klass = test.klass
      test.iseq({}, klass.deps())
      test.iseq(
        ' : public metax::root::Object',
        test.baselang.formatParentSpec(klass))
    end receiver OoplCpp;

  end behavior formatParentSpec;

  behavior fqnToTarget : map #:
    Convert a fully-qualified name into a Bazel BUILD target and --test_args.

    Returns:
      namespace: str
        The namespace portion of the fqn
      class: str
        The class within the namepace. Not present if fqn is just a namespace.
      method: str
        The method within the namepace. Not present if fqn has no method.
      target: str
        The full BUILD target for the specified fqn.
      test_target: str
        The full BUILD target for the test target associated with specified fqn.
      test_arg: str
        The --test_arg value to pass to the target (not present if not needed)
      kind: str
        The kind of fqn ('namespace', 'class', or 'method'). Not present if
        error exists.
      path: str
        The path to a baselang file containing the fqn.
      test_path: str
        The path to a baselang file containing the test variant of fqn.
      error: str
        If present, the fqn is not valid, and this value explains why.
        Callers must test for present of this to establish success.
  params:
    var fqn : str #:
      The fully qualified namespace[.class[.method]] for which a target is
      desired.
  scope:
    receiver BaseLanguageOopl #:
      This implementation is applicable to baselanguages that have per-class
      BUILD targets and 'first-class' class files.
    scope:
      result = {}
      /# The smallest granularity of target is a class. For methods we use
      /# --test_arg.
      metac = self.compiler()
      metarep = metac.repositoryPath()
      fs = metac.fs()
      parts = fqn.split('.')
      k = len(parts)
      ispy = self.id() == 'python'

      /# Establish the namespace portion of the fqn.
      nmsps = []
      rootdir = fs.join(metarep, metac.basePath())
      ndir = rootdir
      i = 0
      while i < k:
        tdir = fs.join(ndir, parts[i])
        if not fs.isdir(tdir): break
        nmsps.append(parts[i])
        ndir = tdir
        i += 1

      if i == 0:
        /# Failed to find any namespaces.
        result['error'] = '%s does not represent a valid target' % fqn
      else:
        result['namespace'] = '.'.join(nmsps)
        testbase = metax.oopl.NamespaceConstruct.TestifyName(nmsps[-1])

        /# NOTE: We can determine whether the namespace is terminal (has classes)
        /# based on whether the _test version of the namespace exists.
        namespace_path = ndir
        namespace_test_path = metax.oopl.NamespaceConstruct.TestifyName(ndir)
        
        namespace_terminal = False
        if fs.isdir(namespace_test_path):
          namespace_terminal = True
        namespace_target = '//%s:%s' % ('/'.join(nmsps), nmsps[-1])
        namespace_test_target = (
          '//%s/%s:%s' % ('/'.join(nmsps[:-1]), testbase, testbase)
          if len(nmsps) > 1 else '//%s:%s' % (testbase, testbase))

        if i < k:
          /# Per-class map files are in .<name>.<suffix>.map (even in python)
          class_candidate = parts[i]
          /# In C++, self.suffix() is .cc, but we need to use .h because the
          /# .h.map file is guaranteed to have all symbols whereas .cc.map will
          /# not have header-inlined symbols.
          suffix = self.suffix()
          map_suffix = '.h' if self.id() == 'cpp' else suffix
          mapbase = '.%s%s.map' % (class_candidate, map_suffix)
          clsbase = '__init__.py' if ispy else class_candidate + suffix
          tstbase = '__init__.py' if ispy else metax.oopl.ClassConstruct.TestifyName(class_candidate) + suffix
          tbase = nmsps[-1] if ispy else class_candidate
          tfile = fs.join(ndir, mapbase)
          if fs.exists(tfile):
            /# We've verified a class name.
            result['target'] = (
              namespace_target if ispy else '//%s:%s' % ('/'.join(nmsps), tbase))
            result['test_target'] = (
              namespace_test_target if ispy
              else '//%s:%s' % (
                metax.oopl.NamespaceConstruct.TestifyName('/'.join(nmsps)),
                metax.oopl.ClassConstruct.TestifyName(class_candidate)))
            result['class'] = class_candidate
            result['path'] = fs.relpath(
              fs.join(namespace_path, clsbase), rootdir)
            if namespace_terminal:
              result['test_path'] = fs.relpath(
                fs.join(namespace_test_path, tstbase), rootdir)

            i += 1
            if i < k:
              /# The fqn is a method.
              /# To validate this, we can parse/grep tfile
              method_name = parts[i]
              verified = False
              with fs.open(tfile, 'r') as mfp:
                for line in mfp:
                  if fqn in line:
                    verified = True
                    break
              if verified:
                result['kind'] = 'method'
                result['method'] = method_name
                if ispy:
                  result['test_arg'] = '%s.%s' % (
                    metax.oopl.ClassConstruct.TestifyName(class_candidate),
                    metax.oopl.ExecutableConstruct.TestifyName(method_name))
                else:
                  result['test_arg'] = metax.oopl.ExecutableConstruct.TestifyName(method_name)
              else:
                result['error'] = '%s is not a method within %s' % (
                  method_name, fqn)
            else:
              /# The fqn is a class.
              result['kind'] = 'class'
              if ispy:
                result['test_arg'] = metax.oopl.ClassConstruct.TestifyName(class_candidate)
          else:
            /# Invalid class name.
            result['error'] = (
              '%s is not a namespace or class in %s' % (class_candidate, fqn))
        else:
          /# The fqn contains only namespaces.
          result['kind'] = 'namespace'
          result['target'] = namespace_target
          if namespace_terminal:
            result['test_target'] = namespace_test_target
          if ispy:
            result['path'] = fs.relpath(
              fs.join(namespace_path, '__init__.py'), rootdir)
            if namespace_terminal:
              result['test_path'] = fs.relpath(
                fs.join(namespace_test_path, '__init__.py'), rootdir)

      return result
    test:
      /# TODO(wmh): Add in additional class-based baselangs as they are supported.
      for bl in ('cc',):
        test.defineClassAndMethods('cc')
        test.iseqmap(
          {
            'namespace': 'metax',
            'target': '//metax:metax',
            'kind': 'namespace',
          },
          test.baselang.fqnToTarget('metax'))
        test.iseqmap(
          {
            'error': 'bad does not represent a valid target',
          },
          test.baselang.fqnToTarget('bad'))
        test.iseqmap(
          {
            'namespace': 'metax.root',
            'target': '//metax/root:root',
            'test_target': '//metax/root_test:root_test',
            'kind': 'namespace',
         },
          test.baselang.fqnToTarget('metax.root'))
        test.iseqmap(
          {
            'namespace': 'metax',
            'error': 'bad is not a namespace or class in metax.bad',
          },
          test.baselang.fqnToTarget('metax.bad'))
        test.iseqmap(
          {
            'namespace': 'metax.root',
            'class': 'Object',
            'target': '//metax/root:Object',
            'test_target': '//metax/root_test:ObjectTest',
            'path': 'metax/root/Object.cc',
            'test_path': 'metax/root_test/ObjectTest.cc',
            'kind': 'class',
          },
          test.baselang.fqnToTarget('metax.root.Object'))
        test.iseqmap(
          {
            'namespace': 'metax.root',
            'class': 'Object',
            'method': 'Init',
            'target': '//metax/root:Object',
            'test_target': '//metax/root_test:ObjectTest',
            'path': 'metax/root/Object.cc',
            'test_path': 'metax/root_test/ObjectTest.cc',
            'test_arg': 'test_Init',
            'kind': 'method',
          },
          test.baselang.fqnToTarget('metax.root.Object.Init'))
        test.iseqmap(
          {
            'namespace': 'metax.root',
            'class': 'Object',
            'target': '//metax/root:Object',
            'test_target': '//metax/root_test:ObjectTest',
            'path': 'metax/root/Object.cc',
            'test_path': 'metax/root_test/ObjectTest.cc',
            'error': 'bad is not a method within metax.root.Object.bad',
          },
          test.baselang.fqnToTarget('metax.root.Object.bad'))

      /# Python is a special case.
      test.defineClassAndMethods('py')
      test.iseqmap(
        {
          'namespace': 'metax',
          'target': '//metax:metax',
          'path': 'metax/__init__.py',
          'kind': 'namespace',
        },
        test.baselang.fqnToTarget('metax'))
      test.iseqmap(
        {
          'error': 'bad does not represent a valid target',
        },
        test.baselang.fqnToTarget('bad'))
      test.iseqmap(
        {
          'namespace': 'metax.root',
          'target': '//metax/root:root',
          'test_target': '//metax/root_test:root_test',
          'kind': 'namespace',
          'path': 'metax/root/__init__.py',
          'test_path': 'metax/root_test/__init__.py',
       },
        test.baselang.fqnToTarget('metax.root'))
      test.iseqmap(
        {
          'namespace': 'metax',
          'error': 'bad is not a namespace or class in metax.bad',
        },
        test.baselang.fqnToTarget('metax.bad'))
      test.iseqmap(
        {
          'namespace': 'metax.root',
          'class': 'Object',
          'target': '//metax/root:root',
          'test_target': '//metax/root_test:root_test',
          'test_arg': 'ObjectTest',
          'kind': 'class',
          'path': 'metax/root/__init__.py',
          'test_path': 'metax/root_test/__init__.py',
        },
        test.baselang.fqnToTarget('metax.root.Object'))
      test.iseqmap(
        {
          'namespace': 'metax.root',
          'class': 'Object',
          'method': 'Init',
          'target': '//metax/root:root',
          'test_target': '//metax/root_test:root_test',
          'test_arg': 'ObjectTest.test_Init',
          'kind': 'method',
          'path': 'metax/root/__init__.py',
          'test_path': 'metax/root_test/__init__.py',
        },
        test.baselang.fqnToTarget('metax.root.Object.Init'))
      test.iseqmap(
        {
          'namespace': 'metax.root',
          'class': 'Object',
          'target': '//metax/root:root',
          'test_target': '//metax/root_test:root_test',
          'error': 'bad is not a method within metax.root.Object.bad',
          'path': 'metax/root/__init__.py',
          'test_path': 'metax/root_test/__init__.py',
        },
        test.baselang.fqnToTarget('metax.root.Object.bad'))
    end;

  end behavior fqnToTarget;

  behavior initializerName : str #:
    The name of the initializer for a given class.

    In most baselangs, this is the name of the class. Specific baselangs
    can override this default implementation (e.g. python).
  params:
    var klass : metax.oopl.ClassConstruct;
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      return '__init__'
    test:
      test.defineClassAndMethods('py')
      test.iseq('__init__', test.baselang.initializerName(test.klass))
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if self.config('use_es2015'):
        /# In javascript using ES2015 class definitions, the initializer is
        /# always 'constructor.  See
        /# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
        result = 'constructor'
      else:
        /# Old-style javascript is different than most other languages, in that
        /# the class is defined (not just initialized) by a function with the
        /# same name as the class. The new class syntax of ES2015 is much
        /# cleaner, but this code path is supported in case we want to use
        /# non-class syntax.
        result = klass.id()
      return result
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      return klass.id()
    test:
    end receiver OoplCpp;

  end behavior initializerName;

  behavior metaMethodBody : vec<str> #:
    Returns the list of lines in baselang syntax used to implement the
    special 'meta' method in every user-level class to return the
    singleton instance of the metaclass.
  params:
    var metainst : str #:
      The name of the baselang variable containing the metaclass instance.
    var metaclass : metax.oopl.ClassConstruct #:
      The metaclass construct. May be null, in which case there is no
      metaclass ... appropriate code should be returned for that situation.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if metaclass:
        meta_body = []
        meta_body.append('result = self.__class__')
        /# TODO(wmh): The following code use to do the following:
        /#   assert result is <class>
        /#   assert result is Meta<class>
        /# However, this breaks in situations where a class does not generate
        /# an implicit 'meta' method (e.g. classes that do not generate a
        /# meta class).  So we have changed the code to:
        /#   assert issubclass(result, <class>)
        /#   assert issubclass(result, Meta<class>)
        /# Look into whether this needs further cleanup/removal/reversion.

        meta_body.append('assert issubclass(result, %s)' % metaclass.underclass().id())
        underclass = metaclass.underclass()
        if not underclass.isTestCase():
          /# CODETANGLE(metainst_for_testclass): We do not currently generate
          /#   MetaFooTest = FooTest
          /# for testcase classes because it causes every method defined on
          /# the test class to be executed twice.
          meta_body.append('assert issubclass(result, %s)' % metainst)
        meta_body.append('return result')
      else:
        meta_body = ['return None']
      return meta_body
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      if metaclass:
        meta_body = ['return %s;' % metainst]
      else:
        meta_body = ['return null;']
      return meta_body
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if metaclass:
        meta_body = ['return %s;' % metainst]
      else:
        meta_body = ['return nullptr;']
      return meta_body
    test:
      test.defineClassAndMethods('cc')
      test.iseqvec(
        ['return MetaCard;'],
        test.baselang.metaMethodBody('MetaCard', test.metaclass))
    end receiver OoplCpp;

  end behavior metaMethodBody;

  behavior parseBazelLog : any #:
    Perform baselang-specific parsing of a bazel test log file.
  params:
    var logdata : str #:
      The entire content of the logfile.
    var tdata : map #:
      Where to write info.  The following keys must be provided:
        status2: str
          One of 'FATAL' or ...
        count: int
          Number of tests ran
        time2: str
          Amount of time taken to run all tests (num plus time unit)
        methods: dict
          maps class.method to map:
            stdout: str
              the stdout of the test method
            stderr: str
              the stderr of the test method
            us: int
              microseconds taken for this method test
            ok: bool
              True if test passed, false if it failed.
    var debug : bool = false #:
      If true, enable debugging output.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      if debug:
        dsep('OoplPython.parseBazelLog Input', delim='@')
        print logdata
        print tdata
        dsep('OoplPython.parseBazelLog Input', delim='@', end=True)
      methods = tdata['methods']

      /# Parse the test.log file.  Contains following structure
      /#   exec ${PAGER:-/usr/bin/less} "$0" || exit 1
      /#   -----------------------------------------------------------------------------
      /#   <one_char_per_test>
      /#   <errors>
      /#   ----------------------------------------------------------------------
      /#   <summary>
      /#
      /#   <status>
      /#   <stdout>
      /#
      /# where
      /#   <one_char_per_test> is '.' or 'E' or ?
      /#   <errors> starts with a line of '======'
      /#   <summary> is of form "Ran 2 tests in 0.001s"
      /#   <status> is of form "FAILED (errors=1)" or "OK"
      /#   <stdout> is the stdout from the test
      /#     - when using Meta infrastructure, setUp() prints out the name
      /#       of the class and method followed by '...'
      /#     - the code executed by the test may add arbitrary output
      /#     - the Meta infrastructure, in tearDown(), prints out the
      /#       time taken in microseconds and ERROR or FAIL if error occurred.
      summary_re = re.compile(
        r'\nRan (?P<count>\d+) tests? in (?P<time>\S+)')
      status_re = re.compile(
        r'\n(?P<status>FAILED|OK)(?: \((?P<counts>\S+)\))?\s*')
      sum = summary_re.search(logdata)
      stat = status_re.search(logdata)
      if not sum or not stat:
        print
        print 'summary: %s' % sum
        print 'status : %s' % stat
        print logdata
        print 'ERROR: Failed to find expected match(es)'
        tdata['status2'] = 'FATAL'
        return

      statdata = stat.groupdict()
      sumdata = sum.groupdict()
      /# print '#' * 70; print target; print statdata; print sumdata

      tdata['count'] = int(sumdata['count'])
      tdata['time2'] = sumdata['time']
      tdata['status2'] = statdata['status']

      /# Obtain error text
      /#  - everything before the start of the sum match if ============ exists
      eqidx = logdata.find('\n=======================')
      if eqidx == -1:
        errors = ''
      else:
        errors = logdata[eqidx:sum.start(0)]
      /#print errors

      /# Now parse the error text
      /#  - after splitting, edata will contain 3K+1 elements where K is the
      /#    number of errors
      /#  - index 0 is text before the first error
      /#     - stdout from code outside test method invocations (useful for
      /#       debugging).
      /#  - within the 3-tuple:
      /#     - index 0 is the name of the method
      /#     - index 1 is the name of the class
      /#     - index 2 is the error text
      ere = re.compile(r'\nERROR: test_(\S+)\s+\(\S+\.(\S+)\)\n')
      edata = ere.split(errors)
      n = len(edata)
      assert (n-1) % 3 == 0
      preout = edata[0].strip()
      if False and preout:
        print '-' * 70
        print preout
        print '-' * 70
        pprint.pprint(edata)

      i = 1
      while i < n:
        method_name = edata[i]
        class_name = edata[i+1]
        assert class_name.endswith('Test')
        class_name = class_name[:-4]
        cmname = class_name + '.' + method_name
        stderr = edata[i+2]
        methods.setdefault(cmname, {})['stderr'] = stderr
        i += 3

      /# Parse the stdout
      /#  - everything after the end of the stat match.
      /#  - consists of
      /#     <class>.<method>     ...<stdout> <time> <status>
      /#    where
      /#      <class> is the name of the class being tested (not test class)
      /#      <method> is the name of the method being tested (not test method)
      /#      <stdout> is whatever was written to stdout when test was run.
      /#               (may contain newlines)
      /#      <time> is how long the test took (<num> ' us')
      /#      <status> is optional and is either ERROR or FAILED
      stdout = logdata[stat.end(0)-1:]  # -1 so we start on a newline (ore below relies on it)
      if stdout[0] != '\n':
        print '#' * 70
        print logdata
        print '-' * 70
        print stdout
        print '#' * 70
        return

      ore = re.compile(
        r'\n(?P<cmname>[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+)\s+\.\.\.')
      tre = re.compile(r' *(?P<us>\d+) us\s+')
      olines = ore.split(stdout)
      n = len(olines)
      assert (n-1) % 2 == 0
      /# There are 2K+1 elements in olines (first element is text before
      /# first method (ignored)). Within each pair of elements thereafter,
      /# first is class.method, second is output (including time at end)
      i = 1
      while i < n:
        cmname = olines[i]
        stdout = olines[i+1]
        tm = tre.search(stdout)
        mdata = methods.setdefault(cmname, {})
        if not tm:
          raise metax.c.Error('Failed to parse microseconds from "%s"' % stdout)
        mdata['us'] = int(tm.group('us'))
        /# We remove the time data from stdout
        stdout = stdout[:tm.start(0)]
        mdata['stdout'] = stdout
        i += 2
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      methods = tdata['methods']

      if debug:
        dsep('OoplJavascript.parseBazelLog Input', delim='@')
        print logdata
        print tdata
        dsep('OoplJavascript.parseBazelLog Input', delim='@', end=True)

      msre = re.compile(r'^(\d{2}):(\d{2}):(\d{2})\.(\d{3})$')

      def StrToMs(val):
        /# Convert a string in form HH:MM:SS.mmm into milliseconds.
        m = msre.match(val)
        if not m: raise metax.c.Error('Invalid ms "%s"' % val)
        seconds = int(m.group(1)) * 3600 + int(m.group(2)) * 60 + int(m.group(3))
        ms = seconds * 1000 + int(m.group(4))
        return ms

      class_start_re = re.compile(
        r'\n-> (?P<time>\S+) : Starting tests: (?P<fqn>\S+)\n')
      class_end_re = re.compile(
        '\n-> (?P<time>\S+) : (?P<runcount>\d+) of (?P<count>\d+) tests run in (?P<duration>\S+)\.\n')
      method_start_re = re.compile(
        r'^-> (?P<time>\S+) : Running test: (?P<method>\S+)')

      tdata['status2'] = '???'

      ms = class_start_re.search(logdata)
      me = class_end_re.search(logdata)
      if ms and me:
        fqn = ms.group('fqn')
        parts = fqn.split('.')
        class_name = metax.oopl.ClassConstruct.UntestifyName(parts[-1])
        namespace_name = '.'.join(parts[:-1])

        tdata['subcount'] = int(me.group('runcount'))
        tdata['count'] = int(me.group('count'))
        tdata['time2'] = me.group('duration')

        methdata = logdata[ms.end(0):me.start(0)]
        if methdata.strip():
          end_re = None
          method = None
          stdout = None

          if debug:
            print methdata
            print '=' * 70

          for line in methdata.split('\n'):
            m = method_start_re.match(line)
            if m:
              test_method_name = m.group('method')
              method_name = metax.oopl.ExecutableConstruct.UntestifyName(test_method_name)
              end_re = re.compile(
                '^-> (?P<time>\S+) : %s : (?P<status>\S+)' % test_method_name)
              cmname = class_name + '.' + method_name
              stdout = []

              if debug:
                print 'Found test method: %s' % str(m.groupdict())

              mdata = methods.setdefault(cmname, {})
              mdata['start'] = m.group('time')
            elif end_re is None:
              print '**** IGNORING %s' % line
            else:
              /# We should always find a method_start before we need end_re.
              m = end_re.match(line)
              if m:
                /# Found end of method.
                mdata['stdout'] = '\n'.join(stdout)
                /# TODO(wmh): Where is stderr written??? Remember that this
                /# isn't necessarily actually stderr, but rather any error
                /# output produced while running the test.
                /# NOTE(wmh): Only add 'stderr' if there are actual errors.
                mdata['end'] = m.group('time')
                mdata['us'] = (StrToMs(mdata['end']) - StrToMs(mdata['start'])) * 1000
                if debug:
                  print 'Found end of method: %s' % str(mdata)
                end_re = None
                stdout = None
              else:
                assert line.startswith('-> ')
                stdout.append(line[3:])

          if stdout:
            print '***** ERROR! Have left-over stdout'
            print '\n'.join(stdout)

          if debug:
            print '@' * 70

      else:
        print 'ERROR: Failed to find class tests!'

      /#import pprint; pprint.pprint(tdata)
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      if debug:
        dsep('OoplCpp.parseBazelLog Input', delim='@')
        print logdata
        print tdata
        dsep('OoplCpp.parseBazelLog Input', delim='@', end=True)
      methods = tdata['methods']

      /# Parse the test.log file. You can see the output interactively with:
      /#   % cd ./tests/cc/gtest/src
      /#   % blaze test --test_output=all :PersonTest
      /#
      /# Contains following structure
      /#   exec ${PAGER:-/usr/bin/less} "$0" || exit 1
      /#   -----------------------------------------------------------------------------
      /#   <env_initializer_output>
      /#   [==========] Running <M> tests from <N> test case.
      /#   [----------] Global test environment set-up.
      /#   <env_setup_output>
      /#   [----------] <M> tests from FrenchDeckTest
      /#   <clsetup_output>
      /#   [ RUN      ] <class>Test.test_<method>
      /#   <initializer_output>
      /#   <setup_output>
      /#   <output>
      /#   <teardown_output>
      /#   <finalizer_output>
      /#   [       OK ] <class>Test.test_<method> (<ms> ms)
      /#   [ RUN      ] <class>Test.test_<method2>
      /#   <*_output2>
      /#   ...
      /#   [  FAILED  ] <class>Test.test_<method2> (<ms2> ms)
      /#   [ RUN      ] <class>Test.test_<method3>
      /#   <*_output3>
      /#   ...
      /#   [       OK ] <class>Test.test_<method3> (<ms3> ms)
      /#   ...
      /#   <clteardown_output>
      /#   [----------] <M> tests from <class>Test (<class_ms> ms total)
      /#
      /#   [----------] Global test environment tear-down
      /#   <env_teardown_output>
      /#   [==========] 3 tests from 1 test case ran. (1 ms total)
      /#   [  PASSED  ] 2 tests.
      /#   [  FAILED  ] 1 test, listed below:
      /#   [  FAILED  ] FrenchDeckTest.test_asStr
      /#
      /#    1 FAILED TEST
      /#   <env_finalizer_output>
      /#
      /# where
      /#   <env_initializer_output>
      /#     output in the initializer of the global Environment subclass
      /#     (usually not provided unless we make it a namespace-wide option).
      /#   <env_setup_output>
      /#     output from Environment::SetUp()
      /#   <clsetup_output>
      /#     output from <class>Test::SetUpTestCase()
      /#   <initializer_output>
      /#     output from <class>Test::<class>Test
      /#   <setup_output>
      /#     output from <class>Test::SetUp()
      /#   <output>
      /#     output from <class>Test::test_<method>
      /#   <teardown_output>
      /#     output from <class>Test::TearDown()
      /#   <finalizer_output>
      /#     output from <class>Test::~<class>Test
      /#   <clteardown_output>
      /#     output from <class>Test::TearDownTestCase()
      /#   <env_teardown_output>
      /#     output from Environment::TearDown()
      /#   <env_finalizer_output>
      /#     output from Environment::~Environment()

      def StrToMicroSeconds(tstr):
        assert tstr.endswith(' ms')
        return int(tstr[:-3]) * 1000

      /# The following is a collection of regexps that should match lines in
      /# logdata. Any line not matching one of these is output associated with
      /# the section identified by the current index.
      /#
      /# Index 7 is special in that we can transition either to index 8 or
      /# index 5 (this cycle allows us to parse multiple test methods).
      regexps = [
        re.compile(r'^exec.*PAGER.*exit'),
        re.compile(r'^---{50,}$'),
        re.compile(
          r'\[==========\] Running (?P<count>\d+) tests from 1 test case\.$'),
        re.compile(
          r'\[----------\] Global test environment set-up\.$'),
        re.compile(
          r'\[----------\] (?P<count>\d+) tests from (?P<class>\S+)Test$'),

        /# This starts the parsing of a test method
        re.compile(
          r'\[ RUN      \] (?P<class>\S+)Test\.test_(?P<method>\S+)$'),

        /# This ends the parsing of a test method.
        re.compile(
          r'\[\s*(?P<mstatus>OK|FAILED)\s*\] '
          r'(?P<class>\S+)Test\.test_(?P<method>\S+) \((?P<mtime>\d+\s*\S+)\)'),

        /# This is the special regexp ... if we are looking for this one,
        /# we need to also check for index 5 (if index 5 matches, we loop
        /# back, processing another test).
        re.compile(
          r'\[----------\] (?P<count>\d+) tests from (?P<class>\S+)Test '
          r'\((?P<time2>\d+ \S+) total\)$'),

        re.compile(
          r'\[----------\] Global test environment tear-down'),
        re.compile(
          r'\[==========\] (?P<count>\d+) tests from 1 test case ran.*'),
        re.compile(r'\[  PASSED  \] (?P<passed>\d+) tests\.'),
        re.compile(r'\[  FAILED  \] (?P<failed>\d+) test, listed below:'),
      ]

      outputs = {5: ['']}
      matches = {}
      order = []
      index = 0

      if debug:
        print '@' * 70
        print logdata
        print '@' * 70

      for line in logdata.split('\n'):
        if debug:
          print '### %s' % line
        if index >= len(regexps):
          outputs.setdefault(index, []).append(line)
        else:
          m = regexps[index].match(line)
          if m:
            /# We have found a new regexp. We advance the regexp index. Any
            /# line that doesn't match against the next regexp is added to
            /# outputs[index-1] (with index 7 being special).
            if debug:
              print 'Found index %d: %s for %s' % (index, str(m.groupdict()), line)
            matches[index] = m.groupdict()
            index += 1
          else:
            /# For every index except 7, the only transition is to index+1.
            /# However, at index 7, we can transition to either 8 or 5, so
            /# the code below checks for the transition to 5.  This means
            /# we are finished parsing one test method and are parsing
            /# another (instead of finishing the parsing of methods).
            if index == 7:
              m = regexps[5].match(line)
              if m:
                /# We are current on the line after the line matching index 6.
                /# There are only two possible matches:
                /#  1) it matches index 7, which ends the method-specific part
                /#     of parsing
                /#  2) it matches index 5, the start of another unittest.
                /#
                /# We are in situation #2 ... it matches index 5. This means
                /# we've just finished processing a test method, with the
                /# (merged) stdout and stderr available in outputs[5] and
                /# some additional info available in matches[5] and matches[6]
                order.append((matches[5], matches[6], outputs[5]))
                matches[5] = m.groupdict()
                outputs[5] = []
                index = 6
              else:
                outputs.setdefault(index - 1, []).append(line)
            else:
              /# The current line did not match next (or prev) regexp, so
              /# it belongs to the output for index-1.
              outputs.setdefault(index - 1, []).append(line)
              if index == 8:
                /# We've matched index 7, so we've parsed the final test method.
                order.append((matches[5], matches[6], outputs[5]))

      /# Now we parse 'order' into 'methods'
      for start_dict, end_dict, outlines in order:
        assert start_dict['class'] == end_dict['class']
        assert start_dict['method'] == end_dict['method']
        cmname = '%s.%s' % (start_dict['class'], start_dict['method'])
        ok = end_dict['mstatus'] == 'OK'
        mdata = {
          'us': StrToMicroSeconds(end_dict['mtime']),
          'ok': ok
        }
        stdout = []
        stderr = []
        tlines = stdout
        tre = re.compile(r': Failure$')
        if outlines:
          if outlines[0] == '':
            outlines.pop(0)
          /# We assume everything in outlines is stdout until we find a line
          /# matching tre, after which we assume everything is stderr.
          for line in outlines:
            m = tre.search(line)
            if m:
              tlines = stderr
            tlines.append(line)
        if stdout:
          mdata['stdout'] = '\n'.join(stdout)
        if stderr:
          mdata['stderr'] = '\n'.join(stderr)
        methods[cmname] = mdata

      /# Establish overall status2
      if 11 in matches:
        assert matches[11]['failed'] > 0
        status = 'FAILED'
      else:
        status = 'OK'
      tdata['status2'] = status

      /# Establish count of number of tests.
      count = matches[7]['count']
      assert count == matches[4]['count']
      tdata['count2'] = int(count)

      /# Establish time taken for all tests.
      tdata['time2'] = matches[7]['time2']

      if debug:
        for i in sorted(outputs):
          print i
          for line in outputs[i]:
            print '  ' + line
        pprint.pprint(matches)
        pprint.pprint(order)
        for key in methods:
          print '%-20s: %s' % (key, methods[key])

    test:
      logdata = (
        >|"""exec ${PAGER:-/usr/bin/less} "$0" || exit 1
        >|-----------------------------------------------------------------------------
        >|[==========] Running 3 tests from 1 test case.
        >|[----------] Global test environment set-up.
        >|[----------] 3 tests from FrenchDeckTest
        >|[ RUN      ] FrenchDeckTest.test_FrenchDeck
        >|Fix C++ teardown
        >|[       OK ] FrenchDeckTest.test_FrenchDeck (0 ms)
        >|[ RUN      ] FrenchDeckTest.test_asStr
        >|unknown file: Failure
        >|C++ exception with description "TestCase.iseq() not yet implemented" thrown in the test body.
        >|Fix C++ teardown
        >|[  FAILED  ] FrenchDeckTest.test_asStr (1 ms)
        >|[ RUN      ] FrenchDeckTest.test_meta
        >|Fix C++ teardown
        >|[       OK ] FrenchDeckTest.test_meta (0 ms)
        >|[----------] 3 tests from FrenchDeckTest (1 ms total)
        >|
        >|[----------] Global test environment tear-down
        >|[==========] 3 tests from 1 test case ran. (1 ms total)
        >|[  PASSED  ] 2 tests.
        >|[  FAILED  ] 1 test, listed below:
        >|[  FAILED  ] FrenchDeckTest.test_asStr
        >|
        >| 1 FAILED TEST
        >|""")
      tdata = {
        'methods': {},
        /# 'log': logdata, 'logpath': '?', 'dir': '?', 'namespace': '?', 'class': '?'
      }
      baselang, _, _, _ = test.cachedInfo('cc')
      baselang.parseBazelLog(logdata, tdata, debug=False)

      test.iseq(
        {'count2': 3,
         'status2': 'FAILED',
         'time2': '1 ms',
         'methods': {
           'FrenchDeck.FrenchDeck': {
             'ok': True,
             'stdout': 'Fix C++ teardown',
             'us': 0,
           },
           'FrenchDeck.asStr': {
             'ok': False,
             'stderr': 'unknown file: Failure\nC++ exception with description "TestCase.iseq() not yet implemented" thrown in the test body.\nFix C++ teardown',
             'us': 1000,
           },
           'FrenchDeck.meta': {
             'ok': True,
             'stdout': 'Fix C++ teardown',
             'us': 0,
           },
         },
        }, tdata, pprint.pformat(tdata))
    end receiver OoplCpp;

  end behavior parseBazelLog;

  behavior processTestOutput #:
    Process the output of non-bazel execution of the baselang test harness.
    Note that various baselangs rely on bazel to provide a testing harness,
    cannot be invoked without bazel (and thus don't have a definition here).
  params:
    var stdout : str #:
      The stdout produced by invoking the non-bazel test harness.
    var stderr : str #:
      The stderr produced by invoking the non-bazel test harness.
    var cwd : str #:
      The directory from which to process.
    var namespace : str #:
      The namespace under test.
    var nofilt : bool = false #:
      If true, do not filter the stdout/stderr, just print verbatim
    var verbosity : int = 0 #:
      0 = Show only errors
      1 = Show one line for each method, and full errors
  scope:

    receiver OoplPython scope:

      if nofilt:
        filterr = stderr
        if stdout:
          dsep(title='stdout')
          print stdout
        if stderr:
          dsep(title='stderr')
          /#print stderr
          print filterr
        if stdout or stderr:
          dsep(end=True)
        return
      import cStringIO
      ifp = cStringIO.StringIO(stderr or '')
      efp = cStringIO.StringIO()
      metac = self.compiler()
      metac.filterMetaOutput(cwd=cwd, ifp=ifp, ofp=efp)
      filterr = efp.getvalue()

      /# Perform base-to-meta line mapping on stderr
      outlines = stdout.split('\n')
      errlines = filterr.split('\n')

      /# Establish some vars.
      outre = re.compile(
        r'^(?P<fqn>\S+)\s+\.\.\.(?P<rest>.*)')
      timere = re.compile(
        r'^(?P<head>.*?)\s+(?P<us>\d+) us  (?:(?P<status>.*))?$')
      failre = re.compile(
        r'^(?P<status>FAIL|ERROR): test_(?P<method>\S+) \(\S+\.(?P<class>\S+)Test\)')
      sepre = re.compile('^(?P<c>[=-])(?P=c){60,}')
      ranre = re.compile(r'^Ran (?P<numtests>\d+) tests? in (?P<seconds>\S+)s')

      def PrintStripped(data, prefix):
        """Strip leading/trailing lines of whitespace from data list."""
        i = 0
        n = len(data)
        if False:
          /# We should NOT be stripping blank leading/trailing lines if they
          /# represent actual output produced by the code ... if spurious
          /# blank lines are being introduced, fix that issue rather than
          /# stripping potentially valuable empty lines from actual output.
          while i < n and not data[i].strip():
            i += 1
          while n > 0 and not data[n-1].strip():
            n -= 1
        for j in range(i, n):
          print prefix + data[j]

      /# We'll add one dict per test to data, merging stdout and stderr.
      /#   name: str
      /#     fqn of test.
      /#   time: int
      /#     number of microseconds
      /#   stdout: vec<str>
      /#   stderr: vec<str>
      data = []
      /# datamap maps fqn name to the same dict stored in data for that fqn.
      datamap = {}

      /# Parse stdout
      /#  - we are expecting lines of the form:
      /#      <class>.<method>                   ...    <time> us  [<status>]
      /#    optionally followed by output from a test method.
      current_fqn = None
      for line in outlines:
        m = outre.match(line)
        if m:
          fqn = m.group('fqn')
          item = {
            'fqn': fqn, 'stdout': [], 'stderr': [], 'status': None,
            'time': None}
          rest = m.group('rest')
          tm = timere.match(rest)
          if tm:
            /# We have a time for this test ... no output expected.
            item['time'] = int(tm.group('us'))
            item['status'] = tm.group('status')
            current_fqn = None
          else:
            /# We did not find a time for this test, which means the test
            /# produced some output on stdout. We consume it in subsequent
            /# iterations through the loop, until we find a line ending in
            /# a timespec.
            current_fqn = fqn
            item['stdout'].append(rest)
          data.append(item)
          datamap[fqn] = item
        else:
          if current_fqn is None:
            /# We are not currently expecting output
            if line.strip():
              print 'UNKNOWN STDOUT: %s' % line
          else:
            /# This is stdout for current_fqn
            item = datamap[current_fqn]
            tm = timere.match(line)
            if tm:
              /# We've found the end of expected stdout
              current_fqn = None
              item['time'] = int(tm.group('us'))
              item['status'] = tm.group('status')
              head = tm.group('head')
              if head:
                item['stdout'].append(head)
            else:
              item['stdout'].append(line)

      /# Parse stderr
      /#  - we are expecting records of the form:
      /#
      /#      =================================================================
      /#      ERROR: test_attrinfo (__main__.ContextTest)
      /#      -----------------------------------------------------------------
      /#      Traceback (most recent call last):
      /#        File "metax/c_test/__init__.py", line 1610, in setUp
      /#          _, _, _, compiler = self.cachedInfo(metal='meta')
      /#      AttributeError: 'ContextTest' object has no attribute 'cachedInfo'
      /#
      /# - It is possible that we will encounter a class/method pair in stderr
      /#   that is NOT present in stdout (not sure how, but it happens).
      i = 0
      N = len(errlines)
      current_fqn = None
      postamble = None
      summary_data = {}
      while i < N:
        line = errlines[i]
        i += 1
        /# We ignore separator lines, as the line after seplines uniquely
        /# identifies which section we are in (at least in output I've seen).
        if sepre.match(line): continue
        failm = failre.match(line)
        ranm = ranre.match(line)

        if failm:
          d = failm.groupdict()
          fqn = '%s.%s' % (d['class'], d['method'])
          if not sepre.match(errlines[i]):
            raise metax.c.Error('Should have found separator line after "%s"' % line)
          if fqn not in datamap:
            item = {
              'fqn': fqn, 'stderr': [], 'stdout': [], 'status': None,
              'time': None
            }
            data.append(item)
            datamap[fqn] = item
          current_fqn = fqn
        elif ranm:
          /# End of tests ... grab all remaining output.
          summary_data.update(ranm.groupdict())
          assert not errlines[i].strip()
          summary_data['status'] = errlines[i+1]
          j = i+2
          while j < len(errlines) and not errlines[j].strip():
            j += 1
          postamble = errlines[j:]
          break
        elif current_fqn is None:
          print 'UNKNOWN STDERR: %s' % line
        else:
          /# A line of stderr for current fqn, if one exists.
          item = datamap[current_fqn]
          item['stderr'].append(line)

      /# Merge the stdout and stderr into a single stream, in the same
      /# format as used in the bazel-generated output.
      sep = '-' * 70
      show_nums = False
      /# print stdout
      last_printed_sep = False
      for i, item in enumerate(data):
        out = item['stdout']
        err = item['stderr']
        special = out or err

        if special and not last_printed_sep: print sep

        if special or verbosity:
          prefix = '%3d) ' % i if show_nums else ''
          print '%s%-40s ... %7d us   %s' % (
            prefix, item['fqn'], item['time'] or -1, item['status'])

        PrintStripped(out, ' |')
        PrintStripped(err, 'E|')

        if special:
          print sep
          last_printed_sep = True
        elif verbosity:
          last_printed_sep = False

      if summary_data:
        print '%-20s: %3d tests in %s seconds: %s' % (
          namespace, int(summary_data['numtests']), summary_data['seconds'],
          summary_data['status'])
      if postamble:
        for line in postamble:
          print line
    end receiver OoplPython;

  end behavior processTestOutput;

  behavior receiverStr : str #:
    Obtain the baselang-specific receiver variable
  params:
    var method : metax.oopl.ExecutableConstruct #:
      The executable for which a receiver is desired.
    var location : str = null #:
      The location feature value of the method. If null, obtained from
      method.
    var style : str = 'base' #:
      One of 'base', 'meta' or 'auto'
        base:
          Use the baselang-defined receiver variable. Note that python and
          perl do not have a lang-defined variable name, but by convention
          the receiver is 'self' in both languages (and 'cls' for class
          methods).
        meta:
          Use the meta-defined receiver variable ('self' for instance,
          'meta' for metaclass, 'test' for testclass)
        auto:
          Establish the meta-level receiver, then look for that variable
          in the user-provided body of the method.  If found, use that
          variable, else use the 'base' variable.
    var myclass : metax.oopl.ClassConstruct = null #:
      The class of the method.  If null, uses method.myclass().
    var sep : bool = false #:
      If true, append the separator character. For style 'base', this
      is baselang-dependent, but for style 'meta' it is always '.'.
    var deref : bool = false #:
      If true, return the version of the base receiver that can respond
        to '.'. For example, for C++, returns '(*this)', because
        '(*this).func()' is legal.
  scope:

    receiver BaseLanguageOopl scope:
      if myclass is None:
        myclass = method.myclass()
      if location is None:
        location = method.attrval('location')
      attrkind = method.attrval('kind')
      if style == 'base':
        if attrkind == 'static':
          /# TODO(wmh): Some baselangs will need to use fqn rather than id.
          /# Also, in C++, the separator between the receiver and method is
          /# different for static methods than for instance/meta methods, and
          /# will have to be special-cased in FieldConstruct.expandMeta().
          result = myclass.id()
        elif self.id() in ('python', 'perl'):
          if myclass.isMeta() or attrkind == 'cls':
            result = 'cls'
          else:
            result = 'self'
        else:
          pvar = 'cls' if location == 'meta' else 'self'
          result = self.config(pvar)
      elif style == 'meta':
        if myclass.isTest():
          result = 'test'
        elif myclass.isMeta():
          result = 'meta'
        else:
          kind = method.attrval('kind')
          result = 'meta' if kind == 'cls' else 'self'
      elif style == 'auto':
        meta_result = 'self' if location == 'user' else location
        pvar = 'cls' if location == 'meta' else 'self'
        base_result = self.config(pvar)
        /# TODO(wmh): search method.attrval('scope:') for references to
        /# the variable stored in result. If found, use it, else use the
        /# baselang version.
        raise metax.c.Error('Not yet supporting receiverStr(base="%s")' % style)
      else:
        raise metax.c.Error('Invalid style "%s"' % style)

      if sep:
        if style == 'base':
          result += self.config('selfsep')
        else:
          result += '.'
      if deref:
        if style == 'base':
          /# TODO(wmh): Generalize? We could define receiverStr() as
          /# a behavior, with this implementation as the default. C++ would
          /# call super and modify slightly.
          if self.id() == 'cpp':
            result = '(*' + result + ')'
      return result
    test:
      ooplpy, _, context, _ = test.cachedInfo(basel='python')
      oopljs, _, _, _ = test.cachedInfo(basel='javascript')
      ooplcc, _, _, _ = test.cachedInfo(basel='cpp')

      filec = metax.meta.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.oopl.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.oopl.ClassConstruct.NewFromData(
        'Card', context, parent=namespace.attr('scope:'),
        secondaries=[('scope:', [])])

      /# instance method
      instance_method = metax.oopl.MethodConstruct.NewFromData(
        'f', context, parent=klass.attr('scope:'))
      instance_method.myclassIs(klass)
      test.iseq('self', ooplpy.receiverStr(instance_method, location='user'))
      test.iseq('self', ooplpy.receiverStr(instance_method))
      test.iseq('self', ooplpy.receiverStr(instance_method, style='meta'))
      test.iseq('this', oopljs.receiverStr(instance_method, location='user'))
      test.iseq('this', oopljs.receiverStr(instance_method))
      test.iseq('self', oopljs.receiverStr(instance_method, style='meta'))
      test.iseq('this', ooplcc.receiverStr(instance_method, location='user'))
      test.iseq('this', ooplcc.receiverStr(instance_method))
      test.iseq('self', ooplcc.receiverStr(instance_method, style='meta'))

      /# meta method
      meta_method =  metax.oopl.MethodConstruct.NewFromData(
        'F', context, parent=klass.attr('scope:'),
        features=[('location', 'meta')])
      meta_method.myclassIs(klass)
      klass.variantIs('meta')
      test.iseq('cls',  ooplpy.receiverStr(meta_method, location='meta'))
      test.iseq('cls',  ooplpy.receiverStr(meta_method))
      test.iseq('meta', ooplpy.receiverStr(meta_method, style='meta'))
      test.iseq('this', oopljs.receiverStr(meta_method, location='meta'))
      test.iseq('this', oopljs.receiverStr(meta_method))
      test.iseq('meta', oopljs.receiverStr(meta_method, style='meta'))
      test.iseq('this', ooplcc.receiverStr(meta_method, location='meta'))
      test.iseq('this', ooplcc.receiverStr(meta_method))
      test.iseq('meta', ooplcc.receiverStr(meta_method, style='meta'))

      /# test method
      test_method =  metax.oopl.MethodConstruct.NewFromData(
        'test_f', context, parent=klass.attr('scope:'),
        features=[('location', 'test')])
      test_method.myclassIs(klass)
      klass.variantIs('test')
      test.iseq('self', ooplpy.receiverStr(test_method, location='test'))
      test.iseq('self', ooplpy.receiverStr(test_method))
      test.iseq('test', ooplpy.receiverStr(test_method, style='meta'))
      test.iseq('this', oopljs.receiverStr(test_method, location='test'))
      test.iseq('this', oopljs.receiverStr(test_method))
      test.iseq('test', oopljs.receiverStr(test_method, style='meta'))
      test.iseq('this', ooplcc.receiverStr(test_method, location='test'))
      test.iseq('this', ooplcc.receiverStr(test_method))
      test.iseq('test', ooplcc.receiverStr(test_method, style='meta'))

      /# Testing the 'sep' param
      test.iseq('self.', ooplpy.receiverStr(instance_method, sep=True))
      test.iseq('this.', oopljs.receiverStr(instance_method, sep=True))
      test.iseq('this->', ooplcc.receiverStr(instance_method, sep=True))

      /# Testing the 'deref' param
      test.iseq('self', ooplpy.receiverStr(instance_method, deref=True))
      test.iseq('this', oopljs.receiverStr(instance_method, deref=True))
      test.iseq('(*this)', ooplcc.receiverStr(instance_method, deref=True))
    end receiver BaseLanguageOopl;

    receiver OoplCpp scope:
      result = super(OoplCpp, self).receiverStr(
        method, location=location, style=style, myclass=myclass, sep=sep)
      if deref:
        if style == 'base':
          result = '(*' + result + ')'
      return result
    test:
      /# Noop - tested in BaseLanguageOopl.receiverStr()
      pass
    end receiver OoplCpp;

  end behavior receiverStr;

  behavior repl #:
    Perform a read-execute-print loop for this baselang.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      banner = 'Welcome to Meta'
      locals = {'a': 1}
      code.interact(banner=banner, local=locals)
    test:
    end receiver OoplPython;

    receiver OoplJavascript scope:
      /# TODO(wmh): Generalize location of phantomjs
      /# TODO(wmh): Need to set things up so that phantomjs loads up the
      /# Meta environment, including any meta files specified.
      subprocess.call(['pjs'])
    test:
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      template = """
       >|%(includes)s
       >|using namespace std;
       >|int main() {
       >|%(body)s
       >|}
       >|"""

      chunks = []
      prompt = '>>> '
      execfile = './tmp'
      tmpfile = 'tmp.cc'

      includes = [
        '#include <iostream>'
      ]

      def GenCode(lines):
        text = '\n'.join(lines)
        if lines:
          chunks.append(text)

        /# Obtain the C++ code to compile.
        code = template % {
          'body': '\n'.join(chunks),
          'includes': '\n'.join(includes),
        }
        fs = self.compiler().fs()
        with fs.open(tmpfile, 'w') as fp:
          fp.write(code)
        return code, text

      import os
      while True:
        /# Obtain a new chunk of C++ code to add to the previous chunks.
        /#  - if line is empty or ends with ';' or '}', terminate
        /#  - otherwise keep reading input
        lines = []
        skip = False
        while True:
          /# Read one line
          line = raw_input(prompt)

          /# Check for exit request.
          if line in ('exit', 'quit'):
            return

          /# Check for special commands
          m = re.match(r'^\s*/(\S+)\s*(.*)', line)
          if m:
            command, args = m.groups()
            if command in ('p', 'print'):
              line = 'cout << %s << endl;' % args
            elif command == 'show':
              skip = True
              code, _ = GenCode(lines)
              print code
              break
            elif command == 'pop':
              skip = True
              chunks.pop()
              break
            elif command == 'include':
              skip = True
              for arg in args.split():
                if arg[0] == '<': pass
                elif arg[0] == '\"': pass
                else:
                  if arg.endswith('.h'):
                    arg = '"%s"' % arg
                  else:
                    arg = '<%s>' % arg
                includes.append('#include %s' % arg)
              break

          /# Register line
          lines.append(line)

          /# Determine if we need to ask for another line or end reading.
          if not line or line[-1] in (';', '}'):
            break

        if skip:
          continue

        code, text = GenCode(lines)

        /# Compile code, and if no compilation errors, run code.
        rc = subprocess.call(['g++', '-o', execfile, tmpfile])
        if rc == 0:
          rc = subprocess.call([execfile])

        if rc == 0:
          /# The code did not produce any compile-time or run-time error, so
          /# we leave it in place.  However, we modify the new chunk so that
          /# any code that prints to cout is commented out.
          /#  - this correctly handles 'p a'
          /#  - this correctly handles 'if (a) { cout << "blah" << endl; }'
          /#  - this incorrectly comments out the cout in
          /#      class A { public: A() { cout << "hello!" << endl; } };
          /#    but we provide an escape-hatch by not commenting out std::cout
          /#      class A { public: A() { std::cout << "hello!" << endl; } };
          chunks.pop()
          qtext = re.sub(r'(^[:])(cout[ <][^;]+;)', r'\1/* \2 */', text)
          chunks.append(qtext)

        else:
          /# The new chunk of C++ code produced a compile or run-time error,
          /# so we remove it from the list of chunks.
          chunks.pop()
    test:
    end receiver OoplCpp;

  end behavior repl;

  behavior superCode : void #:
    Write baselang code to invoke a superclass method.
  params:
    var method : metax.oopl.ExecutableConstruct #:
      The method for which super code is desired.
    var output : vec<str> #:
      Where to append lines of baselang code representing the super-call.
    var width : int = 80 #:
      Maximum width that lines can take on.
    var return_var : str = null #:
      If present, assign the result of the super call to the given var.
  scope:
    abstract receiver BaseLanguageOopl;

    receiver OoplPython scope:
      recstr = self.receiverStr(method)
      myclass = method.myclass()
      class_name = myclass.id()
      method_name = method.id()
      super_method = ''
      if return_var:
        super_method += '%s = ' % return_var
      super_method += 'super(%s, %s).%s' % (class_name, recstr, method_name)
      metafile = method.metafile()

      /# TODO(wmh): Should we do LOOKUP here? If we don't always do it
      /# (except for block-valued attributes) how will the user know when an
      /# attribute is inherited and when it isn't?  On the other hand, if
      /# super doesn't exist explicitly, we could assume the parent is invoked
      /# with the same args as method, providing a convenient short-hand that
      /# is common.
      super_attr, super_args = method.attrpair('super', default=None)
      if super_args:
        param_str, _ = self.compileExpr(
          super_args, metafile, executable=method)
        /# TODO(wmh): This logic should be implemented in compileExpr. Note
        /# that it already has the method in 'executable', so it can obtain
        /# the params and check for multi vars.
        params = method.parsedParams()
        varvec = params.get('varvec', None)
        varmap = params.get('varmap', None)
        if varvec or varmap:
          arglist = re.split(r'\s*,\s*', param_str[1:-1])
          if varvec:
            for i, arg in enumerate(arglist):
              if arg == varvec['name']:
                arglist[i] = '*' + arg
                break
          if varmap:
            for i, arg in enumerate(arglist):
              if arg == varmap['name']:
                arglist[i] = '**' + arg
                break
          param_str = '(%s)' % (', '.join(arglist))
      else:
        param_str = '()'

      if len(super_method) + len(param_str) < width:
        output.append(super_method + param_str)
      else:
        output.append(super_method + '(')
        output.append('    ' + param_str[1:])
    test:
      test.defineClassAndMethods('py')

      /# An initializer
      out = []
      test.baselang.superCode(test.initializer, out)
      test.iseqvec(['super(Card, self).__init__(a, b=1, c=False)'], out)

      /# A non-iniitalizer method
      out = []
      test.baselang.superCode(test.method2, out)
      test.iseqvec(['super(Card, self).f(a, b=1, c=False)'], out)
    end receiver OoplPython;

    receiver OoplJavascript scope:
      kind = method.attrval('kind', default=metax.c.LOOKUP)
      recstr = self.receiverStr(method)
      myclass = method.myclass()
      class_name = myclass.id()
      method_name = method.id()

      use_es2015_classes = self.config('use_es2015')

      args = []

      if use_es2015_classes:
        super_method = 'super'
      else:
        super_method = '%s.base' % myclass.fqn()
        args.append(recstr)

      if kind == 'initializer':
        if not use_es2015_classes:
          args.append("'constructor'")
      else:
        if use_es2015_classes:
          super_method += '.' + method.id()
        else:
          args.append("'%s'" % method.id())

      /# TODO(wmh): Should we do LOOKUP here? If we don't always do it
      /# (except for block-valued attributes) how will the user know when an
      /# attribute is inherited and when it isn't?  On the other hand, if
      /# super doesn't exist explicitly, we could assume the parent is invoked
      /# with the same args as method, providing a convenient short-hand that
      /# is common.
      metafile = method.metafile()
      super_attr, super_args = method.attrpair('super', default=None)
      if super_args:
        for sarg in super_args.value():
          sstr, _ = self.compileExpr(sarg, metafile, executable=method)
          args.append(sstr)
      output.append(super_method + '(' + ', '.join(args) + ');')


    test:
      oopljs, _, context, _ = test.cachedInfo(basel='javascript')

      filec = metax.meta.FileConstruct.NewFromData(
        'File', context, secondaries=[('scope:', [])])
      namespace = metax.oopl.NamespaceConstruct.NewFromData(
        'nm.sp', context, parent=filec.attr('scope:'),
        secondaries=[('scope:', [])])
      klass = metax.oopl.ClassConstruct.NewFromData(
        'Card', context, namespace.attr('scope:'), secondaries=[('scope:', [])])
      kscope = klass.attr('scope:')
      exprp = metax.c.ExprParser(test.metafileFor('(a, b=1, c=false)\n'))
      expr = exprp.parse()

      /# An initializer
      initializer = metax.oopl.MethodConstruct.NewFromData(
        '__init__', context, parent=kscope,
        features=[('kind', 'initializer')],
        secondaries=[('super', expr)])
      initializer.myclassIs(klass)
      out = []
      oopljs.superCode(initializer, out)
      test.iseqvec(["super(a, b=1, c=false);"], out)

      /# A non-iniitalizer method
      method = metax.oopl.MethodConstruct.NewFromData(
        'f', context, parent=kscope, secondaries=[('super', expr)])
      method.myclassIs(klass)
      out = []
      oopljs.superCode(method, out)
      test.iseqvec(["super.f(a, b=1, c=false);"], out)
    end receiver OoplJavascript;

    receiver OoplCpp scope:
      kind = method.attrval('kind')

      if kind == 'initializer':
        /# The superCode() method is for generating code WITHIN a code block
        /# for invoking a superclass method. Invoking a parent constructor
        /# in C++ happens in the initlist, NOT within the code block, so we
        /# write nothing to output for initializers here ... handled in
        /# OoplCpp.augmentVarset().
        pass
      else:
        myclass = method.myclass()
        parent_classes = myclass.parentclasses()
        parent = parent_classes[0]
        pfqn = parent['fqn']
        pparts = pfqn.split('.')

        method_name = method.id()
        metafile = method.metafile()
        super_method = 'this->%s::%s' % (pparts[-1], method_name)

        /# TODO(wmh): Should we do LOOKUP here? If we don't always do it
        /# (except for block-valued attributes) how will the user know when an
        /# attribute is inherited and when it isn't?  On the other hand, if
        /# super doesn't exist explicitly, we could assume the parent is invoked
        /# with the same args as method, providing a convenient short-hand that
        /# is common.
        super_attr, super_args = method.attrpair('super', default=None)

        if super_args:
          param_str, _ = self.compileExpr(
            super_args, metafile, executable=method)
        else:
          param_str = '()'

        if len(super_method) + len(param_str) + 1 < width:
          output.append('%s%s;' % (super_method, param_str))
        else:
          output.append("%s(" % super_method)
          output.append('    ' + param_str[1:] + ';')
    test:
      test.defineClassAndMethods('cc')
      /# An initializer
      out = []
      test.baselang.superCode(test.initializer, out)
      test.iseqvec([], out)

      /# A non-iniitalizer method
      out = []
      test.baselang.superCode(test.method2, out)
      test.iseqvec(['this->metax::root::Object::f(a, b=1, c=false);'], out)
    end receiver OoplCpp;

  end behavior superCode;

end MetaLanguage oopl;
