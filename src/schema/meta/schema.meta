MetaLanguage meta name Meta toplevel <MetaLanguage|File> #:
  The constructs in Meta(Meta), the root Meta language that all other Meta
  languages inherit from.

  Implementation Notes:
   - any time this file is modified, meta.c.MetaLanguage.Bootstrap() should
     be updated to reflect the change.
config:

  abstract
  Construct _meta_ #:
    Abstract construct from which all Meta(Meta) constructs inherit.

    IMPORTANT: Before implementing this construct in metax.meta, we need to
    deal with circularity issues introduced by having metax.c need metax.meta
    and metax.meta need metax.c (if we move MetaConstruct before we move
    BaseLanguageConstruct, etc.). Try moving BaseLanguageConstruct first.
  config:
  end;

  Construct MetaLanguage < _meta_ #:
    The MetaLanguage construct defines the collection of constructs making up
    a Meta Language.
  config:

    primary
    Attribute MetaLanguage : id = <required> #:
      The name of the Meta language being defined.

    secondary
    Attribute name : word = <required> #:
      A human-readable name for this base lang. Any non-whitespace is allowed.

    secondary
    Attribute parent : xid = <empty> #:
      Indicates which meta language this schema extends.  If empty, the root
      language 'Meta' is assumed.

    secondary
    Attribute toplevel : enum = <empty> #:
      A list of toplevel constructs that can appear in a program written in
      this MetaLanguage.

    secondary
    Attribute color : word = <empty> #:
      Specifies a color to use when highlighting the primary key of this
      construct. The value is anything legal in CSS Color Module Level 3
      (https://developer.mozilla.org/en-US/docs/Web/CSS/color_value)
      but without any whitespace allowed. Examples:
        purple
        rgb(255,128,100)
        #ab76d9

    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      An arbitrary multi-line comment used to describe the purpose of the
      Meta language being defined.

    secondary
    Attribute config: : complex = <empty> children <Construct|BaseLanguage> #:
      The complex block within which the legal set of constructs for this
      Meta language resides (instances of Construct).

    secondary
    Attribute scope: : complex = <empty> aliases <::> #:
      Each Meta file, as it is parsed, is added to this scope.

  assocs:
    resource metameta path "../schema/meta/schema.meta";
    resource metaoopl path "../schema/oopl/schema.meta";
    resource metadoc path "../schema/doc/schema.meta";
  scope:

    field name : str #:
      The human-presentable name of this Meta language. It is what is inserted
      for X in Meta(X).

    field metalangparent : MetaLanguageConstruct #:
      The parent MetaLanguage of this MetaLanguage. Only null for Meta(Meta).

    field toplevel : vec<str> #:
      The list of construct kinds that are legal at top-level within .meta files
      implemented in this MetaLanguage. The toplevel kinds of ancestor languages
      are also legal and do not need to be explicitly specified here.

    field baselangs : @map<str,BaseLanguage> #:
      The collection of BaseLanguage instances supported by this
      MetaLanguage.  A key is added for the id, name, aliases and
      suffix(es) of the language.

    field baselist : @vec<BaseLanguage> #:
      The collection of BaseLanguage instances in this MetaLanguage.

    field basesels : @map<str,str> #:
      Maps suffix to BaseLanguage for legal suffixes that can appear in
      attribute key selectors. Only the first suffix associated with each
      BaseLanguage is allowed here.

    field consmap : @map<str,class> #:
      Maps construct kind to subclass of Construct.  If a particular
      construct id is not present, GenericConstruct is assumed.

    lifecycle params:
      var id : str;
      var parent : ComplexBlock #:
        Should always be null.  Required so that the MetaLanguage initializer
        matches the Construct initializer.
      var context : Context #:
        Should always be null.  Required so that the MetaLanguage initializer
        matches the Construct initializer.
      var precount : int = 0 #:
        Should always be zero. Required so that the MetaLanguage initializer
        matches the Construct initializer.
    super (id, parent, context, precount=precount)
    scope:
      /# The special Meta* baselang suffix is always legal.
      self.basesels()['*'] = None

      /# IMPORTANT: This construct is not properly initialized until
      /# postCreationInitialization() is invoked, which cannot be invoked
      /# until the name, toplevel and metalangparent fields have been
      /# initialized.
    end lifecycle;

    method postCreationInitialization #:
      Perform post-creation initialization
    scope:
      name = self.name()
      assert name is not None
      toplevel = self.toplevel()
      assert toplevel is not None
      uid = self.id()

      metalangparent = self.metalangparent()
      if uid != 'meta':
        assert metalangparent is not None

      if metalangparent:
        toplevel = metalangparent.toplevel() + toplevel
        self.toplevelIs(toplevel)

        /# Inherit parent constructs into self.
        pmap = metalangparent.consmap()
        for kind, ccls in pmap.iteritems():
          self.registerConstructClass(kind, ccls)
    end method postCreationInitialization;

    method registerConstructClass #:
      Associate a construct with a subclass of Construct.
    params:
      var kind : str #:
        A construct kind.
      var cls : class<Construct> #:
        The subclass of Construct to use to represent instances of
        construct 'kind'.
    scope:
      /# print 'Registering %s %s for %s' % (kind, cls.__name__, self.id())
      assert issubclass(cls, metax.c.Construct)
      self._consmap[kind] = cls
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      test.iseqvec(test.metaoopl_consids, sorted(metaoopl._consmap))
    end method registerConstructClass;

    method getConstructClass : class<Construct> #:
      Obtain the construct class to use for instances of constructs of
      kind 'kind'.
    params:
      var kind : str #:
        A construct kind.
    scope:
      return self._consmap.get(kind, None)
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      conscls = metaoopl.getConstructClass('Construct')
      test.issame(metax.meta.ConstructConstruct, conscls)
    end method getConstructClass;

    method registerBase #:
      Add a BaseLanguage to this MetaLanguage
    params:
      var base : BaseLanguage #:
        The baselanguage to add.
    scope:
      bases = self.baselangs()
      suffixes = base.suffixes()
      name = base.name()
      for key in [base.id(), base.name(), base.name().lower()] + list(suffixes):
        current = bases.get(key, None)
        if current and current is not base:
          raise InternalError(
            "Attempt to register base %s with key '%s' already used by %s"
            % (base.id(), key, current.id()))
        bases[key] = base
      if suffixes:
        self.basesels()[suffixes[0]] = base
      self.baselist().append(base)
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      test.iseqvec(
        ['C++', 'Javascript', 'Python'],
        sorted([baselang.name() for baselang in metaoopl.baselist()]))
    end method registerBase;

    method baselangNamed : BaseLanguage #:
      The BaseLanguage instance associated with a given name.
    params:
      var nora : str #:
        The name, alias, suffix or id of the baselang desired.
    scope:
      return self.baselangs().get(nora, None)
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      ooplpy = metaoopl.baselangNamed('Python')
      test.isinst(ooplpy, metax.c.OoplPython)
    end method baselangNamed;

    method toplevelConstructKinds : vec<str> #:
      The list of construct kinds that can appear at top-level within a
      meta file implemented in this meta language.
    scope:
      return self.toplevel()
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      test.iseqvec(
        ['MetaLanguage', 'File', 'namespace', 'class'],
        metaoopl.toplevelConstructKinds())
    end method toplevelConstructKinds;

    method isValidBase : bool #:
      Determine if a given string is a valid string to appear within a
      attribute key selector to identify a baselang.
    params:
      var basesel : str #:
        The baselang selector found within an attribute key.
    scope:
      return basesel in self.basesels()
    test:
      _, metaoopl, _, _ = test.cachedInfo()
      test.istrue(metaoopl.isValidBase('py'))
      test.istrue(metaoopl.isValidBase('js'))
      test.isfalse(metaoopl.isValidBase('xx'))
    end method isValidBase;

    method preExpandFileConstruct #:
      Perform pre-expand actions on FileConstruct.
    params:
      var file_construct : metax.meta.FileConstruct;
    scope:
      children = file_construct.attrval('scope:')

      /# We perform a special analysis to move file-level class constructs into
      /# implicit namespaces.
      /#  - IMPORTANT: I initially planned to implement this insert-class-into-namespace
      /#    logic in NamespaceConstruct.expandMeta() and ClassConstruct.expandMeta().
      /#    Unfortunately, doing so causes NamespaceConstruct.expandMeta() to
      /#    be invoked on the test namespace before the test methods from the
      /#    implicit class are added to it, meaning no test methods are
      /#    produced and state is uninitialized causing the compiler to crash.
      /#    By performing the operation here, we can get the constructs into
      /#    the expected state before we do any expansion. As an added benefit,
      /#    the logic is in one place instead of scattered across two methods.
      /#  - NOTE: it would be nice if FileConstruct was meta-langugage-agnostic,
      /#    but this code is inherently Meta(Oopl)-centric. Move it into a
      /#    metalanguage template method and invoke the method on the metalang.
      current_namespace = None
      for child in children:
        ckind = child.kind()
        if ckind == 'namespace':
          current_namespace = child
          namespace_scope = child.attr('scope:', default=None)
          if namespace_scope is None:
            /# TODO(wmh): How to indicate that this attribute is implicitly
            /# added, and should not be used during canonicalization?
            /#  - do we add an implicit field to ComplexBlock? Or to NamespaceConstruct?
            scope = metax.c.ComplexBlock(None, 'scope:', [])
            /# print 'Added new scope to %s' % child.kindfqn()
            child.registerAttribute(scope)
        elif ckind == 'class':
          /# We have a File-level class ... move it into namespace.
          if current_namespace is None:
            metafile.error(
              'Must specify a namespace before a class can be defined',
              line=file_construct.primary().line())
            /# TODO(wmh): Is it safe to return so early?
            return
          else:
            child.namespaceIs(current_namespace)
            nmsp_scope = current_namespace.attr('scope:')
            child.changeParent(nmsp_scope)
            /# print 'Implicitly added %s to %s' % (
            /#   child.kindfqn(), current_namespace.kindfqn())
            current_namespace._setClassVariant(child)
    test:
    end method preExpandFileConstruct;

  end Construct MetaLanguage;

  Construct Construct < _meta_ #:
    The construct used to define new constructs within a MetaLanguage config block,
    and the construct used to modify/augment a pre-existing construct within
    the complex blocks of constructs that define a 'config' block.

    Any construct that contains one or more complex blocks should always provide
    a complex-valued 'config' attribute within which Construct instances can
    appear to change aspects of the construct within all complex blocks of
    the construct.
  config:

    feature
    Attribute presence : <abstract|concrete> = concrete #:
      Dictates whether this construct can appear in Meta files are not.
    config:
      FeatureValue abstract #:
        Such a construct cannot legally appear in Meta source files, but rather
        is a collection of attributes that concrete constructs extending this
        construct all share.
      FeatureValue concrete #:
        Such a construct can legally appear in Meta source files.

    primary
    Attribute Construct : id = <required> #:
      The construct 'kind'.  Used in many places.

    secondary
    Attribute clsname : id = <empty> #:
      The class name associated with this construct. If not specified, the
      default '<id>Construct' is assumed.

    secondary
    Attribute parent : xid = <empty> aliases <<> #:
      The name of the Construct this construct extends.

    secondary
    Attribute associations: : simple = <empty> aliases <assocs:> #:
      The collection of assoc and resource instances needed by the class.
      This is a simple block within Meta(Meta), but when copied to the
      class representing the construct it is parsed as a complex block and
      should contain assocs, resources and remarks only.

    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      A multi-line block describing the purpose of this construct.

    secondary
    Attribute config: : complex = <empty> children <Attribute|Template> #:
      Used to define the attributes available within a construct, the
      order in which they appear, default values, etc.

    secondary
    Attribute expand: : simple = <empty> #:
      The code defining the expandMeta() method

    secondary
    Attribute import: : simple = <empty> #:
      The code defining the expandMeta() method

    secondary
    Attribute translate: : simple = <empty> #:
      The code defining the translateMeta() method

    secondary
    Attribute compile: : simple = <empty> #:
      The code defining the compileMeta() method

    secondary
    Attribute scope: : simple = <empty> #:
      The code defining the class that implements this construct.

  scope:

    method className : str #:
      The fully qualified name of the class implementing this construct.
    scope:
      result = self.attrval('clsname', default=None)
      if result is None:
        cid = self.id()
        result = cid[0].capitalize() + cid[1:] + 'Construct'
      return result
    test:
      _, _, _, compiler = self.cachedInfo(metal='oopl')
      metalang = compiler.metalang()
      config = metalang.attr('config:')
      namespace = config.cons('namespace')
      test.iseq('NamespaceConstruct', namespace.className())
      root = config.cons('_oopl_')
      test.iseq('OoplConstruct', root.className())
    end method className;
    
  end Construct;

  Construct Template < _meta_ #:
    A template for use in compiling a construct into a base language.
  config:

    primary
    Attribute Template : word = <required> #:
      The id of the Template is used within code to obtain a template for
      a particular purpose. Names should be baselang ids or baselang ids
      with a '_test' suffix.

    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      A multi-line block describing the purpose of this Template.

    secondary
    Attribute scope: : simple = <empty> aliases <::> #:
      Specifies the template lines. Variables are denoted with the syntax
        ${var}
      and will be replaced with values determined within the code. The
      indentation before a variable influences how multi-line values are
      indented.

  scope:
  end Construct Template;

  Construct Attribute < _meta_ #:
    An attribute defined on a construct.  Key/value pair.
  config:

    feature
    Attribute kind : <undef|feature|primary|secondary> = undef #:
      There are three kinds of attributes, feature, primary and secondary.
    config:
      FeatureValue undef #:
        A placeholder for indicating that a kind was not explicitly provided.
      FeatureValue feature #:
        A feature attribute always appears before the primary attribute.
        The feature attribute key is always optional (and is very rarely
        specified, because feature attribute values uniquely identify
        their associated key).  Feature attribute values are limited to
        a predefined set of feature-specific words.
      FeatureValue primary #:
        A primary attribute always has the name of the construct as its key,
        and an identifier as its value.
      FeatureValue secondary #:
        A secondary attribute always appears after the primary attribute.
        Some
    end;

    feature
    Attribute key : <nokey|showkey|aliaskey> = showkey #:
      Controls whether the canonical representation of a construct
      shows the key for this attribute or not.
    config:
      FeatureValue nokey #:
        The canonical representation of instances of this construct do not
        print the key of this feature attribute.
      FeatureValue showkey #:
        The canonical representation of instances of this construct prints
        out the cnaonical key name of this feature attribute.
      FeatureValue aliaskey #:
        The canonical representation of instances of this construct uses the
        first alias specified in the 'aliases' secondary attribute.
    end;

    feature
    Attribute value : <noval|userval|showval> = showval #:
      Controls whether the canonical representation of a construct shows
      the value of this attribute or not.
    config:
      FeatureValue noval #:
        Do not show the value. This produces invalid code, but is useful
        in some situations.
      FeatureValue userval #:
        Use the value token provided by user.
      FeatureValue showval #:
        Use the canonical value token.
    end Attribute value;

    primary
    Attribute Attribute : word = <required> #:
      The canonical name of the attribute. If an Attribute has a type of
      'simple' or 'complex', the name must end with ':'. This allows us to
      be able to add a non-block and block version of the same name, and
      opens the possibility of allowing more flexibility in syntax in the
      future.

    secondary
    Attribute default : word = <empty> aliases <=> #:
      The default value of this attribute for instances that do not explicitly
      define the attribute.  This is the most common thing to modify in 'config'
      blocks.

    secondary
    Attribute type : word = <empty> aliases <:> #:
      The type of the attribute.  Legal values are:
        enum : the value is constrained to be one of a set of predefined words
        id : an identifier
        xid : a collection of one or more identifiers separated with '.'
        word : a collection of characters not containing whitespace
        expr : an expression
          num : a literal numbe
          id : an identifier
          xid : an identifier
          plist : a parameter list
          str : a quoted string
          list : a list of expressions
          hash : a dict of expressions
          call : a callsite
        type : a Meta type
        simple : a simple block (i.e. an indented collection of lines)
        complex : a complex block (i.e. an indented collection of constructs)
        simplex : a block that is complex if selector is '*', else simple

    secondary
    Attribute children : enum = <empty> #:
      An enum of construct kinds, representing the set of Constructs that can
      appear within the value of this attribute. Meaningful for attributes of
      'complex' type and those of 'simple' type that can become complex if given
      a <*> selector.

    secondary
    Attribute aliases : enum = <empty> #:
      A literal enum of abbreviations that can be used in place of
      the canonical key of this attribute. The normal form is <val1|val2|val3>,
      but one can also use ,<val1,val2,val3>, #<val1#val2#val3>, etc.

    secondary
    Attribute autokey : str = <empty> #:
      Not normally provided. If given, it is a literal string containing a
      single character that values of this attribute always start with. It
      indicates that the key associated with the value is not necessary ... if
      the char specified here is seen when an attribute key is expected, Meta
      knows it is this attribute that is being identified.

    secondary
    Attribute replacer : word = <empty> #:
      Not normally provided, and currently only applicable to primary attributes
      whose values are optional (value <auto>). If present, it indicates that a
      value found after a primary key should instead be assigned as the value of
      an implicitly created attribute whose key is specified by replacer. If
      an explicit value for that attribute is subsequently parsed, the value
      is moved back to the primary key.

    secondary
    Attribute delim : str = <empty> #:
      Not normally provided. Only used for Attributes of kind feature.
      If given, it indicates that this feature is multi-valued, separated
      by the value of this string, which is usually a single char like '+' or
      '-'. An empty string indicates that the feature value should be split
      on each character.

    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      A description of the attribute.

    secondary
    Attribute config: : complex = <empty> children <FeatureValue> #:
      For feature attributes, this can contain the collection of FeatureValue
      instances associated with the attribute.  Ignored for primary and
      secondary attributes.

  scope:
  end Construct Attribute;

  Construct FeatureValue < _meta_ #:
    Each Construct can have zero or more feature attributes (which appear before
    the primary key). Each feature attribute has a feature key whose value comes
    from a pre-defined set of string values. The FeatureValue construct allows
    one to define an individual value, provide documentation for its semantics,
    allows for aliases to be introduced (useful when wanting to perform
    renamings), etc.
  config:
    primary
    Attribute FeatureValue : word = <required> #:
      The canonical feature value.

    secondary
    Attribute aliases : enum = <empty> #:
      A literal enum of abbreviations that can be used in place of
      the canonical key of this attribute. The normal form is <val1|val2|val3>,
      but one can also use ,<val1,val2,val3>, #<val1#val2#val3>, etc.

    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      A collection of lines documenting the semantics of the FeatureValue.

  scope:
  end Construct FeatureValue;

  Construct File < _meta_ #:
    A construct containing all constructs within a .meta file. This construct is
    often NOT explicitly provided (in which case it is implicitly defined). It
    can, however, be useful to explicit define this construct in situations
    where one wants to customize constructs and attributes appearing anywhere in
    the file.
  config:
    primary
    Attribute File : word = <required> #:
      The absolute (symlink-resolved) path of the meta file.

    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      A description of the purpose of the meta file.

    secondary
    Attribute scope: : complex = <empty> aliases <::> #:
      All top-level constructs appearing in a metafile are added to this
      block.

    secondary
    Attribute config: : complex = <empty> #:
      Modify construct/attribute defaults, etc. across all constructs found
      within a .meta file.

      Note that the value of the children attribute differs by Meta Language,
      and is the legal set of top-level constructs within the meta language.

  expand:
    metax.c.D.expand.sinfo(self.id())
    metafile = self.metafile()
    metalang = self.metalang()

    metalang.preExpandFileConstruct(self)
    children = self.attrval('scope:')

    /# Now expand all children.
    /#  - It is EXTREMELY important that we make a copy of children to
    /#    iterate over, because the scope is dynamically modified during
    /#    iteration!
    for child in list(children):
      child.expandMeta()

    metax.c.D.expand.end()

  import:
    metax.c.D.imports.sinfo(self.id())

    debug = False

    /# We obtain the set of metafiles that this metafile depends on that
    /# have not already been parsed.
    metapaths = set()
    metafile = self.metafile()
    metac = metafile.compiler()
    existing_classes = metac.classes()
    existing_metafiles = metac.metafiles()
    fs = metac.fs()
    baselang = metac.baselang()
    if debug:
      print 'HERE in FileConstruct.importMeta for %s' % metafile.path()
    for fqn in metafile.classdeps():
      if fqn in existing_classes:
        /# We already have the class parsed, so we do not need to check its
        /# meta file.
        pass
      else:
        class_path = fs.join(metac.repositoryPath(), baselang.classPath(fqn))
        meta_path = metac.basePathToMeta(class_path)

        /# Canonicalize path
        if meta_path is None:
          /# This can happen, for example, when a user specifies 
          /#   cls assoc <class>;
          /# when <class> is not a legal class.
          klass = metac.classes().get(fqn, None)

          /# TODO(wmh): Decide how to enable/disable this.
          if False:
            metafile.warning(
              'Failed to find class %s' % fqn,
              line=klass.primary().line() if klass else -1)
        elif fs.exists(meta_path):
          meta_path = fs.realpath(meta_path)

        /# Register metafile
        if debug:
          print '  %s = %s' % (fqn, meta_path)
        if meta_path in existing_metafiles:
          pass
        elif meta_path:
          metapaths.add(meta_path)

    /# We import all of the dependent metafiles.
    for meta_path in metapaths:
      if debug:
        print '  *** Loading %s' % meta_path
      metafile = metac.getMeta(
        meta_path, expand=True,
        /# I suspect there are times where we will need to perform a
        /# recursive invocation of imports, but am not yet clear whether it
        /# is better to do it depth-first (here) or breadth-first (by
        /# iterating within this method until no more metafiles exist).
        /# Prelminary experiments with setting this to True were causing us
        /# to load the same file multiple times, but that may be fixed
        /# (and if not, can be fixed).
        imports=False,
        /# We definitely don't need to translate or compile these classes.
        translate=False, compile=False)
      if debug:
        print '  *** Loaded %s' % metafile.path()

    /# Establish which metafiles need to be transitively loaded due to
    /# additional unresolved dependencies in the above code.
    /#  - TODO(wmh): what needs to be done here?

    /# Now we have our children perform post-import actions.
    scope, children = self.attrpair('scope:')
    user_children = list(children)
    for child in user_children:
      child.importMeta()

    metax.c.D.imports.end()

  translate:
    metax.c.D.translate.sinfo(self.id())
    scope, children = self.attrpair('scope:')
    for child in children:
      child.translateMeta()
    metax.c.D.translate.end()

  compile:
    metax.c.D.compile.sinfo(self.id())
    scope, children = self.attrpair('scope:')
    for child in children:
      child.compileMeta()
    metax.c.D.compile.end()

  scope:

    field current : Construct #:
      The current top-level construct.
      Exact semantics depends on the Meta language being parsed. In Meta(Oopl),
      this is a NamespaceConstruct, and is used to establish which namespace
      to add a class that is a file level.

    method path : str #:
      The path to this construct within the metafile.
    scope:
      return ''
    test:
    end method path;

  end Construct File;

  Construct BaseLanguage #:
    Each instance of BaseLanguage identifies a pre-existing language that is
    supported by this MetaLanguage.
  config:

    feature
    Attribute presence : <abstract|concrete> = concrete #:
      Dictates whether this baselang defines a concrete or abstract class.
    config:
      FeatureValue abstract #:
        Such a baselang cannot legally appear in Meta source files, but rather
        is a collection of attributes that concrete baselangs extending this
        baselang all share.
      FeatureValue concrete #:
        Such a baselang can legally appear in Meta source files.

    primary
    Attribute BaseLanguage : id = <required> #:
      A unique identifier (amongst all baselangs in a metalang) for this
      baselang. Used in file names, class and variable names, etc., so it must
      be an identifier.

    secondary
    Attribute name : word = <required> #:
      A human-readable name for this base lang. Any non-whitespace is allowed.

    secondary
    Attribute clsname : id = <empty> #:
      The class name associated with this BaseLanguage. If not specified, the
      default 'BaseLanguage<Id>' is assumed.
      TODO(wmh): Deal with the inconsistency in naming of this attribute in
      Construct vs BaseLanguage.  Maybe rename 'name' from Construct to
      clsname.

    secondary
    Attribute parent : xid = <empty> aliases <<> #:
      The id of the BaseLanguage construct this BaseLanguage construct extends.
      Also defines the class inheritance.

    secondary
    Attribute suffixes : enum = <empty> #:
      A list of suffixes associated with this baselang. The first suffix is
      priviledged (it is what is used in attribute key params).

    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      Notes on how this baselang participates in the metalang.

    secondary
    Attribute scope: : complex = <empty> aliases <::> #:
      Class-level constructs to be added to the class associated with this
      construct.

    secondary
    Attribute config: : complex = <empty> #:
      Modify construct/attribute defaults, etc. across all constructs found
      within a BaseLanguage.

      TODO(wmh): This may not be relevant for BaseLanguage constructs.
  end Construct BaseLanguage;

end MetaLanguage meta;
