MetaLanguage doc name Doc parent meta toplevel <presentation|document|spreadsheet> #:
  Augmentation and unification of object-oriented programming languages.
config:

  abstract
  Construct _doc_ clsname DocConstruct pclsname metax.meta.Construct #:
    Abstract construct from which all Meta(Doc) constructs inherit.

    All constructs in Meta(Doc) inherit from this abstract construct,
    so the Attribute definitions here are available in subconstructs.
    However, note that the existence of an Attribute here does NOT mean it
    is automatically included in the subconstruct ... the subconstruct
    must specify the primary attribute (and any customization of other
    values).
  config:

    secondary
    Attribute comment: : simple = <empty> aliases <#:> #:
      Arbitrary multi-line text describing the purpose of the construct.

    secondary
    Attribute notes: : simple = <empty> #:
      Visible comments. Will be added to as a title on the HTML version of the
      construct.

    secondary
    Attribute config: : complex = <empty> children <Construct> #:
      The complex block that defines/modifies Construct/Attribute instances.

    secondary
    Attribute scope: : complex = <empty> aliases <::> #:
      The collection of subconstructs.

  expand:
    /# TODO(wmh): Switch this to be abstract to force children to
    /# define the method.
    print '%s: %sConstruct.expandMeta() should be defined' % (
      self.kindid(), self.kind().capitalize())
  translate:
    /# TODO(wmh): Switch this to be abstract to force children to
    /# define the method.
    print '%s: %sConstruct.translateMeta() should be defined' % (
      self.kindid(), self.kind().capitalize())
  scope:
    abstract method kind : str;

    method streamLine #:
      Add a single line to a stream, handling indenting.
    params:
      var line : str #:
        The line to add
      var stream : str = 'body' #:
        The stream to add to.
      var indent : str = '' #:
        What to add before each line.
    scope:
      streams = self.metafile().streams()
      if line:
        streams.addLine(stream, indent + line)
      else:
        streams.addLine(stream, '')
    test:
    end method streamLine;

    method streamLines #:
      Add lines to a stream, handling >| syntax, initerpolation and indenting.
    params:
      var lines : vec<str> #:
        The lines to add
      var stream : str = 'body' #:
        The stream to add to.
      var indent : str = '' #:
        What to add before each line.
    scope:
      def VarSub(m):
        /# Convert a variable to a value.
        /#  - if the variable is a kind name like panel or slide, we replace
        /#    the var with the id of that construct.
        /#  - what other vars do we want to support?
        var = m.group('var')
        if var in ('panel', 'slide'):
          cons = self.ancestor(var)
          result = cons.id() if cons else '?'
        else:
          result = '?'
        return result

      def Interpolate(m):
        /# Handle an entire specialized variable interpolation request.
        varstr = m.group('varstr')
        result = metax.c.VAR_RE.sub(VarSub, varstr)
        return '"' + result + '"'

      prefix_re = metax.c.SPECIAL_PREFIX_RE2
      interpolation_re = metax.c.INTERPOLATION_RE
      streams = self.metafile().streams()
      for line in lines:
        m = prefix_re.match(line)
        if m:
          line = m.group('line')
        elif line:
          line = indent + line
        line = interpolation_re.sub(Interpolate, line)
        streams.addLine(stream, line)
    test:
    end method streamLines;

    method tagStr : tuple<str,str> #:
      Determine an html start tag with html attributes from this Meta construct.
    params:
      var tag : str #:
        The tag to use.
    scope:
      id = self.id()
      attrs = []
      if not Context.IsAutoId(id) and id[0] != '_':
        fqn = self.fqn(terminal='slide', noauto=True)
        attrs.append('id="%s"' % fqn)

      style_expr = self.attrval('style', default=None)
      style = style_expr.asStr(unquote=True).strip() if style_expr else ''

      font = self.attrval('font', default=None)
      if font is not None:
        if style and style[-1] != ';': 
          style += '; '
        style += 'font-size: %s%%;' % font

      if style:
        attrs.append('style="%s"' % style)

      astr = ' '.join(attrs)
      start = '<%s %s>' % (tag, astr) if astr else '<%s>' % tag
      end = '</%s>' % tag

      return start, end
    test:
    end method tagStr;

  end Construct _doc_;

  Construct document < _doc_ #:
    The document construct.
  config:

    primary
    Attribute document : word = <required> #:
      The name of the document

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <native>;

  scope:
  end Construct document;

  Construct presentation < _doc_ #:
    The presentation construct.
  config:

    primary
    Attribute presentation : word = <required> #:
      The name of the namespace.

    secondary
    Attribute width : num = 1000 #:
      The width (in pixels) of each slide.

    secondary
    Attribute height : num = 800 #:
      The height (in pixels) of each slide.

    secondary
    Attribute padding : num = 10 #:
      The padding (in pixels, all sides) for each slide. The active area to
      write into should take this padding into account.

    Attribute comment:;
    Attribute config:;
    Attribute scope: children <slide|native|style|script|filter>;

  expand:
    scope, children = self.attrpair('scope:')
    for construct in children:
      construct.expandMeta()
  translate:
    /# TODO(wmh): Add assocs to constructs
    import json

    metafile = self.metafile()
    streams = metafile.streams()
    streams.initStreams('style', 'jslibs', 'body')

    /# NOTE: We do NOT process scope, and instead do slides(), so that
    /# we don't have to process tags again.  If we introduce constructs
    /# within presentations other than slides, we'll need to fix this.
    slides = self.slides()
    for child in self.attrval('scope:'):
      if child.kind() == 'slide':
        if child in self.slides():
          child.translateMeta()
      else:
        child.translateMeta()
        
    fs = self.compiler().fs()
    path = '%s.html' % self.id()
    with fs.open(path, 'w') as fp:
      /# TODO(wmh): Use a template!
      fp.write('{% extends "base.html" %}\n')

      /###
      /# Now the CSS from style constructs.
      fp.write('\n')
      fp.write('{% block css %}\n')
      for line in streams.stream('style'):
        fp.write(line + '\n')
      fp.write('{% endblock %}\n')

      /###
      /# Now the javascript libraries
      fp.write('\n')
      fp.write('{% block jslibs %}\n')
      fp.write(
        '<script type="text/javascript" src="/static/js/metadoc.js"></script>\n')
      /# All script constructs inserted first
      for line in streams.stream('jslibs'):
        fp.write(line + '\n')
      /# Now the javascript relied upon by Meta(Doc).
      slides = self.slides()
      nums = len(slides)
      animations = self.animations()
      fp.write('<script type="text/javascript">\n')
      fp.write('  var numSlides = %d;\n' % nums)
      fp.write('  var SlideInfo = {\n')
      for i in range(nums):
        slide = slides[i]
        sdata = {'id': slide.id()}
        anims = animations.get(i, None)
        if anims:
          sdata['subids'] = anims
        fp.write('    %d: %s,\n' % (i, json.dumps(sdata)))
      fp.write('  };\n')
      fp.write('</script>\n')
      /# Close javascript.
      fp.write('{% endblock %}\n')

      /###
      /# Now the slide content
      fp.write('\n')
      fp.write('{% block content %}\n')
      for line in streams.stream('body'):
        fp.write(line + '\n')
      fp.write('{% endblock %}\n')
    print 'Wrote %s' % path

    return (None, None)
  scope:

    field slides : @vec<SlideConstruct> #:
      The slides, in order.  Populated in SlideConstruct.expandMeta().

    field width : int #:
      The width (in pixels) of each slide.
    scope:
      accessor get lazy:
        res = int(self.attrval('width', default=metax.c.LOOKUP))
        -> res
    end;

    field height : int #:
      The height (in pixels) of each slide.
    scope:
      accessor get lazy:
        res = int(self.attrval('height', default=metax.c.LOOKUP))
        -> res
    end;

    field padding : int #:
      The padding (in pixels) of each slide.
    scope:
      accessor get lazy:
        res = int(self.attrval('padding', default=metax.c.LOOKUP))
        -> res
    end;

    field animations : @map #:
      Maps slide index to list of slide subids.  The subids do not have the
      slide id prefix on them.

  end Construct presentation;

  Construct slide < _doc_ #:
    The slide construct.
  config:

    primary
    Attribute slide : word = <auto> #:
      The name of the class.

    secondary
    Attribute repeat : word = <empty> #:
      Insert a copy of a named slide (value is id of slide to insert).

    secondary
    Attribute animate : str = <empty> #:
      Space-or-commad-separated list of subids to animate (hide initially, and
      incrementally show when up/down arrows are used).

    secondary
    Attribute tags : str = <empty> #:
      A collection of tags marking this slide. During compilation, slides can
      be selected or unselected based on tag matches.

    secondary
    Attribute classes : str = <empty> #:
      A semicolon-separate list of key=value pairs where each key represents an
      subid, and the value indicates one or more space-separated CSS classes to
      add to the element identified by the subid.

    Attribute notes:;
    Attribute comment:;
    Attribute config:;
    Attribute scope: children <native|panel>;

  expand:
    /# TODO(wmh): Add assocs to constructs!
    import re

    preso = self.ancestor('presentation')
    assert preso
    width = preso.width()
    height = preso.height()
    padding = preso.padding()

    /# Establish if this slide is to be processed or not, based on tags.
    tags = []
    tagstr = self.attrval('tags', default=None)
    if tagstr:
      tags = tagstr.asStr(unquote=True).strip().split()
    self.tagsIs(tags)

    if 'disabled' in tags:
      /# This slide is treated as if it doesn't exist at all.
      /# It is not added to Presentation.slides(), etc.
      /# TODO(wmh): Generalize how slides are disabled.
      pass

    else:
      /# Note that the absolute position of .panel divs within relative relative
      /# position .slide are from the top-left of margin, not from the top-left
      /# of border.
      self.bboxIs([0, 0, width, height])
      slides = preso.slides()
      index = len(slides)
      self.indexIs(index)
      slides.append(self)

      /# If there are animations specified, record them with the preso.
      animate = self.attrval('animate', default=None)
      if animate:
        parts = re.split(r'\s*,?\s*', animate.asStr(unquote=True))
        preso.animations()[index] = parts
  translate:
    /# TODO(wmh): Add assocs to constructs!
    import re

    metafile = self.metafile()
    preso = self.ancestor('presentation')
    slides = preso.slides()
    width = preso.width()
    height = preso.height()
    animate = self.attrval('animate', default=None)

    self.streamLine('')
    self.streamLine('<div id="%s" class="slide">' % self.id())

    title = self.attrval('title', default=None)
    if title:
      tstr = title.asStr(unquote=True)
      self.streamLine('  <h1>%s</h1>' % tstr)
      /# We consume some space at the top for the title.
      self.bbox()[1] += 100

    repeat_attr, repeat = self.attrpair('repeat', default=None)

    /# The scope: of a slide is a complex block.
    /#  - native constructs are dumped verbatim
    /#  - panels are where the real power lies.
    scope = self.attrval('scope:', default=None) or []
    if scope and repeat:
      metafile.warning(
        'repeat is ignored when scope: provided',
        line=repeat_attr.line())
    elif not scope and repeat:
      parent = self.parent()
      other = parent.cons(repeat, default=None)
      if other is None:
        metafile.error(
          '%s references unknown %s' % (self.id(), repeat),
          line=repeat_attr.line())
      else:
        /# We clone the 'scope:' attribute of the referred to construct,
        /# adding the new clone as the 'scope:' attribute of self.
        /#  - this ensures that variable interpolation in the cited slide
        /#    are re-evaluated within the context of this new slide,
        /#    especially important if variable interpolation is used to
        /#    establish ids for html elements (we don't want the same ids
        /#    in different slides).
        other_scope = other.attr('scope:', default=None)
        new_scope = other_scope.clone(self)
        self.registerAttribute(new_scope)
        scope = new_scope.value()
        /# TODO(wmh): Is the following still needed? Should this be for
        /# self.bbox instead??
        other.bboxIs([0, 0, width, height])
        
    for construct in scope:
      construct.translateMeta()

    csize = 20

    if self is slides[0]:
      /# First slide, no left arrow
      /# TODO(wmh): This does not properly account for slide 0 being disabled!
      cleft = ''
    else:
      /# CODOETANGLE(leftarrow)
      cleft = '&nbsp;&nbsp;<span onclick="slideStep(-1);">&#x21e6;</span>'

    if self is slides[-1]:
      /# Last slide, no right arrow
      /# TODO(wmh): This does not properly account for slide 0 being disabled!
      cright = ''
    else:
      /# CODOETANGLE(rightarrow)
      cright = '<span onclick="oneStep(1);">&#x21e8;</span>'

    if animate:
      /# There are animations in this slide, so we show up/down arrows.
      ccenter = '<span onclick="animateStep(-1);">&#x21e7;</span> <span onclick="animateStep(1);">&#x21e9;</span>'
    else:
      ccenter = ''

    clines = [
      '<div class="panel" style="height: %dpx; left: 0px; top: %dpx; width: %dpx;">' % (csize, height-csize, width),
      '  <table style="color: #999; font-size: %dpt; width: %dpx;"><tr>'
      '<td style="text-align: left; width: 33%%;">%s</td>'
      '<td style="text-align: center; width: 34%%;">%s</td>'
      '<td style="text-align: right; width: 33%%;">%s</td>'
      '</tr></table>' % (csize, width, cleft, ccenter, cright),
      '</div>',
    ]
    self.streamLines(clines, indent='  ') 

    self.streamLine('</div>')

    /# If there is a 'classes' attribute, we add some javascript.
    cssinfo = self.attrval('classes', default=None)
    if cssinfo:
      self.streamLine('<script type="text/javascript">')
      parts = re.split(r'\s*;\s*', cssinfo.asStr(unquote=True).strip())
      for part in parts:
        /# TODO(wmh): Handle errors instead of crashing python.
        subid, css = part.split('=')
        id = '%s-%s' % (self.id(), subid)
        for csscls in css.split():
          self.streamLine('  addClass("%s", "%s");' % (id, csscls))
      self.streamLine('</script>')
    return (None, None)
  scope:

    field index : int #:
      The position of this slide in its parent.  Assigned in
      SlideConstruct.expandMeta().

    field bbox : vec<int> #:
      The left-top-right-bottom points of the available bounding box.

    field tags : vec<str> #:
      Tags associated with this slide.

  end Construct slide;

  Construct panel < _doc_ #:
    The panel construct.
  config:

    feature
    Attribute side : <top|left|right|bottom> = left #:
      Identifies which side of the current bounding box this panel consumes.
    config:
      FeatureValue left #:
        Consume the entire available height on the left side.
      FeatureValue right #:
        Consume the entire avaiable height on the right side.
      FeatureValue top #:
        Consume the entire available width on the top side.
      FeatureValue bottom #:
        Consume the entire available width on the bottom side.
    end Attribute side;

    primary
    Attribute panel : id = <auto> #:
      The name of the class.

    secondary
    Attribute style : str = <empty> #:
      Explicit CSS style to add to the <div>.

    secondary
    Attribute color : word = <empty> aliases <fg> #:
      The foreground colo

    secondary
    Attribute background : word = <empty> aliases <bg> #:
      The foreground color.

    secondary
    Attribute border : str = <empty> #:
      Describes the border. Format:
        <spec>    ::- <subspec> (';' <subspec>)?
        <subspec> ::- [<pos>]<num>[<color>]['/'<style>]
        <pos>     ::- [lrtb]+         (indicates which borders ... if empty, all)
        <num>     ::- \d+             (width of border in pixels)
        <color>   ::- named color or #hex, etc.  Default is black
        <style>   ::- 'none' | 'hidden' | 'dotted' | 'dashed' | 'solid' |
                      'double' | 'groove' | 'ridge' | 'inset' | 'outset'
      Examples:
        1             = border: 1px black solid;
        l2            = border-left: 2px black solid;
        t3blue/dashed = border-top: 3px blue dashed;

    secondary
    Attribute size : num = 1.0 #:
      If 'side' is 'left' or 'right', this refers to the desired width of the
      panel.  If 'side' is 'top', this refers to the desired height of the
      panel.  If it is a value greater than 1, it is assumed to be pixels. If
      it is a float between 0.0 and 1.0 inclusive, it is assumed to be a
      fractional amount of existing space in appropriate dimension. A value
      of 0.5 means 50%, and a value of 1.0 means consume all remaining space
      (the default).

    secondary
    Attribute font : num = 100 #:
      The size of text within this panel relative to the parent container.
      Thus, 100 means same size, 80 means 80% of parent, 150 means 150% of
      parent, etc.

    secondary
    Attribute top : num = 0 #:
      A pixel adjustment margin-top for this panel.

    Attribute notes:;
    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <list>;
  expand:
    scope_attr, scope = self.attrpair('scope:', default=None)
    if scope_attr:
      if scope_attr.isComplexBlock():
        /# expand children.
        for child in scope:
          child.expandMeta(output=output)
  translate:
    /# TODO(wmh): Add assocs to constructs!
    import re

    /# A panel provides the core formatting mechanism. It is a <div> with
    /# support for sizing, etc.
    metafile = self.metafile()
    streams = metafile.streams()
    slide = self.ancestor('slide')
    preso = self.ancestor('presentation')
    padding = preso.padding()
    bbox = slide.bbox()
    left, top, right, bottom = bbox
    width = right - left
    height = bottom - top

    title = self.attrval('title', default=None) or ''
    side = self.attrval('side')
    /# TODO(wmh): As of 2018-10-25, attribute values of type 'num' are
    /# represented as strings when they should be ints/floats. Fix this.
    size = float(self.attrval('size'))
    font = int(self.attrval('font'))
    fgcolor = self.attrval('color')
    bgcolor = self.attrval('background')
    border_attr, border_str = self.attrpair('border', default=None)
    border = border_str.asStr(unquote=True) if border_str else ''
    style_str = self.attrval('style', default=metax.c.LOOKUP)
    top_margin_adj = int(self.attrval('top'))
    notes = self.attrval('notes:', default=None) or []

    style_data = {}
    if bgcolor:
      style_data['background-color'] = bgcolor
    if fgcolor:
      style_data['color'] = fgcolor
    if font and font != 100:
      style_data['font-size'] = '%d%%' % font
    if top_margin_adj:
      style_data['margin-top'] = '%dpx' % top_margin_adj

    bre = re.compile(
      r'^(?P<pos>[lrtb]*)'
      r'(?P<num>\d+)'
      r'(?P<color>[^/\t ]*)'
      r'(?:/(?P<style>\S+))?$'
    )
    if border:
      bmap = {
        'a': 'border',
        't': 'border-top',
        'b': 'border-bottom',
        'l': 'border-left',
        'r': 'border-right'
      }
      for spec in border.split(';'):
        m = bre.match(spec)
        if m:
          pos = m.group('pos') or 'a'
          px = int(m.group('num'))
          color = m.group('color') or 'black'
          style = m.group('style') or 'solid'
          for c in list(pos):
            style_data[bmap[c]] = '%dpx %s %s' % (px, color, style)
        else:
          metafile.error(
            'Invalid border spec "%s"' % spec, line=border_attr.line())

    /# If size is between 0 and 1, it is a fractional value. If it is greater
    /# than 1, it is a number of pixels.
    if size >= 0.0 and size <= 1.0:
      /# We convert to pixels.
      if side in ('left', 'right'):
        /# size is a fraction of current width
        pixels = int(size * width + 0.5)
      else:
        /# size is a fraction of current height
        pixels = int(size * height + 0.5)
    else:
      pixels = int(size + 0.5)

    if side in ('left', 'right'):
      /# pixels refers to the width of this panel.
      if pixels > width:
        /# Request to consume more pixels than we have available.
        raise Error('fix me')
      style_data['width'] = '%dpx' % pixels
      style_data['height'] = '%dpx' % height
      style_data['top'] = '%dpx' % (top + padding)
      if side == 'left':
        style_data['left'] = '%dpx' % (left + padding)
        bbox[0] += pixels
      else:
        style_data['left'] = '%dpx' % (right - pixels)
        bbox[2] -= pixels
    else:
      /# pixels refers to the height of this panel.
      if pixels > height:
        /# Request to consume more pixels than we have available.
        raise Error('fix me')
      style_data['height'] = '%dpx' % pixels
      style_data['width'] = '%dpx' % width
      style_data['left'] = '%dpx' % (left + padding)
      if side == 'top':
        style_data['top'] = '%dpx' % (top + padding)
        bbox[1] += pixels
      else:
        style_data['top'] = '%dpx' % (bottom - pixels)
        bbox[3] -= pixels

    /# TODO(wmh): Do indentation properly, using MetaSegments and
    /# template instantiation.
    style = '; '.join(
      ['%s: %s' % (k, style_data[k]) for k in sorted(style_data)]) + ';'
    style += style_str.asStr(unquote=True)
    titlestr = ''
    if notes:
      titlestr = ' title="%s"' % (
        '\n'.join(notes).replace('\"', '&quot;'))
      /# We insert an indicator into the HTML (small red square in top left
      /# corner of the slide).
      /#  - note that top left corner of slide isn't appropriate for all
      /#    panels (really only for the title panel). Need to find a better
      /#    way of indicating per-panel notes.
      streams.addLine(
        'body',
        '<img class="panel" src="/static/demo/turquoise.png" style="top: 0px; left: 0px;"/>')

    divstr = '  <div class="panel" style="%s"%s>' % (style, titlestr)
    streams.addLine('body', divstr)

    scope_attr, scope = self.attrpair('scope:', default=None)
    if scope_attr:
      if scope_attr.isComplexBlock():
        /# The scope is a complex block ... subconstructs write into 
        /# appropriate streams.
        for child in scope:
          child.translateMeta()
      else:
        /# The scope is a simple block ... we write it verbatim.
        self.streamLines(scope, indent='    ')

    streams.addLine('body', '  </div>')

    return (None, None)
  scope:
  end Construct panel;

  Construct style < _doc_ #:
    The style construct.
  config:

    primary
    Attribute style : id = <auto> #:
      The name of the style construct.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simple;
  expand:
  translate:
    /# TODO(wmh): Add assocs to Construct and copy over to classes.
    import re

    metafile = self.metafile()
    preso = self.ancestor('presentation')
    streams = metafile.streams()
    scope = self.attrval('scope:', default=None) or []
    vre = re.compile(r'\${([a-zA-Z0-9]+)}')
    vmap = {
      'width': preso.width(),
      'height': preso.height(),
      'padding': preso.padding(),
    }

    def Repl(m):
      var = m.group(1)
      val = vmap.get(var, None)
      return str(val)

    /# Hardcoded CSS for class 'slide' and 'panel'.
    style_code = """
     >|.slide {
     >|  display: none;
     >|  width: ${width}px;
     >|  height: ${height}px;
     >|  margin-left: auto;
     >|  margin-right: auto;
     >|  padding: ${padding}px;
     >|  /* border-left: 1px solid black; */
     >|  /* border-right: 1px solid black; */
     >|  background-color: #fdf7ef;
     >|  /*
     >|   * relative position is crucial to allowing panels to specify themselves
     >|   * absolutely within this parent div.
     >|   */
     >|  position: relative; 
     >|}
     >|
     >|.panel {
     >|  position: absolute;
     >|  margin: 0px;
     >|  padding: 0px;
     >|}
     >|"""
    style_code = vre.sub(Repl, style_code)
    streams.addLines('style', style_code.split('\n'))

    for line in scope:
      line = vre.sub(Repl, line)
      streams.addLine('style', line)

    return (None, None)
  scope:
  end Construct style;

  Construct script < _doc_ #:
    The script construct.
  config:

    primary
    Attribute script : id = <auto> #:
      The name of the script construct.

    secondary
    Attribute path : str = <empty> #:
      An explicit path to a script.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simple;

  translate:
    metafile = self.metafile()
    streams = metafile.streams()
    scope = self.attrval('scope:', default=None)
    if scope:
      streams.addLine('jslibs', '<script type="text/javascript">')
      streams.addLines('jslibs', scope)
      streams.addLine('jslibs', '</script>')
    else:
      path = self.attrval('path', default=None)
      if path:
        streams.addLine(
          '<script type="text/javascript" src="%s"/>' % path)

    return (None, None)
  scope:
  end Construct script;

  Construct list < _doc_ #:
    The list construct.
  config:

    feature
    Attribute kind : <ordered|ol|unordered|ul> = unordered #:
      What kind of list.
    config:
      FeatureValue unordered aliases <ul> #:
        The list is unordered.
      FeatureValue ordered aliases <ol> #:
        The list is ordered.
    end Attribute kind;

    primary
    Attribute list : id = <auto> #:
      The name of the list construct.

    secondary
    Attribute path : str = <empty> #:
      An explicit path to a list.

    secondary
    Attribute style : str = <empty> #:
      Explicit CSS style to add to the <div>.

    secondary
    Attribute font : num = 100 #:
      The size of text within this list relative to the parent container.
      Thus, 100 means same size, 80 means 80% of parent, 150 means 150% of
      parent, etc.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <item>;

  translate:
    metafile = self.metafile()
    kind = self.attrval('kind')
    indent = '  ' * (self.distance('panel')+1)
    subindent = indent + '  '
    start, end = self.tagStr('ol' if kind == 'ordered' else 'ul')

    /# start
    self.streamLine(start, indent=indent)

    /# body
    scope_attr, scope = self.attrpair('scope:', default=None)
    if scope_attr:
      if scope_attr.isComplexBlock():
        for child in scope:
          child.translateMeta()
      else:
        self.streamLines(scope, indent=subindent)

    /# end
    self.streamLine(end, indent=indent)

    return (None, None)
  scope:
  end Construct list;

  Construct item < _doc_ #:
    The item construct.
  config:

    primary
    Attribute item : id = <auto> #:
      The name of the item construct.

    secondary
    Attribute is : str = <empty> #:
      The title portion of this list item.

    secondary
    Attribute style : str = <empty> #:
      Explicit CSS style to add to the <div>.

    secondary
    Attribute font : num = 100 #:
      The size of text within this list relative to the parent container.
      Thus, 100 means same size, 80 means 80% of parent, 150 means 150% of
      parent, etc.

    Attribute comment:;
    Attribute config:;
    Attribute scope: : simplex children <list> #:
      If simple, it is raw text to place within the <li>. If complex, it is
      a list or various other Meta construct we decide to create.

  translate:
    metafile = self.metafile()

    indent = '  ' * (self.distance('panel')+1)
    subindent = indent + '  '
    start, end = self.tagStr('li')
    
    /# start
    self.streamLine(start, indent=indent)

    /# body
    isval = self.attrval('is', default=None)
    if isval:
      self.streamLine(isval.asStr(unquote=True), indent=subindent)

    scope_attr, scope = self.attrpair('scope:', default=None)
    if scope_attr:
      if scope_attr.isComplexBlock():
        for child in scope:
          child.translateMeta()
      else:
        self.streamLines(scope, indent=subindent)

    /# end
    self.streamLine(end, indent=indent)

    return (None, None)
  scope:
  end Construct item;

  Construct filter < _doc_ #:
    The filter construct.
  config:

    primary
    Attribute filter : id = <auto> #:
      The name of the class.

    secondary
    Attribute re : str = <required> #:
      The regexp to filter

    secondary
    Attribute replacement : str = <required> aliases <=> #:
      The replacement.

    Attribute comment:;

  end Construct filter;

  Construct native < _doc_ clsname DocNativeConstruct #:
    The native construct.
  config:

    primary
    Attribute native : id = <auto> #:
      The name of the native.

    Attribute comment:;
    Attribute scope: : simple;
  expand:
  translate:
    metafile = self.metafile()
    streams = metafile.streams()
    scope = self.attrval('scope:', default=None) or []
    parent = self.parentConstruct()
    indent = '  ' if parent.kind() == 'slide' else ''
    self.streamLines(scope, indent=indent)
    return (None, None)
  scope:
  end Construct native;

  abstract
  BaseLanguage _root_ clsname BaseLanguageDoc #:
    Abstract superclass of all baselangs in Meta(Doc).
  scope:
  end BaseLanguage _root_;

  BaseLanguage html < _root_ name Html suffixes <html> #:
    Functionality for compiling Meta(Doc) code in html.
  scope:

    lifecycle params:
      var id : str;
      var parent : metax.c.ComplexBlock;
      var context : metax.c.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('html')
      self.nameIs('Html')
      self.suffixesIs(['html'])
    end;

  end BaseLanguage html;

  BaseLanguage markdown < _root_ name Markdown suffixes <md> #:
    Functionality for compiling Meta(Doc) code in markdown.    
  scope:

    lifecycle params:
      var id : str;
      var parent : metax.c.ComplexBlock;
      var context : metax.c.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('markdown')
      self.nameIs('Markdown')
      self.suffixesIs(['markdown'])
    end;

  end BaseLanguage markdown;

  BaseLanguage tex < _root_ name TeX suffixes <tex> #:
    Functionality for compiling Meta(Doc) code in tex.
  scope:

    lifecycle params:
      var id : str;
      var parent : metax.c.ComplexBlock;
      var context : metax.c.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('tex')
      self.nameIs('Tex')
      self.suffixesIs(['tex'])
    end;

  end BaseLanguage tex;

end MetaLanguage doc;
