namespace metax.doc scope:

  abstract
  class DocConstruct < metax.meta.Construct #:
    Abstract construct from which all Meta(Doc) constructs inherit.

    All constructs in Meta(Doc) inherit from this abstract construct,
    so the Attribute definitions here are available in subconstructs.
    However, note that the existence of an Attribute here does NOT mean it
    is automatically included in the subconstruct ... the subconstruct
    must specify the primary attribute (and any customization of other
    values).
  assocs:
    std assoc json;
    std assoc os;
    std assoc pprint;
    cls assoc metax.c.Compiler;
    resource testdoc1 path "../../kernel/testdata/metadoc/test1.metadoc";
  scope:

    static
    field Compiler : metax.c.Compiler #:
      Obtain a compiler for Meta(Doc).
    scope:
      accessor get lazy:
        /# TODO(wmh): Will this corrupt a pre-existing initialization?
        metax.c.Compiler.Initialize()
        /#metax.root.Object.Init(cli=None)
        metac = metax.c.Compiler(metal='doc', basel='html')
        -> metac
    end field Compiler;

    abstract method kind : str;

    method streamLine #:
      Add a single line to a stream, handling indenting.
    params:
      var line : str #:
        The line to add
      var stream : str = 'body' #:
        The stream to add to.
      var indent : str = '' #:
        What to add before each line.
    scope:
      streams = self.metafile().streams()
      if line:
        streams.addLine(stream, indent + line)
      else:
        streams.addLine(stream, '')
    test:
    end method streamLine;

    method streamLines #:
      Add lines to a stream, handling >| syntax, initerpolation and indenting.
    params:
      var lines : vec<str> #:
        The lines to add
      var stream : str = 'body' #:
        The stream to add to.
      var indent : str = '' #:
        What to add before each line.
    scope:
      def VarSub(m):
        /# Convert a variable to a value.
        /#  - if the variable is a kind name like panel or slide, we replace
        /#    the var with the id of that construct.
        /#  - what other vars do we want to support?
        var = m.group('var')
        if var in ('panel', 'slide'):
          cons = self.ancestor(var)
          result = cons.id() if cons else '?'
        else:
          result = '?'
        return result

      def Interpolate(m):
        /# Handle an entire specialized variable interpolation request.
        varstr = m.group('varstr')
        result = metax.c.VAR_RE.sub(VarSub, varstr)
        return '"' + result + '"'

      prefix_re = metax.c.SPECIAL_PREFIX_RE2
      interpolation_re = metax.c.INTERPOLATION_RE
      streams = self.metafile().streams()
      for line in lines:
        m = prefix_re.match(line)
        if m:
          line = m.group('line')
        elif line:
          line = indent + line
        line = interpolation_re.sub(Interpolate, line)
        streams.addLine(stream, line)
    test:
    end method streamLines;

    method tagStr : tuple<str,str> #:
      Determine an html start tag with html attributes from this Meta construct.
    params:
      var tag : str #:
        The tag to use.
    scope:
      id = self.id()
      attrs = []
      if not Context.IsAutoId(id) and id[0] != '_':
        fqn = self.fqn(terminal='slide', noauto=True)
        attrs.append('id="%s"' % fqn)

      style_expr = self.attrval('style', default=None)
      style = style_expr.asStr(unquote=True).strip() if style_expr else ''

      font = self.attrval('font', default=None)
      if font is not None:
        if style and style[-1] != ';': 
          style += '; '
        style += 'font-size: %s%%;' % font

      if style:
        attrs.append('style="%s"' % style)

      astr = ' '.join(attrs)
      start = '<%s %s>' % (tag, astr) if astr else '<%s>' % tag
      end = '</%s>' % tag

      return start, end
    test:
    end method tagStr;

    static
    method Parse : metax.meta.Construct #:
      Parse a metadoc file.
    params:
      var path : str;
    scope:
      return DocConstruct.Compiler().parseMeta(path)
    end method Parse;

    override
    method expandMeta params:
      var output : vec<metax.c.Construct> = null #:
        Where to write constructs created during expansion.
    scope:
      /# TODO(wmh): Switch this to be abstract to force children to
      /# define the method.
      print '%s: %sConstruct.expandMeta() should be defined' % (
        self.kindid(), self.kind().capitalize())
    end method expandMeta;

    override
    method translateMeta
    scope:
      /# TODO(wmh): Switch this to be abstract to force children to
      /# define the method.
      print '%s: %sConstruct.translateMeta() should be defined' % (
        self.kindid(), self.kind().capitalize())
    end method translateMeta;

  end class DocConstruct;

  class DocumentConstruct < DocConstruct #:
    The document construct.
  scope:

    method kind : str scope:
      return 'document'
    end method kind;

  end class DocumentConstruct;

  class PresentationConstruct < DocConstruct #:
    The presentation construct.
  scope:

    method kind : str scope:
      return 'presentation'
    end method kind;

    field slides : @vec<SlideConstruct> #:
      The slides, in order.  Populated in SlideConstruct.expandMeta().

    field width : int #:
      The width (in pixels) of each slide.
    scope:
      accessor get lazy:
        res = int(self.attrval('width', default=metax.c.LOOKUP))
        -> res
    end;

    field height : int #:
      The height (in pixels) of each slide.
    scope:
      accessor get lazy:
        res = int(self.attrval('height', default=metax.c.LOOKUP))
        -> res
    end;

    field padding : int #:
      The padding (in pixels) of each slide.
    scope:
      accessor get lazy:
        res = int(self.attrval('padding', default=metax.c.LOOKUP))
        -> res
    end;

    field animations : @map #:
      Maps slide index to list of slide subids.  The subids do not have the
      slide id prefix on them.

    field charts : @map<str,str> #:
      Maps chart ids to chart types.

    field datamap : @map<str,DataConstruct> #:
      Maps data ids to 'data' constructs. Allows us to obtain data from
      tables for incorporation into charts.

    method registerData #:
      Register a 'data' construct, enforcing uniqueness.
    params:
      var data : *metax.doc.DataConstruct #:
        The data construct to register.
    scope:
      name = data.id()
      datamap = self.datamap()
      if name in datamap:
        metafile = self.metafile()
        metafile.error(
          '%s has same id as %s' % (data.kindfqn(), datamap[name]),
          line=data.primary().line())
      else:
        datamap[name] = data
    test:
    end method registerData;

    override
    method expandMeta params:
      var output : vec<metax.c.Construct> = null #:
        Where to write constructs created during expansion.
    scope:
      scope, children = self.attrpair('scope:')
      for construct in children:
        construct.expandMeta()
    end method expandMeta;

    override
    method translateMeta
    scope:
      /# TODO(wmh): This must be changed to use templates!!
      rawmode = os.getenv('METADOC_RAW', '') == 'true'
      /# print 'NOTE: Here with rawmode %s' % rawmode    
      metadoc_js_path = 'metadoc.js' if rawmode else '/static/js/metadocs.js'

      metafile = self.metafile()
      streams = metafile.streams()
      streams.initStreams(
        /# A <style> to add CSS to.
        'style',
        /# A collection of javascript code (not including tag).
        'script',
        /# A collection of one or more <script> nodes (including the tags).
        'jslibs',
        /# The normal stream of content for the presentation.
        'body'
      )

      /# NOTE: We do NOT process scope, and instead do slides(), so that
      /# we don't have to process tags again.  If we introduce constructs
      /# within presentations other than slides, we'll need to fix this.
      slides = self.slides()
      for child in self.attrval('scope:'):
        if child.kind() == 'slide':
          if child in self.slides():
            child.translateMeta()
        else:
          child.translateMeta()

      fs = self.compiler().fs()
      path = '%s.html' % self.id()
      with fs.open(path, 'w') as fp:
        /# TODO(wmh): Use a template!
        if rawmode:
          fp.write('<html>\n')
          fp.write('  <head>\n')
        else:
          fp.write('{% extends "base.html" %}\n')

        /###
        /# Now the CSS from style constructs.
        fp.write('\n')
        fp.write('  <style>\n' if rawmode else '{% block css %}\n')
        for line in streams.stream('style'):
          fp.write('    ' + line + '\n')
        fp.write('  </style>\n' if rawmode else '{% endblock %}\n')

        /###
        /# Now the javascript libraries
        fp.write('\n')
        fp.write('' if rawmode else '{% block jslibs %}\n')
        fp.write(
          '  <script type="text/javascript" src="%s"></script>\n' % metadoc_js_path)
        /# All script constructs inserted first
        for line in streams.stream('jslibs'):
          fp.write(line + '\n')
        /# The google visualization libraries.
        charts = self.charts()
        packages = set(charts.values())
        packages.add('table')
        if len(charts):
          fp.write(
            '  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>\n')
          fp.write('  <script type="text/javascript">\n')
          fp.write(
            "    google.charts.load('current', {'packages': %s});\n"
            % str(sorted(packages)))
          fp.write('    google.charts.setOnLoadCallback(drawCharts);\n')
          fp.write('    function drawCharts() {\n')
          for chart_id in sorted(charts):
            fp.write('      draw_%s();\n' % chart_id)
          fp.write('    }\n')
          fp.write('  </script>\n')
        /# The implicit script next
        script_lines = streams.stream('script')
        if script_lines:
          fp.write('  <script type="text/javascript">\n')
          for line in script_lines:
            fp.write('    ' + line + '\n')
          fp.write('  </script>\n')
        /# Now the javascript relied upon by Meta(Doc).
        slides = self.slides()
        nums = len(slides)
        animations = self.animations()
        fp.write('<script type="text/javascript">\n')
        fp.write('  // We do not use var here because they are declared in\n')
        fp.write('  // metadoc.js\n')
        if rawmode:
          fp.write('  targetSlide = 0;\n')
        else:
          fp.write('  targetSlide = {{ targetSlide|default(0) }};\n')
        fp.write('  numSlides = %d;\n' % nums)
        fp.write('  SlideInfo = {\n')
        for i in range(nums):
          slide = slides[i]
          sdata = {'id': slide.id()}
          anims = animations.get(i, None)
          if anims:
            sdata['subids'] = anims
          fp.write('    %d: %s,\n' % (i, json.dumps(sdata)))
        fp.write('  };\n')
        fp.write('</script>\n')
        /# Close javascript.
        fp.write('' if rawmode else '{% endblock %}\n')

        if rawmode:
          fp.write('  </head>\n')

        /###
        /# Now the slide content
        fp.write('\n')
        fp.write('  <body>\n' if rawmode else '{% block content %}\n')
        for line in streams.stream('body'):
          fp.write(line + '\n')


        /# We start with the desired slide.
        fp.write('<script>showSlide(targetSlide);</script>\n')

        fp.write('  </body>\n<html>\n' if rawmode else '{% endblock %}\n')
      print 'Wrote %s' % path

      return (None, None)
    end method translateMeta;

  end class PresentationConstruct;

  class SlideConstruct < DocConstruct #:
    The slide construct.
  scope:

    method kind : str scope:
      return 'slide'
    end method kind;

    field index : int #:
      The position of this slide in its parent.  Assigned in
      SlideConstruct.expandMeta().

    field bbox : vec<int> #:
      The left-top-right-bottom points of the available bounding box.

    field tags : vec<str> #:
      Tags associated with this slide.

    override
    method expandMeta params:
      var output : vec<metax.c.Construct> = null #:
        Where to write constructs created during expansion.
    scope:
      /# TODO(wmh): Add assocs to constructs!
      import re

      preso = self.ancestor('presentation')
      assert preso
      width = preso.width()
      height = preso.height()
      padding = preso.padding()

      /# Establish if this slide is to be processed or not, based on tags.
      tags = []
      tagstr = self.attrval('tags', default=None)
      if tagstr:
        tags = tagstr.asStr(unquote=True).strip().split()
      self.tagsIs(tags)

      if 'disabled' in tags:
        /# This slide is treated as if it doesn't exist at all.
        /# It is not added to Presentation.slides(), etc.
        /# TODO(wmh): Generalize how slides are disabled.
        pass

      else:
        /# Note that the absolute position of .panel divs within relative relative
        /# position .slide are from the top-left of margin, not from the top-left
        /# of border.
        self.bboxIs([0, 0, width, height])
        slides = preso.slides()
        index = len(slides)
        self.indexIs(index)
        slides.append(self)

        /# If there are animations specified, record them with the preso.
        animate = self.attrval('animate', default=None)
        if animate:
          parts = re.split(r'\s*,?\s*', animate.asStr(unquote=True))
          preso.animations()[index] = parts
    end method expandMeta;

    override
    method translateMeta
    scope:
      /# TODO(wmh): Add assocs to constructs!
      import re

      metafile = self.metafile()
      preso = self.ancestor('presentation')
      slides = preso.slides()
      width = preso.width()
      height = preso.height()
      animate = self.attrval('animate', default=None)

      self.streamLine('')
      self.streamLine('<div id="%s" class="slide">' % self.id())

      title = self.attrval('title', default=None)
      if title:
        tstr = title.asStr(unquote=True)
        self.streamLine('  <h1>%s</h1>' % tstr)
        /# We consume some space at the top for the title.
        self.bbox()[1] += 100

      repeat_attr, repeat = self.attrpair('repeat', default=None)

      /# The scope: of a slide is a complex block.
      /#  - native constructs are dumped verbatim
      /#  - panels are where the real power lies.
      scope = self.attrval('scope:', default=None) or []
      if scope and repeat:
        metafile.warning(
          'repeat is ignored when scope: provided',
          line=repeat_attr.line())
      elif not scope and repeat:
        parent = self.parent()
        other = parent.cons(repeat, default=None)
        if other is None:
          metafile.error(
            '%s references unknown %s' % (self.id(), repeat),
            line=repeat_attr.line())
        else:
          /# We clone the 'scope:' attribute of the referred to construct,
          /# adding the new clone as the 'scope:' attribute of self.
          /#  - this ensures that variable interpolation in the cited slide
          /#    are re-evaluated within the context of this new slide,
          /#    especially important if variable interpolation is used to
          /#    establish ids for html elements (we don't want the same ids
          /#    in different slides).
          other_scope = other.attr('scope:', default=None)
          new_scope = other_scope.clone(self)
          self.registerAttribute(new_scope)
          scope = new_scope.value()
          /# TODO(wmh): Is the following still needed? Should this be for
          /# self.bbox instead??
          other.bboxIs([0, 0, width, height])

      for construct in scope:
        construct.translateMeta()

      csize = 20

      if self is slides[0]:
        /# First slide, no left arrow
        /# TODO(wmh): This does not properly account for slide 0 being disabled!
        cleft = ''
      else:
        /# CODOETANGLE(leftarrow)
        cleft = '&nbsp;&nbsp;<span onclick="slideStep(-1);">&#x21e6;</span>'

      if self is slides[-1]:
        /# Last slide, no right arrow
        /# TODO(wmh): This does not properly account for slide 0 being disabled!
        cright = ''
      else:
        /# CODOETANGLE(rightarrow)
        cright = '<span onclick="oneStep(1);">&#x21e8;</span>'

      if animate:
        /# There are animations in this slide, so we show up/down arrows.
        ccenter = '<span onclick="animateStep(-1);">&#x21e7;</span> <span onclick="animateStep(1);">&#x21e9;</span>'
      else:
        ccenter = ''

      clines = [
        '<div class="panel" style="height: %dpx; left: 0px; top: %dpx; width: %dpx;">' % (csize, height-csize, width),
        '  <table style="color: #999; font-size: %dpt; width: %dpx;"><tr>'
        '<td style="text-align: left; width: 33%%;">%s</td>'
        '<td style="text-align: center; width: 34%%;">%s</td>'
        '<td style="text-align: right; width: 33%%;">%s</td>'
        '</tr></table>' % (csize, width, cleft, ccenter, cright),
        '</div>',
      ]
      self.streamLines(clines, indent='  ') 

      self.streamLine('</div>')

      /# If there is a 'classes' attribute, we add some javascript.
      cssinfo = self.attrval('classes', default=None)
      if cssinfo:
        self.streamLine('<script type="text/javascript">')
        parts = re.split(r'\s*;\s*', cssinfo.asStr(unquote=True).strip())
        for part in parts:
          /# TODO(wmh): Handle errors instead of crashing python.
          subid, css = part.split('=')
          id = '%s-%s' % (self.id(), subid)
          for csscls in css.split():
            self.streamLine('  addClass("%s", "%s");' % (id, csscls))
        self.streamLine('</script>')
      return (None, None)
    end method translateMeta;

  end class SlideConstruct;

  class PanelConstruct < DocConstruct #:
    The panel construct.
  scope:

    method kind : str scope:
      return 'panel'
    end method kind;

    override
    method expandMeta params:
      var output : vec<metax.c.Construct> = null #:
        Where to write constructs created during expansion.
    scope:
      scope_attr, scope = self.attrpair('scope:', default=None)
      if scope_attr:
        if scope_attr.isComplexBlock():
          /# expand children.
          for child in scope:
            child.expandMeta(output=output)
    end method expandMeta;

    override
    method translateMeta
    scope:
      /# TODO(wmh): Add assocs to constructs!
      import re

      /# A panel provides the core formatting mechanism. It is a <div> with
      /# support for sizing, etc.
      metafile = self.metafile()
      streams = metafile.streams()
      slide = self.ancestor('slide')
      preso = self.ancestor('presentation')
      padding = preso.padding()
      bbox = slide.bbox()
      left, top, right, bottom = bbox
      width = right - left
      height = bottom - top

      title = self.attrval('title', default=None) or ''
      side = self.attrval('side')
      /# TODO(wmh): As of 2018-10-25, attribute values of type 'num' are
      /# represented as strings when they should be ints/floats. Fix this.
      size = float(self.attrval('size'))
      font = int(self.attrval('font'))
      fgcolor = self.attrval('color')
      bgcolor = self.attrval('background')
      border_attr, border_str = self.attrpair('border', default=None)
      border = border_str.asStr(unquote=True) if border_str else ''
      style_str = self.attrval('style', default=metax.c.LOOKUP)
      top_margin_adj = int(self.attrval('top'))
      notes = self.attrval('notes:', default=None) or []

      style_data = {}
      if bgcolor:
        style_data['background-color'] = bgcolor
      if fgcolor:
        style_data['color'] = fgcolor
      if font and font != 100:
        style_data['font-size'] = '%d%%' % font
      if top_margin_adj:
        style_data['margin-top'] = '%dpx' % top_margin_adj

      bre = re.compile(
        r'^(?P<pos>[lrtb]*)'
        r'(?P<num>\d+)'
        r'(?P<color>[^/\t ]*)'
        r'(?:/(?P<style>\S+))?$'
      )
      if border:
        bmap = {
          'a': 'border',
          't': 'border-top',
          'b': 'border-bottom',
          'l': 'border-left',
          'r': 'border-right'
        }
        for spec in border.split(';'):
          m = bre.match(spec)
          if m:
            pos = m.group('pos') or 'a'
            px = int(m.group('num'))
            color = m.group('color') or 'black'
            style = m.group('style') or 'solid'
            for c in list(pos):
              style_data[bmap[c]] = '%dpx %s %s' % (px, color, style)
          else:
            metafile.error(
              'Invalid border spec "%s"' % spec, line=border_attr.line())

      /# If size is between 0 and 1, it is a fractional value. If it is greater
      /# than 1, it is a number of pixels.
      if size >= 0.0 and size <= 1.0:
        /# We convert to pixels.
        if side in ('left', 'right'):
          /# size is a fraction of current width
          pixels = int(size * width + 0.5)
        else:
          /# size is a fraction of current height
          pixels = int(size * height + 0.5)
      else:
        pixels = int(size + 0.5)

      if side in ('left', 'right'):
        /# pixels refers to the width of this panel.
        if pixels > width:
          /# Request to consume more pixels than we have available.
          raise Error('fix me')
        style_data['width'] = '%dpx' % pixels
        style_data['height'] = '%dpx' % height
        style_data['top'] = '%dpx' % (top + padding)
        if side == 'left':
          style_data['left'] = '%dpx' % (left + padding)
          bbox[0] += pixels
        else:
          style_data['left'] = '%dpx' % (right - pixels)
          bbox[2] -= pixels
      else:
        /# pixels refers to the height of this panel.
        if pixels > height:
          /# Request to consume more pixels than we have available.
          raise Error('fix me')
        style_data['height'] = '%dpx' % pixels
        style_data['width'] = '%dpx' % width
        style_data['left'] = '%dpx' % (left + padding)
        if side == 'top':
          style_data['top'] = '%dpx' % (top + padding)
          bbox[1] += pixels
        else:
          style_data['top'] = '%dpx' % (bottom - pixels)
          bbox[3] -= pixels

      /# TODO(wmh): Do indentation properly, using MetaSegments and
      /# template instantiation.
      style = '; '.join(
        ['%s: %s' % (k, style_data[k]) for k in sorted(style_data)]) + ';'
      style += style_str.asStr(unquote=True)
      titlestr = ''
      if notes:
        titlestr = ' title="%s"' % (
          '\n'.join(notes).replace('\"', '&quot;'))
        /# We insert an indicator into the HTML (small red square in top left
        /# corner of the slide).
        /#  - note that top left corner of slide isn't appropriate for all
        /#    panels (really only for the title panel). Need to find a better
        /#    way of indicating per-panel notes.
        streams.addLine(
          'body',
          '<img class="panel" src="/static/demo/turquoise.png" style="top: 0px; left: 0px;"/>')

      divstr = '  <div class="panel" style="%s"%s>' % (style, titlestr)
      streams.addLine('body', divstr)

      scope_attr, scope = self.attrpair('scope:', default=None)
      if scope_attr:
        if scope_attr.isComplexBlock():
          /# The scope is a complex block ... subconstructs write into 
          /# appropriate streams.
          for child in scope:
            child.translateMeta()
        else:
          /# The scope is a simple block ... we write it verbatim.
          self.streamLines(scope, indent='    ')

      streams.addLine('body', '  </div>')

      return (None, None)
    end method translateMeta;

  end class PanelConstruct;

  abstract
  class AbstractDataConstruct < DocConstruct #:
    Abstract super-construct of table and chart.
  scope:

    method kind : str scope:
      return '_data_'
    end method kind;

    lifecycle  clinit:
      /# Converts metadoc cell types to google visualization cell types
      cls.JSTYPE_MAP = {
        'ymd': 'date',
        'date': 'date',
        'datetime': 'datetime',
        'ymdhms': 'datetime',
        'hms': 'timeofday',
        'timeofday': 'timeofday',
        'string': 'string',
        'str': 'string',
        'num': 'number',
        'number': 'number',
        'int': 'number',
        'float': 'number',
        'real': 'number',
        'bool': 'boolean',
        'boolean': 'boolean',
        /# Special indicator that we are to ignore this column.
        'void': False,
      }

      /# For converting boolean data cells to Python boolean
      cls.BOOL_MAP = {
        /# true values
        'true': True,
        't': True,
        'yes': True,
        'y': True,
        '1': True,
        /# false values
        'false': False,
        'f': False,
        'no': False,
        'n': False,
        '0': False,
      }
    end;

    method columnInfo : vec<map> #:
      Parse the 'columns:' (or 'columns') attribute into a list of maps containing:
        name : str
          The name of the column, used when referencing it, to form default
          labels, etc.
        index: int
          The index of the column (ordered lexical position), starting from 0.
        rawtype : str
          The type as it appears in the .metadoc source file
        type : str
          The type of the column, in terms of Google Visualization chart types.
          Note that the rawtype can be various additional values, all of which
          map down to one of the GV types stored here.
        label : str
          What to display in the header for this column.  If not present,
          a capitalized version of name is assumed.
        width : str
          The width desired when displaying the column.
          TODO(wmh): decide what formats this will support. Is it the standard
          CSS dimensions like 'px', 'em', 'ch', etc? Or something else?
        data : DataConstruct
          The DataConstruct that this column references. This is handled
          different for 'data' vs 'chart' constructs.
        from : str
          The table (and column) from which to obtain data.
        formula : function
          A function accepting a single parameter 'x' that returns a value in
          terms of x.
    scope:
      presentation = self.ancestor('presentation')
      datamap = presentation.datamap()

      cls = self.__class__
      /# TODO(wmh): Add a 'columns' str-valued attribute and allow one to
      /# specify simply columns that way, rather than having to always use the
      /# heaviness of a complex-valued 'columns:' attribute. Can use the
      /# following regexp for matching words within the 'column' string:
      /#   cre = re.compile(
      /#     r'^\s*(?P<name>[a-zA-Z_][a-zA-Z_0-9]*)(?::(?P<type>%s))?\s*$'
      /#     % '|'.join(jstypemap.keys()))
      result = []
      metafile = self.metafile()      
      columns_attr, columns = self.attrpair('columns:', default=None)
      if columns_attr is None:
        metafile.error(
          'Must provide columns attribute', line=self.primary().line())
        return

      /# We establish the default value to use for 'from' if a 'column' within
      /# the 'columns:' block does not explicitly provide its own 'from'.
      default_from = self.attrval('from') if self.kind() == 'chart' else None

      for index, column in enumerate(columns):

        /# The label indicates the printable representation of the column.
        label_str = column.attrval('label')
        if label_str:
          label = label_str.asStr(unquote=True)
        else:
          label = self.id().capitalize()

        /# The width will be used to control how wide the column is in display
        width_str = column.attrval('width')
        if width_str:
          /# TODO(wmh): Establish what the various width formats will be.
          /# CSS like 'px', 'em', 'ch', etc? Or something else?
          width = width_str.asStr(unquote=True)
        else:
          width = None

        /# Process any provided formula.
        formula = None
        formula_attr, formula_expr = column.attrpair('formula', default=None)
        if formula_attr is not None:
          try:
            formula = eval('lambda cell: ' + formula_expr.asStr(unquote=True))
          except SyntaxError as e:
            metafile.error(
              'Invalid formula: %s' % str(e), line=formula_attr.line())

        /# Identify 'data', the DataConstruct from which this column is sourced.
        /#  - if self is a DataConstruct, it is used, otherwise
        /#    (self is ChartConstruct) we need to establish the DataConstruct
        /#    by looking at the 'from' attribute.
        /#  - if no 'from' is found explicitly specified on the 'column'
        /#    instance, we use the default specified by the 'from' attribute
        /#    of the 'chart' parent.  It is an error for it to also be
        /#    unspecified.
        if self.kind() == 'data':
          data = self
          dataname = data.id()
          datacol = self.id()
          columninfo = None
          fromstr = None
        else:
          from_attr, fromstr = column.attrpair('from', default=metax.c.LOOKUP)
          if not fromstr:
            if not default_from and self.kind() == 'chart':
              metafile.error(
                'Must provide from attribute on column or chart',
                line=column.primary().line())
            else:
              fromstr = default_from

          dataname, datacol, data, columninfo = (None, None, None, None)
          if fromstr:
            fromparts = fromstr.split('.')
            if len(fromparts) == 1:
              /# No column within the table was specified, so we assume the user
              /# wants the column within the table that matches the name of 
              /# this column.
              dataname = fromparts[0]
              datacol = column.id()
            elif len(fromparts) == 2:
              dataname, datacol = fromparts
            else:
              metafile.error(
                'Invalid from "%s"' % fromstr, line=from_attr.line())
            if dataname:
              data = datamap.get(dataname, None)
              if data is None:
                metafile.error(
                  'Unknown data "%s" referenced' % dataname,
                  line=from_attr.line())
              else:
                columninfo = data.columns()[datacol]

            /# print 'fromstr="%s" dataname=%s datacol=%s data=%s' % (fromstr, dataname, datacol, data)

        type_attr, rawtype = column.attrpair('type', default=None)
        if type_attr is None:
          /# This is an error if we are parsing a 'data' construct, and is
          /# normal if we are defining a 'chart', since type for charts can
          /# be inferred from the underlying 'data' column.
          if data:
            jstype = columninfo['meta']['type']
          else:
            metafile.error('Missing type', line=self.primary().line())
            jstype = None
        else:
          jstypemap = cls.JSTYPE_MAP
          jstype = jstypemap.get(rawtype, None)
          if jstype is None:
            metafile.error(
              'Invalid column type "%s"' % rawtype, line=type_attr.line())

        info = {
          'name': column.id(),
          'index': index,
          'rawtype': rawtype,
          'type': jstype,
          'label': label,
          'width': width,
          'data': data,
          'dataname': dataname,
        }
        if self.kind() == 'chart':
          info['from'] = fromstr
          info['column'] = columninfo
        if formula:
          info['formula'] = formula
        result.append(info)
      return result
    test:
      metafile = metax.doc.DocConstruct.Parse(
        metax.root.Object.Resource('metax.doc.DataConstruct.testdoc1'))
      data1 = metafile.find('/preso1/slide1/panel1/data1')
      chart1 = metafile.find('/preso1/slide1/panel2/table1')

      test.iseq(
        [
          {'index': 0, 'name': 'time', 'dataname': 'data1',
           'width': '', 'data': data1, 'label': '',
           'type': 'timeofday', 'rawtype': 'hms'},
          {'index': 1, 'name': 'fruit', 'dataname': 'data1',
           'width': '', 'data': data1, 'label': '',
           'type': 'string', 'rawtype': 'str'},
          {'index': 2, 'name': 'count', 'dataname': 'data1',
           'width': '', 'data': data1, 'label': '',
           'type': 'number', 'rawtype': 'int'},
          {'index': 3, 'name': 'rating', 'dataname': 'data1',
           'width': '', 'data': data1, 'label': '',
           'type': 'number', 'rawtype': 'real'},
        ],
        data1.columnInfo())

      /# It is important to translate the data1 construct before we call
      /# chart1.columnInfo() because columnInfo() relies on the underlying
      /# data instance being registered with the presentation.
      data1.translateMeta()

      chart_colinfo = chart1.columnInfo()
      for col in chart_colinfo:
        if 'formula' in col:
          del col['formula']

      test.iseq(
        [
          {
            'column': {
              'data': {
                '13:30': {'python': [13, 30, 0, 0], 'raw': '13:30'},
                '13:35': {'python': [13, 35, 0, 0], 'raw': '13:35'},
                '13:45': {'python': [13, 45, 0, 0], 'raw': '13:45'}},
              'meta': {
                'data': data1,
                'dataname': 'data1',
                'index': 0,
                'label': '',
                'name': 'time',
                'rawtype': 'hms',
                'type': 'timeofday',
                'width': ''}
            },
            'data': data1,
            'dataname': 'data1',
            'from': 'data1',
            'index': 0,
            'label': '',
            'name': 'time',
            'rawtype': None,
            'type': 'timeofday',
            'width': '',
          },
          {
            'column': {
              'data': {
                '13:30': {'python': 'apple', 'raw': 'apple'},
                '13:35': {'python': 'banana', 'raw': 'banana'},
                '13:45': {'python': 'cantelope', 'raw': 'cantelope'},
              },
              'meta': {
                'data': data1,
                'dataname': 'data1',
                'index': 1,
                'label': '',
                'name': 'fruit',
                'rawtype': 'str',
                'type': 'string',
                'width': ''},
            },
            'data': data1,
            'dataname': 'data1',
            'from': 'data1',
            'index': 1,
            'label': '',
            'name': 'fruit',
            'rawtype': None,
            'type': 'string',
            'width': '',
            /# 'formula': <function> deleted above
          },
          {
            'column': {
              'data': {
                '13:30': {'python': 1, 'raw': '1'},
                '13:35': {'python': 3, 'raw': '3'},
                '13:45': {'python': 2, 'raw': '2'}},
              'meta': {
                'data': data1,
                'dataname': 'data1',
                'index': 2,
                'label': '',
                'name': 'count',
                'rawtype': 'int',
                'type': 'number',
                'width': ''},
            },
            'data': data1,
            'dataname': 'data1',
            'from': 'data1',
            'index': 2,
            'label': '',
            'name': 'count',
            'rawtype': None,
            'type': 'number',
            'width': '',
            /# 'formula': <function> deleted above
          },
        ],
        chart_colinfo)
      return
    end method columnInfo;

    method optionInfo : vec<str> #:
      Obtain the option: contents.
    scope:
      options = self.attrval('options:', default=None) or []
      return options
    end method optionInfo;

  end class AbstractDataConstruct;

  class DataConstruct < AbstractDataConstruct #:
    Define a data.

    The scope block is a 2d data table.
  assocs:
    std assoc re;
  scope:

    method kind : str scope:
      return 'data'
    end method kind;

    field columns : vec<map> #:
      Maps column names to meta-info about the column.  This is just a caching
      of the return value of AbstractDataConstruct.columnInfo()

    field colmap : map<str,map<str,any>> #:
      Maps column names to row key to cell value (as python object)

    field rowmap : map #:
      Maps row keys to col name to cell value (as python object)

    field rows : vec<map> #:
      Maintains the order in which rows appeared in source. Each element is
      a row data dict (see rowmap above).

    lifecycle 
    clinit:
      /# Each cell in a data is separated by '|' and whitespace.
      cls.SEP_RE = re.compile(r'\s*\|\s*')

      /# A data line starting with the following is ignored.
      /#  - TODO(wmh): Use the regexp defined in Meta(Oopl) for this!
      cls.COM_RE = re.compile(r'^\s*\/\#')

      /# The legal representation of a 'hms' (aka 'timeofday') column.
      /#  - hour, or hour:min or hour:min:sec (with ':' being optional).
      cls.HMS_RE = re.compile(r'^(\d{2})(?::?(\d{2})(?::?(\d{2}(?:(\.\d+))?))?)?$')

    clsetup:
      import metax.c
      import metastrap
      metastrap.Setup()

      if True:
        /# Parse a test .metadoc file.
        path = metax.root.Object.Resource('metax.doc.DataConstruct.testdoc1')
        metafile = metax.doc.DocConstruct.Parse(path)
        data = metafile.find('/preso1/slide1/panel1/data1')
      else:
        /# This is the hard way, and would need more work to populate
        /# a robust DataConstruct instance. Decided it was easier to just
        /# parse a .metadoc file instead.  Leaving this code here though
        /# as a useful reminder of how one can set up constructs from scratch.
        metafile = None
        metalang = metac.metalang()
        context = metalang.context()
        preso = metax.doc.PresentationConstruct.NewFromData(
          'apreso', context, secondaries=[('scope:', [])])
        slide = metax.doc.SlideConstruct.NewFromData(
          'aslide', context, parent=preso.attr('scope:'),
          secondaries=[('scope:', [])])
        panel = metax.doc.PanelConstruct.NewFromData(
          'apanel', context, parent=slide.attr('scope:'),
          secondaries=[('scope<*>:', [])])
        /# TODO(wmh): There is something very strange going on in NewFromData
        /# when populating simplex scopes. You would think we'd call
        /#   panel.attr('scope<*>:'
        /# to obtain the scope created in the previous call. But that returns
        /# a SimpleBlock, whereas calling
        /#   panel.attr('scope:'
        /# returns the complex block.  WTF??
        data = metax.doc.DataConstruct.NewFromData(
          'adata', context, parent=panel.attr('scope:'),
          secondaries=[('scope:', [])])
      cls.Data1 = data
      cls.TestMetafile = metafile
    setup:
      test.data1 = self.__class__.Data1
    end;

    method translateMeta scope:
      cls = self.__class__
      metafile = self.metafile()
      streams = metafile.streams()
      presentation = self.ancestor('presentation')

      boolmap = AbstractDataConstruct.BOOL_MAP

      def Str2Date(dstr):
        ss = len(dstr)
        if ss == 8:
          startdate = datetime.datetime.strptime(dstr, '%Y%m%d')
        elif ss == 10:
          startdate = datetime.datetime.strptime(dstr, '%Y%m%d%H')
        elif ss == 12:
          startdate = datetime.datetime.strptime(dstr, '%Y%m%d%H%M')
        elif ss == 14:
          startdate = datetime.datetime.strptime(dstr, '%Y%m%d%H%M%S')
        else:
          startdate = None
        return startdate

      /# Record this data object with the presentation.
      presentation.registerData(self)

      /# Obtain the column data
      columns = self.columnInfo()

      /# Create an initial column-based mapping.
      /#  - maps column name to dict containing key 'meta', which is a map 
      /#    of the generic column info
      /#  - later in this method, we will add a 'data' key to each dict which
      /#    maps unique row key values to column cell values.
      colmap = {col['name']: {'meta': col} for col in columns}

      /# Establish the column name whose values are unique and is used as key.
      /#  - those values will be used as the key in rowmap and
      /#    colmap[col]['data']
      /#  - some column MUST be able to act as the unique key. If the data
      /#    itself doesn't guarantee this, user should add a number column
      /#    that does (until we can provide it automatically).
      keycol = self.attrval('key') or columns[0]['name']

      /# Process the table data rows.
      /#  - The scope: block contains data, one line per row, with each column
      /#    delimited by sepre.
      /#  - for each row
      /#     - we obtain a 'row' dict mapping column name to cell value
      /#     - we add the 'row' dict to rows
      /#     - we add the 'row' to rowmap using row[keycol] as the key.
      /#     - we populate colmap[col]['data'][keycol] with column values.
      rows = []  # maintains each row map in order
      rowmap = {}  # mapping from unique row key to row map instance
      num_columns = len(columns)
      scope_attr, scope = self.attrpair('scope:', default=None)
      line_offset = scope_attr.line()
      scope = scope or []

      for ln, line in enumerate(scope, start=1):
        if not line.strip():
          /# Ignore empty lines.
          pass
        elif cls.COM_RE.match(line):
          /# Ignore comment lines
          pass
        else:
          /# Split the line into cells.
          /#  - The row is expected to start and end with '|' (modulo whitespace)
          /#    and for each cell to be separated by '|'
          /#  - We create a dict mapping column names to cell values.
          cells = cls.SEP_RE.split(line)
          k = len(cells)
          if k-2 != num_columns:
            /# This line has an invalid number of cells.
            /# print '**** HERE with scope line %d' % scope_attr.line()
            metafile.error(
              'Expecting %d cells, found %d' % (num_columns, k-2),
              line=line_offset + ln)
          else:
            /# We have a valid line.
            row = {}
            for i in range(0, num_columns):
              cell = cells[i+1]  # The first element of 'cells' are spurious.
              colinfo = columns[i]
              colname = colinfo['name']
              jstype = colinfo['type']

              if not cell:
                /# Empty cell means value is None
                value = None
              elif jstype == 'string':
                value = cell
              elif jstype == 'number':
                try:
                  if cell.isdigit():
                    value = int(cell)
                  else:
                    value = float(cell)
                except (ValueError, AttributeError):
                  metafile.error(
                    'Invalid number "%s"' % cell, line=line_offset + ln)
                  value = 0.0
              elif jstype in ('datetime', 'date'):
                /# Create a javascript Date instance.
                value = Str2Date(cell)
                if value is None:
                  metafile.error(
                    'Invalid date "%s"' % cell, line=line_offset + ln)
              elif jstype == 'timeofday':
                m = cls.HMS_RE.match(cell)
                if m:
                  value = [
                    int(m.group(1) or 0),
                    int(m.group(2) or 0),
                    int(m.group(3) or 0),
                    int(float(m.group(4) or 0) * 100000)]
                else:
                  metafile.error(
                    'Invalid timeofday "%s"' % cell, line=line_offset + ln)
              elif jstype == 'boolean':
                value = boolmap.get(cell.lower(), None)
                if pyval is None:
                  metafile.error(
                    'Invalid boolean "%s"', line=line_offset + ln)
              else:
                raise metax.c.InternalError('Unhandled jstype "%s"' % jstype)
              row[colname] = {'python': value, 'raw': cell}

            /# We add the parsed row dict to the in-order list of rows.
            rows.append(row)

            /# Each row has some column value that is unique, which is used
            /# as a key so we can merge across rows.
            /#  - we create a mapping from unique row value to row dict
            /#  - for every column, we create a mapping from unique row value
            /#    to list of values (parallelse the 'rows' list).
            row_key = row[keycol]['raw']
            rowmap[row_key] = row

      /# Now that we have all the parsed rows, we go back and create, for
      /# each column, a mapping from unique row key value to column value.
      for col in columns:
        colname = col['name']
        values = {}
        for row in rows:
          row_key = row[keycol]['raw']
          values[row_key] = row[colname]
        colmap[colname]['data'] = values

      self.columnsIs(colmap)
      self.rowsIs(rows)
      self.rowmapIs(rowmap)
    test:
      data = test.data1
      test.isnull(data.columns())
      test.isnull(data.rows())

      data.translateMeta()

      test.iseq(
        {'count': {
          'data': {
            '13:30': {'python': 1, 'raw': '1'},
            '13:35': {'python': 3, 'raw': '3'},
            '13:45': {'python': 2, 'raw': '2'}},
          'meta': {
            'data': data,
            'dataname': 'data1',
            'index': 2,
            'label': '',
            'name': 'count',
            'rawtype': 'int',
            'type': 'number',
            'width': '',
          },
        },
        'fruit': {
          'data': {
            '13:30': {'python': 'apple', 'raw': 'apple'},
            '13:35': {'python': 'banana', 'raw': 'banana'},
            '13:45': {'python': 'cantelope', 'raw': 'cantelope'}},
          'meta': {
            'data': data,
            'dataname': 'data1',
            'index': 1,
            'label': '',
            'name': 'fruit',
            'rawtype': 'str',
            'type': 'string',
            'width': '',
          },
        },
        'rating': {
          'data': {
            '13:30': {'python': 3, 'raw': '3'},
            '13:35': {'python': 4, 'raw': '4'},
            '13:45': {'python': 5, 'raw': '5'}},
          'meta': {
            'data': data,
            'dataname': 'data1',
            'index': 3,
            'label': '',
            'name': 'rating',
            'rawtype': 'real',
            'type': 'number',
            'width': '',
          },
        },
        'time': {
          'data': {
            '13:30': {'python': [13, 30, 0, 0], 'raw': '13:30'},
            '13:35': {'python': [13, 35, 0, 0], 'raw': '13:35'},
            '13:45': {'python': [13, 45, 0, 0], 'raw': '13:45'}},
          'meta': {
            'data': data,
            'dataname': 'data1',
            'index': 0,
            'label': '',
            'name': 'time',
            'rawtype': 'hms',
            'type': 'timeofday',
            'width': '',
          },
        },
      },
      data.columns())

      test.iseq(
        [{'count': {'python': 1, 'raw': '1'},
         'fruit': {'python': 'apple', 'raw': 'apple'},
         'rating': {'python': 3, 'raw': '3'},
         'time': {'python': [13, 30, 0, 0], 'raw': '13:30'}},
         {'count': {'python': 3, 'raw': '3'},
          'fruit': {'python': 'banana', 'raw': 'banana'},
          'rating': {'python': 4, 'raw': '4'},
          'time': {'python': [13, 35, 0, 0], 'raw': '13:35'}},
         {'count': {'python': 2, 'raw': '2'},
          'fruit': {'python': 'cantelope', 'raw': 'cantelope'},
          'rating': {'python': 5, 'raw': '5'},
          'time': {'python': [13, 45, 0, 0], 'raw': '13:45'}}],
        data.rows())
    end method translateMeta;

    override
    method expandMeta params:
      var output : vec<metax.c.Construct> = null #:
        Where to write constructs created during expansion.
    scope:
      /# Nothing to do for translate (so far).
      pass
    end method expandMeta;

  end class DataConstruct;

  class ChartConstruct < AbstractDataConstruct #:
    Define a chart (a view of data).
  assocs:
    std assoc re;
    usertest std assoc datetime;
  scope:

    method kind : str scope:
      return 'chart'
    end method kind;

    lifecycle  clsetup:
      cls.TestMetafile = metax.doc.DocConstruct.Parse(
        metax.root.Object.Resource('metax.doc.DataConstruct.testdoc1'))
      cls.Data1 = cls.TestMetafile.find('/preso1/slide1/panel1/data1')
      /# Important to do this so that the chart has access to the data!
      cls.Data1.translateMeta()
      cls.Chart1 = cls.TestMetafile.find('/preso1/slide1/panel2/table1')
    setup:
      cls = self.__class__
      test.metafile = cls.TestMetafile
      test.data1 = cls.Data1
      test.chart1 = cls.Chart1
      test.notnull(test.chart1)

    method translateMeta scope:
      metafile = self.metafile()
      streams = metafile.streams()
      presentation = self.ancestor('presentation')
      chart_type = self.attrval('type')
      presentation.charts()[self.id()] = chart_type

      jslines = []

      /# Define the datatable and its columns.
      columns = self.columnInfo()
      /# pprint.pprint(columns)
      jslines.append(
        'var data = new google.visualization.DataTable();')
      jslines.append('')
      jstypes = []
      sources = set()
      colnames = []
      for colinfo in columns:
        name = colinfo['name']
        data = colinfo['data']
        if not data: raise metax.root.InternalError('Should not be possible')
        assert colinfo['dataname'] == data.id()  # invariant for now, but may change
        colnames.append(name)
        sources.add(colinfo['dataname'])
        jstype = colinfo['type']
        if jstype is None: break
        jslines.append("data.addColumn('%s', '%s');" % (jstype, name))
        jstypes.append(jstype)
      jslines.append('')

      /# The key column is always the first column
      /#  - this is mandated by the way Google Visualization datatables are
      /#    structured, with the first column representing an x value,
      /#    and subsequent columns representing y values and variations
      /#    thereof.
      keycol = columns[0]['name']

      /# Create data rows
      /#  - we need to create rows that will be converted into javascript
      /#    DataTable entries.
      /#  - each column worth of data can come from different tables, so to
      /#    ensure a merging across all tables each column contains a
      /#    rowkey-to-column-value.
      /#  - we first form a mapping from rowkey to row data, then
      /#    sort by rowkey to obtain the linearlized list.
      rowmap = {}
      for column in columns:
        colname = column['name']
        colmap = column['column']['data']
        gvtype = column['type']
        formula = column.get('formula', None)
        for rowkey in colmap:
          pyval = colmap[rowkey]['python']
          if formula:
            pyval = formula(pyval)
          jsval = self.py2js(gvtype, pyval)
          rowmap.setdefault(rowkey, {})[colname] = jsval

      /# Now convert the map of maps to a list of lists.
      jslines.append('data.addRows([')
      rows = []
      for rowkey in sorted(rowmap):
        row = rowmap[rowkey]
        rowlist = [row[k] for k in colnames]
        jslines.append('  [%s],' % ', '.join(rowlist))
      jslines.append(']);')

      /# The options come from the 'options' seconary attribute.
      jslines.append('')
      jslines.append('var options = {')
      for line in self.optionInfo():
        jslines.append('  ' + line)
      jslines.append('};')
      jslines.append('')

      /# Now write javascript to create the chart object and render it.
      chart_type_class = {
        /# Add type-to-class mappings for those classes that are not just
        /# a capitalization of the type.
      }
      chart_class = chart_type_class.get(chart_type, chart_type.capitalize())
      jslines.append(
        "var chart = new google.visualization.%s(document.getElementById('%s'));" %
        (chart_class, self.id()))
      jslines.append(
        /# TODO(wmh): Provide some means of establishing which GV classes 
        /# recognize convertOptions, and which do not.
        'chart.draw(data, options);'
        /# 'chart.draw(data, google.charts.%s.convertOptions(options));' % chart_class
      )

      /# Write to the script stream
      func_name = 'draw_%s' % self.id()
      streams.addLine('script', 'function %s() {' % func_name)
      for line in jslines:
        streams.addLine('script', '  ' + line)
      streams.addLine('script', '}')

      /# Write a <div> to the body stream.
      streams.addLine('body', '    <div id="%s"></div>' % self.id())
    test:
      streams = test.metafile.streams()
      streams.initStreams('script')
      test.chart1.translateMeta()

      test.iseqtext(
        >|"""function draw_table1() {
        >|  var data = new google.visualization.DataTable();
        >|  
        >|  data.addColumn('timeofday', 'time');
        >|  data.addColumn('string', 'fruit');
        >|  data.addColumn('number', 'count');
        >|  
        >|  data.addRows([
        >|    [[13, 30, 0, 0], 'apples', 0.6],
        >|    [[13, 35, 0, 0], 'bananas', 1.0],
        >|    [[13, 45, 0, 0], 'cantelopes', 0.8],
        >|  ]);
        >|  
        >|  var options = {
        >|    chart: {
        >|      title: 'Test Title',
        >|      subtitle: 'Test SubTitle'
        >|    },
        >|    width: 900,
        >|    height: 500
        >|  };
        >|  
        >|  var chart = new google.charts.Table(document.getElementById('table1'));
        >|  chart.draw(data, google.charts.Table.convertOptions(options));
        >|}""",
        '\n'.join(streams.stream('script')))

    end method translateMeta;

    method py2js : str #:
      Convert a python value to a string representing javascript code producing
      the same value.
    params:
      var gvtype : str #:
        The (google vizualization) type of the value.
      var pyval : any #:
        A python value.
    scope:
      if gvtype == 'string':
        if "\"" in pyval:
          if "'" in pyval:
            value = "'%s'" % pyval.replace("'", "\\'")
          else:
            value = "'%s'" % pyval
        elif "'" in pyval:
          value = '"%s"' % pyval
        else:
          value = "'%s'" % pyval

      elif gvtype == 'number':
        /# TODO(wmh): Should we perform some formatting on this?
        value = str(pyval)
      elif gvtype in ('datetime', 'date'):
        /# pyval is a datetime.datetime
        value = 'new Date(%d, %d, %d, %d, %d, %d)' % (
          pyval.year, pyval.month-1, pyval.day,
          pyval.hour, pyval.minute, pyval.second)
      elif gvtype == 'timeofday':
        /# pyval is a list of four values [hour, min, second, microseconds]
        value = str(pyval)
      elif gvtype == 'boolean':
        value = 'true' if pyval else 'false'
      else:
        raise metax.c.InternalError('Unhandled gvtype "%s"' % gvtype)
      return value
    test:
      test.iseq("'a string'", test.chart1.py2js('string', 'a string'))
      test.iseq('"a \'string\'"', test.chart1.py2js('string', "a 'string'"))
      test.iseq('\'a "string"\'', test.chart1.py2js('string', 'a "string"'))
      test.iseq("\'\\\'\\\'\"\"\'", test.chart1.py2js('string', '\'\'""'))
      test.iseq('1', test.chart1.py2js('number', 1))
      test.iseq('3.14', test.chart1.py2js('number', 3.14))
      test.iseq(
        'new Date(2018, 11, 11, 6, 11, 0)',
        test.chart1.py2js('datetime', datetime.datetime(2018, 12, 11, 6, 11)))
      test.iseq(
        '[4, 20, 0, 0]', test.chart1.py2js('timeofday', [4, 20, 0, 0]))
      test.iseq('false', test.chart1.py2js('boolean', False))
      test.iseq('true', test.chart1.py2js('boolean', True))
    end method py2js;

    override
    method expandMeta params:
      var output : vec<metax.c.Construct> = null #:
        Where to write constructs created during expansion.
    scope:
      /# Nothing to do for translate (so far).
      pass

    end method expandMeta;

  end class ChartConstruct;

  class ColumnConstruct < DocConstruct #:
    Define a column (within any _data_ subconstruct).
  scope:

    method kind : str scope:
      return 'column'
    end method kind;

  end class ColumnConstruct;

  class StyleConstruct < DocConstruct #:
    The style construct.
  scope:

    method kind : str scope:
      return 'style'
    end method kind;

    override
    method expandMeta params:
      var output : vec<metax.c.Construct> = null #:
        Where to write constructs created during expansion.
    scope:
    end method expandMeta;

    override
    method translateMeta
    scope:
      /# TODO(wmh): Add assocs to Construct and copy over to classes.
      import re

      metafile = self.metafile()
      preso = self.ancestor('presentation')
      streams = metafile.streams()
      scope = self.attrval('scope:', default=None) or []
      vre = re.compile(r'\${([a-zA-Z0-9]+)}')
      vmap = {
        'width': preso.width(),
        'height': preso.height(),
        'padding': preso.padding(),
      }

      def Repl(m):
        var = m.group(1)
        val = vmap.get(var, None)
        return str(val)

      /# Hardcoded CSS for class 'slide' and 'panel'.
      style_code = """
       >|.slide {
       >|  display: none;
       >|  width: ${width}px;
       >|  height: ${height}px;
       >|  margin-left: auto;
       >|  margin-right: auto;
       >|  padding: ${padding}px;
       >|  /* border-left: 1px solid black; */
       >|  /* border-right: 1px solid black; */
       >|  background-color: #fdf7ef;
       >|  /*
       >|   * relative position is crucial to allowing panels to specify themselves
       >|   * absolutely within this parent div.
       >|   */
       >|  position: relative; 
       >|}
       >|
       >|.panel {
       >|  position: absolute;
       >|  margin: 0px;
       >|  padding: 0px;
       >|}
       >|"""
      style_code = vre.sub(Repl, style_code)
      streams.addLines('style', style_code.split('\n'))

      for line in scope:
        line = vre.sub(Repl, line)
        streams.addLine('style', line)

      return (None, None)
    end method translateMeta;

  end class StyleConstruct;

  class ScriptConstruct < DocConstruct #:
    The script construct.
  scope:

    method kind : str scope:
      return 'script'
    end method kind;

    override
    method expandMeta params:
      var output : vec<metax.c.Construct> = null #:
        Where to write constructs created during expansion.
    scope:
    end method expandMeta;

    override
    method translateMeta
    scope:
      metafile = self.metafile()
      streams = metafile.streams()
      scope = self.attrval('scope:', default=None)
      if scope:
        streams.addLine('jslibs', '<script type="text/javascript">')
        streams.addLines('jslibs', scope)
        streams.addLine('jslibs', '</script>')
      else:
        path_expr = self.attrval('path', default=None)
        if path_expr:
          path = path_expr.asStr(unquote=True)
          streams.addLine(
            /# IMPORTANT: Side note about javascript ... must use <script></script>
            /# not <script/> ... the latter doesn't get processed properly in
            /# Chrome as of 2018-11-30.
            'jslibs', '<script type="text/javascript" src="%s"></script>' % path)

      return (None, None)
    end method translateMeta;

  end class ScriptConstruct;

  class ListConstruct < DocConstruct #:
    The list construct.
  scope:

    method kind : str scope:
      return 'list'
    end method kind;

    override
    method translateMeta
    scope:
      metafile = self.metafile()
      kind = self.attrval('kind')
      indent = '  ' * (self.distance('panel')+1)
      subindent = indent + '  '
      start, end = self.tagStr('ol' if kind == 'ordered' else 'ul')

      /# start
      self.streamLine(start, indent=indent)

      /# body
      scope_attr, scope = self.attrpair('scope:', default=None)
      if scope_attr:
        if scope_attr.isComplexBlock():
          for child in scope:
            child.translateMeta()
        else:
          self.streamLines(scope, indent=subindent)

      /# end
      self.streamLine(end, indent=indent)

      return (None, None)
    end method translateMeta;

  end class ListConstruct;

  class ItemConstruct < DocConstruct #:
    The item construct.
  scope:

    method kind : str scope:
      return 'item'
    end method kind;

    override
    method translateMeta
    scope:
      metafile = self.metafile()

      indent = '  ' * (self.distance('panel')+1)
      subindent = indent + '  '
      start, end = self.tagStr('li')

      /# start
      self.streamLine(start, indent=indent)

      /# body
      isval = self.attrval('is', default=None)
      if isval:
        self.streamLine(isval.asStr(unquote=True), indent=subindent)

      scope_attr, scope = self.attrpair('scope:', default=None)
      if scope_attr:
        if scope_attr.isComplexBlock():
          for child in scope:
            child.translateMeta()
        else:
          self.streamLines(scope, indent=subindent)

      /# end
      self.streamLine(end, indent=indent)

      return (None, None)
    end method translateMeta;

  end class ItemConstruct;

  class FilterConstruct < DocConstruct #:
    The filter construct.
  scope:

    method kind : str scope:
      return 'filter'
    end method kind;

  end class FilterConstruct;

  class DocNativeConstruct < DocConstruct #:
    The native construct.
  scope:

    method kind : str scope:
      return 'native'
    end method kind;

    override
    method expandMeta params:
      var output : vec<metax.c.Construct> = null #:
        Where to write constructs created during expansion.
    scope:
    end method expandMeta;

    override
    method translateMeta
    scope:
      metafile = self.metafile()
      streams = metafile.streams()
      scope = self.attrval('scope:', default=None) or []
      parent = self.parentConstruct()
      indent = '  ' if parent.kind() == 'slide' else ''
      self.streamLines(scope, indent=indent)
      return (None, None)
    end method translateMeta;

  end class DocNativeConstruct;

  abstract
  class BaseLanguageDoc < metax.meta.BaseLanguageConstruct #:
    Abstract superclass of all baselangs in Meta(Doc).
  scope:

  end class BaseLanguageDoc;

  class DocHtml < BaseLanguageDoc #:
    Functionality for compiling Meta(Doc) code in html.
  scope:

    lifecycle  params:
      var id : str;
      var parent : metax.c.ComplexBlock;
      var context : metax.c.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('html')
      self.nameIs('Html')
      self.suffixesIs(['html'])
    end;

  end class DocHtml;

  class DocMarkdown < BaseLanguageDoc #:
    Functionality for compiling Meta(Doc) code in markdown.    
  scope:

    lifecycle  params:
      var id : str;
      var parent : metax.c.ComplexBlock;
      var context : metax.c.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('markdown')
      self.nameIs('Markdown')
      self.suffixesIs(['markdown'])
    end;

  end class DocMarkdown;

  class DocTex < BaseLanguageDoc #:
    Functionality for compiling Meta(Doc) code in tex.
  scope:

    lifecycle  params:
      var id : str;
      var parent : metax.c.ComplexBlock;
      var context : metax.c.Context;
      var precount : int = 0;
    super (id, parent, context, precount=precount)
    scope:
      self.idIs('tex')
      self.nameIs('Tex')
      self.suffixesIs(['tex'])
    end;

  end class DocTex;

end namespace metax.doc;
