namespace metax.lib.shell #:
  An abstract Shell class.

  This Shell class provides an interactive command-line-based environment
  modeled on unix filesystems and unix shells, but it adds a few new features.

  The filesystem shown by this Shell is virtual (it does not have to have
  anything to do with the actual filesystem, although one can mirror real
  file hierarches within the shell if desired).

  Each Directory within the filesystem knows how to automatically generate
  and refresh its list of child objects. A user of this class provides
  specifications for what the directory hierarchy looks like, including how
  to generate content within directories.

  In addition to the filesystem-generating functionality, this Shell also
  allows one to:
    - associate commands with implementations via defineCommand()
    - define variables of three different kinds:
       - shell
         - these are set explicitly by the 'set' command.
       - childvar
         - these are dictated by the current working directory
         - they are readonly
       - environment
         - variables that are 'inherited' into subprocesses.
         - NOTE: As of 2018/01/02, env.var. support is minimal, since the
           code currently has no mechansim whereby one can invoke
           subprocesses, and thus no real need for env.vars.
    - define aliases for commands
    - view command history

  Example Usage:

    class MyShell < metax.lib.Shell scope:
      lifecycle scope:
        self.defineComand('<newcommand>', self.methodImplementCommand)
        ...
        root = self.filesystem()
        readme = root.add('file', 'README', content='Example content')
        root.add('symlink', 'docs.txt', link=readme)
        misc = root.add('dir', 'misc')
        home = root.add(
          'dir', 'home',
          childvar='user', generator=Users, childvar=freshold=120)
        # In the above, the signature of Users is
        #    Users(dir:Directory) : vec<Node>
        # and it should return a list of newly created Node instances that
        # have already been registered within the 'dir' arg.

     def main():
       shell = MyShell()
       shell.run()

scope:

  nometanotest
  class Error < metax.root.Error;

  nometanotest
  class InternalError < Error;

  nometanotest
  class UndefinedVariable < Error;

  nometanotest
  class InvalidDirectoryError < Error;

  native ##:
    TODO(wmh): Use metax.c constants? Use enum.
  scope<py>:
    REQUIRED = object()
    DEFAULT = object()
    UNDEF = object()
  end;

  class Shell #:
    Represents a generic command-line shell.

    This provides basic shell-like functionality.  Subclasses add
    domain-specific functionality.
  assocs:
    std assoc logging;
    std usertest assoc os;
    std assoc re;
    std usertest assoc pprint;
    std assoc shlex;
    std assoc subprocess;
    std assoc time;
  scope:

    field history : @vec #:
      Maintains a history of commands executed.

    field rcfile : str #:
      Where the rc init file for this shell resides.  Contents are loaded
      at the start of run().

    field fp : ostream = out #:
      Where to write output.

    field columns : int #:
      The number of columns in the connected terminal (only relevant to fp
      if fp is that terminal, of course).

    field vars : map #:
      Matains vars of various kinds. Maps kinds to variable names to maps
      containing:
        kind: str
          Kind of variable ('shell', 'context', 'env', etc.)
        name: str
          Name of variable
        type: function
          Function accepting string that returns typed repr or TypeError.
        default: any
          Default value (properly typed)
        summary: str
          One-line summary of variable
        desc: str
          Multi-line summary of variable
        readonly: bool or function
          Indicates variable is readonly. If it is a function, the value
          returned by getvar() is produced by invoking this function with
          the Shell instance as its sole argument.
        value: any
          The current value of the variable
        time: float
          The last time the value was updated as a unix timestamp.

    field commands : map #:
      A mapping from command name to map containing:
        method : method
          The method implementing the command. The method should accept any
          number of args (but zero keyword args).
        dispatcher : method (optional)
          If present, a method used to dispatch the 'method' method.
          It should be a function accepting three args:
            name: str
              The name of the method (i.e. the value of the 'name' param above).
            method: method
              The method object (i.e. the value of the 'method' param above)
            args: vec<str>
              The args found after the prompt, to be passed to the method.

      TODO(wmh): This simple (and limited) mechanism should be replaced with the
      Comamnd/Flag/Arg hiearchy defined in metax.cli (i.e. src/kernel/cli.meta)
    scope:
      accessor get test:
        sh = test.shell
        test.iseq(
          ['alias', 'aliases', 'cat', 'cd', 'help', 'history', 'ls',
           'pwd', 'quit', 'set', 'vars'],
          sorted(sh.commands().keys()))
    end field commands;

    field aliases : map #:
      Aliases for commands ala bash alias.
    scope:
      accessor get test:
        sh = test.shell
        test.iseq({}, sh.aliases())
        sh.aliasCommand('ls', 'ls -F')
        sh.aliasCommand('h', 'history 10')
        test.iseq({'h': 'history 10', 'ls': 'ls -F'}, sh.aliases())
    end field aliases;

    raw
    field directory_families : vec;

    field filesystem : Directory #:
      The top of the directory hierarchy.

    field cwd : str scope:
      accessor set #:
        Any time the 'cwd' field is set, we need to update the context vars
        which are uniquely identified by the current directory.
      scope:
        self._cwd = value
        if value is not None:
          /# self.log('Switching to %s\n', value.abspath())
          /# We need to reset the context vars based on the current directory.
          path = value.abspath()
          if not path.endswith('/'):
            path = path + '/'
          family = value.familyPath()
          var_re = re.compile('<([^>\s]+)>')
          family_str = var_re.sub('(?P<\\1>[^\/]+)', family)
          try:
            path_re = re.compile(family_str)
          except re.error as e:
            print('FAMILY: %s' % family)
            print('FAMILY_STR: %s' % family_str)
            print('ERROR: %s' % e)
            raise Exception('testing things')
          pmatch = path_re.match(path)
          if pmatch:
            self._vars['context'] = pmatch.groupdict()
          else:
            raise Error(
              'Failed to parse\n  %s\nwith\n  %s\n' % (path, family_str))
      test:
        sh = test.shell
        root = sh.filesystem()
        sh.cwdIs(root)
        test.istrue(root is sh._cwd)

        /# The following sets up a generating directory so that we have context
        /# variables and can test the context-generating code of cwdIs().
        def Gen(parent):
          result = []
          result.append(metax.lib.shell.Directory(parent, 'subdir'))
          result.append(metax.lib.shell.File(parent, 'subfile'))
          return result

        d = metax.lib.shell.DynamicDirectory(
          root, 'dir', 'test', generator=Gen, freshold=10)
        sh.changeDirCommand('dir/subdir')
        dd = sh._cwd
        sh.cwdIs(dd)
        test.istrue(dd is sh._cwd)
        test.iseq({'test': 'subdir'}, sh._vars['context'])
    end field cwd;

    lifecycle params:
      var fp : ostream = out #:
        Where to write output (useful for unittesting).
      var rcfile : str = null #:
        Where to obtain an initial initialization file.  If None,
        uses $HOME/.wshrc.
    scope:
      self.fpIs(fp)

      /# The 'vars' field maps variable names to a dict maintaining the value
      /# and meta-information about the variable.
      self._vars = {
        'env': {},
        'context': {},
        'shell': {},
        /# Note that subclasses can add arbitrary new kinds to this field
        /# via defineKind().
      }
      self.defineVariable(
        'prompt', str, default='wsh> ',
        summary='The string to print when prompting for input')

      /# The 'commands' field maps command names to methods.
      self._commands = {}
      self.defineCommand('alias', self.aliasCommand)
      self.defineCommand('aliases', self.printAliasesCommand)
      self.defineCommand('cd', self.changeDirCommand)
      self.defineCommand('help', self.helpCommand)
      self.defineCommand('pwd', self.pwdCommand)
      self.defineCommand('history', self.historyCommand)
      self.defineCommand('ls', self.listDirCommand)
      self.defineCommand('vars', self.printVarsCommand)
      self.defineCommand('quit', self.quitCommand)
      self.defineCommand('set', self.setvarCommand)
      self.defineCommand('cat', self.catCommand)

      /# The 'aliases' field maps command names to aliases
      self._aliases = {}

      /# Directories are grouped into families, and each directory family
      /# is created from the same template.  This field is a list of
      /# tuples containing:
      /#   [0] regexp to apply to full path
      /#   [1] list of strings naming the groups found in the regexp
      /# For example, the path
      /#    /domain/holst.ca/user/wade/groups/group1
      /# can be described by the directory family:
      /#    /domain/([^/]+)/user/([^/]+)/groups/([^/]+)
      /# with groupings:
      /#    (domain_name, user_name, group_name)
      self._directory_families = []

      /# The Filesystem is defined by the root directory.  It will get populated
      /# as the user interacts with it via shell commands.
      root = Directory(None, '')
      self._filesystem = root

      /# Current directory
      self._cwd = root

      /# The initial directory is '/'.
      self.changeDirCommand('/')

      if rcfile is None:
        rcfile = os.path.join(os.getenv('HOME', '/'), '.wshrc')
      self.rcfileIs(rcfile)

      /# Establish column width
      /#   TODO(wmh): If we went to python3-only, we could use
      /#   shutil.get_terminal_size()
      rows, columns = os.popen('stty size', 'r').read().split()
      self.columnsIs(int(columns))

    clinit:
      cls.HISTORY_RE = re.compile('^\s*!(-?\d+|!)\s*$')

      def Bool(v):
        vv = v.lower()
        if vv in ('1', 't', 'true', 'y', 'yes'):
          result = True
        elif vv in ('0', 'f', 'false', 'n', 'no'):
          result = False
        else:
          raise TypeError('Invalid boolean value "%s"' % v)
        return result

      cls.TYPE_FUNCS = {
        'str': str,
        'int': int,
        'bool': Bool,
        'float': float,
        'double': float,
        /# TODO(wmh): Handle 'real<17>', etc.
      }
    end lifecycle;

    method log params:
      var msg : str #:
        The message to log.
      multi var args : vec #:
        Used to replace printf sequences in msg.
    scope:
      fullmsg = unicode(msg % args)
      self._fp.write(fullmsg)
    test:
      sh = test.shell
      out = sh._fp
      sh.log('Test %s here %s', 'a', 'b')
      test.iseq(
        'Test a here b', out.getvalue())
    end method log;

    method registerDirectoryFamily params:
      var regexp : str;
      var groups : vec;
    scope:
      self._directory_families.append((regexp, groups))
    test:
      test.iseq(1, len(test.shell._directory_families))
      test.shell.registerDirectoryFamily('/cell/<cell>', ('special',))
      test.iseq(2, len(test.shell._directory_families))
    end method registerDirectoryFamily;

    method registerDirectoryGenerator #:
      Register a set of path generators.

      Example:
        genspec = '/domain/<domain>/'
    params:
      var genspec : str;
    scope:
      raise Error('Is this code dead?')
      freshold = 10
      spec_re = re.compile('^<(\S+?)(?::(\S+?)(?:\@(\d+))?)?>')
      parts = genspec.split('/')
      if parts[0] == '':
        parts.pop(0)
        dir = self._filesystem
        for part in parts:
          spec_match = spec_re.match(part)
          if spec_match:
            /# A generator specification
            subname, genname, freshold = spec_match.groups()
            if not freshold:
              freshold = 3600
            generator = getattr(self, genname)
            child = DynamicDirectory(dir, subname, 'fixme', generator, freshold)
          else:
            /# Literal directory component
            child = Directory(dir, part, freshold, None)
          self.log('part = %s\n', part)
    test:
      /# I think this method is unused (it is broken as of 2019-05-18 and has
      /# no obvious callers).
      return

      sh = test.shell
      fs = sh.filesystem()
      fs.listChildren()
      sh.registerDirectoryGenerator('/domain/<domain>')
      fs.listChildren()
    end method registerDirectoryGenerator;

    method defineCommand #:
      Add a command to this shell, with associated implementation.
    params:
      var name : str #:
        Name of command
      var method : method #:
        The method implementing the command. The method should
        accept any number of args (but zero keyword args).
      var dispatcher : method = null #:
        If present, a method used to dispatch the 'method' method.
        It should be a function accepting three args:
          name: str
            The name of the method (i.e. the value of the 'name' param above).
          method: method
            The method object (i.e. the value of the 'method' param above)
          args: vec<str>
            The args found after the prompt, to be passed to the method.
    scope:
      self._commands[name] = {'method': method, 'dispatcher': dispatcher}
    test:
      sh = test.shell
      /# Shell.__init__ calls self.defineCommand() many times.
      test.istrue('alias' in sh._commands)
    end method defineCommand;

    method defineKind #:
      Define a new kind of variable.

      After invoking this for <kind>, calls to defineVariable passing <kind>
      as the value of the 'kind' param will be legal.
    params:
      var kind : str #:
        The new kind
    scope:
      vars = self.vars()
      if kind in vars:
        raise Error('Kind %s is already registered' % kind)
      vars[kind] = {}
    test:
      sh = test.shell
      test.iseq(['context', 'env', 'shell'], sorted(sh._vars.keys()))
      sh.defineKind('flag')
      test.iseq(['context', 'env', 'flag', 'shell'], sorted(sh._vars.keys()))
    end method defineKind;

    method defineVariable #:
      Define a new variable within the shell.
    params:
      var name : str #:
        Name of variable
      var type : any #:
        A callable function that accepts a string value and returns the
        type-correct representation of that value if it is legal, or raises
        TypeError if not legal.
        TODO(wmh): Do we want to all this to be one of a set of string values
        that get converted to appropriate functions?
      var kind : str = 'shell' #:
        Known kinds include:
          'context' --> directory context variable
          'shell'   --> a \"normal\" variable
          'env'     --> environment variable
        But subclasses can add arbitrary new kinds as they choose. For
        example, The metax.c.shell.Shell subclass adds kind 'flag' to
        capture flag values.
      var readonly : any = null #:
        If not null, it is an indication that the variable is readonly. If
        it is the value True, it is a normal readonly variable. However, it
        can also be a function that accepts a single arg (a Shell instance)
        and returns a value. This is useful for variables whose values come
        from external sources (time, terminal width, random number, etc.)
      var default : any = REQUIRED #:
        The default value for this variable. If it is the special value
        REQUIRED, an error is raised in var() if that value would be returned.
      var summary : str = '' #:
        A one-line summary for the variable
      var desc : str = '' #:
        A multi-line description of the variable.
    scope:
      if not callable(type):
        /# Convert the string-valued type into a function that does type
        /# conversion/checking.
        typestr = type
        type = self.__class__.TYPE_FUNCS.get(type, None)
        if type is None:
          /# TODO(wmh): Fix this:
          /#  - If type == 'enum<val1,val2,...>', create a lambda that verifies
          /#    that the value is one of those listed in the enum.
          /#  - If type == 'list<T>', the value should already be a list, and
          /#    we need only recursively validate the type of each element.
          print(
            'WARNING: In metax.lib.shell.Shell, type %s not yet handle' %
            typestr)
          type = str
      assert callable(type)

      info = {
        'kind': kind,
        'name': name,
        'type': type,
        'default': default,
        'summary': summary,
        'desc': desc,
      }
      if readonly:
        info['readonly'] = readonly
      kvars = self._vars.get(kind, None)
      if kvars is None:
        raise Error('Invalid kind %s' % kind)
      kvars[name] = info
    test:
      sh = test.shell
      sh.defineVariable(
        'home', str, kind='shell', summary='example varible',
        default='', desc='description of example variable')
      vinfo = sh._vars['shell']['home']
      test.iseqmap(
        {
          'kind': 'shell',
          'name': 'home',
          'type': str,
          'default': '',
          'summary': 'example varible',
          'desc': 'description of example variable',
       },
       vinfo)
    end method defineVariable;

    method run scope:
      rcfile = self.rcfile()
      if os.path.exists(rcfile):
        with open(rcfile) as fp:
          for line in fp:
            for command, args in self.split(line):
              self.runCommand(command, args)

      while True:
        /# Obtain the command.
        sys.stdout.write(self.getsh('prompt'))
        /# Read a line - an empty result means EOF
        line = sys.stdin.readline()

        /# EOF means quit (but we process it so that cleanup happens.
        if not line:
          line = 'quit'
        else:
          /# Empty lines are ignored
          line = line.strip()
          if not line: continue

        /# process commands
        for command, args in self.split(line):
          self.runCommand(command, args)
    test:
      /# Highlevel interactive command. Not testing here.
      pass
    end method run;

    method split : vec<tuple<str,vec<str>>> #:
      Split a string into a list of str/list pairs.
    params:
      var value : str;
    scope:
      tokens = shlex.split(value)
      args = []
      commands = []
      commands.append(args)
      for token in tokens:
        if token and token[-1] == ';':
          token = token[:-1]
          if token:
            args.append(token)
          args = []
          commands.append(args)
        else:
          args.append(token)
      result = []
      for args in commands:
        command = args.pop(0)
        result.append((command, args))
      return result
    test:
      test.iseqvec(
        [('cd', ['a b']), ('echo', ['a b; c', 'foo bar'])],
        test.shell.split('cd \'a b\'; echo "a b; c" "foo bar"'))
    end method split;

    method unsplit : str #:
      Convert a command/args pair to a single string.
    params:
      var command : str #:
        The initial command token.
      var args : vec<str> #:
        Args to the command
    scope:
      parts = [command]
      for arg in args:
        if ' ' in arg:
          /# Whitespace exists in the arg ... needs quoting
          if "\"" in arg:
            if "'" in arg:
              /# Both " and ' are in the string.
              parts.append("\"%s\"" % arg.replace("'", "\\'"))
            else:
              /# There is a " but no '
              parts.append("'%s'" % arg)
          elif "'" in arg:
            /# There is a ' but no "
            parts.append("\"%s\"" % arg)
          else:
            /# There is neither ' nor "
            parts.append("'%s'" % arg)
        else:
          /# No whitespace
          parts.append(arg)
      return ' '.join(parts)
    test:
      test.iseq(
        '''echo a 'b c' 'd \" e' "f ' g" "he said "don\\'t""''',
        test.shell.unsplit(
          'echo', ['a', 'b c', 'd \" e', "f ' g", 'he said "don\'t"']))
    end method unsplit;

    protected
    method runCommand : any #:
      Processs a single command.

      Returns:
        The result of the method invoked or null if no command was invoked.
        Currently no way to distinguish between a successful invocation that
        returns null and an unsuccessful invocation.
    params:
      var command : str #:
        The command to execute.
      var args : vec<str> #:
        A collection of tokens to parse as a command.
    scope:
      result = None

      history_match = self.HISTORY_RE.match(command)
      if history_match:
        /# If the command is a history reference, obtain the actual history
        /# line.
        numbang = history_match.group(1)
        index = -1 if numbang == '!' else int(numbang)
        command, hargs = self._history[index]
        logging.info('Obtained %d from history = %s', index, hargs)
        args = hargs + args

      elif command in self._aliases:
        /# The command is an alias.
        /#  - note that we do not apply aliases to commands from history, as
        /#    they already had aliases applied when they were first invoked.
        prearg_groups = self.split(self._aliases[command])
        if len(prearg_groups) > 1:
          print(
            'ERROR: Not supporting aliases producing %d commands' %
            len(prearg_groups))
        command, preargs = prearg_groups[0]
        args = preargs + args

      /# Identify the associated method and execute it.
      if command:
        self.dispatch(command, args)
        self._history.append((command, args))

      return result
    test:
      sh = test.shell
      sh.runCommand('alias', ['ls', 'ls -F'])
      test.iseq([('alias', ['ls', 'ls -F'])], sh._history)
      test.iseq({'ls': 'ls -F'}, sh._aliases)
    end method runCommand;

    protected
    method dispatch : bool #:
      Find and execute a command based on a command and args provided by user.

      Returns:
        true if command was found and invoked (regardless of success of
        command), false if command not legal.
    params:
      var command : str #:
        A word provided by the user representing a registered command to invoke.
      var args : vec<str> #:
        The args provided by the user after the command.
    scope:
      info = self._commands.get(command, None)
      if info:
        result = True
        try:
          method = info['method']
          dispatcher = info['dispatcher']
          if dispatcher:
            res = dispatcher(command, method, args)
          else:
            res = method(*args)
          /# Currently NOT returning 'res' as result, although it makes sense
          /# to do so if we clean up the command methods to always return
          /# something meaningful.
        except Error as e:
          self.log('%s: %s\n', e.__class__.__name__, str(e))
        except IndexError as e:
          /# This often happens if the method implementing the command is
          /# careless about how it parses arguments (and assumes that an
          /# argument exists that doesn't
          /# TODO(wmh): Print the usage associated with the command.
          self.log("Error: command '%s' expects more arguments\n", command)
      else:
        result = False
        sys.stderr.write("Unknown command '%s' - ignored.\n" % command)
      return result
    test:
      sh = test.shell
      test.iseq({}, sh._aliases)
      test.istrue(sh.dispatch('alias', ['ls', 'ls -F']))
      test.iseq({'ls': 'ls -F'}, sh._aliases)
    end method dispatch;

    remark #:
      ----------------------------------------------------------------------
      Methods defining interactive commands.

    method aliasCommand #:
      Create an alias for a command.
    params:
      multi var args : vec;
    scope:
      if len(args) == 2:
        if '=' in args[0]:
          /# We do a little hackery to support syntax of the form:
          /#    alias ls='ls -F'
          /# rather than
          /#    alias ls 'ls -F'
          /# The form results in args = ("ls='ls", "-F'")
          /# We make it ('ls', 'ls -F')
          self.log('Patching %s.  Do not use =.\n', str(args))
          new_command, orig_command = args[0].split('=', 1)
          orig_command += ' ' + args[1]
          quote_match = re.match("(['\"])?(.*)\\1$", orig_command)
          if quote_match:
            orig_command = quote_match.group(2)
        else:
          new_command, orig_command = args
        self._aliases[new_command] = orig_command
      else:
        self.log('ERROR: Currently requiring exactly two args to alias\n')
    test:
      sh = test.shell
      sh.aliasCommand('ls', 'ls -F')
      test.iseq({'ls': 'ls -F'}, sh._aliases)
      sh.aliasCommand('this', 'is', 'test')
      test.iseqtext(
        'ERROR: Currently requiring exactly two args to alias\n',
        test.outfp.getvalue())
    end method aliasCommand;

    method printAliasesCommand #:
      Print all existing aliases.
    params:
      multi var args : vec;
    scope:
      for alias in sorted(self._aliases):
        self.log('%-20s = %s\n', alias, self._aliases[alias])
    test:
      sh = test.shell
      sh.aliasCommand('ls', 'ls -F')
      sh.aliasCommand('h', 'history')
      sh.printAliasesCommand()
      test.iseqtext(
        'h                    = history\n'
        'ls                   = ls -F\n',
        test.outfp.getvalue())
    end method printAliasesCommand;

    method pwdCommand #:
      Print working directory.
    params:
      multi var args : vec;
    scope:
      self.log(self.cwd().abspath() + '\n')
    test:
      sh = test.shell
      sh.pwdCommand()
      test.iseqtext(
        '/\n',
        test.outfp.getvalue())
    end method pwdCommand;

    method historyCommand #:
      Show the history of commands.
    params:
      multi var args : vec;
    scope:
      size = len(self._history)
      if len(args) > 0:
        start = size - int(args[0])
      else:
        start = 0
      for index in xrange(start, size):
        cmd, args = self._history[index]
        line = self.unsplit(cmd, args)
        self.log('%5d  %s\n', index, line)
    test:
      sh = test.shell
      sh.runCommand('alias', ['ls', 'ls -F'])
      sh.defineVariable('a', int, default=0, summary='test var')
      sh.runCommand('set', ['a', '1'])
      sh.historyCommand()
      test.iseqtext(
        "    0  alias ls 'ls -F'\n"
        '    1  set a 1\n',
        test.outfp.getvalue())
    end method historyCommand;

    method catCommand #:
      Show the contents of one or more files.
    params:
      multi var args : vec;
    scope:
      dir = self.cwd()
      for path in args:
        if '/' in path:
          print('WARNING: Not yet handling relpaths in cat. Ignoring ' + path)
          continue
        node = dir.child(path)
        if not node:
          print('File "%s" does not exist.' % path)
          continue
        if node.isSymlink():
          node = node.link()
          if not node:
            print('Symlink "%s" has no link' % path)
            continue

        if node.isDir():
          print('Cannot cat directory "%s"' % path)
          continue
        else:
          print(node.content())
    test:
      sh = test.shell
      sh.runCommand('alias', ['ls', 'ls -F'])
      sh.defineVariable('a', int, default=0, summary='test var')
      sh.runCommand('set', ['a', '1'])
      sh.historyCommand()
      test.iseqtext(
        "    0  alias ls 'ls -F'\n"
        '    1  set a 1\n',
        test.outfp.getvalue())
    end method catCommand;

    method quitCommand #:
      Exit the shell.
    params:
      multi var args : vec;
    scope:
      self.log('Goodbye\n')
      sys.exit(1)
    test:
      sh = test.shell
      test.raises(SystemExit, sh.quitCommand)
    end method quitCommand;

    method helpCommand #:
      Provide summary of commands.

      Without arguments, provides one-line summary of all commands.
      With an argument, provides multi-line description of a given command.
    params:
      multi var args : vec;
    scope:
      if len(args):
        info = self._commands.get(args[0])
        if info:
          method = info['method']
          self.log('%s\n' % method.im_func.func_doc)
        else:
          sys.stderr.write("Unknown command '%s'" % args[0])

      else:
        for command in sorted(self._commands.keys()):
          info = self._commands[command]
          method = info['method']
          /#print(dir(method.im_func))
          desc = method.im_func.func_doc
          lines = re.split(
            '\n', desc or 'Missing doc string: ' % method.__name__)
          self.log('%-15s: %s\n', command, lines[0])
    test:
      sh = test.shell
      sh.helpCommand()
      test.iseqtext(
        'alias          : Create an alias for a command.\n'
        'aliases        : Print all existing aliases.\n'
        'cat            : Show the contents of one or more files.\n'
        'cd             : Switch to a specified directory.\n'
        'help           : Provide summary of commands.\n'
        'history        : Show the history of commands.\n'
        'ls             : List contents of directory.\n'
        'pwd            : Print working directory.\n'
        'quit           : Exit the shell.\n'
        'set            : Set a shell variable to a given value.\n'
        'vars           : Print all variables.\n',
        test.outfp.getvalue())
    end method helpCommand;

    method listDirCommand #:
      List contents of directory.

        -F  = prefix dirs with /, etc.
        -l  = long listing (one line per file)
        -a  = show . files.
    params:
      multi var args : vec;
    scope:
      /# TODO(wmh): Support listing of a specified directory (currently only
      /# lists current directory - i.e. ignores args).
      dir = self._cwd
      annotate = False
      hidden = False
      detailed = False
      args = list(args)
      while args and args[0][0] == '-':
        flag = args.pop(0)
        if flag == '-F':
          annotate = True
        elif flag == '-a':
          hidden = True
        elif flag == '-l':
          detailed = True
        else:
          print('WARNING: Ignoring unknown flag %s' % flag)
      if args:
        print('WARNING: The ls command currently ignores arguments')
      dir.listChildren(
        fp=self._fp, annotate=annotate, hidden=hidden, detailed=detailed)
    test:
      sh = test.shell
      root = sh.filesystem()
      metax.lib.shell.Directory(root, 'subdir')
      metax.lib.shell.File(root, 'subfile')
      sh.listDirCommand()
      test.iseqtext(
        'subdir  subfile\n',
        test.outfp.getvalue())
      out = self.fp()
      sh._fp = out
      sh.listDirCommand('-F')
      test.iseqtext(
        'subdir/  subfile\n',
        out.getvalue())
    end method listDirCommand;

    method changeDirCommand #:
      Switch to a specified directory.
    params:
      multi var args : vec;
    scope:
      /# Because the directory hierarchy is dynamically created and updated,
      /# 'cd' is a more complicated concept than one might at first think. One
      /# must determine how and when to generate content, how generated
      /# subdirectories will be set up so that they can generate their own
      /# content, when and when not to generate content for all parent
      /# directories of a path, etc.
      if args:
        dirname = args[0]
      else:
        dirname = '/'
      if dirname != '/' and dirname.endswith('/'):
        dirname = dirname[0:-1]

      /# Obtain the directories making up the path to switch to.
      parts = dirname.split('/')

      if dirname == '/' or dirname == '':
        dir = self._filesystem
        parts = []
      elif dirname.startswith('/'):
        /# full path
        dir = self._filesystem
        /# skip the first part (it is an empty string)
        parts.pop(0)
      else:
        /# relative path
        dir = self._cwd

      /# We refresh dir itself to make sure we are working with up-to-date
      /# information
      dir.refresh()

      /# Traverse directories, generating as we go
      for part in parts:
        if part == '..':
          /# Move up to parent.
          dir = dir.parent()
          if dir is None:
            print('WARNING: Cannot move above root')
            break
          else:
            self.cwdIs(dir)
            dir.refresh()
        elif part == '.':
          /# Noop.
          pass
        else:
          /# Part should be a subdirectory of dir
          if dir.contains(part):
            dir = dir.child(part)
            if dir.isDir():
              /# We set the directory each time thru, so that the context vars
              /# are set each time.
              self.cwdIs(dir)
              /# We ensure that the subdir is still fresh.
              dir.refresh()
            else:
              print('ERROR: %s is not a directory' % dir.abspath())
              break
          else:
            raise InvalidDirectoryError(
              'Directory %s has no child %s' % (dir.abspath(), part))
    test:
      sh = test.shell
      fs = sh.filesystem()
      fs.add('dir', 'domain')
      sh.changeDirCommand('domain')
      /# More tests here.
    end method changeDirCommand;

    method setvarCommand #:
      Set a shell variable to a given value.

      This is invoked if the command encountered at the prompt is 'set', with
      all subsequent words being treated as args.

      Two idioms are supported:
        set <var> <value>
      and
        set <var> '=' <value>
    params:
      var var : str #:
        Name of variable being set.
      multi var args : vec #:
        The args after 'set'.  Can be either a list of two elements
        representing <var> and <value>, or a list of three elements,
        <var, '=' and <value.
    scope:
      /# TODO(wmh): add var validation and value typing?
      vars = self._vars['shell']
      if var in vars:
        value = args[0]
        if value == '=':
          value = args[1]
        self.setvar('shell', var, value)
      else:
        raise Error("Attempt to set the value of undefined variable '%s'" % var)
    test:
      sh = test.shell
      sh.defineVariable('a', int, default=0, summary='test var')
      sh.setvarCommand('a', '1')
      test.iseq(1, sh._vars['shell']['a']['value'])
      sh.setvarCommand('a', '=', '2')
      test.iseq(2, sh._vars['shell']['a']['value'])
    end method setvarCommand;

    method printVarsCommand #:
      Print all variables.
    params:
      multi var args : vec;
    scope:
      kinds = self._vars
      for kind in sorted(kinds):
        kvars = kinds[kind]
        if kvars:
          self.log('\n%s variables:\n' , kind)
          for var in sorted(kvars.keys()):
            value = self.getvar(kind, var)
            self.log('  %-15s = %s\n', var, repr(value))
    test:
      sh = test.shell
      sh.defineVariable('a', int, default=0, summary='test var')
      sh.defineVariable('cell', str, kind='context', default='qa')
      sh.printVarsCommand()
      test.iseqtext("""
        >|context variables:
        >|  cell            = 'qa'
        >|
        >|shell variables:
        >|  a               = 0
        >|  prompt          = 'wsh> '
        >|""",
        test.outfp.getvalue())
    end method printVarsCommand;

    remark #:
      ----------------------------------------------------------------------
      Service methods

    protected
    method _info : map #:
      Get all info associated with a variable.
    params:
      var kind : str #:
        The kind of variable desird.
      var var : str #:
        The variable name.
      var undef : any = REQUIRED #:
        Note that this is NOT a default for the value of the variable, but
        rather a default for variable info returned if the variable is not
        defined. If this is REQUIRED or DEFAULT, an error is raised.
    scope:
      vars = self._vars
      kvars = vars.get(kind, None)
      if kvars is None:
        raise Error('Invalid kind %s' % kind)
      vinfo = kvars.get(var, undef)
      if vinfo is REQUIRED or vinfo is DEFAULT:
        raise UndefinedVariable('Undefined variable %s (%s)' % (var, kind))
      return vinfo
    test:
      sh = test.shell
      sh.defineVariable(
        'width', int, kind='shell', default=70, summary='desired output width')
      sh.defineVariable(
        'termwidth', int, kind='shell', default=75,
        readonly=lambda sh: int(os.popen('stty size', 'r').read().split()[1]),
        summary='current terminal width')
      sh.defineVariable('cell', str, kind='context', default='qa')
      sh.defineVariable('HOME', str, kind='env', default='/home/bob')

      test.iseqmap(
        {
          'kind': 'shell',
          'name': 'width',
          'default': 70,
          'summary': 'desired output width',
          'type': int,
          'desc': '',
        },
        sh._info('shell', 'width'))

      test.iseq(
        {
          'kind': 'context',
          'name': 'cell',
          'default': 'qa',
          'summary': '',
          'type': str,
          'desc': '',
        },
        sh._info('context', 'cell'))

      test.raises(
        metax.lib.shell.UndefinedVariable, sh._info, 'context', 'missing')

      test.isnull(sh._info('context', 'missing', undef=None))
    end method _info;

    method getvar : any #:
      Obtain the (typed) value of a variable (of any kind) with default support.

      Each variable has an associated type, and the return value is typed
      accordingly.

      Raises:
        Error: If the variable does not exist.
    params:
      var kind : str #:
        The kind of variable desird.
      var var : str #:
        The variable name.
      var default : any = DEFAULT #:
        The value to return if the var is defined but not yet initialized.
        If REQUIRED, raises an error in this situation.
        If DEFAULT, uses the default specified when the variable was defined
        via defineVariable() (which by default is also REQUIRED, and thus
        also raises an error).
      var undef : any = REQUIRED #:
        The default value to return from _info if the variable is not defined
        at all.
         - If REQUIRED, raises an error.
         - If DEFAULT, currently same as REQUIRED (raises an error).
         - If not a dict, it is assumed to be the value to return for the
           variable itself, but if it is a dict, it is assumed to contain all
           the keys normally returned from self._info() included either
           'value' or 'default', from which the actual value is obtained.
    scope:
      /# NOTE: There are two levels at which defaults can be interpreted.
      /#  1. For a defined but uninitialized variable, what to return (default)
      /#  2. For an undefined variable, what to return (undef)
      vinfo = self._info(kind, var, undef=undef)

      if vinfo is REQUIRED or vinfo is DEFAULT:
        /# This should not happen currently, as we should instead raise an
        /# error in _info.
        raise InternalError('How did we get here?')

      elif not isinstance(vinfo, dict):
        result = vinfo

      elif 'value' not in vinfo:
        /# Defined but uninitialized (or generatable)
        readonly = vinfo.get('readonly', None)
        if readonly and callable(readonly):
          /# We have a dynamic generator.
          result = readonly(self)
        elif default is DEFAULT:
          result = vinfo['default']
        else:
          result = default

      else:
        result = vinfo['value']

      /# The result can take on a value of REQUIRED if the var doesn't have an
      /# explicit value and either:
      /#  - the 'default' param of this method was specified as REQUIRED
      /#    (which means we do NOT pay attention to default values and require
      /#    that the variable be explicitly set in order to be valid).
      /#  - when the variable was defined in defineVariable(), no explicit
      /#    default was specified (which implicitly sets the default to
      /#    REQUIRED).
      if result is REQUIRED:
        raise Error(
          'Variable %s (%s) is uninitialized and required' % (var, kind))

      return result
    test:
      sh = test.shell
      sh.defineVariable(
        'width', int, kind='shell', default=70, summary='desired output width')
      sh.defineVariable(
        'termwidth', int, kind='shell', default=75,
        readonly=lambda sh: int(os.popen('stty size', 'r').read().split()[1]),
        summary='current terminal width')
      sh.defineVariable('cell', str, kind='context', default='qa')
      sh.defineVariable('HOME', str, kind='env', default='/home/bob')

      test.iseq(70, sh.getvar('shell', 'width'))
      test.iseq(sh.columns(), sh.getvar('shell', 'termwidth'))
      test.iseq('qa', sh.getvar('context', 'cell'))
      test.iseq('/home/bob', sh.getvar('env', 'HOME'))
    end method getvar;

    method setvar : any #:
      Set the value of a variable, with type conversion and type checking.
    params:
      var kind : str #:
        The kind of variable being set.
      var var : str #:
        Name of variable being set.
      var value : any #:
        Actual (typed) value or string representation of the value to set.
      var undef : any = REQUIRED #:
        The default value to return if the variable is not defined at all.
        If REQUIRED, raises an error.
        If DEFAULT, currently same as REQUIRED (raises an error).
        If not a dict, it is assumed to be the value to return for the variable
        itself, but if it is a dict, it is assumed to contain all the keys
        normally returned from self._info().
    scope:
      /# See getvar() for details on undef vs default.
      vinfo = self._info(kind, var, undef=undef)

      if vinfo is REQUIRED or vinfo is DEFAULT:
        /# This should not happen currently, as we should instead raise an
        /# error in _info.
        raise InternalError('How did we get here?')

      elif not isinstance(vinfo, dict):
        result = vinfo

      elif vinfo.get('readonly', None):
        self.log(
          'Variable %s (%s) is readonly (not setting value to %s)',
          var, kind, value)

      else:
        /# Verify that the value matches the specified type. The 'type' field in
        /# vinfo should be a callable that accepts a string and returns a typed
        /# value or raises TypeError if the input is invalid.
        typer = vinfo['type']
        try:
          value = typer(value)
        except TypeError as e:
          raise Error(
            'Invalid value "%s" for %s (%s): %s' % (value, var, kind, e))

        vinfo['value'] = value
        /# Record when the value was last updated.
        vinfo['time'] = time.time()
    test:
      sh = test.shell
      sh.defineVariable(
        'width', int, kind='shell', default=70, summary='desired output width')
      sh.defineVariable(
        'termwidth', int, kind='shell', default=75,
        readonly=lambda sh: int(os.popen('stty size', 'r').read().split()[1]),
        summary='current terminal width')
      sh.defineVariable('cell', str, kind='context', default='qa')
      sh.defineVariable('HOME', str, kind='env', default='/home/bob')

      test.iseq(70, sh.getvar('shell', 'width'))
      sh.setvar('shell', 'width', 50)
      test.iseq(50, sh.getvar('shell', 'width'))

      test.iseq('qa', sh.getvar('context', 'cell'))
      sh.setvar('context', 'cell', 'nj')
      test.iseq('nj', sh.getvar('context', 'cell'))

      test.iseq('/home/bob', sh.getvar('env', 'HOME'))
      sh.setvar('env', 'HOME', '/home/alice')
      test.iseq('/home/alice', sh.getvar('env', 'HOME'))

      /# Modifying a readonly variable produces error message.
      test.iseq(sh.columns(), sh.getvar('shell', 'termwidth'))
      sh.setvar('shell', 'termwidth', 90)
      test.iseq(
        'Variable termwidth (shell) is readonly (not setting value to 90)',
        test.outfp.getvalue())
    end method setvar;

    method getsh : any #:
      Obtain the (typed) value of a shell variable.

      This is only for shell variables ... use getctx() for context variables,
      or getvar() for arbitrary kinds.

      Raises:
        Error: If the variable does not exist.
    params:
      var var : str #:
        The variable name.
      var default : any = DEFAULT #:
        The value to return if the var is not set. If REQUIRED, raises an error.
      var undef : any = REQUIRED #:
        The value returned from _info() if variable not defined at all. See
        getvar() for more on differences between default and undef, when they
        are the same and when they differ.
    scope:
      return self.getvar('shell', var, default=default, undef=undef)
    test:
      sh = test.shell
      sh.defineVariable('a', int, default=0, summary='test var')
      sh.setvarCommand('a', '1')
      test.iseq('wsh> ', sh.getsh('prompt'))
      test.iseq(1, sh.getsh('a'))
    end method getsh;

    method getctx : map #:
      Obtain the value of a context variable.

      Each variable has an associated type, and the return value is typed
      accordingly.

      Raises:
        Error: If the variable does not exist.
    params:
      var var : str #:
        The variable name.
      var default : any = DEFAULT #:
        The value to return if the var is not set. If REQUIRED, raises an error.
      var undef : any = REQUIRED #:
        The value returned from _info() if variable not defined at all. See
        getvar() for more on differences between default and undef, when they
        are the same and when they differ.
    scope:
      return self.getvar('context', var, default=default, undef=undef)
    test:
      sh = test.shell
      sh.defineVariable('cell', str, kind='context', default='qa')
      test.iseq('qa', sh.getctx('cell'))
    end method getctx;

    method context : map #:
      Obtain the current collection of context var/value pairs.
    scope:
      return self._vars['context']
    test:
      test.iseq({}, test.shell.context())
    end method context;

    method executeShellCommand #:
      Execute a shell command, capturing/printing output.
    params:
      var command : str #:
        (bash) shell command to execute
      var prompt : bool = true #:
        If True, prompt user before executing command
    scope:
      /# Verify that the user really wants to execute this command
      if prompt:
        while True:
          sys.stdout.write("Execute '%s'? " % command)
          ans = sys.stdin.readline().strip()
          if ans == 'y' or ans == 'yes':
            break
          elif ans == 'n' or ans == 'no':
            return

      /# Execute the command in the shell, capturing stdout and stderr
      p = subprocess.Popen(command, shell=True,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
      try:
        stdout, stderr = p.communicate()
        retcode = p.returncode
        if retcode < 0:
          sys.stderr.write('Child was terminated by signal %d' % -retcode)
        else:
          sys.stderr.write('Child returned %d' % retcode)
          if stdout:
            self.log('-' * 70 + '\n')
            self.log('STDOUT:\n')
            self.log(stdout + '\n')
          if stderr:
            self.log('-' * 70 + '\n')
            self.log('STDERR:\n')
            self.log(stderr + '\n')
      except OSError as e:
        sys.stderr.write('Execution failed: %s' % e)
        retcode = subprocess.call("mycmd" + " myarg", shell=True)
        if retcode < 0:
          sys.stderr.write('Child was terminated by signal %d' % -retcode)
        else:
          sys.stderr.write('Child returned %d' % retcode)
    test:
      /# Need to mox out sys.stdin.readline
      pass
    end method executeShellCommand;
  end class Shell;

  abstract
  class Node #:
    Abstract superclass of classes representing filesystem objects.
  scope:

    field name : str #:
      The name (within parent) of this directory

    field parent : Node #:
      The parent directory.  It may be None in two situations:
        1) self is the root of the filesystem
        2) self is an instance that cannot be fully initialized with
           a parent until later.  It is for this reason that parentIs()
           registers the child, instead of doing that registration here.
    scope:
      accessor set scope:
        if value is None:
          self._parent = value
        else:
          name = self.name()
          current_parent = self.parent()
          if current_parent:
            /# We are already in a different parent, so we remove ourselves from
            /# it.
            if name in current_parent.children():
              del current_parent.children()[name]
          self._parent = value
          if value:
            /# We always register ourselves with our parent.
            /# TODO(wmh): Consider switching to a less magical implementation.
            value.registerChild(self)
      test:
        /# Note that parentIs() is invoked by Node.__init__ and
        /# thus setUp() has invoked it a number of times.  Thus, testing
        /# parent() is a means of testing parentIs().  We add some additional
        /# tests here to verify that current parent deletion works.

        /# Create a child of /
        blah = metax.lib.shell.Directory(test.root, 'blah')

        /# Ensure that the child knows its parent, and parent contains child
        test.iseq(test.root, blah.parent())
        test.iseq(True, test.root.contains('blah'))

        /# Now change the parent from / to /dir
        blah.parentIs(test.dir)

        /# Verify that child knows parent and parent contains child
        test.iseq(test.dir, blah.parent())
        test.iseq(True, test.dir.contains('blah'))

        /# Verify that the old parent (/) does NOT contain child
        test.iseq(False, test.root.contains('blah'))
    end field parent;

    lifecycle params:
      var parent : Node;
      var name : str;
    scope:
      self.nameIs(name)
      self._parent = None  # needed because parentIs() expects it to be defined.
      self.parentIs(parent)
    setup:
      test.defineFiles()
    end lifecycle;

    method abspath : str #:
      Full path of this file system object.
      Returns string representing absolute path.
    scope:
      result = []
      obj = self
      while obj:
        result.append(obj.name())
        obj = obj.parent()
      result = '/'.join(reversed(result))
      if not result:
        result = '/'
      return result
    test:
      test.iseq('/', test.root.abspath())
      test.iseq('/dir', test.dir.abspath())
      test.iseq('/dir/subdir', test.subdir.abspath())
      test.iseq('/file', test.file.abspath())
      test.iseq('/dir/subfile', test.subfile.abspath())
    end method abspath;

    method isDir scope:
      return False
    test:
      test.iseq(True, test.root.isDir())
      test.iseq(True, test.dir.isDir())
      test.iseq(True, test.subdir.isDir())
      test.iseq(False, test.file.isDir())
      test.iseq(False, test.subfile.isDir())
    end method isDir;

    method isSymlink scope:
      return False
    test:
      test.iseq(False, test.root.isSymlink())
      test.iseq(False, test.dir.isSymlink())
      test.iseq(False, test.subdir.isSymlink())
      test.iseq(False, test.file.isSymlink())
      test.iseq(False, test.subfile.isSymlink())
      test.iseq(True, test.link.isSymlink())
    end method isSymlink;

  end class Node;

  class Directory < Node #:
    Represents a directory within which the shell can navigate.
  scope:

    field children : @map #:
      The collection of subfiles/directories (dictionary maps name to
      instance of Directory or File)

    field infomap : *map #:
      A collection of key/value pairs that clients can read/write as they
      choose. Useful for storing information used in generator functions.
      Intentionally a pointer because this is often unused.

    lifecycle params:
      var parent : Directory;
      var name : str #:
        A string representing a unique (base) name within the parent
    super (parent, name)
    scope:
    setup:
      test.defineFiles()
    end lifecycle;

    protected
    method refresh #:
      Conditionally re-generate my list of children.
    scope:
    test:
      test.root.refresh()
    end method refresh;

    method isGenerator scope:
      return False
    test:
      test.iseq(False, test.root.isGenerator())
      test.iseq(False, test.dir.isGenerator())
      test.iseq(False, test.subdir.isGenerator())
    end method isGenerator;

    method familyPath : str #:
      Return the family path of this directory.
      Returns str starting and ending with '/', containing path strings
      and/or special <context> placeholders.
    scope:
      parent = self.parent()
      if parent:
        result = parent.familyPath()
        /# MEMORY(wmh): If you are coming back to this code after being away for
        /# awhile, do not go messing with it without understanding what is going
        /# on. No, it is not a typo that we are checking the parent for
        /# generator status, or using the parent childvar.
        if parent.isGenerator() and parent.childvar():
          result += '<%s>' % parent.childvar()
        else:
          result += self.name()
      else:
        result = self.name()
      result += '/'
      return result
    test:
      test.iseq('/', test.root.familyPath())
      test.iseq('/dir/', test.dir.familyPath())
      test.iseq('/dir/subdir/', test.subdir.familyPath())

      test.defineFiles(generator=True)
      gendir = test.gendir
      test.iseq('/hier/', gendir.familyPath())
      namespace = gendir.child('wmh')
      test.iseq('/hier/<namespace>/', namespace.familyPath())
      klass = namespace.child('Triangle')
      test.iseq('/hier/<namespace>/<class>/', klass.familyPath())
      method = klass.child('area')
      test.iseq('/hier/wmh/Triangle/area', method.abspath())
    end method familyPath;

    method listChildren #:
      List the contents of this directory.
    params:
      var fp : ostream = out #:
        Where to write the output.
      var detailed : bool = false #:
        True means print a 'ls -l' style listing
      var regexp : *regexp = null #:
        If non-None, a string regexp that names must match against
      var glob : *str = null #:
        If non-None, a string glob that names must match against
      var annotate : bool = false #:
        If True, suffix names with '/' if directories
      var hidden : bool = false #:
        By default, do not show children starting with '.'. If this is true,
        do show them.
    scope:
      /# Ensure that my children are up-to-date
      self.refresh()

      /# Print out my children.
      data = []
      for child_name in sorted(self.children()):
        if not hidden and child_name[0] == '.':
          continue
        if regexp and not re.match(regexp, child_name):
          continue
        child = self.children()[child_name]
        if detailed:
          /# TODO(wmh): Add in 'ls -l' style output here
          data.append('?rwx------ ? ? %s' % child_name)
        else:
          if annotate:
            if child.isDir():
              child_name += '/'
            elif child.isSymlink():
              child_name += '@'
          data.append(child_name)
      if detailed:
        fp.write(u'\n'.join(data) + '\n')
      else:
        /# TODO(wmh): provide multi-child-per-line support
        output = self.__class__.FormatListing(
          data, width=self.terminalWidth())
        fp.write(u'' + output + '\n')
      return data
    test:
      fp = test.fp()
      test.iseq(
        ['dir', 'file'],
        test.root.listChildren(fp=fp, detailed=False, annotate=False))
      test.iseq(
        ['dir/', 'file'],
        test.root.listChildren(fp=fp, detailed=False, annotate=True))
      test.iseqtext('dir  file\ndir/  file\n', fp.getvalue())
    end method listChildren;

    protected
    method terminalWidth : int #:
      Return the width of the current terminal.
      Returns int
    scope:
      /# This is its own method so that we easily control it during unit tests.
      return int(os.getenv('COLUMNS', '70')) - 5
    test:
      test.islt(60, test.root.terminalWidth())
    end method terminalWidth;

    meta protected
    method FormatListing : str #:
      Format a list of files similar to how 'ls' does, in multiple columns.
      Returns str.  Multi-line string representing the formatted set of rows of
      columns.
    params:
      var files : vec<str> #:
        The text to format into rows of columns.
      var width : int = 80 #:
        The maximum width of each line
      var maxword : int = 0 #:
        Any word whose length is larger than this is truncated to this length
        for display purposes.
    scope:
      if not files:
        return ''
      numfiles = len(files)
      /# We know that we can format the listing using numfiles rows (one file
      /# per row) regardless of the width specified. We have the method
      /# formatListingUsing(), which determines whether the files can be
      /# formatted using a given number of rows. We could linearly try rowsize
      /# 1, rowsize 2, all the way up to row size numfiles. But we can do better
      /# with a binary search.
      start = 1
      end = numfiles

      if True:
        numrows = 0
        while start != end:
          numrows = start + (end - start) / 2

          result = cls.FormatListingUsing(
              numrows, files, width=width, maxword=maxword)
          if result:
            /# We can fit in numrows, but maybe we can fit in even fewer.
            end = numrows
          else:
            /# We cannot fit in numrows ... try more rows.
            start = numrows + 1
        if numrows != end:
          result = cls.FormatListingUsing(
              end, files, width=width, maxword=maxword)

      else:
        rows = 1
        while True:
          result = cls.FormatListingUsing(
              rows, files, width=width, maxword=maxword)
          if result or rows > len(files):
            break
          rows += 1

      return result
    end method FormatListing;

    meta protected
    method FormatListingUsing : str #:
      Attempt to format a list of words into a specified number of rows.
      Returns str (if successful) or null (if not possible)
    params:
      var numrows : int #:
        The number of rows to format into.
      var files : vec<str> #:
        The text to format into rows of columns.
      var width : int = 0 #:
        The maximum width of each line
      var maxword : int = 0 #:
        Any word whose length is larger than this is truncated to this length
        for display purposes.
      var colspace : int = 2 #:
        Amount of spaces between each column
    scope:
      if maxword <= 0:
        maxword = 1000000
      files = sorted(files)

      /# TODO(wmh): This needs a fix-up for situations where there are a small
      /# number of small-length files ... in such situations the files are
      /# spread across the entire width allowed, instead of being more
      /# compactly listed.

      ok = True
      i = 0
      n = len(files)
      widths = []
      total = 0
      while i < n:
        /# Amongst the words that will appear in the current column, determine
        /# the maximum length.
        col_width = 0
        for j in range(0, numrows):
          index = i + j
          if index >= n:
            break
          word = files[i+j]
          size = min(len(word), maxword)
          if size > col_width:
            col_width = size

        widths.append(col_width)

        /# Increment the total width of the line needed to display all words.
        /# Note that if we've already processed a column, we need to add
        /# 'colspace' between columns as well.
        if total > 0:
          total += colspace
        total += col_width

        /# If our total width exceeds maximum width, this formatting is not
        /# possible.  However, if numrows is sufficient to allow a single file
        /# per line, we allow it even if it exceeds width.
        if numrows < n and total > width:
          ok = False
          break

        /# Advance to the word starting the next column
        i += numrows

      if ok:
        numcols = len(widths)

        /# We've found a width distribution that allows us to fit all files
        /# into the specified number of rows (using 'numcols' columns). We
        /# first check whether the fit is tighter than it needs to be, and
        /# if so, we add some additional space between each column.
        if numcols > 1:
          diff = width - total
          extra_spaces = diff / (numcols-1)
          if extra_spaces:
            widths = [width + extra_spaces for width in widths]

        /# Now we create the multi-line string of rows of columns.
        lines = []
        for r in range(0, numrows):
          i = r
          row = []
          for width in widths:
            if i < n:
              word = files[i]
              if len(word) > maxword:
                word = word[:maxword-1] + '$'
              row.append(word.ljust(width))
            else:
              break
            i += numrows
          spacing = ' ' * colspace
          lines.append(spacing.join(row).rstrip())
        if len(lines) == 1:
          result = re.sub(r'\s+', '  ', lines[0])
        else:
          result = '\n'.join(lines)
      else:
        result = None
      return result
    end method FormatListingUsing;

    method isDir scope:
      return True
    test:
      test.iseq(True, test.root.isDir())
      test.iseq(True, test.dir.isDir())
      test.iseq(False, test.file.isDir())
    end method isDir;

    method contains : bool #:
      Determine if the given name is a subclass of myself.
      Returns:
        true if name is a child of self, false otherwise.
    params:
      var name : str;
    scope:
      return name in self._children
    test:
      test.iseq(True, test.root.contains('dir'))
      test.iseq(True, test.root.contains('file'))
      test.iseq(False, test.root.contains('subfile'))
      test.iseq(True, test.dir.contains('subfile'))
      test.iseq(True, test.dir.contains('subdir'))
      test.iseq(False, test.dir.contains('nondir'))
    end method contains;

    method child : Node #:
      Obtain the child object identified by name.
      Returns:
        null if name isn't a child.
    params:
      var name : str;
    scope:
      return self._children.get(name, None)
    test:
      test.iseq(test.dir, test.root.child('dir'))
      test.iseq(test.file, test.root.child('file'))
      test.iseq(None, test.root.child('subfile'))
      test.iseq(test.subfile, test.dir.child('subfile'))
      test.iseq(test.subdir, test.dir.child('subdir'))
      test.iseq(None, test.dir.child('nondir'))
    end method child;

    method registerChild params:
      var child : Node;
    scope:
      self._children[child.name()] = child
      /# print('Added %s below %s' % (child.name(), self.name()))
    test:
      /# Because Node.__init__ calls registerChild to register
      /# every object with its parent, we can test registerChild by
      /# ensuring that dicts have their expected values.
      test.iseq(test.file, test.root._children['file'])
      test.iseq(test.dir, test.root._children['dir'])
      test.iseq(test.subfile, test.dir._children['subfile'])
      test.iseq(test.subdir, test.dir._children['subdir'])
    end method registerChild;

    method add : Node #:
      Create a new file system object and register with self.

      The kind (dir, file or symlink) is determined by kind. If dir, whether it
      Directory or DynamicDirectory is determined by existence of the
      generator param.

      IMPORTANT: There are two places where add can be invoked:
        1. In some function that statically creates a directory hierarchy
        2. In a generator function
      It does not make sense to add a generating subdir to a generating dir
      in case #1 ... it only makes sense in #2, sicne the statically added
      child will be erased the first time the parent directory is refreshed.
    params:
      var kind : str #:
        One of 'dir', 'file' or 'symlink'
      var name : str #:
        A string representing a unique (base) name within the parent
      var generator : method = null #:
        A method that accepts a single Directory as argument, and returns the
        list of Node instances that that Directory should have as
        children.
      var childvar : str = null #:
        Must be specified if generator is specified, and ignored if generator
        is null.  Represents the context variable associated with child
        objects within the newly created directory.
      var freshold : int = -1 #:
        Number of seconds that the child contents of this Directory are
        considered fresh (accesses after that duration will result in the
        generator being invoked again).
      var content : str = null #:
        Only legal for kind 'file'. Specifies the contents of the file.
      var link : Node = null #:
        Only legal for kind 'symlink'. Specifies the object linked to.
      var info : map = null #:
        If provided, the infomap field of the created Node is set to this
        value. Only legal for kind 'dir'.
    scope:
      if generator:
        if freshold < 0:
          raise Error('Must provide freshold if generator.')
        result = DynamicDirectory(self, name, childvar, generator, freshold)
      elif kind == 'dir':
        result = Directory(self, name)
      else:
        if generator or freshold > -1:
          raise Error(
            'Non-dir children must not specify childvar, generator or freshold')
        if kind == 'file':
          result = File(self, name)
        elif kind == 'symlink':
          result = Symlink(self, name)
        else:
          raise Error('Invalid kind "%s"' % kind)

      /# Deal with content, link, and infomap
      if content is not None:
        if kind == 'file':
          result.contentIs(content)
        else:
          raise Error(
            'The content keyword is only legal for kind file not %s' % kind)
      if link is not None:
        if kind == 'symlink':
          result.linkIs(link)
        else:
          raise Error(
            'The link keyword is only legal for kind symlink not %s' % kind)
      if info is not None:
        if kind == 'dir':
          result.infomapIs(info)
          /# print('**** Have set %s info to %s' % (result.abspath(), info))
        else:
          raise Error(
            'The infomap keyword is only legal for kind dir not %s' % kind)
      /# We do NOT need to invoke registerChild() here, because during
      /# creation of result we passed in the parent (aka self) and the
      /# Directory initializer implicitly invokes registerChild() on the
      /# parent when non-null.
      return result
    test:
      test.root.add('dir', 'domain')
      /# More tests here.
    end method add;

    method info : any #:
      Get/set a key in the infomap dict.

      Returns:
        The value associated with 'key' (if assignment is requested, the
        value returned is for what was in the key before assignment, not after)
    params:
      var key : str #:
        An arbitrary key in info.
      var value : any = UNDEF #:
        What value to assign to the key.  If UNDEF, no assignment is made.
    scope:
      infomap = self.infomap()
      if infomap is None:
        /# We have not set any keys on this dir's infomap yet.
        if value is UNDEF:
          /# We are getting ... no map means result always null.
          result = None
        else:
          /# We are setting ... create a map and initialize.
          result = None
          self.infomapIs({key: value})
      else:
        /# We have an infomap.
        if value is UNDEF:
          /# We are getting the value.
          result = infomap.get(key, None)
        else:
          /# We are getting then setting the value.
          result = infomap.get(key, None)
          infomap[key] = value
      return result
    test:
      d = test.dir
      test.isnull(d._infomap)
      test.isnull(d.info('a'))
      test.isnull(d._infomap)
      test.isnull(d.info('a', 1))
      test.iseq({'a': 1}, d._infomap)
      test.iseq(1, d.info('a'))
    end method info;

  end class Directory;

  class DynamicDirectory < Directory #:
    Represents a directory whose content is dynamically created.

    A special 'generator' function produces the dynamic content, and an
    associated freshness value (freshold) is maintained (previously computed
    dynamic data is considered fresh until it is older than the specified
    freshness time).

    Note that it does not make sense to call add() on an instance of
    this class, because such an invocation is a static child (the existence
    of which will go away the first time the generating directory is refreshed).
    Any child directories must be specified in the generator.
  assocs:
    usertest std assoc datetime;
    usertest std assoc time;
  scope:

    field generator : method #:
      The contents of the directory are produced by invoking this method.
      Accepts a single Directory $dir as argument, and returns the list of Node
      instances that that Directory should have as children. The objects should
      already be registered as children of the directory argument, and should be
      in the children() map of $dir (both of which happens automatically if one
      uses $dir.add() to create the children).

    field childvar : str #:
      The name of the context variable associated with the children of this
      directory instance.  This may be null to indicate that the children of
      this directory are not all part of some categorizable group.

    field updated : float #:
      Each instance records the last time it was updated. We mark it non-updated
      on initialization so that the first call to '_refresh' will update
      children from self._generator.

    field freshold : int #:
      For now, each instance records its freshness threshold in seconds.
      May want to find a more efficient means of storing this though
      (for example based on the generic path of this node).

    lifecycle #:
      Initialize an instance.
    params:
      var parent : Directory;
      var name : str;
      var childvar -> childvar;
      var generator -> generator;
      var freshold -> freshold;
    super (parent, name)
    scope:
      self._updated = datetime.datetime.fromtimestamp(0)
      /# IMPORTANT: We do NOT invoke _refresh() within this constructor, as this
      /# would result in an exponential initialization of all transitive
      /# children that have generators. Instead, directories are made "active"
      /# ONLY be 'cd'ing into them, and 'cd' (aka changeDirCommand) is
      /# responsible for the initial (and all subsequent) refreshes.
    test:
      test.iseqvec(
        ['hier', 'file', 'dir'],
        test.root.children().keys())
    setup:
      test.defineFiles(generator=True)
    end lifecycle;

    method isGenerator scope:
      return True
    test:
      test.isfalse(test.root.isGenerator())
      test.isfalse(test.dir.isGenerator())
      test.isfalse(test.subdir.isGenerator())
      test.istrue(test.gendir.isGenerator())
    end method isGenerator;

    override
    method child : Node #:
      Obtain the child object identified by name.
      Returns:
        null if name isn't a child.
    params:
      var name : str;
    scope:
      /# We invoke refresh() to ensure that there is actual content to search.
      self.refresh()
      return super(DynamicDirectory, self).child(name)
    test:
      test.iseq(test.dir, test.root.child('dir'))
      test.iseq(test.file, test.root.child('file'))
      test.iseq(None, test.root.child('subfile'))
      test.iseq(test.subfile, test.dir.child('subfile'))
      test.iseq(test.subdir, test.dir.child('subdir'))
      test.iseq(None, test.dir.child('nondir'))
    end method child;

    method updateTime params:
      var value : time = null;
    scope:
      if not value:
        value = datetime.datetime.now()
      self._updated = value
    test:
      d = test.gendir.updated()
      time.sleep(0.001)
      test.gendir.updateTime()
      test.istrue(d < test.gendir.updated())
    end method updateTime;

    protected
    method refresh : bool #:
      Conditionally re-generate my list of children.

      Returns:
        true if refreshing occurred, false if self still fresh.
    params:
      var force : bool = false #:
        If true, refresh regardless of whether cached data is fresh or  not.
      var verbose : bool = false #:
        If true, print out some details of actions performed.
    scope:
      now = datetime.datetime.now()
      td = now - self.updated()
      total_seconds = td.seconds + td.days * 24 * 3600

      if total_seconds > self.freshold() or force:
        /# We clear the set of children, so that the generator has a fresh
        /# slate within which to generate new children.
        children = self._children
        children.clear()

        /# Invoke my generator to obtain a list of Nodes
        child_list = self._generator(self)

        /# Although it is not strictly necessary to require generators to
        /# return the list of children, since the act of creating the children
        /# will implicitly register them as needed, we do require generators
        /# to return the list of children so that we can verify some invariants:
        /#  - the parent of each returned child is self
        /#  - the parent knows about the child.
        if not isinstance(child_list, (list, tuple)):
          raise Error(
            'The generator for %s returned %s ... must return children' %
            (self.abspath(), str(child_list)))

        /# Do some verification.
        for child in child_list:
          assert child.parent() is self
          assert children.get(child.name()) is child

        /# Update our lasted-updated field
        self.updateTime(now)

        result = True
      else:
        result = False
      return result
    test:
      test.iseqvec(['games', 'metax', 'wmh'], sorted(test.gendir.children()))

      /# We've set the freshness threshold to 10 seconds, so calling _refresh
      /# now should not require an update.
      test.isfalse(test.gendir.refresh())

      /# By setting the updatedd value back 30 seconds, we ensure that
      /# a new call to _refresh will trigger an update.
      d = datetime.datetime.now()
      test.gendir.updateTime(d - datetime.timedelta(seconds=30))
      test.istrue(test.gendir.refresh())
      test.istrue(test.gendir.updated() >= d)
    end method refresh;

    meta
    method FilesystemGenerator : any #:
      Returns a function suitable for use as the generator of a filesystem file
      dictated by the current path of this direc
    params:
      var prefix : str #:
        The prefix within the virtual filesystem where the real filesystem is
        to be mirrored.
      var freshold : int = 60 #:
        How long virtual representations of data are considered valid for.
        Note that 'cd' may perform updates of parent directories, so setting
        freshold to 0 can incur some expense.
    scope:
      if isinstance(prefix, Directory):
        raise Error(
          'FilesystemGenerator was invoked as a generator rather than a '
          'generator of the generator.\nCall the method, do not just reference '
          "it. And don't forget to pass in a prefix")
      /# Define the generator.
      def Generator(dir):
        result = []
        virtual_path = dir.abspath()
        assert virtual_path.startswith(prefix)
        real_path = virtual_path[len(prefix):] or '/'
        if os.path.isdir(real_path):
          /# print('***** HERE with %s=%s' % (virtual_path, real_path))
          for basename in os.listdir(real_path):
            fullpath = os.path.join(real_path, basename)
            /# print(u'  ' + basename)
            if os.path.islink(fullpath):
              destpath = os.readlink(fullpath)
              /# TODO(wmh): Decide how to handle these. Do we create the entire
              /# directory hierarchy of the destination path? Or change
              /# Symlink so that its 'link' (or some other field) is the
              /# absolute path (rather than a Node).
              link = None
              if False:
                print(
                  'WARNING: Not currently properly handling symlink %s (in %s)'
                  % (basename, virtual_path))
              /# child = dir.add('symlink', basename, link=link)
              child = None
            elif os.path.isdir(fullpath):
              /# The child needs to be able to perform the same dynamic
              /# generation of its children as the current dir, so it uses the
              /# same generator.
              child = dir.add(
                'dir', basename, freshold=freshold, generator=dir.generator())
            else:
              /# Normal file.
              child = dir.add('file', basename)
            if child:
              result.append(child)
        else:
          print('ERROR: %s is not a directory' % real_path)
        return result
      /# Return it.
      return Generator
    test:
    end method FilesystemGenerator;

  end class DynamicDirectory;

  class File < Node #:
    Represents a terminal file, which the shell can interact with.
  scope:

    field content : str #:
      The contents of the file.

    lifecycle params:
      var parent : Directory;
      var name : str;
      var content -> content = null;
    super (parent, name)
    scope:
    end lifecycle;
  end class File;

  class Symlink < Node #:
    Represents a symlink to another Node instance.
  scope:

    field link : Node #:
      The filesystem object linked to.

    lifecycle params:
      var parent : Directory;
      var name : str;
      var link : Node;
    super (parent, name)
    scope:
      self._link = link
    end lifecycle;

    method isSymlink scope:
      return True
    test:
      test.defineFiles()
      test.istrue(test.link.isSymlink())
      test.isfalse(test.subfile.isSymlink())
    end method isSymlink;

    method __getattr__ params:
      var name : str;
    scope:
      /# TODO(wmh): This is rather fragile, as it delegates to self._link for
      /# all methods not defined in Node, but does NOT delegate for those
      /# methods that ARE defined in Node (because Symlink is a subclass of Node
      /# and thus inherits all those methods, so __getattr__ won't be called for
      /# them. This means we may often NOT be calling the desired method. Might
      /# want to use __getattribute__ instead!
      return getattr(self._link, name)
    test:
      /# TODO(wmh): I don't think this method can every be invoked meaingfully.
      pass
    end method __getattr__;
  end class Symlink;

  test
  class TestCase < metax.test.TestCase scope:
    lifecycle setup:
      test.outfp = test.fp()
      sh = metax.lib.shell.Shell(fp=test.outfp)
      test.shell = sh
      sh.registerDirectoryFamily('/dir/([^/]+)', ('special',))
    end lifecycle;

    method defineFiles params:
      var generator : bool = false #:
        If true, define some generators too.
    scope:
      root = metax.lib.shell.Directory(None, '')
      test.root = root
      test.dir = metax.lib.shell.Directory(root, 'dir')
      test.subdir = metax.lib.shell.Directory(test.dir, 'subdir')
      test.file = metax.lib.shell.File(root, 'file')
      test.subfile = metax.lib.shell.File(test.dir, 'subfile')
      test.link = metax.lib.shell.Symlink(test.dir, 'link', test.subfile)

      if generator:
        def GenMethod(p):
          /# All elements in result are simple files whose names are methods.
          return [
            p.add('file', method)
            /# In a real application, the method names would come from somme
            /# dynamic source (otherwise there would be no need to generate
            /# them dynamically).
            for method in ('draw', 'area', 'perimeter')
          ]
        def GenClass(p):
          /# All elements in result are directories whose names are classes
          /# and whose contents are generated methods.
          return [
            p.add(
              'dir', klass, childvar='method', generator=GenMethod,
              freshold=120)
            /# In a real application, the class names would come from somme
            /# dynamic source (otherwise there would be no need to generate
            /# them dynamically).
            for klass in ('Shape', 'Triangle', 'Rectangle')
          ]
        def GenSpace(p):
          /# All elements in result are directories whose names are namespaces
          /# and whose contents are generated classes.
          return [
            p.add(
              'dir', namespace, childvar='class', generator=GenClass,
              freshold=120)
            /# In a real application, the namespace names would come from somme
            /# dynamic source (otherwise there would be no need to generate
            /# them dynamically).
            for namespace in ('metax', 'wmh', 'games')
          ]

        generator = lambda rec: (
          rec.add('file', 'a'),
          rec.add('file', 'b'),
          rec.add(
            'dir', 'subgen',
            generator=lambda r: (
              r.add('file', 'c'),
              r.add('dir', 'jobs', childvar='job', generator=lambda rr: (
                rr.add('file', 'd')), freshold=20),
            ),
            freshold=100))
        test.gendir = root.add(
          'dir', 'hier', childvar='namespace', generator=GenSpace, freshold=10)

        test.root.refresh()
        test.gendir.refresh()
    end;

  end class TestCase;

end namespace metax.lib.shell;
