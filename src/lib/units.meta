namespace metax.units #:
  Implement units.

  TODO(wmh): Consider using the decimal.Decimal class to represent values.
  Cancel that ... not portable to other languages.
scope:

  class Error < metax.root.Error #:
    The exception class for this module.

  class InvalidQuantity < Error #:
    When one attempts to create a subclass of FixedDimensionQuantity with
    a string value

  class Dimension #:
    Describes a dimension of measurement.
  scope:
    field index : int #:
      The order of this dimension in ordered lists.
    field name : str #:
      The canonical name of the dimension.
    field si : str #:
      The name of the base SI unit.
    field quantity : str #:
      A one-letter indicator
    field dim : str #:
      A different one-letter indicator.
    field units : map<str,Unit> #:
      Maps unit names to Unit instances.

    lifecycle params:
      var index -> index;
      var name -> name;
      var si -> si;
      var quantity -> quantity;
      var dim -> dim;
      var units : vec<map> #:
        Each element contains the following keys:
          name: str
          suffix: str
          scale: float
        Used to create Unit instances.
    scope<py>:
      units = {}
      index = 0
      for udata in units:
        name = udata['name']
        unit = Unit(self, index, name, udata['suffix'], udata['scale'])
        units[name] = unit
        index += 1
      self.unitsIs(units)
    scope<cc>:
    end;

  end class Dimension;

  class Unit #:
    Describes a unit of measurement.
  scope:
    field dimension : Dimension #:
      The dimension this unit belongs to.
    field name : str #:
      Name of the unit
    field suffix : str #:
      Suffix used to concisely represent this unit.
    field scale : float #:
      The scale of this unit relative to the base unit for the dimension
      (the base unit is the one with scale 1.0)
    field index : int #:
      The order of this unit within its dimension.

    lifecycle params:
      var dimension -> dimension;
      var index -> index;
      var name -> name;
      var suffix -> suffix;
      var scale -> scale;
    scope<py>:
    scope<cc>:
    end;
  end class Unit;

  class Quantity #:
    Represents a physical quantity expressed in terms of SI base units:
      https://en.wikipedia.org/wiki/SI_base_unit
    Also supports physical quantities representing SI drevied units:
      https://en.wikipedia.org/wiki/SI_derived_unit
    For both base and derived units, conversion from non-SI units are also
    supported.
  assocs<py>:
    std assoc logging;
    std assoc math;
    std assoc re;
  scope:

    static
    field Re : regexp #:
      A unit representation is a collection of unit specs separated by
      separators.
       - unit specs are [<value>]<base_unit>[unit_power] and uniquely
         identify the associated dimension.
       - legal separators are '*', '', and '/' (spaces allowed before/after)

    static
    field Str : map<int,str> #:
      Maps integer powers to ascii string representations.
      TODO(wmh): Convert the keys to strings (also contains 'times': '*', which
      won't fly in C++).

    static
    field Unicode : map<int,str> #:
      Maps integer powers to unicode string representations.
      TODO(wmh): Convert the keys to strings (also contains 'times': '*', which
      won't fly in C++).

    meta
    field PowerBits : int = 4 #:
      The number of bits reserved for each base unit to express powers.
        2 --> -2 to 1       can fit 32 in 64bit
        3 --> -4 to 3       can fit 21
        4 --> -8 to 7       can fit 16
        5 --> -16 to 15     can fit 12
        6 --> -32 to 31     can fit 10
        7 --> -64 to 63     can fit  9

    meta
    field UnitBits : int = 4 #:
      The number of bits reserved for each base dimension to express unit
      kind (e.g. kg or pound or stone, meter or foot, etc.)

    meta
    field Dimensions : map #:
      Base dimensions: https://en.wikipedia.org/wiki/International_System_of_Units
      https://en.wikipedia.org/wiki/International_System_of_Quantities
      See the unix command 'units' and in particular the data file
      /usr/share/misc/units.lib

    field value : double #:
      The value of the unit.

    field powers : int #:
      Encodes the exponents
         a b c d e f g h
        L M T I O N J !

      Where:
        L is length
        M is mass
        T is time
        I is current
        O is temperature
        N is amount
        J is intensity

      Each of these 7 core quantities is given K bits in which to encode this
      exponent. Note that K=4 uses 32 bits and supports values between -8 and 7,
      while K=6 uses 48 bits and supports values between -32 and +31.

          0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
         -8-7-6-5-4-3-2-1 0 1  2  3  4  5  6  7  if -8
         -7-6-5-4-3-2-1 0 1 2  3  4  5  6  7  8  if -7

      IMPORTANT: Note that by using a single integral value to express the
      exponents, we are limiting ourselves to integral powers. However, there
      are times where we need to express rational powers. This could be done by
      adding an additional bitstream to represent power denominators to
      complement the existing power numerators. The number of bits used for
      denominator can be independent of the number used for numerator.
      Furthermore, the demoniator would not need to maintain negative values.
      For example, if we use 5 bits for numerator (-16 to +15) and 4 bits for
      denominator (0-15), we can express all rational numbers of the form p/q
      where -16 <= p <= 15 and 0 <= q <= 15. This would require 7*5 + 7*4 = 59
      less than 64 bits, so it would be encodable in a single int64.
    end field powers;

    lifecycle #:
      Normally one uses Quantity.New() which computes the correct
      parameters to pass to this initializer.
    params:
      var value -> value;
      var powers -> powers;
    scope<py>:
    clinit<py>:

      /# TODO(wmh): This variable is unused currently (field 'Dimensions' is
      /# initialized explicitly below). Decide whether the Dimension class
      /# is useful or not.
      dimensions = {
        'length': Dimension(
          0, 'length', 'meter', 'l', 'L', units=[
            {'name': 'meter', 'suffix': 'm', 'scale': 1.0},
            {'name': 'kilometer', 'suffix': 'km', 'scale': 1000.0},
            {'name': 'centimeter', 'suffix': 'cm', 'scale': 0.01},
            {'name': 'millimeter', 'suffix': 'mm', 'scale': 0.001},
            {'name': 'micrometer', 'suffix': 'um', 'scale': 0.000001},
            {'name': 'nanometer', 'suffix': 'nm', 'scale': 0.000000001},
            {'name': 'inch', 'suffix': 'in', 'scale': 0.0254},
            {'name': 'foot', 'suffix': 'ft', 'scale': 0.3048},
            {'name': 'yard', 'suffix': 'yd', 'scale': 0.9144},
            {'name': 'mile', 'suffix': 'mi', 'scale': 1609.34},
            {'name': 'nautical_mile', 'suffix': 'M', 'suffix2': 'NM', 'scale': 1852},
          ],
        ),
        'mass': Dimension(
          1, 'mass', 'kilogram', 'm', 'M', units=[
            {'name': 'kilogram', 'suffix': 'kg', 'scale': 1.0},
            {'name': 'gram', 'suffix': 'g', 'scale': 0.001},
            {'name': 'milligram', 'suffix': 'mg', 'scale': 0.000001},
            {'name': 'microgram', 'suffix': 'ug', 'scale': 0.000000001},
            {'name': 'tonne', 'aliases': ['metric_ton'], 'suffix': 't', 'scale': 1000.0},
            {'name': 'long_ton', 'aliases': ['imperial_ton'], 'suffix': 'longton', 'scale': 1016.05},
            {'name': 'ton', 'aliases': ['us_ton'], 'suffix': 'ton', 'scale': 907.185},
            {'name': 'pound', 'suffix': 'lb', 'scale': 0.453592},
            {'name': 'ounce', 'suffix': 'oz', 'scale': 0.0283495},
            {'name': 'stone', 'suffix': 'st', 'scale': 6.35029},
          ]
        ),
        'time': Dimension(
          2, 'time', 'second', 't', 'T', units=[
            {'name': 'second', 'suffix': 's', 'scale': 1.0},
            {'name': 'millisecond', 'suffix': 'ms', 'scale': 0.001},
            {'name': 'microsecond', 'suffix': 'us', 'scale': 0.000001},
            {'name': 'nanosecond', 'suffix': 'ns', 'scale': 0.000000001},
            {'name': 'minute', 'suffix': 'min', 'scale': 60.0},
            {'name': 'hour', 'suffix': 'h', 'scale': 3600.0},
            {'name': 'day', 'suffix': 'd', 'scale': 86400.0},
            {'name': 'week', 'suffix': 'w', 'scale': 604800.0},
          ],
        ),
        'current': Dimension(
          3, 'current', 'ampere', 'I', 'I', units=[
            /# https://en.wikipedia.org/wiki/Ampere
            {'name': 'ampere', 'suffix': 'A', 'scale': 1.0},
          ],
        ),
        'temperature': Dimension(
          4, 'temperature', 'kelvin', 'T', 'O',  # TODO(wmh): Theta, not O.
          units=[
            {'name': 'kelvin', 'suffix': 'K', 'scale': 0.0},
            {'name': 'celsius','suffix': 'C', 'scale': 0.0,
             /#'to': lambda v: v + 273.15,
             /#'from': lambda v: v - 273.15,
            },
            {'name': 'fahrenheit', 'suffix': 'F','scale': 0.0,
             /#'to': lambda v: (v + 459.67) * (5.0/9.0),
             /#'from': lambda v: (v * 1.8) - 459.67,
            },
          ],
        ),
        'amount': Dimension(
          5, 'amount', 'mole', 'n', 'N', units=[
            {'name': 'mole', 'suffix': 'mol', 'scale': 1.0},
          ],
        ),
        'intensity': Dimension(
          6, 'intensity', 'candela', 'Iv', 'J', units=[
            /# https://en.wikipedia.org/wiki/Candela
            {'name': 'candela', 'suffix': 'cd', 'scale': 1.0},
          ],
        ),
        /# Not parted of the SI standard.
        'info': Dimension(
          7, 'info', 'bit', '', 'B', units=[
            {'name': 'bit', 'suffix': 'bits', 'scale': 1.0},
            {'name': 'byte', 'suffix': 'B', 'scale': 8.0},
          ],
        ),
      }

      /# cls.Dimensions3Is(dimensions)

      cls.DimensionsIs({
        'length': {
          'index': 0,
          'si': 'meter',
          'quantity': 'l',
          'dim': 'L',
          'units': {
            'meter': {'suffix': 'm', 'scale': 1.0, 'num': 0},
            'kilometer':  {'suffix': 'km', 'scale': 1000.0, 'num': 1},
            'centimeter': {'suffix': 'cm', 'scale': 0.01, 'num': 2},
            'millimeter': {'suffix': 'mm', 'scale': 0.001, 'num': 3},
            'micrometer': {'suffix': 'um', 'scale': 0.000001, 'num': 4},
            'nanometer':  {'suffix': 'nm', 'scale': 0.000000001, 'num': 5},
            'inch': {'suffix': 'in', 'scale': 0.0254, 'num': 6},
            'foot': {'suffix': 'ft', 'scale': 0.3048, 'num': 7},
            'yard': {'suffix': 'yd', 'scale': 0.9144, 'num': 8},
            'mile': {'suffix': 'mi', 'scale': 1609.34, 'num': 9},
            'nautical_mile': {'suffix': 'M', 'suffix2': 'NM', 'scale': 1852, 'num': 10},
          },
        },
        'mass': {
          'index': 1,
          'si': 'kilogram',
          'quantity': 'm',
          'dim': 'M',
          'units': {
            'kilogram': {'suffix': 'kg', 'scale': 1.0, 'num': 0},
            'gram': {'suffix': 'g', 'scale': 0.001, 'num': 1},
            'milligram': {'suffix': 'mg', 'scale': 0.000001, 'num': 2},
            'microgram': {'suffix': 'ug', 'scale': 0.000000001, 'num': 3},
            'tonne': {'aliases': ['metric_ton'], 'suffix': 't', 'scale': 1000.0, 'num': 4},
            'long_ton': {'aliases': ['imperial_ton'], 'suffix': 'longton', 'scale': 1016.05, 'num': 5},
            'ton': {'aliases': ['us_ton'], 'suffix': 'ton', 'scale': 907.185, 'num': 6},
            'pound': {'suffix': 'lb', 'scale': 0.453592, 'num': 7},
            'ounce': {'suffix': 'oz', 'scale': 0.0283495, 'num': 8},
            'stone': {'suffix': 'st', 'scale': 6.35029, 'num': 9},
          },
        },
        'time': {
          'index': 2,
          'si': 'second',
          'quantity': 't',
          'dim': 'T',
          'units': {
            'second': {'suffix': 's', 'scale': 1.0, 'num': 0},
            'millisecond': {'suffix': 'ms', 'scale': 0.001, 'num': 1},
            'microsecond': {'suffix': 'us', 'scale': 0.000001, 'num': 2},
            'nanosecond':  {'suffix': 'ns', 'scale': 0.000000001, 'num': 3},
            'minute': {'suffix': 'min', 'scale': 60.0, 'num': 4},
            'hour': {'suffix': 'h', 'scale': 3600.0, 'num': 5},
            'day': {'suffix': 'd', 'scale': 86400.0, 'num': 6},
            'week': {'suffix': 'w', 'scale': 604800.0, 'num': 7},
          },
        },
        'current': {
          'index': 3,
          'si': 'ampere',
          'quantity': 'I',
          'dim': 'I',
          'units': {
            /# https://en.wikipedia.org/wiki/Ampere
            'ampere': {'suffix': 'A', 'scale': 1.0, 'num': 0},
          },
        },
        'temperature': {
          'index': 4,
          'si': 'kelvin',
          'quantity': 'T',
          'dim': 'O',  # TODO(wmh): Theta, not O.
          'units': {
            'kelvin': {'suffix': 'K', 'scale': 0.0, 'num': 0},
            'celsius': {
              'suffix': 'C',
              'scale': 0.0,
              /#'to': lambda v: v + 273.15,
              /#'from': lambda v: v - 273.15,
              'num': 1,
            },
            'fahrenheit': {
              'suffix': 'F',
              'scale': 0.0,
              /#'to': lambda v: (v + 459.67) * (5.0/9.0),
              /#'from': lambda v: (v * 1.8) - 459.67,
              'num': 2,
            },
          },
        },
        'amount': {
          'index': 5,
          'si': 'mole',
          'quantity': 'n',
          'dim': 'N',
          'units': {
            'mole': {'suffix': 'mol', 'scale': 1.0, 'num': 0},
          },
        },
        'intensity': {
          'index': 6,
          'si': 'candela',
          'quantity': 'Iv',
          'dim': 'J',
          'units': {
            /# https://en.wikipedia.org/wiki/Candela
            'candela': {'suffix': 'cd', 'scale': 1.0, 'num': 0},
          },
        },

        /# Not parted of the SI standard.
        'bit': {
          'index': 7,
          'si': 'bit',
          'quantity': '',
          'dim': 'B',
          'units': {
            'bit': {'suffix': 'bits', 'scale': 1.0, 'num': 0},
            'byte': {'suffix': 'B', 'scale': 8.0, 'num': 1},
          },
        },
      })

      /# For each dimension, we add a 'units2' map that maps unit suffixes
      /# to the same maps that unit names have. This will allow us to implement
      /# the units method using either names or suffixes. Although it would
      /# be more intuitive to just add suffix keys to the existing 'units'
      /# map, code elsewhere relies on units keys being unit names not
      /# suffixes.
      for dim, dimdata in cls.Dimensions().items():
        units = dimdata['units']
        units2 = {}
        for udata in list(units.values()):
          suffix = udata['suffix']
          assert suffix not in units2
          units2[suffix] = udata
        dimdata['units2'] = units2

      /# Initialize PowerMap
      /#   If we use k bits to represent each power, we can represent (2^k)-1
      /#   numbers. To represent both positive and negative numbers we want to
      /#   have 0 be represented by 2^(k-1). Thus, if k = 6, a power of 0 is
      /#   represented by 2^5 = 32. A bitstream that encodes 7 chunks of 6 bits
      /#   in which each chunk has conceptual value 0 means we need bit stream
      /#   100000100000100000100000100000100000100000 which is 0x20820820820 in
      /#   hex. The following initializes PowerMap with the appropriate integer
      /#   values to initialize N chunks of P bits, keyed by P (where N is
      /#   len(BaseDimensions)
      powermap = {}
      numdim = len(cls.Dimensions())
      for P in range(2, 8):
        bstr = '1' + '0' * (P-1)
        bitstr = bstr * numdim
        intval = int(bitstr, 2)
        powermap[P] = intval
      cls.PowerMap = powermap

      /# ZeroPowers is an int64 representing a powers value of all zeros.
      cls.ZeroPowers = powermap[cls.PowerBits()]

      cls.DerivedUnits = {
        /# https://en.wikipedia.org/wiki/SI_derived_unit
        /# Name      Sym. Quantity                 Equivalents    base unit
        /# hertz     Hz   frequency                1/s            s-1
        /# radian    rad  angle                    m/m            1
        /# steradian sr   solid angle              m2/m2          1
        /# newton    N    force, weight            kg*m/s2        kg*m*s-2
        /# pascal    Pa   pressure, stress         N/m2           kg*m-1*s-2
        /# joule     J    energy, work, heat       N*m;C*V;W*s    kg*m2*s-2
        /# watt      W    power,radiant flux       J/s;V*A        kg*m2*s-3
        /# coulomb   C    electric charge          s*A;F*V        s*A
        /#                quantity of electricity
        /# volt      V    voltage                  W/A;J/C        kg*m2*s-3*A-1
        /#                electrical pot. diff.
        /#                electromotive force
        /# farad     F    electrical capacitance   C/V;s/ohms     kg-1*m-2*s4*A2
        /# ohm       0    electrical resistance    1/S;V/A        kg*m2*s-3*A-2
        /#                impedance, reactance
        /# siemens   S    electrical conductance   1/0;A/V        kg-1*m-2*s3*A2
        /# weber     Wb   magnetic flux            J/A;T*m2       kg*m2*s-2*A-1
        /# tesla     T    magnetic field strength  V*s/m2;Wb/m2   kg*s-2*A-1
        /#                magnetic flux density    ;N/(A*m)
        /# henry     H    electrical inductance    V*s/A;0*s;Wb/A kg*m2*s-2*A-2
        /# degree C  C    temp rel. to 273.15 K    K              K
        /# lumen     lm   luminous flux            cd*sr          cd
        /# lux       lx   illuminance              lm/m2          m-2*cd
        /# becquerel Bq   radioactivity            1/s            s-1
        /#                (decays per unit time)
        /# gray      Gy   absorbed dose            J/kg           m2*s-2
        /#                (of ionizing radiation)
        /# sievert   Sv   equivalent dose          J/kg           m2*s-2
        /#                (of ionizing radiation)
        /# katal     kat  catalytic activity       mol/s          s-1*mol
        'frequency': {
          'si': 'hertz',
          'powers': {'s': -1},
          'units': {
            'hertz': {'suffix': 'Hz', 'scale': 1.0, 'num': 0},
          }
        },
        'angle': {
          'si': 'radian',
          'powers': {},
          'units': {
            'radian': {'suffix': 'rad', 'scale': 1.0, 'num': 0},
            'degree': {'suffix': 'o', 'suffix2': 'degs', 'scale': 0.0174533, 'num': 1},
            'gradian': {'suffix': 'gon', 'scale': 0.015708, 'num': 2},
            'milliradian': {'suffix': 'mil', 'scale': 0.001, 'num': 3},
            'arc_minute': {'suffix': "\'", 'suffix2': 'arcmin', 'scale': 0.000290888, 'num': 4},
            'arc_second': {'suffix': '\"', 'suffix2': 'arcsec', 'scale': 4.84813681e-6, 'num': 5},
          },
        },
        'force': {
          'si': 'newton',
          'powers': {'kg': 1, 'm': 1, 's': -2},
          'units': {
            'newton': {'suffix': 'N', 'scale': 1.0, 'num': 0},
          },
        },
      }

      /# Verify some invariants and create unitmap
      unitmap = {}
      num_units = 2 ** cls.UnitBits()
      items = list(cls.Dimensions().items())
      items.extend(cls.DerivedUnits.items())
      for dimension, data in items:
        data['name'] = dimension
        /# There must be a units key in data.
        units = data['units']
        /# There will be an index for base dimensions, but not for derived units
        /# (and a powers for derived units but not for base dimensions).
        index = data.get('index', None)
        powers = data.get('powers', None)
        /# There must be an si value, which must exist in units with num 0.
        si = data['si']
        siunit = units[si]
        num = siunit['num']
        assert num == 0, 'dimension %s has si %s and unitnum %d != 0' % (dimension, si, num)
        /# There must be no more than num_units units.
        assert len(units) <= num_units, 'dimension %s has %d units > max %d' % (dimension, len(units), num_units)

        /# Iterate over units.
        /#  - add some additional keys ('unit' and 'dimension')
        /#  - register each unit in unitmap with various keys, ensuring uniqueness.
        for unit, kdata in units.items():
          kdata['dimension'] = dimension
          kdata['unit'] = unit
          if index is not None:
            kdata['index'] = index
          if powers is not None:
            kdata['powers'] = powers
          suffix = kdata['suffix']
          suffix2 = kdata.get('suffix2', None)
          plural = unit + 's'
          keys = [unit, plural, suffix]
          if suffix2:
            keys.append(suffix2)
          aliases = kdata.get('aliases', None)
          if aliases:
            keys.extend(aliases)
          for key in keys:
            if key is not None:
              existing = unitmap.get(key, None)
              if existing and kdata is not existing:
                raise Error(
                  'Found conflict for %s:\n%s vs\n%s' %
                  (key, existing, kdata))
              unitmap[key] = kdata
        /# We also allow one to specify a unit by the generic dimension name.
        unitmap[dimension] = siunit
      /# We add a special None unitmap to support "no unit".
      unitmap[None] = {'unit': None, 'num': 0, 'power': 0}

      /# Debuggging
      if False:
        for key in sorted(unitmap):
          unitdata = unitmap[key]
          print('%-20s = %s' % (key, unitdata.get('suffix', None)))

      cls.UnitMap = unitmap

      /# Parsing this implicitly breaks WAE code, which does not yet contain
      /# a copy of /usr/share/misc/units.lib.
      /# cls.ParseUnits()

      cls.ReIs(re.compile(
        /# The numeric part (significant notation allowed, and can be empty).
        r'([-+]?[0-9]*(?:\.\d+)?(?:e[+-]?\d+)?)'
        /# The base unit part (optional)
        /#  - We could improve this by enumerating all the legal units, but that
        /#    would produce a more inefficient regexp
        /#  - we do not allow '*' or '/' because they are "unit operators" that
        /#    can appear in the separators between units.
        r'([^\d\s^*/]+)?'
        /# The unit power part (optional)
        r'(?:\^(-?\d+))?'
      ))

      cls.UnicodeIs({
        1: '\u00b9',
        2: '\u00b2',
        3: '\u00b3',
        4: '\u2074',
        5: '\u2075',
        6: '\2076',
        7: '\2077',
        8: '\2078',
        9: '\2079',
        0: '\2070',
        -1: '\u207b\u00b9',
        -2: '\u207b\u00b2',
        -3: '\u207b\u00b3',
        -4: '\u207b\u2074',
        -5: '\u207b\u2075',
        -6: '\u207b\2076',
        -7: '\u207b\2077',
        -8: '\u207b\2078',
        -9: '\u207b\2079',
        'times': '\u00b7',
      })

      cls.StrIs({
        1: '',
        2: '^2',
        3: '^3',
        4: '^4',
        5: '^5',
        6: '^6',
        7: '^7',
        8: '^8',
        9: '^9',
        0: '^0',
        -1: '^-1',
        -2: '^-2',
        -3: '^-3',
        -4: '^-4',
        -5: '^-5',
        -6: '^-6',
        -7: '^-7',
        -8: '^-8',
        -9: '^-9',
        'times': '*',
      })

      cls.Subclasses = None
    setup:
      Quantity = metax.units.Quantity
      DE = metax.units.Quantity.DimensionEncoding
      test.q1 = Quantity(7.5, DE({'length': 1}))
      test.q2 = Quantity.New('6.2ft')
      test.q3 = Quantity.New('6m / 2s')
      test.q4 = Quantity.New('6m / s')
      test.q5 = Quantity.New('2')
      test.q6 = Quantity.New('1 / 3s')
      test.q7 = Quantity.New('14.41 g/cm^3')
    scope<cc>:
    end lifecycle;

    meta
    method New : Quantity #:
      Create a new Quantity instance given a string representation.
    params:
      var spec : str #:
        A string representation of the quantity, which can be a combination
        of powers of arbitrary units for zero or more of the seven physical
        unit dimensions (length, mass, time, temperature, current, amount, and
        intensity).
      var subcls : class = null #:
        The class to use to create the instance. If null, cls is used.
        This exists in order to allow FixedDimensionQuantity.New to be
        defined (overriding this method) while still having Quantity.New
        create an instance of some subclass of FixedDimensionQuantity.
      var debug : bool = false #:
        If true, enable debugging.
    scope<py>:
      /# Establish how many bits are used to represent the unit exponent for
      /# each dimension.
      PowerBits = cls.PowerBits()
      PB2 = 1 << (PowerBits - 1)

      /# Split the string representation into groups of unit specs separated
      /# by multiplicative operators (only '*', '' and '/' are allowed).
      /#  - ignoring the first element of 'parts', there should be an intergral
      /#    number of groups of four elements:
      /#      0. float value (may be None)
      /#      1. base unit str (may be None)
      /#      2. power indicator (may be None)
      /#      3. operator ('*', '' or '/'  with spaces removed)
      nre = cls.Re()
      parts = nre.split(spec)
      if debug: print('parts: %s' % parts)
      n = len(parts)
      assert (n - 1) % 4 == 0

      /# We initialize the powers to "conceptual 0's" for all dimensions,
      /# which means setting the actual values to PB2 (half way between 0 and
      /# PB2*2)
      powers = Quantity.ZeroPowers

      /# Some initial values for variables
      denominator = False
      value = 1.0
      units = 0
      nonsi = []
      unitmap = cls.UnitMap

      /# Parse each group of four elements in 'parts'.
      i = 1
      while i < n:
        /# Obtain the unit parts (val, unit, power, sep)
        val = float(parts[i] or 1)
        unit = parts[i+1]
        pstr = parts[i+2]
        sep = parts[i+3].strip()

        /# Establish the unit data.
        /#  - note that unit is None for the first bundle of 4 values, and
        /#    unitmap has an entry for None (power=0, num=0)
        udata = unitmap.get(unit, None)
        if not udata:
          raise Error('Invalid unit "%s" in "%s"' % (unit, spec))

        /# Establish the power.
        /#  - if no power is provided, one is assumed except for the special
        /#    'no unit' unit, which has power 0.
        power = int(pstr or udata.get('power', 1))
        if denominator:
          power = -power
          val = 1/val

        /# Convert the value to canonical si if not already.
        num = udata['num']
        scale = udata.get('scale', None)
        if num:
          assert power
          /# A non-zero num means the specified unit is not canonical
          /# SI, so we need to convert val to the canonical SI representation.
          if not scale:
            raise Error('when is scale boolean false?')
          if scale:
            val *= scale ** power
          else:
            /# The only time we should get here is for 'temperature'. In
            /# python, we could store a 'to' key in the udata that contains
            /# a lambda to convert. However, that is more messy in C++, having
            /# keys with different types forcing use of 'any' or variant.
            /# They also do not work when initializing via constant field expr
            /# (which is very useful for C++).
            print('here with unit=%s' % unit)
            val = udata['to'](val)
          /# We need to remember the non-si unit.
          /# print('HERE with nonsi %s = %s' % (udata['unit'], udata['suffix']))

        if debug:
          print('-' * 70)
          print('udata=%s' % udata)
          print('value=%s' % value)
          print('val=%s' % val)
          print('unit=%s' % unit)
          print('power=%s' % power)
          print('num=%s' % num)
          print('scale=%s' % scale)

        /# Modify the total value of the quantity appropriately.
        /# - note that we have already switched the sign of power if denominator
        /#   is true, so we can simply multiple by val and rest assured that
        /#   it will divide when appropriate.
        value *= val

        /# Encode the power in powers.
        /#  - each dimension is assigned a chunk of bits within 'powers'
        /#    starting at index PowerBits * udata['index']
        /#  - In b bits we can representing numbers from 0 to (2^b)-1
        /#  - If we subtract 2^(b-1) from the above range, we get numbers from
        /#    -2^(b-1) to 2^(b-1)-1
        /#  - note that the powers bitstream was initialized such that the
        /#    value of each bitchunk is PB2 (which represents 0). We thus
        /#    add/subtraction power from that baseline.
        if power:
          /# Encode powers
          index = udata.get('index', None)
          if index is None:
            /# We have a derived unit
            powers = cls.DimensionEncoding(udata['powers'])
          else:
            /# We have a base unit.
            powers = cls.Encode(
              powers, PowerBits * udata['index'], PowerBits, power, incr=True)

        /# Establish whether there is an indication to switch denominator.
        if sep == '/':
          /# TODO(wmh): We allow arbitrary divisors, toggling back and forth
          /# between numerator and denominator.
          denominator = not denominator
        elif sep == '*' or sep == '':
          pass
        else:
          raise Error('Invalid separator "%s" within "%s"' % (sep, spec))

        /# Advance to next unit spec.
        i += 4

      /# The last sep should always be empty.
      if sep:
        raise Error('Invalid final sep "%s" in "%s"' % (sep, spec))

      /# Create and return the Quantity instance.
      if subcls is None:
        /# TODO(wmh): The code above uses 'cls' to access static/meta variables.
        /# Should we be using subcls instead?
        subcls = cls
      result = subcls(value, powers)
      return result
    test<py>:
      New = metax.units.Quantity.New

      q1 = New('7.5kg')
      test.iseq(7.5, q1.value())
      q2 = New('7.5kg 8.1m / 10s^2')
      test.iseq(6.075, q2.value())
      q3 = New('7.5kg*8.1m / 10s^2', debug=False)
      test.iseq(q2.value(), q3.value())
      q4 = New('30 degs')
      test.isapprox(0.523599, q4.value())
      q5 = New('2days')
      test.isapprox(172800.0, q5.value())
      q6 = New('-0.1d')
      test.isapprox(-8640.0, q6.value())
      q7 = New('5h')
      test.isapprox(18000.0, q7.value())

      q8 = New('14.41 g/cm^3', debug=False)
      test.isapprox(14410.0, q8.value())
    end method New;

    static
    method ParseUnits : map #:
      Parse the data file associated with the unix 'units' command:
        /usr/share/misc/units.lib
    params:
      var path : str = '/usr/share/misc/units.lib' #:
        The path to the units file to parse.
    scope<cc>:
    scope<py>:
      /# Each line is one of:
      /#  - comment: starts with '/'
      /#  - empty: only whitespace
      /#  - normal: <name>  [<scale>] <expr>
      /#
      /# Where
      /#   <name> is a unit or constant
      /#   <scale> is a float
      /#   <expr> is <name>[<op><name>]...
      /#   <op> is '/' or '-'
      nre = re.compile(
        r'(?P<name>[-_a-zA-Z%]+[0-]?)'
        r'\s+(?P<scale>\d*\.\d*(?:e[+-]\d+)?|\d+(?:e[+-]\d+)?)?'
        r'(?:\|(?P<divisor>\d+(?:\.\d+)?))?'
        r'\s*(?P<expr>.*)')

      umap = {}
      aliases = {}
      with open(path, 'r') as fp:
        ln = 0
        for line in fp:
          ln += 1
          if line[0] in ('/', '#'):
            /# comments ignored.
            continue
          elif not line.strip():
            /# empty lines ignored
            continue
          else:
            m = nre.match(line)
            if m:
              name = m.group('name')
              scale = m.group('scale')
              divisor = m.group('divisor')
              expr = m.group('expr')
              if scale is None:
                aliases[name] = expr
              else:
                fscale = float(scale)
                if divisor:
                  fscale /= float(divisor)
                sd = '%s / %s' % (scale, divisor) if divisor else scale
                /# print('%-30s = %-30s = %10g = %s' % (name, sd, fscale, expr))
                umap[name] = {'scale': fscale, 'other': expr}
            else:
              print('Line %4d unknown: %s' % (ln, line))
      Quantity.Aliases = aliases
      Quantity.Units = umap
    test<py>:
      metax.units.Quantity.ParseUnits()
    end method ParseUnits;

    static
    method Encode : int #:
      Set or increment an encoded bit-sequence within a bit-stream
    params:
      var bits : int #:
        The bit-stream to modify.  A modified version of this will be returned.
      var start : int #:
        The start bit
      var width : int #:
        The number of bits to set/incr.
      var value : int #:
        The bit-sequence to add.  If incr is true, this may be negative, but
        the result of current + value must be non-negative.
      var incr : bool = false #:
        If true, increment rather than set.
    scope<cc>:
    scope<py>:
      /# We need to replace the width bits of 'bits' from position 'start'
      /# to 'start+width-1' with either 'value' or 'current value + value'
      /#  - we form a mask that is all 1's except for the width bits starting
      /#    at start (which are all zero)
      /#  - we verify that value < 2^width
      /#  - if incr:
      /#    - current = (bits >> start) & ((1 << width)-1)
      /#    - shifted = (current + value) << start
      /#    else (setting, not incrementing ... do not need to know current val):
      /#    - shifted = 'value << start'
      /#  - result = (bits & mask) | shifted

      /# print('-' * 70)
      /# print('bitstr   = ' + bin(bits)[2:])
      /# print('start=%d width=%d value=%d incr=%s' % (start, width, value, incr))

      /# Create the mask for bits not affected by this call.
      fullmask = 0xfffffffffffffff  # intentionally 60 bits not 64
      smask = (1 << start) - 1
      unaffected_mask = (fullmask << (width + start)) | smask
      /# print('unaffect = ' + bin(unaffected_mask)[2:])

      /# Create the mask for bits affected by this call.
      max = (1 << width)

      /# If we are incrementing the current value, obtain current value and
      /# adjust 'value' accordingly.
      if incr:
        affected_mask = (max - 1) << start
        /# print('affected = ' + bin(affected_mask)[2:])
        current = (bits & affected_mask) >> start
        /# print('current  = ' + bin(current)[2:])
        value += current

      /# print('value    = ' + bin(value)[2:])

      /# Verify that the value to be encoded within 'width' bits is non-negative
      /# and less than 2^width
      if value < 0 or value >= max:
        raise Error('value %d is not within [0,%d)' % (value, max))

      /# Form the result
      result = (bits & unaffected_mask) | (value << start)

      /# print('result   = ' + bin(result)[2:])
      return result
    test<py>:
      Encode = metax.units.Quantity.Encode

      test.iseq(0x10, Encode(0, 4, 2, 1))
      test.iseq(0x30, Encode(0x10, 4, 2, 2, incr=True))
      test.raises(metax.units.Error, Encode, 0x30, 4, 2, 1, incr=True)

      test.iseq(0x33, Encode(0x30, 0, 2, 3))
      test.iseq(0x31, Encode(0x33, 0, 2, -2, incr=True))
    end method Encode;

    static
    method DimensionEncoding : int #:
      Return an encoding of powers of units.
    params:
      var units : map #:
        Maps unit names/aliases/abbrevs to integer powers (positive or negative)
    scope<cc>:
    scope<py>:
      nb = cls.PowerBits()
      result = cls.ZeroPowers
      unitmap = cls.UnitMap
      for unit, power in units.items():
        unitdata = unitmap.get(unit, None)
        if not unitdata: raise Error('Invalid unit "%s"' % unit)
        start = nb * unitdata['index']
        result = cls.Encode(result, start, nb, power, incr=True)
      return result
    test<py>:
      UE = metax.units.Quantity.DimensionEncoding
      PB = metax.units.Quantity.PowerBits()
      N = len(metax.units.Quantity.Dimensions())
      val0 = '1' + '0' * (PB-1)
      valm2 = '0' + '1' * (PB-2) + '0'
      val1 = '1' + '0' * (PB-2) + '1'

      test.iseqtext('0b' + val0*N, bin(UE({})))
      test.iseqtext(
        '0b' + val0*(N-3) + valm2 + val0 + val1,
        bin(UE({'m': 1, 's': -2})))
      test.iseqtext(
        '0b' + val0*(N-3) + valm2 + val0 + val1,
        bin(UE({'length': 1, 'time': -2})))
    end method DimensionEncoding;

    static
    method AddDimensionEncodings : int #:
      Add two encodings together.
    params:
      var encoding : int #:
        The first encoding
      var encoding2 : int #:
        The second encoding
      var negate : bool = false #:
        If true, subtract encoding2 rather than add.
    scope<cc>:
    scope<py>:
      PowerBits = Quantity.PowerBits()
      N = len(Quantity.Dimensions())
      PB2 = 1 << (PowerBits - 1)
      mask = (1 << PowerBits) - 1
      result = encoding
      start = 0
      maxbit = N * PowerBits
      while start < maxbit:
        dim_power = ((encoding2 >> start) & mask) - PB2
        if dim_power:
          if negate:
            dim_power = -dim_power
          result = Quantity.Encode(
            result, start, PowerBits, dim_power, incr=True)
        start += PowerBits
      return result
    test<py>:
      UE = metax.units.Quantity.DimensionEncoding
      ADE = metax.units.Quantity.AddDimensionEncodings
      zeros = UE({})
      e = UE({'length': 1, 'time': -2})
      test.iseq(2290648713, e)
      e2 = ADE(e, e)
      test.iseq(2290648202, e2)
      e3 = ADE(e, e, negate=True)
      test.iseq(zeros, e3)
      /# test.iseq(Q.AddDimensionEncodings(1, 5))
    end method AddDimensionEncodings;

    method clone : Quantity #:
      Create a new instance of this quantity.
    scope<cc>:
    scope<py>:
      return self.__class__(self.value(), self.powers())
    test<py>:
      res = test.q1.clone()
    end method clone;

    method subclone : metax.units.Quantity #:
      Create an instance of a subclass based on powers that copies self.

      Returns:
        An instance of a subclass if a subclass matching self.units() exists,
        else null.
    scope<cc>:
    scope<py>:
      cls = self.__class__
      subclasses = cls.Subclasses
      if subclasses is None:
        subclasses = {
          'm': Length,
          'kg': Mass,
          /# TODO(wmh): Add all other subclasses here!  Keys are the
          /# result of quantity.units().
        }
        cls.Subclasses = subclasses
      units, umult = self.units()
      subclass = subclasses.get(units, None)
      if subclass:
        result = subclass(self.value())
        assert result.powers() == self.powers()
      else:
        /# logging.warning('Failed to subclone %s %s', cls.__name__, self)
        result = None
      return result
    test<py>:
      res = test.q1.subclone()
      test.issame(metax.units.Length, res.meta())
      test.isapprox(7.5, res.value())
      q2 = metax.units.Quantity.New('20kg')
      res2 = q2.subclone()
      test.issame(metax.units.Mass, res2.meta())
      test.isapprox(20.0, res2.value())

      /# A quantity that doesn't have an associated subclass.
      q3 = metax.units.Quantity.New('15s')
      res3 = q3.subclone()
      test.isnull(res3)
    end method subclone;

    method __str__ : str #:
      Obtain the printable representation of this quantity.
    scope<cc>:
    scope<py>:
      return self.asStr()
    test<py>:
      test.iseq('7.50000 m', str(test.q1))
    end method __str__;

    method asStr : str #:
      Format this quantity according to desired units, precision, digits, width,
      format, unicode status, etc.
    params:
      var units : map = null #:
        If specified, indicates for some subset of units which unit to use.
      var precision : int = -1 #:
        How many digits after decimal to print.  If -1, a default is used
        depending on digits.
      var digits : int = -1 #:
        How many significant digits to use.  If -1, a default is used depending
        on whether precision is specified.
      var width : int = -1 #:
        How many digits to use to represent the numeric portion.
      var unicode : bool = false #:
        If true, express result in unicde.
      var form : str = '%1.5f' #:
        Format of numeric portion
      var nosuffix : bool = false #:
        If true, do not add suffix.
    scope<cc>:
    scope<py>:
      suffix, umult = self.units(units=units, unicode=unicode)
      value = self.value() * umult
      result = (form % value)
      if suffix and not nosuffix:
        result += ' ' + suffix
      return result
    test<py>:
      test.iseq('7.50000 m', test.q1.asStr())
      test.iseq('1.88976 m', test.q2.asStr())
      test.iseq('3.00000 m/s', test.q3.asStr())
      test.iseq('3.00000 m/s', test.q3.asStr(unicode=True))
      test.iseq('6.00000 m/s', test.q4.asStr())
      test.iseq('2.00000', test.q5.asStr())
      test.iseq('0.33333 /s', test.q6.asStr())

      units = {'length': 'foot'}
      q1 = test.q1
      test.iseq('24.60630 ft', q1.asStr(units=units))
      q4 = q1 * q1
      test.iseq('605.46996 ft^2', q4.asStr(units=units))
    end method asStr;

    method unitValue : float #:
      Obtain the value of this quantity in specified units
    params:
      var units : map = null #:
        If specified, indicates for some subset of units which unit to use.
    scope:
      suffix, umult = self.units(units=units)
      return self.value() * umult
    test:
      test.iseq(7.5, test.q1.unitValue())
      test.iseq(750.0, test.q1.unitValue(units={'length': 'cm'}))
      test.isapprox(24.606299, test.q1.unitValue(units={'length': 'ft'}))
    end method unitValue;

    method dimPower : int #:
      The power to which a given dimension is raised.
    params:
      var dim : str #:
        The dimension (a key in Dimensions()) to obtain a power for.
    scope:
      cls = self.__class__
      PowerBits = cls.PowerBits()
      HalfPB = 1 << (PowerBits-1)
      mask = (1 << PowerBits) - 1
      powers = self.powers()
      dimension_data = Quantity.Dimensions()[dim]
      start = PowerBits * dimension_data['index']
      power = int(((powers >> start) & mask) - HalfPB)
      return power
    test:
      test.iseq(1, test.q1.dimPower('length'))
      test.iseq(0, test.q1.dimPower('mass'))

      test.iseq(1, test.q7.dimPower('mass'))
      test.iseq(-3, test.q7.dimPower('length'))
      test.iseq(0, test.q7.dimPower('temperature'))
    end method dimPower;

    method units : tuple<str,float> #:
      Return back the units (as a str or unicode) for this quantity and the
      unit value multiplier.
    params:
      var units : map = null #:
        If specified, indicates for some subset of units which unit to use.
      var unicode : bool = false #:
        If true, return unicode, else str.
    scope<cc>:
    scope<py>:
      umult = 1.0
      if units is None:
        units = {}
      cls = self.__class__
      dimensions = Quantity.Dimensions()
      psuffixes = []   # positive power suffixes
      nsuffixes = []   # negative power suffixes
      cmap = cls.Unicode() if unicode else cls.Str()
      times_char = cmap['times']
      for dim in sorted(
        dimensions, key=lambda dim: dimensions[dim]['index']
      ):
        power = self.dimPower(dim)
        if power:
          dimension_data = dimensions[dim]
          dunit = units.get(dim, dimension_data['si'])
          udata = dimension_data['units'].get(dunit, dimension_data['units2'].get(dunit, None))
          if udata is None:
            raise Error('Failed to find %s unit with name/suffix "%s"' % (dim, dunit))
          umult /= udata['scale'] ** power

          suffix = udata['suffix']
          if abs(power) != 1:
            suffix += cmap[abs(power)]

          if power < 0:
            nsuffixes.append(suffix)
          else:
            psuffixes.append(suffix)

      suffix = times_char.join(psuffixes)
      if nsuffixes:
        suffix += '/'
        suffix += times_char.join(nsuffixes)
      return (suffix, umult)
    test<py>:
      test.iseq(('m', 1.0), test.q1.units())
      test.iseq(('m/s', 1.0), test.q3.units())
      test.iseq(('m/s', 1.0), test.q3.units(unicode=True))

      test.iseq(('ft', 3.280839895013123), test.q1.units(units={'length': 'foot'}))
      test.iseq(('ft', 3.280839895013123), test.q1.units(units={'length': 'ft'}))

      q4 = test.q1 * test.q1
      test.iseq(('ft^2', 10.763910416709722), q4.units(units={'length': 'foot'}))

      test.iseq(('kg/m^3', 1.0), test.q7.units())
      test.iseq(('kg/m³', 1.0), test.q7.units(unicode=True))
      test.iseq(('g/cm^3', 0.0010000000000000002), test.q7.units(units={'length': 'cm', 'mass': 'g'}))
      test.iseq(('g/cm³', 0.0010000000000000002), test.q7.units(units={'length': 'cm', 'mass': 'g'}, unicode=True))
    end method units;

    method sqrt : Quantity #:
      Return a new Quantity that is the square root (in value and units)
      of this quantity.
    scope:
      uparts = []
      dimensions = Quantity.Dimensions()
      for dim in sorted(
        dimensions, key=lambda dim: dimensions[dim]['index']
      ):
        power = self.dimPower(dim)
        if power:
          if power % 2 != 0:
            raise Error('Not yet handling dim %s power %d in sqrt' % (dim, power))
          power /= 2
          dimension_data = dimensions[dim]
          units = dimension_data['units']
          upart = units[dimension_data['si']]['suffix']
          if power != 1:
            upart = '^%d' % power
          uparts.append(upart)
      ustr = '*'.join(uparts)
      result = Quantity.New('%1.16f %s' % (math.sqrt(self.value()), ustr))
      return result
    test:
      q1 = metax.units.Quantity.New('100 m^2')
      q2 = q1.sqrt()
      test.iseq('10.00000 m', q2.asStr())
    end method sqrt;

    method __add__ : Quantity #:
      Return a new Quantity produced by adding self and other
    params:
      var other : Quantity;
    scope<cc>:
    scope<py>:
      if self.powers() != other.powers():
        raise TypeError(
          'Cannot add %s and %s' %
          (self.asStr(unicode=True), other.asStr(unicode=True)))
      return Quantity(self.value() + other.value(), self.powers())
    test<py>:
      q = test.q1 + test.q2
      test.iseq('9.38976 m', q.asStr())
      test.raises(TypeError, test.q1.__add__, test.q6)
    end method __add__;

    method plus : Quantity #:
      Modify self by adding other, returning self.
    params:
      var other : Quantity;
    scope<cc>:
    scope<py>:
      if self.powers() != other.powers():
        raise TypeError(
          'Cannot add %s and %s' %
          (self.asStr(unicode=True), other.asStr(unicode=True)))
      self._value += other.value()
      return self
    test<py>:
      q = test.q1
      q.plus(test.q2)
      test.iseq('9.38976 m', q.asStr())
      test.raises(TypeError, test.q1.plus, test.q6)
    end method plus;

    method __iadd__ : Quantity #:
      Modify self by adding other
    params:
      var other : Quantity;
    scope<cc>:
    scope<py>:
      return self.plus(other)
    test<py>:
      q = test.q1
      q += test.q2
      test.iseq('9.38976 m', q.asStr())
      test.raises(TypeError, test.q1.__iadd__, test.q6)
    end method __iadd__;

    method __sub__ : Quantity #:
      Return a new Quantity produced by subtracting other from self
    params:
      var other : Quantity;
    scope<cc>:
    scope<py>:
      if self.powers() != other.powers():
        raise TypeError(
          'Cannot subtract %s from %s' %
          (other.asStr(unicode=True), self.asStr(unicode=True)))
      return Quantity(self.value() - other.value(), self.powers())
    test<py>:
      q = test.q1 - test.q2
      test.iseq('5.61024 m', q.asStr())
      test.raises(TypeError, test.q1.__add__, test.q6)
    end method __sub__;

    method minus : Quantity #:
      Modify self by subtracting other, returning self.
    params:
      var other : Quantity;
    scope<cc>:
    scope<py>:
      if self.powers() != other.powers():
        raise TypeError(
          'Cannot subtract %s from %s' %
          (other.asStr(unicode=True), self.asStr(unicode=True)))
      self._value -= other.value()
      return self
    test<py>:
      q = test.q1
      q.minus(test.q2)
      test.iseq('5.61024 m', q.asStr())
      test.raises(TypeError, test.q1.__sub__, test.q6)
    end method minus;

    method __isub__ : Quantity #:
      Modify self by subtracting other
    params:
      var other : Quantity;
    scope<cc>:
    scope<py>:
      return self.minus(other)
    test<py>:
      q = test.q1
      q -= test.q2
      test.iseq('5.61024 m', q.asStr())
      test.raises(TypeError, test.q1.__sub__, test.q6)
    end method __isub__;

    method __mul__ : Quantity #:
      Return a new Quantity produced by multiplying self and other.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope<cc>:
    scope<py>:
      cls = self.__class__
      if isinstance(other, (int, float)):
        result = self.clone()
        result._value *= other
      else:
        powers = cls.AddDimensionEncodings(self.powers(), other.powers())
        result = Quantity(self.value() * other.value(), powers)
      return result
    test<py>:
      /# Multiply by another quantity.
      res = test.q1 * test.q6
      test.iseq('2.50000 m/s', res.asStr())

      /# Multiple by scalar.
      res2 = test.q1 * 2
      test.iseq('15.00000 m', res2.asStr())
    end method __mul__;

    method times : Quantity #:
      Modify self by multiplying by other. Returns self.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope<cc>:
    scope<py>:
      cls = self.__class__
      if isinstance(other, (int, float)):
        self._value *= other
      else:
        powers = cls.AddDimensionEncodings(self.powers(), other.powers())
        self._value *= other.value()
        self.powersIs(powers)
      return self
    test<py>:
      q = test.q1
      q.times(test.q6)
      test.iseq('2.50000 m/s', test.q1.asStr())

      /# We verify that q.times(q) properly squares value and increments power.
      q = metax.units.Quantity.New('2.5m')
      q.times(q)
      test.iseq('6.25000 m^2', q.asStr())

      /# Multiple by int and float scalars.
      q.times(2)
      q.times(1.5)
      test.iseq('18.75000 m^2', q.asStr())
    end method times;

    method __imul__ : Quantity #:
      Modify self by multiplying by other.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope<cc>:
    scope<py>:
      return self.times(other)
    test<py>:
      test.q1 *= test.q6
      test.iseq('2.50000 m/s', test.q1.asStr())
    end method __imul__;

    method __truediv__ : Quantity #:
      Return a new Quantity produced by multiplying self and other.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope<cc>:
    scope<py>:
      cls = self.__class__
      if isinstance(other, (int, float)):
        result = self.clone()
        result._value /= other
      else:
        powers = cls.AddDimensionEncodings(
          self.powers(), other.powers(), negate=True)
        result = Quantity(self.value() / other.value(), powers)
      return result
    test<py>:
      q = metax.units.Quantity.New('3s')
      res = test.q1 / q
      test.iseq('2.50000 m/s', res.asStr())

      /# Divide by int/float scalars.
      res2 = test.q1 / 2
      test.iseq('3.75000 m', res2.asStr())
      res3 = res2 / 0.5
      test.iseq('7.50000 m', res3.asStr())
    end method __truediv__;

    method __div__ : Quantity #:
      Return a new Quantity produced by multiplying self and other.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope<cc>:
    scope<py>:
      /# TODO(wmh): This should call __truediv__. It is provided to support
      /# python2 (in python2, / is defined by __div__ while in python3 / is
      /# defined by __truediv). Note that in python3, __floordiv__ defines //.
      cls = self.__class__
      if isinstance(other, (int, float)):
        result = self.clone()
        result._value /= other
      else:
        powers = cls.AddDimensionEncodings(
          self.powers(), other.powers(), negate=True)
        result = Quantity(self.value() / other.value(), powers)
      return result
    test<py>:
      q = metax.units.Quantity.New('3s')
      res = test.q1 / q
      test.iseq('2.50000 m/s', res.asStr())

      /# Divide by int/float scalars.
      res2 = test.q1 / 2
      test.iseq('3.75000 m', res2.asStr())
      res3 = res2 / 0.5
      test.iseq('7.50000 m', res3.asStr())
    end method __div__;

    method divideby : Quantity #:
      Modify self by dividing by other. Returns self.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope<cc>:
    scope<py>:
      cls = self.__class__
      if isinstance(other, (int, float)):
        self._value /= other
      else:
        powers = cls.AddDimensionEncodings(
          self.powers(), other.powers(), negate=True)
        self._value /= other.value()
        self.powersIs(powers)
      return self
    test<py>:
      newq = metax.units.Quantity.New('3s')
      q = test.q1
      q.divideby(newq)
      test.iseq('2.50000 m/s', q.asStr())

      /# Divide by scalars.
      q = metax.units.Quantity.New('5.2m')
      q.divideby(2)
      q.divideby(1.5)
      test.iseq('1.73333 m', q.asStr())
    end method divideby;

    method __idiv__ : Quantity #:
      Modify self by dividing by other.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope<cc>:
    scope<py>:
      return self.divideby(other)
    test<py>:
      newq = metax.units.Quantity.New('3s')
      test.q1 /= newq
      test.iseq('2.50000 m/s', test.q1.asStr())
    end method __idiv__;

    implicit
    command wunits #:
      Wade's units.
    scope<cc>:
    scope<py>:
      for line in cli.rest:
        q = Quantity.New(line)
        print('%-40s = %s' % (line, q.asStr()))
    end command wunits;

    test
    method test_v1
    scope<cc>:
    scope<py>:
      Quantity = metax.units.Quantity
      /# TODO(wmh): Fix temperature (deleted 'to' and 'from' ... need better
      /# solution).
      /#q = Quantity.New('273.15C')
      /# print(q)
    end method test_v1;

  end class Quantity;

  class FixedDimensionQuantity < Quantity #:
    An abstract superclass of subclasses of Quantity whose powers() field
    is fixed.
  scope:

    meta
    field Powers : int<64> #:
      This is initialized by each subclass to a constant representing the
      encoded constant powers() value of all instances.

    superx
    lifecycle params:
      var value : double;
      var powers : int = 0;
    scope<py>:
      if powers == 0:
        powers = self.__class__.Powers()
      super(FixedDimensionQuantity, self).__init__(value, powers)
    scope<cc>:
    end lifecycle;

    meta
    method New : FixedDimensionQuantity #:
      Obtain a new subclass of FixedDimensionQuantity
    params:
      var spec : str #:
        A string representation of the quantity, which can be a combination
        of powers of arbitrary units for zero or more of the seven physical
        unit dimensions (length, mass, time, temperature, current, amount, and
        intensity).
      var dim : str = null #:
        If present, the class name of the result must match this value (case
        ignored).
    scope:
      if cls is FixedDimensionQuantity:
        raise Error(
          'Must invoke Instance on subclass of FixedDimensionQuantity')
      result = Quantity.New(spec, subcls=cls)

      if dim:
        cname = result.__class__.__name__.lower()
        if cname != dim.lower():
          raise InvalidQuantity(
            '%s yields %s when expecting %s' %
            (spec, cname, dim.lower()))

      if result.powers() != cls.Powers():
        raise InvalidQuantity(
          'Specification "%s" is invalid for dimension %s' %
          (spec, cls.__name__))
      return result
    test:
      test.isapprox(7.0, metax.units.Time.New('7s').seconds())
      test.raises(metax.units.InvalidQuantity, metax.units.Time.New, '7m')
    end method New;

  end class FixedDimensionQuantity;

  class Length < FixedDimensionQuantity ::

    lifecycle
    clinit<py>:
      cls.PowersIs(Quantity.DimensionEncoding({'length': 1}))
    setup<py>:
      test.l1 = metax.units.Length(7.5)
    end;

    method inches : float #:
      Returns this length in inches.
    scope:
      return self.value() / Quantity.Dimensions()['length']['units']['inch']['scale']
    test:
      test.isapprox(295.275590, test.l1.inches())
    end method inches;

    method feet : float #:
      Returns this length in feet
    scope:
      return self.value() / Quantity.Dimensions()['length']['units']['foot']['scale']
    test:
      test.isapprox(24.6062992, test.l1.feet())
    end method feet;

    test
    method testx_basics scope<py>:
      test.iseq('7.50000 m', test.l1.asStr())
    scope<cc>:
    end method testx_basics;

  end class Length;

  class Mass < FixedDimensionQuantity ::

    lifecycle
    clinit<py>:
      cls.PowersIs(Quantity.DimensionEncoding({'mass': 1}))
    setup<py>:
      test.m1 = metax.units.Mass(7.5)
    end;

    method pounds : float #:
      Returns this mass in pounds
    scope:
      return self.value() / Quantity.Dimensions()['mass']['units']['pound']['scale']
    test:
      test.isapprox(16.534683, test.m1.pounds())
    end method pounds;

    test
    method testx_basics
    scope<py>:
      test.iseq('7.50000 kg', test.m1.asStr())
    scope<cc>:
    end method testx_basics;

  end class Mass;

  class Time < FixedDimensionQuantity ::

    lifecycle
    clinit<py>:
      cls.PowersIs(Quantity.DimensionEncoding({'time': 1}))
    setup<py>:
      test.l1 = metax.units.Time(6.1)
    end;

    method milliseconds : double #:
      Return this time in milliseconds
    scope:
      return self.value() * 1000.0
    test:
      expected = 6100.0
      test.isapprox(expected, test.l1.milliseconds())
      /# This ensures that the hard-coded constant matches value in Dimensions.
      scale = metax.units.Quantity.Dimensions()['time']['units']['millisecond']['scale']
      test.isapprox(expected, test.l1.value() / scale)
    end method milliseconds;

    method microseconds : double #:
      Return this time in microseconds
    scope:
      return self.value() * 1000000.0
    test:
      expected = 6100000.0
      test.isapprox(expected, test.l1.microseconds())
      /# This ensures that the hard-coded constant matches value in Dimensions.
      scale = metax.units.Quantity.Dimensions()['time']['units']['microsecond']['scale']
      test.isapprox(expected, test.l1.value() / scale)
    end method microseconds;

    method nanoseconds : double #:
      Return this time in nanoseconds
    scope:
      return self.value() * 1000000000.0
    test:
      expected = 6100000000.0
      test.isapprox(expected, test.l1.nanoseconds())
      /# This ensures that the hard-coded constant matches value in Dimensions.
      scale = metax.units.Quantity.Dimensions()['time']['units']['nanosecond']['scale']
      test.isapprox(expected, test.l1.value() / scale)
    end method nanoseconds;

    method seconds : double #:
      Return this Time in seconds.
    scope:
      return self.value()
    test:
      expected = 6.1
      test.isapprox(expected, test.l1.seconds())
      /# This ensures that the hard-coded constant matches value in Dimensions.
      scale = metax.units.Quantity.Dimensions()['time']['units']['second']['scale']
      test.isapprox(expected, test.l1.value() / scale)
    end method seconds;

    method minutes : double #:
      Return this time in minutes
    scope:
      return self.value() / 60.0
    test:
      expected = 0.1016666666
      test.isapprox(expected, test.l1.minutes())
      /# This ensures that the hard-coded constant matches value in Dimensions.
      scale = metax.units.Quantity.Dimensions()['time']['units']['minute']['scale']
      test.isapprox(expected, test.l1.value() / scale)
    end method minutes;

    method hours : double #:
      Return this time in hours
    scope:
      return self.value() / 3600.0
    test:
      expected = 0.00169444
      test.isapprox(expected, test.l1.hours())
      /# This ensures that the hard-coded constant matches value in Dimensions.
      scale = metax.units.Quantity.Dimensions()['time']['units']['hour']['scale']
      test.isapprox(expected, test.l1.value() / scale)
    end method hours;

    method days : double #:
      Return this time in days
    scope:
      return self.value() / 86400.0
    test:
      expected = 0.000071
      test.isapprox(expected, test.l1.days())
      /# This ensures that the hard-coded constant matches value in Dimensions.
      scale = metax.units.Quantity.Dimensions()['time']['units']['day']['scale']
      test.isapprox(expected, test.l1.value() / scale)
    end method days;

    test
    method testx_basics
    scope<py>:
      test.iseq('6.10000 s', test.l1.asStr())
    scope<cc>:
    end method testx_basics;

  end class Time;

  class NonSIQuantity #:
    A unit in non-SI terms.
  scope:

    field si : Quantity #:
      The quantity expressed in SI units.
    field units : int #:
      An encoding of the non-si units to express the value in.

    lifecycle #:
      NonSIQuantity instances are not usually created manually, but rather returned
      by Quantity.New when non-si units are used.
    params:
      var si -> si;
      var units -> units;
    scope<py>:
    scope<cc>:
    end;

  end class NonSIQuantity;

  test
  class TestCase < metax.test.TestCase scope:
    lifecycle setup:
    end;
  end class TestCase;

end namespace metax.units;
