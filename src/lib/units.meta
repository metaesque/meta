namespace metax.units #:
  Implement units.

  TODO(wmh): Consider using the decimal.Decimal class to represent values.
  Cancel that ... not portable to other languages.
scope:

  class Error < metax.root.Error #:
    The exception class for this module.

  class Quantity #:
    Represents a physical quantity expressed in terms of SI base units:
      https://en.wikipedia.org/wiki/SI_base_unit
    Also supports physical quantities representing SI drevied units:
      https://en.wikipedia.org/wiki/SI_derived_unit
    For both base and derived units, conversion from non-SI units are also
    supported.
  assocs<py>:
    std assoc logging;
    std assoc re;
  scope:

    meta
    method New : Quantity #:
      Create a new Quantity instance given a string representation.
    params:
      var repr : str #:
        A string representation of the quantity, which can be a combination
        of powers of arbitrary units for zero or more of the seven physical
        unit dimensions (length, mass, time, temperature, current, amount, and
        intensity).
      var debug : bool = false #:
        If true, enable debugging.
    scope:
      /# Establish how many bits are used to represent the unit exponent for
      /# each dimension.
      PowerBits = cls.PowerBits()
      PB2 = 1 << (PowerBits - 1)

      /# Split the string representation into groups of unit specs separated
      /# by multiplicative operators (only '*', '' and '/' are allowed).
      /#  - ignoring the first element of 'parts', there should be an intergral
      /#    number of groups of four elements:
      /#      0. float value (may be None)
      /#      1. base unit str (may be None)
      /#      2. power indicator (may be None)
      /#      3. operator ('*', '' or '/'  with spaces removed)
      nre = cls.Re()
      parts = nre.split(repr)
      if debug: print(parts)
      n = len(parts)
      assert (n - 1) % 4 == 0

      /# We initialize the powers to "conceptual 0's" for all dimensions,
      /# which means setting the actual values to PB2 (half way between 0 and
      /# PB2*2)
      powers = Quantity.ZeroPowers

      /# Some initial values for variables
      denominator = False
      value = 1.0
      units = 0
      nonsi = []
      unitmap = cls.UnitMap

      /# Parse each group of four elements in 'parts'.
      i = 1
      while i < n:
        /# Obtain the unit parts (val, unit, power, sep)
        val = float(parts[i] or 1)
        unit = parts[i+1]
        pstr = parts[i+2]
        sep = parts[i+3].strip()

        /# Establish the unit data.
        udata = unitmap.get(unit, None)
        if not udata:
          raise Error('Invalid unit "%s" in "%s"' % (unit, repr))

        /# Establish the power.
        /#  - if no power is provided, one is assumed except for the special
        /#    'no unit' unit, which has power 0.
        power = int(pstr or udata.get('power', 1))

        /# Convert the value to si if not already.
        num = udata['num']
        if num:
          /# A non-zero num means the specified unit is not SI, so we need to
          /# convert val to the SI equivalent
          scale = udata['scale']
          if scale:
            val *= udata['scale']
          else:
            /# The only time we should get here is for 'temperature'. In
            /# python, we could store a 'to' key in the udata that contains
            /# a lambda to convert. However, that is more messy in C++, having
            /# keys with different types forcing use of 'any' or variant.
            /# They also do not work when initializing via constant field expr
            /# (which is very useful for C++).
            print('here with unit=%s' % unit)
            val = udata['to'](val)
          /# We need to remember the non-si unit.
          /# print('HERE with nonsi %s = %s' % (udata['unit'], udata['suffix']))

        if debug:
          print(val)
          print(unit)
          print(power)
          print(udata)

        /# Modify the total value of the quantity appropriately based on whether
        /# we are currently multiplying or dividing.
        if denominator:
          value /= val
          power = -power
        else:
          value *= val

        /# Encode the power in powers.
        /#  - each dimension is assigned a chunk of bits within 'powers' 
        /#    starting at index PowerBits * udata['index']
        /#  - In b bits we can representing numbers from 0 to (2^b)-1
        /#  - If we subtract 2^(b-1) from the above range, we get numbers from
        /#    -2^(b-1) to 2^(b-1)-1
        /#  - note that the powers bitstream was initialized such that the
        /#    value of each bitchunk is PB2 (which represents 0). We thus
        /#    add/subtraction power from that baseline.
        if power:
          index = udata.get('index', None)
          if index is None:
            /# We have a derived unit
            powers = cls.DimensionEncoding(udata['powers'])
          else:
            /# We have a base unit.
            powers = cls.Encode(
              powers, PowerBits * udata['index'], PowerBits, power, incr=True)

        /# Establish whether there is an indication to switch denominator.
        if sep == '/':
          /# TODO(wmh): We allow arbitrary divisors, toggling back and forth
          /# between numerator and denominator.
          denominator = not denominator
        elif sep == '*' or sep == '':
          pass
        else:
          raise Error('Invalid separator "%s" within "%s"' % (sep, repr))
         
        /# Advance to next unit spec.
        i += 4

      /# The last sep should always be empty.
      if sep:
        raise Error('Invalid final sep "%s" in "%s"' % (sep, repr))

      /# Create and return the Quantity instance.
      result = Quantity(value, powers)
      return result
    test:
      New = metax.units.Quantity.New
      q1 = New('7.5kg')
      test.iseq(7.5, q1.value())
      q2 = New('7.5kg 8.1m / 10s^2')
      test.iseq(6.075, q2.value())
      q3 = New('7.5kg*8.1m / 10s^2')
      test.iseq(q2.value(), q3.value())
      q4 = New('30 degs')
      test.isapprox(0.523599, q4.value())
    end method New;

    static
    method ParseUnits : map #:
      Parse the data file associated with the unix 'units' command:
        /usr/share/misc/units.lib
    params:
      var path : str = '/usr/share/misc/units.lib' #:
        The path to the units file to parse.
    scope:
      /# Each line is one of:
      /#  - comment: starts with '/'
      /#  - empty: only whitespace
      /#  - normal: <name>  [<scale>] <expr>
      /#
      /# Where
      /#   <name> is a unit or constant
      /#   <scale> is a float
      /#   <expr> is <name>[<op><name>]...
      /#   <op> is '/' or '-'
      nre = re.compile(
        r'(?P<name>[-_a-zA-Z%]+[0-]?)'
        r'\s+(?P<scale>\d*\.\d*(?:e[+-]\d+)?|\d+(?:e[+-]\d+)?)?'
        r'(?:\|(?P<divisor>\d+(?:\.\d+)?))?'
        r'\s*(?P<expr>.*)')

      umap = {}
      aliases = {}
      with open(path, 'r') as fp:
        ln = 0
        for line in fp:
          ln += 1
          if line[0] in ('/', '#'):
            /# comments ignored.
            continue
          elif not line.strip():
            /# empty lines ignored
            continue
          else:
            m = nre.match(line)
            if m:
              name = m.group('name')
              scale = m.group('scale')
              divisor = m.group('divisor')
              expr = m.group('expr')
              if scale is None:
                aliases[name] = expr
              else:
                fscale = float(scale)
                if divisor:
                  fscale /= float(divisor)
                sd = '%s / %s' % (scale, divisor) if divisor else scale
                /# print('%-30s = %-30s = %10g = %s' % (name, sd, fscale, expr))
                umap[name] = {'scale': fscale, 'other': expr}
            else:
              print('Line %4d unknown: %s' % (ln, line))
      Quantity.Aliases = aliases
      Quantity.Units = umap
    test:
      metax.units.Quantity.ParseUnits()
    end method ParseUnits;

    static
    method Encode : int #:
      Set or increment an encoded bit-sequence within a bit-stream
    params:
      var bits : int #:
        The bit-stream to modify.  A modified version of this will be returned.
      var start : int #:
        The start bit
      var width : int #:
        The number of bits to set/incr.
      var value : int #:
        The bit-sequence to add.  If incr is true, this may be negative, but
        the result of current + value must be non-negative.
      var incr : bool = false #:
        If true, increment rather than set.
    scope:
      /# We need to replace the width bits of 'bits' from position 'start'
      /# to 'start+width-1' with either 'value' or 'current value + value'
      /#  - we form a mask that is all 1's except for the width bits starting
      /#    at start (which are all zero)
      /#  - we verify that value < 2^width
      /#  - if incr:
      /#    - current = (bits >> start) & ((1 << width)-1)
      /#    - shifted = (current + value) << start
      /#    else (setting, not incrementing ... do not need to know current val):
      /#    - shifted = 'value << start'
      /#  - result = (bits & mask) | shifted

      /# print('-' * 70)
      /# print('bitstr   = ' + bin(bits)[2:])
      /# print('start=%d width=%d value=%d incr=%s' % (start, width, value, incr))

      /# Create the mask for bits not affected by this call.
      fullmask = 0xfffffffffffffff  # intentionally 60 bits not 64
      smask = (1 << start) - 1
      unaffected_mask = (fullmask << (width + start)) | smask
      /# print('unaffect = ' + bin(unaffected_mask)[2:])

      /# Create the mask for bits affected by this call.
      max = (1 << width)

      /# If we are incrementing the current value, obtain current value and
      /# adjust 'value' accordingly.
      if incr:
        affected_mask = (max - 1) << start
        /# print('affected = ' + bin(affected_mask)[2:])
        current = (bits & affected_mask) >> start
        /# print('current  = ' + bin(current)[2:])
        value += current

      /# print('value    = ' + bin(value)[2:])

      /# Verify that the value to be encoded within 'width' bits is non-negative
      /# and less than 2^width
      if value < 0 or value >= max:
        raise Error('value %d is not within [0,%d)' % (value, max))

      /# Form the result
      result = (bits & unaffected_mask) | (value << start)
      
      /# print('result   = ' + bin(result)[2:])
      return result
    test:
      Encode = metax.units.Quantity.Encode

      test.iseq(0x10, Encode(0, 4, 2, 1))
      test.iseq(0x30, Encode(0x10, 4, 2, 2, incr=True))
      test.raises(metax.units.Error, Encode, 0x30, 4, 2, 1, incr=True)

      test.iseq(0x33, Encode(0x30, 0, 2, 3))
      test.iseq(0x31, Encode(0x33, 0, 2, -2, incr=True))
    end method Encode;

    static
    method DimensionEncoding : int #:
      Return an encoding of powers of units.
    params:
      var units : map #:
        Maps unit names/aliases/abbrevs to integer powers (positive or negative)
    scope:
      nb = cls.PowerBits()
      result = cls.ZeroPowers
      unitmap = cls.UnitMap
      for unit, power in units.items():
        unitdata = unitmap.get(unit, None)
        if not unitdata: raise Error('Invalid unit "%s"' % unit)
        start = nb * unitdata['index']
        result = cls.Encode(result, start, nb, power, incr=True)
      return result
    test:
      UE = metax.units.Quantity.DimensionEncoding
      PB = metax.units.Quantity.PowerBits()
      N = len(metax.units.Quantity.Dimensions())
      val0 = '1' + '0' * (PB-1)
      valm2 = '0' + '1' * (PB-2) + '0'
      val1 = '1' + '0' * (PB-2) + '1'

      test.iseqtext('0b' + val0*N, bin(UE({})))
      test.iseqtext(
        '0b' + val0*(N-3) + valm2 + val0 + val1,
        bin(UE({'m': 1, 's': -2})))
      test.iseqtext(
        '0b' + val0*(N-3) + valm2 + val0 + val1,
        bin(UE({'length': 1, 'time': -2})))
    end method DimensionEncoding;

    static
    method AddDimensionEncodings : int #:
      Add two encodings together.
    params:
      var encoding : int #:
        The first encoding
      var encoding2 : int #:
        The second encoding
      var negate : bool = false #:
        If true, subtract encoding2 rather than add.
    scope:
      PowerBits = Quantity.PowerBits()
      N = len(Quantity.Dimensions())
      PB2 = 1 << (PowerBits - 1)
      mask = (1 << PowerBits) - 1
      result = encoding
      start = 0
      maxbit = N * PowerBits
      while start < maxbit:
        dim_power = ((encoding2 >> start) & mask) - PB2
        if dim_power:
          if negate:
            dim_power = -dim_power
          result = Quantity.Encode(
            result, start, PowerBits, dim_power, incr=True)
        start += PowerBits
      return result
    test:
      UE = metax.units.Quantity.DimensionEncoding
      PB = metax.units.Quantity.PowerBits()
      ADE = metax.units.Quantity.AddDimensionEncodings
      zeros = UE({})
      e = UE({'length': 1, 'time': -2})
      test.iseq(2290648713, e)
      e2 = ADE(e, e)
      test.iseq(2290648202, e2)
      e3 = ADE(e, e, negate=True)
      test.iseq(zeros, e3)
      /# test.iseq(Q.AddDimensionEncodings(1, 5))
    end method AddDimensionEncodings;

    static field Re : regexp #:
      A unit representation is a collection of unit specs separated by
      separators.
       - unit specs are [<value>]<base_unit>[unit_power] and uniquely
         identify the associated dimension.
       - legal separators are '*', '', and '/' (spaces allowed before/after)

    static field Str : map<int,str> #:
      Maps integer powers to ascii string representations.
      TODO(wmh): Convert the keys to strings (also contains 'times': '*', which
      won't fly in C++).                                              

    static field Unicode : map<int,str> #:
      Maps integer powers to unicode string representations.
      TODO(wmh): Convert the keys to strings (also contains 'times': '*', which
      won't fly in C++).                                              

    field value : double #:
      The value of the unit.

    field powers : int #:
      Encodes the exponents 
         a b c d e f g h
        L M T I O N J !

      Where:
        L is length
        M is mass
        T is time
        I is current
        O is temperature
        N is amount
        J is intensity

      Each of these 7 core quantities is given K bits in which to encode this
      exponent. Note that K=4 uses 32 bits and supports values between -8 and 7,
      while K=6 uses 48 bits and supports values between -32 and +31.

          0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
         -8-7-6-5-4-3-2-1 0 1  2  3  4  5  6  7  if -8
         -7-6-5-4-3-2-1 0 1 2  3  4  5  6  7  8  if -7

      IMPORTANT: Note that by using a single integral value to express the
      exponents, we are limiting ourselves to integral powers. However, there
      are times where we need to express rational powers. This could be done by
      adding an additional bitstream to represent power denominators to
      complement the existing power numerators. The number of bits uses for
      denominator can be independent of the number used for numerator.
      Furthermore, the demoniator would not need to maintain negative values.
      For example, if we use 5 bits for numerator (-16 to +15) and 4 bits for
      denominator (0-15), we can express all rational numbers of the form p/q
      where -16 <= p <= 15 and 0 <= q <= 15. This would require 7*5 + 7*4 = 59
      less than 64 bits, so it would be encodable in a single int64.

    meta field PowerBits : int = 4 #:
      The number of bits reserved for each base unit to express powers.
        2 --> -2 to 1       can fit 32 in 64bit
        3 --> -4 to 3       can fit 21
        4 --> -8 to 7       can fit 16
        5 --> -16 to 15     can fit 12
        6 --> -32 to 31     can fit 10
        7 --> -64 to 63     can fit  9

    meta field UnitBits : int = 4 #:
      The number of bits reserved for each base dimension to express unit
      kind (e.g. kg or pound or stone, meter or foot, etc.)

    meta field Dimensions : map #:
      Base dimensions: https://en.wikipedia.org/wiki/International_System_of_Units
      https://en.wikipedia.org/wiki/International_System_of_Quantities
      See the unix command 'units' and in particular the data file
      /usr/share/misc/units.lib
    default {
      'length': {
      },
    };

    field testit : map = {
      'length': {
        'index': 0,
        'si': 'meter',
        'quantity': 'l',
        'dim': 'L',
        'units': {
          'meter': {'suffix': 'm', 'scale': 1.0, 'num': 0},
          'kilometer':  {'suffix': 'km', 'scale': 1000.0, 'num': 1},
          'centimeter': {'suffix': 'cm', 'scale': 0.01, 'num': 2},
          'millimeter': {'suffix': 'mm', 'scale': 0.001, 'num': 3},
          'micrometer': {'suffix': 'um', 'scale': 0.000001, 'num': 4},
          'nanometer':  {'suffix': 'nm', 'scale': 0.000000001, 'num': 5},
          'inch': {'suffix': 'in', 'scale': 0.0254, 'num': 6},
          'foot': {'suffix': 'ft', 'scale': 0.3048, 'num': 7},
          'yard': {'suffix': 'yd', 'scale': 0.9144, 'num': 8},
          'mile': {'suffix': 'mi', 'scale': 1609.34, 'num': 9},
          'nautical_mile': {'suffix': 'M', 'suffix2': 'NM', 'scale': 1852, 'num': 10},
        },
      },
      'mass': {
        'index': 1,
        'si': 'kilogram',
        'quantity': 'm',
        'dim': 'M',
        'units': {
          'kilogram': {'suffix': 'kg', 'scale': 1.0, 'num': 0},
          'gram': {'suffix': 'g', 'scale': 0.001, 'num': 1},
          'milligram': {'suffix': 'mg', 'scale': 0.000001, 'num': 2},
          'microgram': {'suffix': 'ug', 'scale': 0.000000001, 'num': 3},
          'tonne': {'aliases': ['metric_ton'], 'suffix': 't', 'scale': 1000.0, 'num': 4},
          'long_ton': {'aliases': ['imperial_ton'], 'suffix': 'longton', 'scale': 1016.05, 'num': 5},
          'ton': {'aliases': ['us_ton'], 'suffix': 'ton', 'scale': 907.185, 'num': 6},
          'pound': {'suffix': 'lb', 'scale': 0.453592, 'num': 7},
          'ounce': {'suffix': 'oz', 'scale': 0.0283495, 'num': 8},
          'stone': {'suffix': 'st', 'scale': 6.35029, 'num': 9},
        },
      },
      'time': {
        'index': 2,
        'si': 'second',
        'quantity': 't',
        'dim': 'T',
        'units': {
          'second': {'suffix': 's', 'scale': 1.0, 'num': 0},
          'millisecond': {'suffix': 'ms', 'scale': 0.001, 'num': 1},
          'microsecond': {'suffix': 'us', 'scale': 0.000001, 'num': 2},
          'nanosecond':  {'suffix': 'ns', 'scale': 0.000000001, 'num': 3},
          'minute': {'suffix': 'min', 'scale': 60.0, 'num': 4},
          'hour': {'suffix': 'hr', 'scale': 3600.0, 'num': 5},
          'day': {'suffix': 'dy', 'scale': 86400.0, 'num': 6},
          'week': {'suffix': 'wk', 'scale': 604800.0, 'num': 7},
        },
      },
      'current': {
        'index': 3,
        'si': 'ampere',
        'quantity': 'I',
        'dim': 'I',
        'units': {
          'ampere': {'suffix': 'A', 'scale': 1.0, 'num': 0},
        },
      },
      'temperature': {
        'index': 4,
        'si': 'kelvin',
        'quantity': 'T',
        'dim': 'O',
        'units': {
          'kelvin': {'suffix': 'K', 'scale': 0.0, 'num': 0},
          'celsius': {
            'suffix': 'C',
            'num': 1,
          },
          'fahrenheit': {
            'suffix': 'F',
            'num': 2,
          },
        },
      },
      'amount': {
        'index': 5,
        'si': 'mole',
        'quantity': 'n',
        'dim': 'N',
        'units': {
          'mole': {'suffix': 'mol', 'scale': 1.0, 'num': 0},
        },
      },
      'intensity': {
        'index': 6,
        'si': 'candela',
        'quantity': 'Iv',
        'dim': 'J',
        'units': {
          'candela': {'suffix': 'cd', 'scale': 1.0, 'num': 0},
        },
      },
      'bit': {
        'index': 7,
        'si': 'bit',
        'quantity': '',
        'dim': 'B',
        'units': {
          'bit': {'suffix': 'bits', 'scale': 1.0, 'num': 0},
          'byte': {'suffix': 'B', 'scale': 8.0, 'num': 1},
        },
      },
    };

    lifecycle #:
      Normally one uses Quantity.New() which computes the correct
      parameters to pass to this initializer.
    params:
      var value -> value;
      var powers -> powers;
    scope:
    metainit:
      cls.DimensionsIs({
        'length': {
          'index': 0,
          'si': 'meter',
          'quantity': 'l',
          'dim': 'L',
          'units': {
            'meter': {'suffix': 'm', 'scale': 1.0, 'num': 0},
            'kilometer':  {'suffix': 'km', 'scale': 1000.0, 'num': 1},
            'centimeter': {'suffix': 'cm', 'scale': 0.01, 'num': 2},
            'millimeter': {'suffix': 'mm', 'scale': 0.001, 'num': 3},
            'micrometer': {'suffix': 'um', 'scale': 0.000001, 'num': 4},
            'nanometer':  {'suffix': 'nm', 'scale': 0.000000001, 'num': 5},
            'inch': {'suffix': 'in', 'scale': 0.0254, 'num': 6},
            'foot': {'suffix': 'ft', 'scale': 0.3048, 'num': 7},
            'yard': {'suffix': 'yd', 'scale': 0.9144, 'num': 8},
            'mile': {'suffix': 'mi', 'scale': 1609.34, 'num': 9},
            'nautical_mile': {'suffix': 'M', 'suffix2': 'NM', 'scale': 1852, 'num': 10},
          },
        },
        'mass': {
          'index': 1,
          'si': 'kilogram',
          'quantity': 'm',
          'dim': 'M',
          'units': {
            'kilogram': {'suffix': 'kg', 'scale': 1.0, 'num': 0},
            'gram': {'suffix': 'g', 'scale': 0.001, 'num': 1},
            'milligram': {'suffix': 'mg', 'scale': 0.000001, 'num': 2},
            'microgram': {'suffix': 'ug', 'scale': 0.000000001, 'num': 3},
            'tonne': {'aliases': ['metric_ton'], 'suffix': 't', 'scale': 1000.0, 'num': 4},
            'long_ton': {'aliases': ['imperial_ton'], 'suffix': 'longton', 'scale': 1016.05, 'num': 5},
            'ton': {'aliases': ['us_ton'], 'suffix': 'ton', 'scale': 907.185, 'num': 6},
            'pound': {'suffix': 'lb', 'scale': 0.453592, 'num': 7},
            'ounce': {'suffix': 'oz', 'scale': 0.0283495, 'num': 8},
            'stone': {'suffix': 'st', 'scale': 6.35029, 'num': 9},
          },
        },
        'time': {
          'index': 2,
          'si': 'second',
          'quantity': 't',
          'dim': 'T',
          'units': {
            'second': {'suffix': 's', 'scale': 1.0, 'num': 0},
            'millisecond': {'suffix': 'ms', 'scale': 0.001, 'num': 1},
            'microsecond': {'suffix': 'us', 'scale': 0.000001, 'num': 2},
            'nanosecond':  {'suffix': 'ns', 'scale': 0.000000001, 'num': 3},
            'minute': {'suffix': 'min', 'scale': 60.0, 'num': 4},
            'hour': {'suffix': 'hr', 'scale': 3600.0, 'num': 5},
            'day': {'suffix': 'dy', 'scale': 86400.0, 'num': 6},
            'week': {'suffix': 'wk', 'scale': 604800.0, 'num': 7},
          },
        },
        'current': {
          'index': 3,
          'si': 'ampere',
          'quantity': 'I',
          'dim': 'I',
          'units': {
            /# https://en.wikipedia.org/wiki/Ampere
            'ampere': {'suffix': 'A', 'scale': 1.0, 'num': 0},
          },
        },
        'temperature': {
          'index': 4,
          'si': 'kelvin',
          'quantity': 'T',
          'dim': 'O',  # TODO(wmh): Theta, not O.
          'units': {
            'kelvin': {'suffix': 'K', 'scale': 0.0, 'num': 0},
            'celsius': {
              'suffix': 'C',
              'scale': 0.0,
              /#'to': lambda v: v + 273.15,
              /#'from': lambda v: v - 273.15,
              'num': 1,
            },
            'fahrenheit': {
              'suffix': 'F',
              'scale': 0.0,
              /#'to': lambda v: (v + 459.67) * (5.0/9.0),
              /#'from': lambda v: (v * 1.8) - 459.67,
              'num': 2,
            },
          },
        },
        'amount': {
          'index': 5,
          'si': 'mole',
          'quantity': 'n',
          'dim': 'N',
          'units': {
            'mole': {'suffix': 'mol', 'scale': 1.0, 'num': 0},
          },
        },
        'intensity': {
          'index': 6,
          'si': 'candela',
          'quantity': 'Iv',
          'dim': 'J',
          'units': {
            /# https://en.wikipedia.org/wiki/Candela
            'candela': {'suffix': 'cd', 'scale': 1.0, 'num': 0},
          },
        },

        /# Not parted of the SI standard.
        'bit': {
          'index': 7,
          'si': 'bit',
          'quantity': '',
          'dim': 'B',
          'units': {
            'bit': {'suffix': 'bits', 'scale': 1.0, 'num': 0},
            'byte': {'suffix': 'B', 'scale': 8.0, 'num': 1},
          },
        },
      })

      /# Initialize PowerMap
      /#   If we use k bits to represent each power, we can represent (2^k)-1
      /#   numbers. To represent both positive and negative numbers we want to
      /#   have 0 be represented by 2^(k-1). Thus, if k = 6, a power of 0 is
      /#   represented by 2^5 = 32. A bitstream that encodes 7 chunks of 6 bits
      /#   in which each chunk has conceptual value 0 means we need bit stream
      /#   100000100000100000100000100000100000100000 which is 0x20820820820 in
      /#   hex. The following initializes PowerMap with the appropriate integer
      /#   values to initialize N chunks of P bits, keyed by P (where N is
      /#   len(BaseDimensions)
      powermap = {}
      numdim = len(cls.Dimensions())
      for P in range(2, 8):
        bstr = '1' + '0' * (P-1)
        bitstr = bstr * numdim
        intval = int(bitstr, 2)
        powermap[P] = intval
      cls.PowerMap = powermap

      /# ZeroPowers is an int64 representing a powers value of all zeros.
      cls.ZeroPowers = powermap[cls.PowerBits()]

      cls.DerivedUnits = {
        /# https://en.wikipedia.org/wiki/SI_derived_unit
        /# Name      Sym. Quantity                 Equivalents    base unit
        /# hertz     Hz   frequency                1/s            s-1
        /# radian    rad  angle                    m/m            1
        /# steradian sr   solid angle              m2/m2          1
        /# newton    N    force, weight            kg*m/s2        kg*m*s−2
        /# pascal    Pa   pressure, stress         N/m2           kg*m−1*s−2
        /# joule     J    energy, work, heat       N*m;C*V;W*s    kg*m2*s−2
        /# watt      W    power,radiant flux       J/s;V*A        kg*m2*s−3
        /# coulomb   C    electric charge          s*A;F*V        s*A
        /#                quantity of electricity
        /# volt      V    voltage                  W/A;J/C        kg*m2*s−3*A−1
        /#                electrical pot. diff.
        /#                electromotive force
        /# farad     F    electrical capacitance   C/V;s/Ω        kg−1*m−2*s4*A2
        /# ohm       Ω    electrical resistance    1/S;V/A        kg*m2*s−3*A−2
        /#                impedance, reactance
        /# siemens   S    electrical conductance   1/Ω;A/V        kg−1*m−2*s3*A2
        /# weber     Wb   magnetic flux            J/A;T*m2       kg*m2*s−2*A−1
        /# tesla     T    magnetic field strength  V*s/m2;Wb/m2   kg*s−2*A−1
        /#                magnetic flux density    ;N/(A*m)
        /# henry     H    electrical inductance    V*s/A;Ω*s;Wb/A kg*m2*s−2*A−2
        /# degree C  °C   temp rel. to 273.15 K    K              K
        /# lumen     lm   luminous flux            cd*sr          cd
        /# lux       lx   illuminance              lm/m2          m−2*cd
        /# becquerel Bq   radioactivity            1/s            s−1
        /#                (decays per unit time)
        /# gray      Gy   absorbed dose            J/kg           m2*s−2
        /#                (of ionizing radiation)
        /# sievert   Sv   equivalent dose          J/kg           m2*s−2
        /#                (of ionizing radiation)
        /# katal     kat  catalytic activity       mol/s          s−1*mol
        'frequency': {
          'si': 'hertz',
          'powers': {'s': -1},
          'units': {
            'hertz': {'suffix': 'Hz', 'scale': 1.0, 'num': 0},
          }
        },
        'angle': {
          'si': 'radian',
          'powers': {},
          'units': {
            'radian': {'suffix': 'rad', 'scale': 1.0, 'num': 0},
            'degree': {'suffix': 'o', 'suffix2': 'degs', 'scale': 0.0174533, 'num': 1},
            'gradian': {'suffix': 'gon', 'scale': 0.015708, 'num': 2},
            'milliradian': {'suffix': 'mil', 'scale': 0.001, 'num': 3},
            'arc_minute': {'suffix': "\'", 'suffix2': 'arcmin', 'scale': 0.000290888, 'num': 4},
            'arc_second': {'suffix': '\"', 'suffix2': 'arcsec', 'scale': 4.84813681e-6, 'num': 5},
          },
        },
        'force': {
          'si': 'newton',
          'powers': {'kg': 1, 'm': 1, 's': -2},
          'units': {
            'newton': {'suffix': 'N', 'scale': 1.0, 'num': 0},
          },
        },
      }

      /# Verify some invariants and create unitmap
      unitmap = {}
      num_units = 2 ** cls.UnitBits()
      items = list(cls.Dimensions().items())
      items.extend(cls.DerivedUnits.items())
      for dimension, data in items:
        data['name'] = dimension
        /# There must be a units key in data.
        units = data['units']
        /# There will be an index for base dimensions, but not for derived units
        /# (and a powers for derived units but not for base dimensions).
        index = data.get('index', None)
        powers = data.get('powers', None)
        /# There must be an si value, which must exist in units with num 0.
        si = data['si']
        siunit = units[si]
        num = siunit['num']
        assert num == 0, 'dimension %s has si %s and unitnum %d != 0' % (dimension, si, num)
        /# There must be no more than num_units units.
        assert len(units) <= num_units, 'dimension %s has %d units > max %d' % (dimension, len(units), num_units)

        /# Iterate over units.
        /#  - add some additional keys ('unit' and 'dimension')
        /#  - register each unit in unitmap with various keys, ensuring uniqueness.
        for unit, kdata in units.items():
          kdata['dimension'] = dimension
          kdata['unit'] = unit
          if index is not None:
            kdata['index'] = index
          if powers is not None:
            kdata['powers'] = powers
          suffix = kdata['suffix']
          suffix2 = kdata.get('suffix2', None)
          keys = [unit, suffix]
          if suffix2:
            keys.append(suffix2)
          aliases = kdata.get('aliases', None)
          if aliases:
            keys.extend(aliases)
          for key in keys:
            if key is not None:
              existing = unitmap.get(key, None)
              if existing and kdata is not existing:
                raise Error(
                  'Found conflict for %s:\n%s vs\n%s' %
                  (key, existing, kdata))
              unitmap[key] = kdata
        /# We also allow one to specify a unit by the generic dimension name.
        unitmap[dimension] = siunit
      /# We add a special None unitmap to support "no unit".
      unitmap[None] = {'unit': None, 'num': 0, 'power': 0}

      /# Debuggging
      if False:
        for key in sorted(unitmap):
          unitdata = unitmap[key]
          print('%-20s = %s' % (key, unitdata.get('suffix', None)))

      cls.UnitMap = unitmap

      /# Parsing this implicitly breaks WAE code, which does not yet contain
      /# a copy of /usr/share/misc/units.lib.
      /# cls.ParseUnits()
    clinit:
      cls.ReIs(re.compile(
        /# The numeric part (significant notation allowed, and can be empty).
        r'([0-9]*(?:\.\d+)?(?:e[+-]?\d+)?)'
        /# The base unit part (optional)
        /#  - We could improve this by enumerating all the legal units, but that
        /#    would produce a more inefficient regexp
        /#  - we do not allow '*' or '/' because they are "unit operators" that
        /#    can appear in the separators between units.
        r'([^\d\s^*/]+)?'
        /# The unit power part (optional)
        r'(?:\^(-?\d+))?'
      ))


      cls.UnicodeIs({
        1: '\u00b9',
        2: '\u00b2',
        3: '\u00b3',
        4: '\u2074',
        5: '\u2075',
        6: '\2076',
        7: '\2077',
        8: '\2078',
        9: '\2079',
        0: '\2070',
        -1: '\u207b\u00b9',
        -2: '\u207b\u00b2',
        -3: '\u207b\u00b3',
        -4: '\u207b\u2074',
        -5: '\u207b\u2075',
        -6: '\u207b\2076',
        -7: '\u207b\2077',
        -8: '\u207b\2078',
        -9: '\u207b\2079',
        'times': '\u00b7',
      })

      cls.StrIs({
        1: '',
        2: '^2',
        3: '^3',
        4: '^4',
        5: '^5',
        6: '^6',
        7: '^7',
        8: '^8',
        9: '^9',
        0: '^0',
        -1: '^-1',
        -2: '^-2',
        -3: '^-3',
        -4: '^-4',
        -5: '^-5',
        -6: '^-6',
        -7: '^-7',
        -8: '^-8',
        -9: '^-9',
        'times': '*',
      })

      cls.Subclasses = None
    end;

    method clone : Quantity #:
      Create a new instance of this quantity.
    scope:
      return self.__class__(self.value(), self.powers())
    test:
      res = test.q1.clone()
    end method clone;

    method subclone : metax.units.Quantity #:
      Create an instance of a subclass based on powers that copies self.

      Returns:
        An instance of a subclass if a subclass matching self.units() exists,
        else null.
    scope:
      cls = self.__class__
      subclasses = cls.Subclasses
      if subclasses is None:
        subclasses = {
          'm': Length,
          'kg': Mass,
          /# TODO(wmh): Add all other subclasses here!  Keys are the
          /# result of quantity.units().
        }
        cls.Subclasses = subclasses
      units = self.units()
      subclass = subclasses.get(units, None)
      if subclass:
        result = subclass(self.value())
        assert result.powers() == self.powers()
      else:
        /# logging.warning('Failed to subclone %s %s', cls.__name__, self)
        result = None
      return result
    test:
      res = test.q1.subclone()
      test.issame(metax.units.Length, res.meta())
      test.isapprox(7.5, res.value())
      q2 = metax.units.Quantity.New('20kg')
      res2 = q2.subclone()
      test.issame(metax.units.Mass, res2.meta())
      test.isapprox(20.0, res2.value())

      /# A quantity that doesn't have an associated subclass.
      q3 = metax.units.Quantity.New('15s')
      res3 = q3.subclone()
      test.isnull(res3)
    end method subclone;

    method __str__ : str #:
      Obtain the printable representation of this quantity.
    scope:
      return self.asStr()
    test:
      test.iseq(' 7.50000 m', str(test.q1))
    end method __str__;

    method asStr : any #:
      docstr
    params:
      var units : map = null #:
        If specified, indicates for some subset of units which unit to use.
      var precision : int = -1 #:
        How many digits after decimal to print.  If -1, a default is used
        depending on digits.
      var digits : int = -1 #:
        How many significant digits to use.  If -1, a default is used depending
        on whether precision is specified.
      var width : int = -1 #:
        How many digits to use to represent the numeric portion.
      var unicode : bool = false #:
        If true, express result in unicde.
    scope:
      form = u'%8.5f'
      suffix = self.units(units=units, unicode=unicode)
      value = self.value()
      result = (form % value)
      if suffix:
        result += ' ' + suffix
      return result
    test:
      test.iseq(' 7.50000 m', test.q1.asStr())
      test.iseq(' 1.88976 m', test.q2.asStr())
      test.iseq(' 3.00000 m*s^-1', test.q3.asStr())
      test.iseq(' 3.00000 m\u00b7s\u207b\u00b9', test.q3.asStr(unicode=True))
      test.iseq(' 6.00000 m*s^-1', test.q4.asStr())
      test.iseq(' 2.00000', test.q5.asStr())
      test.iseq(' 0.33333 s^-1', test.q6.asStr())
    end method asStr;

    method units : basestring #:
      Return back the units (as a str or unicode) for this quantity.
    params:
      var units : map = null #:
        If specified, indicates for some subset of units which unit to use.
      var unicode : bool = false #:
        If true, return unicode, else str.
    scope:
      if units is None:
        units = {}
      cls = self.__class__
      PowerBits = cls.PowerBits()
      HalfPB = 1 << (PowerBits-1)
      mask = (1 << PowerBits) - 1
      dimensions = cls.Dimensions()
      powers = self.powers()
      suffixes = []
      cmap = cls.Unicode() if unicode else cls.Str()
      times_char = cmap['times']
      for dimension_data in sorted(
        dimensions.values(), key=lambda unit: unit['index']
      ):
        start = PowerBits * dimension_data['index']
        power = int(((powers >> start) & mask) - HalfPB)
        if power:
          udata = dimension_data['units'][dimension_data['si']]
          suffix = udata['suffix']
          if power != 1:
            suffix += cmap[power]
          suffixes.append(suffix)
      return times_char.join(suffixes)
    test:
      test.iseq('m', test.q1.units())
      test.iseq('m*s^-1', test.q3.units())
      test.iseq('m\u00b7s\u207b\u00b9', test.q3.units(unicode=True))
    end method units;

    method __add__ : Quantity #:
      Return a new Quantity produced by adding self and other
    params:
      var other : Quantity;
    scope:
      if self.powers() != other.powers():
        raise TypeError(
          'Cannot add %s and %s' % 
          (self.asStr(unicode=True), other.asStr(unicode=True)))
      return Quantity(self.value() + other.value(), self.powers())
    test:
      q = test.q1 + test.q2
      test.iseq(' 9.38976 m', q.asStr())
      test.raises(TypeError, test.q1.__add__, test.q6)
    end method __add__;

    method plus : Quantity #:
      Modify self by adding other, returning self.
    params:
      var other : Quantity;
    scope:
      if self.powers() != other.powers():
        raise TypeError(
          'Cannot add %s and %s' % 
          (self.asStr(unicode=True), other.asStr(unicode=True)))
      self._value += other.value()
      return self
    test:
      q = test.q1
      q.plus(test.q2)
      test.iseq(' 9.38976 m', q.asStr())
      test.raises(TypeError, test.q1.plus, test.q6)
    end method plus;

    method __iadd__ : Quantity #:
      Modify self by adding other
    params:
      var other : Quantity;
    scope:
      return self.plus(other)
    test:
      q = test.q1
      q += test.q2
      test.iseq(' 9.38976 m', q.asStr())
      test.raises(TypeError, test.q1.__iadd__, test.q6)
    end method __iadd__;

    method __sub__ : Quantity #:
      Return a new Quantity produced by subtracting other from self
    params:
      var other : Quantity;
    scope:
      if self.powers() != other.powers():
        raise TypeError(
          'Cannot subtract %s from %s' % 
          (other.asStr(unicode=True), self.asStr(unicode=True)))
      return Quantity(self.value() - other.value(), self.powers())
    test:
      q = test.q1 - test.q2
      test.iseq(' 5.61024 m', q.asStr())
      test.raises(TypeError, test.q1.__add__, test.q6)
    end method __sub__;

    method minus : Quantity #:
      Modify self by subtracting other, returning self.
    params:
      var other : Quantity;
    scope:
      if self.powers() != other.powers():
        raise TypeError(
          'Cannot subtract %s from %s' % 
          (other.asStr(unicode=True), self.asStr(unicode=True)))
      self._value -= other.value()
      return self
    test:
      q = test.q1
      q.minus(test.q2)
      test.iseq(' 5.61024 m', q.asStr())
      test.raises(TypeError, test.q1.__sub__, test.q6)
    end method minus;

    method __isub__ : Quantity #:
      Modify self by subtracting other
    params:
      var other : Quantity;
    scope:
      return self.minus(other)
    test:
      q = test.q1
      q -= test.q2
      test.iseq(' 5.61024 m', q.asStr())
      test.raises(TypeError, test.q1.__sub__, test.q6)
    end method __isub__;

    method __mul__ : Quantity #:
      Return a new Quantity produced by multiplying self and other.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope:
      cls = self.__class__
      if isinstance(other, (int, float)):
        result = self.clone()
        result._value *= other
      else:
        powers = cls.AddDimensionEncodings(self.powers(), other.powers())
        result = Quantity(self.value() * other.value(), powers)
      return result
    test:
      /# Multiply by another quantity.
      res = test.q1 * test.q6
      test.iseq(' 2.50000 m*s^-1', res.asStr())

      /# Multiple by scalar.
      res2 = test.q1 * 2
      test.iseq('15.00000 m', res2.asStr())
    end method __mul__;

    method times : Quantity #:
      Modify self by multiplying by other. Returns self.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope:
      cls = self.__class__
      if isinstance(other, (int, float)):
        self._value *= other
      else:
        powers = cls.AddDimensionEncodings(self.powers(), other.powers())
        self._value *= other.value()
        self.powersIs(powers)
      return self
    test:
      q = test.q1
      q.times(test.q6)
      test.iseq(' 2.50000 m*s^-1', test.q1.asStr())

      /# We verify that q.times(q) properly squares value and increments power.
      q = metax.units.Quantity.New('2.5m')
      q.times(q)
      test.iseq(' 6.25000 m^2', q.asStr())

      /# Multiple by int and float scalars.
      q.times(2)
      q.times(1.5)
      test.iseq('18.75000 m^2', q.asStr())
    end method times;

    method __imul__ : Quantity #:
      Modify self by multiplying by other.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope:
      return self.times(other)
    test:
      test.q1 *= test.q6
      test.iseq(' 2.50000 m*s^-1', test.q1.asStr())
    end method __imul__;

    method __div__ : Quantity #:
      Return a new Quantity produced by multiplying self and other.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope:
      cls = self.__class__
      if isinstance(other, (int, float)):
        result = self.clone()
        result._value /= other
      else:
        powers = cls.AddDimensionEncodings(
          self.powers(), other.powers(), negate=True)
        result = Quantity(self.value() / other.value(), powers)
      return result
    test:
      q = metax.units.Quantity.New('3s')
      res = test.q1 / q
      test.iseq(' 2.50000 m*s^-1', res.asStr())

      /# Divide by int/float scalars.
      res2 = test.q1 / 2
      test.iseq(' 3.75000 m', res2.asStr())
      res3 = res2 / 0.5
      test.iseq(' 7.50000 m', res3.asStr())
    end method __div__;

    method divideby : Quantity #:
      Modify self by dividing by other. Returns self.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope:
      cls = self.__class__
      if isinstance(other, (int, float)):
        self._value /= other
      else:
        powers = cls.AddDimensionEncodings(
          self.powers(), other.powers(), negate=True)
        self._value /= other.value()
        self.powersIs(powers)
      return self
    test:
      newq = metax.units.Quantity.New('3s')
      q = test.q1
      q.divideby(newq)
      test.iseq(' 2.50000 m*s^-1', q.asStr())

      /# Divide by scalars.
      q = metax.units.Quantity.New('5.2m')
      q.divideby(2)
      q.divideby(1.5)
      test.iseq(' 1.73333 m', q.asStr())
    end method divideby;

    method __idiv__ : Quantity #:
      Modify self by dividing by other.
    params:
      var other : any #:
        Either Quantity or scalar.
    scope:
      return self.divideby(other)
    test:
      newq = metax.units.Quantity.New('3s')
      test.q1 /= newq
      test.iseq(' 2.50000 m*s^-1', test.q1.asStr())
    end method __idiv__;

    implicit
    command wunits #:
      Wade's units.
    scope:
      for line in cli.rest:
        q = Quantity.New(line)
        print('%-40s = %s' % (line, q.asStr()))
    end command wunits;

    test
    lifecycle setup:
      Quantity = metax.units.Quantity
      DE = metax.units.Quantity.DimensionEncoding
      test.q1 = Quantity(7.5, DE({'length': 1}))
      test.q2 = Quantity.New('6.2ft')
      test.q3 = Quantity.New('6m / 2s')
      test.q4 = Quantity.New('6m / s')
      test.q5 = Quantity.New('2')
      test.q6 = Quantity.New('1 / 3s')
    end;

    test
    method test_v1 scope:
      Quantity = metax.units.Quantity
      /# TODO(wmh): Fix temperature (deleted 'to' and 'from' ... need better
      /# solution).
      /#q = Quantity.New('273.15C')
      /# print(q)

  end class Quantity;

  class FixedDimensionQuantity < Quantity #:
    An abstract superclass of subclasses of Quantity whose powers() field
    is fixed.
  scope:

    meta
    field Powers : int<64> #:
      This is initialized by each subclass to a constant representing the
      encoded constant powers() value of all instances.

    superx
    lifecycle params:
      var value : double;
    scope:
      super(FixedDimensionQuantity, self).__init__(value, self.__class__.Powers())

  end class FixedDimensionQuantity;

  class Length < FixedDimensionQuantity ::
    meta
    lifecycle scope:
      cls.PowersIs(Quantity.DimensionEncoding({'length': 1}))

    test method testx_basics scope:
      test.iseq(' 7.50000 m', test.l1.asStr())
    test lifecycle setup:
      test.l1 = metax.units.Length(7.5)
  end class Length;

  class Mass < FixedDimensionQuantity ::
    meta
    lifecycle scope:
      cls.PowersIs(Quantity.DimensionEncoding({'mass': 1}))
    test method testx_basics scope:
      test.iseq(' 7.50000 kg', test.l1.asStr())
    test lifecycle setup:
      test.l1 = metax.units.Mass(7.5)
  end class Mass;

  class NonSIQuantity #:
    A unit in non-SI terms.
  scope:
    field si : Quantity #:
      The quantity expressed in SI units.
    field units : int #:
      An encoding of the non-si units to express the value in.

    lifecycle #:
      NonSIQuantity instances are not usually created manually, but rather returned
      by Quantity.New when non-si units are used.
    params:
      var si -> si;
      var units -> units;
    scope:
    end;

  end class NonSIQuantity;

end namespace metax.units;