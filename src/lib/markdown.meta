namespace metax.lib.markdown #:
  Classes related to parsing and converting Wade's Markdown, an extension
  of the official markdown syntax.

  Hierarchy
    Book
    Parser
    Object
      HR
      Block
        Paragraph
        Quote
        List
        Code
        HTML
        Table
        Row
        Panel
        BlockGroup
          ListItem
          Section

  Markdown descriptions:
    Basics:
      https://www.markdownguide.org/basic-syntax/
      https://daringfireball.net/projects/markdown/syntax
    Extended:
      https://www.markdownguide.org/extended-syntax/
      https://guides.github.com/features/mastering-markdown/

  Planned extensions (of my own)
   - The syntax {text} is an indication that 'text' should be surrounded
     with HTML markup (usually <span> or <code>, etc.) with some set of
     classes.
   - At the bottom of the markdown file, one can specify mappings for
     text block with the syntax:
      {regexp}: <code class=\"...\">
      {regexp}: <span class=\"...\">

  | Concept   | Sub      | How                       | Orig | GFM | PHP  | WMD  |
  | --------  | ---      | ---                       | :-:  | :-: | :-:- | :-:  |
  | Paragraph |          | separate with empty line  | Y    | Y   | Y    | Y    |
  | Style     | text     | {text}[css]               | N    | N   | N    | TODO |
  | Emphasis  | italic   | *i*   _i_                 | Y    | Y   | Y    | Y    |
  |           | bold     | **b** __b__               | Y    | Y   | Y    | Y    |
  | Link      | inline   | [text](url \"title\")     | Y    | Y   | Y    | TODO |
  |           | ref      | [title][name]             | Y    | Y   | Y    | TODO |
  |           |          | [name]: url \"title\"     | .    | .   | .    | .    |
  | Image     | inline   | ![alt](url \"title\")     | Y    | Y   | Y    | TODO |
  |           | ref      | ![alt][name]              | Y    | Y   | Y    | TODO |
  |           |          | [name]: url \"title\"     | .    | .   | .    | .    |
  |           | linked   | [![title](imgurl)](url)]  | Y    | Y   | Y    | TODO |
  | Footnote  |          | [^name]                   | ?    | ?   | Y    | TODO |
  |           |          | [^name]: text             | .    | .   | .    | TODO |
  | Line      | breaks   | end line with 2+ spaces   | Y    | ?   | N    | TODO |
  | Lists     | bullet   | * item                    | Y    | Y   | Y    | Y    |
  |           |          | - item                    | Y    | Y   | Y    | Y    |
  |           | numbered | 1. item                   | Y    | Y   | Y    | Y    |
  |           | defn     | text                      |      |     | Y    | TODO |
  |           |          | : text                    | .    | .   | .    | .    |
  | Block     | quote    | > quoted text             | Y    | Y   | Y    | Y    |
  |           | code     | ```[lang]                 | Y    | Y   | Y    | Y    |
  |           |          | text                      | .    | .   | .    | .    |
  |           |          | ```                       | .    | .   | .    | .    |
  | HTML      |          | Insert as-is              | Y    | ?   | ?    | Y    |
  | Preformat |          | start line with 4+ spaces | Y    | Y   | Y(2) | Y    |
  | Code      |          | `text`                    | Y    | Y   | Y    | TODO |
  | Headers   | level 1  | # text                    | Y    | Y   | Y    | Y    |
  |           |          | ======                    | Y    | ?   | ?    | TODO |
  |           | level 2  | ## text                   | Y    | Y   | Y    | Y    |
  |           |          | ------                    | Y    | ?   | ?    | TODO |
  |           | level 3  | ### text                  | Y    | Y   | Y    | Y    |
  |           | level 4  | #### text                 | Y    | Y   | Y    | Y    |
  |           | level 5  | ##### text                | Y    | Y   | Y    | Y    |
  |           | level 6  | ###### text               | Y    | Y   | Y    | Y    |
  | Abbrevs   |          | *[abbrev]: text           | ?    | ?   | Y    | TODO |

  Where
    - text: what is visible in HTML
    - url: a URL (relative or absolute)
    - title: appears when one hovers over the entity in HTML
    - alt: makes images accessible to visually impaired
    - name: a symbolic reference defined at bottom of file.
    - css: a list of comma separate CSS class names.

scope:

  class Error < metax.root.Error;

  class Parser #:
    A parser for wmh-flavored markdown.
  assocs:
    std assoc time #:
      Needed to support --countinvocations (must auto-import in Meta so we don't
      have to do this!)
    std assoc io;
    std assoc os;
    std usertest assoc pprint;
    usertest std assoc re;
    std assoc sys #:
      TODO(wmh): When one uses ostream or out (for example), there
      is an implicit dependency on 'sys' in python. How do we automatically
      include these assocs when needed, but not otherwise?
    cls usertest assoc metax.io.Sink;
  scope:

    meta
    field ListRe : regexp;

    field book : Book #:
      A Book instance to register info with.
      May be null, in which case info not registered.

    field labels : @map #:
      A mapping from label name to maps containing:
        url: str
          The url associated with the label.
        title: str
          The (optional) title associated with the label.

    field quiet : bool #:
      If true, certain warnings are not reported
       - Line <l>: Ignoring special <kind> semantics because it is not preceeded by blank line: ...

    lifecycle params:
      var quiet -> quiet = false;
    scope:
    clinit:
      /# We time the code in each 'kind' below, but only if this code was
      /# compiled with --countinstances on.
      cli = metax.root.MetaObject.CLI()
      if not cli:
        /# TODO(wmh): Meta should be generating code for this automatically!
        if False:
          print(
            "***** metax.root.MetaObject.CLI() not initialized. Invoke\n"
            "  metax.c.Compiler.Bootstrap(['metac', 'test']) to support!")
        dotimes = False
      else:
        dotimes = cli.countinstances
      cls.DoTimes = dotimes

      cls.SectionRe = re.compile(r'^(?P<hash>#{1,6})\s*(?P<title>.*)')

      cls.ListReIs(re.compile(
        r'^(?P<indent> {0,3})'
        r'(?:(?P<ul>[+*-])|(?P<ol>\d+)\.)'
        r'(?P<postdent>\s+)'
        r'(?P<text>.*)'))

      cls.CATEGORIES = [
        /# Each of these is (name, regexp, needs_new_block)
        ('empty', re.compile(r'^\s*$'), False),
        ('html', re.compile(r'^<(?P<tag>[a-zA-Z0-9]+)[ >]'), True),
        ('section', re.compile(r'^(?P<hash>#{1,6})\s*(?P<title>.*)'), True),
        /# CODETANGLE(quote): see cls.Block_quote_re below which must match
        ('quote', re.compile(r'^>(?: |$)'), False),
        ('code', re.compile(r'^    '), True),
        ('code', re.compile(r'^(?P<code>[`~]{3,})\s*(?P<lang>\S+)?'), True),
        ('table', re.compile(r'^Table:'), True),
        ('panel', re.compile(r'^Panel:'), True),
        ('hr', re.compile(r'^\s*([*+-] ?){3,}\s*$'), False),
        ('label', re.compile(
          r'^\s*\[(?P<label>[^ \t\]]+)\]:\s*(?P<url>\S+)'
          r'(?:\s*\"(?P<title>[^\"]*)\")?'), False),
        ('list', cls.ListRe(), None),
        /# TODO(wmh): Consider allow whitespace before the  to support
        /# pagebreaks inside code blocks (indented 4 spaces), etc.
        ('page', re.compile(r'^\{(?P<page>[ivx0-9]+)\}'), False),
        ('newcol', re.compile(r'^'), False),
        ('comment', re.compile(r'^\s*/\#\s*(?P<comment>.*)'), False),
        /# ('eof', re.compile(r'^__EOF__$'), False),
      ]
      cls.CATMAP = {trip[0]: trip[1] for trip in cls.CATEGORIES}

      /# A line representing a table row.
      cls.Table_row_re = re.compile(r'^\s*\|')
      /# A line representing a post-table abbrev
      cls.Table_abbrev_re = re.compile(r'^\s*\=\s*(?P<abbrev>[^=]*[^=\s])\s*=\s*(?P<title>.*\S)')
      /# A line representing a post-table note
      cls.Table_note_re = re.compile(r'^\s*(?P<mark>[*â€ ]+)\s+(?P<note>.*\S)')

      /# When an html block ends.
      cls.Html_end_re = re.compile(r'^</(?P<tag>[a-zA-Z0-9]+)>')

      /# When we are in a block quote
      /#  - CODETANGLE(quote): see 'quote' in CATEGORIES above, which must match
      cls.Block_quote_re = re.compile(r'^>(?: |$)')

      /# A line representing a panel line
      cls.Panel_re = re.compile(r'^(\s{4,}|$)(.*)')

      cls.Code_re = re.compile(r'^(    |$)')

      cls.Amp_re = re.compile('&(?:(?P<html>[a-zA-Z]+;))?')

      cls.Urlkey_re = re.compile(r'(?P<key><<<URLKEY\d+>>>)')

      cls.Delim_re = re.compile(r'\s*(?:\||-\+)\s*')

      cls.Abbrev_re = re.compile(r'(?P<title>.*\S)\s*\[=(?P<abbrev>.*)\]\s*$')

      cls.Mark_re = re.compile(r'^(?P<mark>\s*\* |\s*\d+\. )\S')

      cls.RomanNumeral = {
        'i'     : 1,
        'ii'    : 2,
        'iii'   : 3,
        'iv'    : 4,
        'v'     : 5,
        'vi'    : 6,
        'vii'   : 7,
        'viii'  : 8,
        'ix'    : 9,
        'x'     : 10,
        'xi'    : 11,
        'xii'   : 12,
        'xiii'  : 13,
        'xiv'   : 14,
        'xv'    : 15,
        'xvi'   : 16,
        'xvii'  : 17,
        'xviii' : 18,
        'xix'   : 19,
        'xx'    : 20,
      }

      cls.KaplanIds = []
    end lifecycle;

    method registerLabel : void #:
      Add a new label to the parser.
    params:
      var label : str;
      var url : str;
      var title : str = null;
    scope:
      data = {'url': url}
      if title:
        data['title'] = title
      self._labels[label] = data
    test:
      parser = test.md
      test.iseq({}, parser.labels())
      parser.registerLabel('label', 'http://metaxy.org', title='metaxy')
      test.iseq(
        {'label': {'url': 'http://metaxy.org', 'title': 'metaxy'}},
        parser.labels())
    end method registerLabel;

    method clearLabels : void #:
      Clear all labels.  This allows a parser to be used in two different
      modes. In one mode, clearLabels() is invoked each time parseFile() is
      called, so that labels are file-specific.   In another mode, a parser
      can parse multiple files without clear labels, so that a book described
      in multiple files can share labels across the individual files.
    scope:
      self._labels.clear()
    test:
      parser = test.md
      parser.registerLabel('label', 'http://metaxy.org', title='metaxy')
      test.iseq(
        {'label': {'url': 'http://metaxy.org', 'title': 'metaxy'}},
        parser.labels())
      parser.clearLabels()
      test.iseq({}, parser.labels())
    end method clearLabels;

    method parseFile : Section #:
      Parse a file into a section.

      Returns:
        The Section instance containing the text from the given lines.
        This will be parent if it wasn't null, else a newly created Section.
    params:
      var path : str #:
        Path to file to parse.
      var parent : Section = null #:
        If null, a dummy parent is implicitly created. An externally created
        Section can be passed in for situations where this file is just one
        section among many within a multi-file book.
      var titlere : regexp = null #:
        If present, specifies how section titles should be massaged. See
        Parser.parseLines() for details.
      var debug : bool = false #:
        Enable debugging if true.
        TODO(wmh): Delete this param.
    scope:
      with open(path, 'r') as fp:
        lines = fp.read().replace('\t', '    ').split('\n')
      return self.parseLines(
        lines, parent=parent, path=path, debug=debug, titlere=titlere)
    test:
      simple = test.parseMarkdown(
        'simple_md', parser=metax.lib.markdown.Parser())
      fp = test.fp()
      simple.show(fp=fp)
      test.contains(
        'This document highlights some markdown features.', fp.getvalue())
    end method parseFile;

    method _advancePosition : int #:
      From a start index within a collection of lines, advance forward until
      a matching condition is/is-not true.

      Returns:
        the index at which processing stopped.
    params:
      var lines : vec<str> #:
        The lines being parsed. They should not end with a newline.
      var start : int #:
        The index within lines to start from. Testing starts at this index
        (i.e. it is checked against matcher).
      var matcher : regexp #:
        The regexp to apply to each line ... consumption stops on
        the line that first matches (or doesn't match, if reverse is True)
        this regexp (the failing line is NOT added to output).
      var reverse : bool = false #:
        If true, continue while matcher is false, and end when it is first true.
        Normally, we continue while matcher is true, and end when it is first
        false.
      var backempty : bool = false #:
        If true, once matcher finds termination index adjust it back past empty
        lines.
      var category : str = null #:
        If present, we are to print out each consumed line in a specific format
        (useful for debugging).
    scope:
      N = len(lines)
      j = start
      while j < N:
        line = lines[j]
        if reverse:
          if re.match(matcher, line):
            break
        else:
          if not re.match(matcher, line):
            break
        if category:
          /# CODETANGLE(debug_parseLines)
          ln = line[:49] + '$' if len(line) > 50 else line
          print('%4d:%-50s  %1s %s' % (j+1, ln, ' ', category))
        j += 1

      if backempty:
        while not lines[j-1]:
          j -= 1

      return j
    test:
      p = test.md
      test.iseq(3,
        p._advancePosition(
          ['here', '  abc', '  def', 'hgi'], 1, re.compile(r'^  ')))
    end method _advancePosition;

    method parseSections : vec<Section> #:
      Parse an entire file of lines
    params:
      var parent : metax.io.Section #:
        The parent section. Only null for top-level.
      var lines : vec<str> #:
        The entire list of lines in the book
      var book : Book #:
        Book being parsed (for registering tables/panels)
    scope:
      result = []
      pagenum = 1
      n = len(lines)

      /# Scan up to first non-empty non-pagenum line (which must be a secionn)
      /#  - capture initial page number
      /#  - capture prelines before section.
      start = 0
      prelines = 0
      while start < n:
        l = lines[start]
        if l:
          if l[0] == '':
            /# l is of form '{<num>}'
            assert l[-1] == '}'
            pagenum = int(l[2:-1])
            prelines = 0
          else:
            break
        else:
          /# Empty line
          prelines += 1
        start += 1
      if lines[start][0] != '#':
        raise Error(
          'Invalid input (line %d of %s): %s' %
          (start, book.name(), lines[start]))

      while start < n:
        child, start, pagenum = self.parseSection(
          parent, lines, start, pagenum, prelines, book)
        parent.addChild(child)
        result.append(child)
        /# count number of empty lines before lines[start]
        prelines = 0
        k = start - 1
        while not lines[k]:
          k -= 1
          prelines += 1
      return result
    test:
      bookpath = metax.root.Object.Resource(
        'simple_md', fqn='metax.lib.markdown_test.TestCase')

      md = metax.lib.markdown.Parser()
      with open(bookpath, 'r') as ifp:
        lines = ifp.read().split('\n')

      book = metax.lib.markdown.Book('Dummy', md, path=bookpath)
      root = metax.lib.markdown.Section(None, title='Testing', parser=md)
      sections = md.parseSections(root, lines, book)
      test.iseq(
        ['A Simple Document', 'And another top-level section'],
        [s.title() for s in sections])
      test.iseq(
        ['A Simple Document', 'And another top-level section'],
        [s.title() for s in root.children()])
    end method parseSections;

    method parseSection : tuple<Section,int,int> #:
      Parse a section into preamble and child Sections, without fully
      parsing details.

      This is a much faster parser than parseLines(), with just-in-time
      parsing of blocks when Section.blocks() is invoked.

      Returns:
       0. Section instance representing data from lines[start] onward
       1. index into lines of the section that is NOT part of the section
          returned.
       2. pagenumber at end of parsed portion
    params:
      var parent : metax.io.Section #:
        The parent section. Only null for top-level.
      var lines : vec<str> #:
        The entire list of lines in the book
      var start : int #:
        The index within lines at which the section being parsed is defined.
      var pagenum : int #:
        The page number of lines[start]
      var prelines : int #:
        The number of empty lines before the start of the section being parsed.
      var book : str #:
        Book being parsed (for debugging)
    scope:
      first = lines[start]

      if True:
        m = Parser.SectionRe.match(first)
        if not m:
          raise Error(
            'expecting "%s" (line %d of %s) to define a section' % (first, start+1, book.name()))
        depth = len(m.group('hash'))
        title = m.group('title')
      else:
        depth = first.find(' ')
        i = depth + 1
        while first[i] == ' ':
          i += 1
        title = first[i:]

      /# print('creating section "%s" with prelines %d' % (title, prelines))

      /# Create the Section instance.
      result = Section(
        parent,
        title,
        parser=self,
        prelines=prelines,
        pagenum=pagenum,
        linenum=start+1,
        /# This is initialized below!
        delayed=None)
      /# print('%5d: %s' % (result.linenum(), result.title()))

      /# We mark the blocks field as null instead of the empty list, so that we
      /# can tell when a Section has been created via Parser.parseSection (not
      /# always fully initialized) and Parser.parseLines() (always fully
      /# initialized).
      result.blocksIs(None)

      /# number of contiguous empty lines seen since last non-empty line.
      empty = 0
      delayed = None

      n = len(lines)
      i = start + 1
      while i < n:
        line = lines[i]
        /# print('%4d: %s' % (i+1, line))

        nc = len(line)
        if nc == 0:
          /# Empty line
          empty += 1
          /# print('Line %d is empty: %d' % ((i+1), empty))
        else:
          /# Non-empty line
          if line[0] == '#':
            if not delayed:
              /# We have discovered the first section *after* the section we
              /# are creating.
              /#  - we initailze result.delayed() with the information needed
              /#    to just-in-time parse blocks
              delayed = (lines, start, i)
              result.delayedIs(delayed)

            m = Parser.SectionRe.match(line)
            if not m:
              raise Error(
                'expecting sub "%s" (line %d) to define a section' % line, i+1)
            d = len(m.group('hash'))
            if d > depth:
              /# Create shams as needed
              numsham = d - depth - 1
              if numsham == 0:
                /# We have a child section that we need to recurse on.
                child, j, pagenum = self.parseSection(
                  result, lines, i, pagenum, empty, book)
              elif numsham == 1:
                /# We need to insert a sham section
                /#  - we hack this by literally inserting the sham into
                /#    lines temporarily
                /#  - we adjust various fields to match with how the non-jit
                /#    parser sets things up.
                orig_prev = lines[i-1]
                lines[i-1] = ('#' * (depth + 1)) + ' SHAM'
                child, j, pagenum = self.parseSection(
                  result, lines, i-1, pagenum, empty, book)

                /# Sham sections should have empty title ''
                child.titleIs('')

                /# Sham sections are not alloewd to have any blocks, so we can
                /# remove delayed.
                child.delayedIs(None)
                child.blocksIs([])

                /# Parser.parseLines() does not properly initialize the pagenum
                /# or linenum of sham sections, so we make this version match
                /# parseLines() for now. TODO(wmh): Fix this in both places!
                /# Ensure Parser.readBook unit test passes for both.
                child.pagenumIs(0)
                child.linenumIs(0)
                subs = child.children()
                if subs:
                  /# The first child section of 'child' needs its prelines updated.
                  subs[0].prelinesIs(empty)

                /# Reinstate original previous line
                lines[i-1] = orig_prev
              else:
                raise Error(
                  'Not supporting need for %d shams in line %d of %s' %
                  (numsham, i+1, book.name()))

              if child:
                result.addChild(child)
                /# Count emptylines before j
                prelines = 0
                while not lines[j-1]:
                  prelines += 1
                  j -= 1
                /# adjust i: so that when we add 1 below, we get back to j
                i = j - 1
              else:
                /# There is nothing more to parse
                break
            else:
              /# We have a sibling or upper section, which means we are finished
              /# parsing this section.
              break
            empty = 0
          else:
            /# Non-empty but not a section indicator
            empty = 0
            /# print('Line %d clearing empty' % (i+1))
            if line[0] == '':
              assert line[-1] == '}'
              pagenum = int(line[2:-1])

            elif nc > 6 and line[5] == ':':
              /# We want to capture Table: and Panel: lines, but we also want to
              /# have parsing be as fast as possible. Conveniently, both Table
              /# and Panel entities have an initial line in which line[5] is a
              /# colon.
              tpkind = line[0:5].lower()
              tptitle = line[7:]
              if tpkind == 'table':
                /# By storing a Section into the table map, we are indicating
                /# to the 'tablesMatching' method that just-in-time block
                /# parsing and table searching is required.
                book.tables()[tptitle] = result
              elif tpkind == 'panel':
                /# Same logic as above for table.
                book.panels()[tptitle] = result

            /# elif line == '__EOF__':
            /#   print('NOTE: Found __EOF__ on line %d' % (i+1))
            /#   i = n
            /#   break
        i += 1

      if not delayed:
        /# We have discovered the first section *after* the section we
        /# are creating.
        /#  - we initailze result.delayed() with the information needed
        /#    to just-in-time parse blocks
        delayed = (lines, start, i)
        result.delayedIs(delayed)

      return result, i, pagenum
    test:
      /###
      /# simple.md
      bookpath = metax.root.Object.Resource(
        'simple_md', fqn='metax.lib.markdown_test.TestCase')
      with open(bookpath, 'r') as ifp:
        lines = ifp.read().split('\n')
      start = 0
      while not lines[start] or lines[start][0] != '#':
        start += 1
      md = metax.lib.markdown.Parser()
      book = metax.lib.markdown.Book('Dummy', md, path=bookpath)
      pagenum = 1
      prelines = 1
      section, next, pagenum = md.parseSection(
        None, lines, start, pagenum, prelines, book)
      test.iseq('A Simple Document', section.title())
      /# test.iseq(169, next)
      test.iseq(2, pagenum)
      test.iseq(
        [
          'Blocks', 'A Second Level-2 Section', 'Titled Blocks',
          'Final thoughts',
        ],
        [child.title() for child in section.children()])

      test.iseq('/A Simple Document', section.fqn())

      /###
      /# eof.md
      if False:
        bookpath = os.path.join(__metadir__, 'testdata', 'markdown', 'eof.md')
        with open(bookpath, 'r') as ifp:
          lines = ifp.read().split('\n')
        md = metax.lib.markdown.Parser()
        book = metax.lib.markdown.Book('Dummy', md, path=bookpath)
        pagenum = 1
        prelines = 1
        start = 0
        section, next, pagenum = md.parseSection(
          None, lines, start, pagenum, prelines, book)
        test.iseq('A Document', section.title())
        test.iseq(22, next)
    end method parseSection;

    method parseLines : Section #:
      Parse a collection of lines as markdown.

      Returns:
        The Section instance containing the text from the given lines.
        This will be parent if it wasn't null, else a newly created Section.
    params:
      var lines : vec<str> #:
        The lines to parse. No trailing newlines!
      var parent : BlockGroup = null #:
        If null, a dummy parent is implicitly created. An externally created
        BlockGroup can be passed in for situations where this file is just one
        section among many within a multi-file book, or when recursively
        parsing a list item within a list.  This value is returned.
      var path : str = null #:
        The path of the file.
      var debug : bool = false #:
        Enable debugging if true.
        TODO(wmh): Delete this param.
      var illegals : vec<str> = null #:
        Some subset of the keys in Parser.CATEGORIES. Indicates which syntactic
        entities are not legal for this invocation. If null, all categories are
        legal.
      var titlere : regexp = null #:
        If present, each parsed section title is matched against this re. If a
        match occurs, one of the named groups should be 'title', and only
        the value of that match is used as the official title. This allows
        for domain-specific syntax to be added to section titles without
        requiring all of that syntax to be present in the official hierarchy.
        Example usecase is D&D, where the manuals sometimes have page numbers
        at the end of section titles starting race definitions. For example
            '# Race: Golem/Clay (Clay Golem) {MM-168}'
        should be treated simple as 'Race: Golem/Clay' when registered.
      var line_start : int = 0 #:
        Index within lines to start at
      var line_end : int = -1 #:
        Index within lines to end at (stop before it). If negative, use
        len(lines).
    scope:
      /# NOTE: This is one of the most expensive methods in this namespace,
      /# at least when parsing D&D source books. As such, I've started
      /# optmiizing various aspects of this method.

      /# The parsing logic is as follows:
      /# - parse each line one after another
      /# - at any given point, we are either 'between blocks' or 'within a
      /#   block'. A block is a contiguous collection of non-empty lines.
      /# - empty lines usually identify the end of a block.
      /# - we keep track of the number of consecutive empty lines seen (so that
      /#   we can recreate the same output as input).
      /# - if we are not currently in a block, and we see a non-empty line, the
      /#   first few characters determines what we do:
      /#    '#': parse a section header (create a new Section)
      /#         affects only the current line (but prelines reset)
      /#    '<': parse an HTML block
      /#         consume all lines up to '^>'
      /#    '> ': parse a blockquote
      /#         consume all lines starting with '>' and all non-empty
      /#         lines after last such line.
      /#    '^    ': parse a code block (consume all lines that are indented
      /#         4+ spaces. Convert &, < and > to &amp; &lt; and &gt;
      /#    '```(\S+)?': a code block in a named language (start or end)
      /#    '^Table:.*': start of table
      /#         Consume lines to end of table
      /#    '^Panel:.*': start of panel
      /#         Consume lines to end of panel
      /#    '^[*+-]{3,}$': a horizontal rule
      /#         How to support '* * *'?
      /#    '^\[\S+\]: (\S+)\s+\'(.*)\': Link label mapping
      /#         Record the mapping and pretend the line doesn't exist.
      /#    '^[*+-][ \t]': an unordered list element
      /#         consume all non-empty non-special lines
      /#    '^\d+\.[ \t]': an ordered list element
      /#         consume all non-empty non-special lines
      /#
      /# - lines fall into one of these categories
      /#   - part of a contiguous block
      /#     - paragraph
      /#     - html
      /#     - blockquote
      /#     - code
      /#     - table
      /#     - list (special)
      /#   - one liners
      /#     - hr           (adds new HR instance to group)
      /#     - label        (updates label map, treated as if doesn't exist)
      /#     - comment      (treated as if it doesn't exist)
      /#     - page         (updates page map, treated as if doesn't exist)
      /#     - new section  (new Section created)
      /#
      /# - within a paragraph:
      /#    - If '<' looks like an html reference, do not escape it, but if
      /#      it isn't an html tag, escape it (same for '>').
      /#    - Escape '&' as '&amp;' unless it is part of an html escape.
      /#    - [(.*)](\S+) --> inline link
      /#    - [(.*)][\S+] --> reference link
      /#    - convert \*[^*]\* to italics unless either \* is surrounded by
      /#      whitespace.  Same for '_'
      /#    - convert \*\*[^*]\*\* to italics unless either \*\* is surrounded by
      /#      whitespace.  Same for '__'
      /#    - convert `...` to <code>...</code>
      /#    - convert <$url> to <a href="$url">$url</a>
      /#
      /# - meta-info
      /#     {<num>} indicates a new page
      /#             indicates a new column
      cls = self.__class__
      categories = cls.CATEGORIES
      if parent is None:
        /# print('WARNING: Making implicit parent section')
        parent = metax.lib.markdown.Section(
          None, title='', parser=self, prelines=0)
      start_blocks = len(parent.blocks())
      if debug:
        print('-' * 70)
        print('Parser.parseLines(): %d lines under %s' % (len(lines), parent))

      /# Maps index within 'lines' to string describing an error.
      errors = {}

      /# A line representing a table row.
      table_row_re = Parser.Table_row_re
      table_note_re = Parser.Table_note_re
      table_abbrev_re = Parser.Table_abbrev_re
      /# When an html block ends.
      html_end_re = Parser.Html_end_re
      /# When we are in a block quote
      block_quote_re = Parser.Block_quote_re
      /# A line representing a panel line
      panel_re = Parser.Panel_re

      dotimes = Parser.DoTimes

      /# This is a debug-only function and all calls to it have been commented
      /# out in the interests of efficiency. Delete?
      def Record(pos, msg):
        """Record status of current line."""
        if debug:
          /# CODETANGLE(debug_parseLines)
          cline = lines[pos]
          ln = cline[:49] + '$' if len(cline) > 50 else cline
          print(
            '%4d:%-50s  %1s %s' %
            (pos+1, ln, ' ', msg))

      def FindEnd(lines, pos):
        """Backup past empty lines.

        Returns: tuple<int,int>
         0. one line past the end of the previous non-blank region.
            this may either be the first blank line, or line[pos+1],
            depending on whether any blank lines existing before line[pos]
         1. the number of blank lines found at/before line[pos]
        """
        prelines = 0
        while lines[pos].strip() == '':
          prelines += 1
          pos -= 1
        end = pos+1
        return end, prelines

      /# The lines making up the current block of text ... when we get to
      /# a newline, we create an appropriate Block subclass instance and
      /# reset this list.
      current_lines = []

      /# The block group within which the block being parsed will be added.
      current_group = parent

      /# How many empty lines were seen before the current list of
      /# contiguous lines.
      /#  - reset to 0 at end of loop below unless current line is empty
      prelines = 0

      /# Which line we are currently processing.
      i = line_start

      /# We are done when i reaches this value.
      N = len(lines)
      if line_end > -1:
        N = line_end
        /# print('Ending at index %d' % N)

      pagenum = 0
      iters = 0
      while i < N:
        /# Important:
        /#  - prelines is set to 0 at end of loop unless current line is empty
        /#    or keep_prelines is True.
        keep_prelines = False

        /# Obtain the current line and validate it.
        line = lines[i]
        nc = len(line)

        /# if line and line[-1] == '\n':
        /#   raise Error(
        /#     'Expecting line %d to NOT end in newline: "%s"' % (i+1, line))

        /# Establish which regexp matches
        mdata = None
        kind = None
        for nm, nmre, needs_new_block in categories:
          m = nmre.match(line)
          if m:
            if needs_new_block is None:
              /# This is a special case for the 'list' category, allowing us
              /# to conditionally determine whether an empty line is needed
              /# before the list or not depending on context.
              /#  - the original markdown spec
              /#      https://daringfireball.net/projects/markdown/syntax#list
              /#    does not clarify whether the start of a list must be
              /#    preceeded by an empty line or not, and whether this also
              /#    applies for nested lists, but in looking at the markdown
              /#    source for the markdown tutorial, it is clear that at
              /#    least sub-lists do not need to be preceeded by whitespace.
              /#  - we can offer different implementations based on whether
              /#    the parent is a Section or a ListItem, or on whether we
              /#    want to support the no-empty-line-needed usecase or not.
              /#    (since the standard requires sub-lists to handle this, we
              /#    may want to remove some of this conditionality).
              assert nm == 'list'
              /#needs_new_block = False if current_group.isListItem() else True
              needs_new_block = False

            if needs_new_block and current_lines:
              if not self.quiet():
                print(
                  'Line %4d: Ignoring special "%s" semantics because it is not '
                  'preceeded by blank line: %s' % (i+1, nm, line))
            elif illegals and nm in illegals:
              print(
                'Line %4d: %s is not legal in this context '
                '(ignoring special semantics): %s' % (i+1, nm, line))
            else:
              mdata = m.groupdict()
              kind = nm
              break

        if dotimes:
          _s = time.time_ns()

        /# We check for a variety of mutually exclusive possibilities.
        /#  - i represents the index of the current line.
        /#  - each elif block is reponsible for adjusting i so that when the
        /#    block finishes and the code loops back up to the 'while',
        /#    the next iteration is processing in the correct spot.
        if kind is None:
          /# This line does not match anything special, so we just add it to
          /# current_lines and advance.

          /# Record(i, 'default')
          if not current_lines:
            /# First line ... remember prelines
            para_prelines = prelines
          current_lines.append(line)
          i += 1

        /# elif kind == 'eof':
        /#   print('***** Here line %d EOF' % (i+1))
        /#   i = N

        elif kind == 'empty':
          /# We have an empty line:
          /#  - if we are currently parsing a text block, this ends the block
          /#    (except table titles actually start a block).
          /#  - if we are not currently parsing a block, we increment prelines
          /#    so that when the block is created we remember how many
          /#    empty lines preceeded it.
          if current_lines:

            /# We have been accumulating a block of text, and the current
            /# empty line indicates we've finished parsing it.  We create
            /# a Paragraph to contain the lines.

            with metax.root.Timer(__metafqn__, 'empty-create'):
              /# CODETANGLE(add_para): This is a repeat of the code elsewhere.

              /# Record(i, 'empty ... block is paragraph')
              para = metax.lib.markdown.Paragraph(
                current_group,
                '\n'.join(current_lines),
                prelines=para_prelines)
              current_group.addBlock(para)
              current_lines = []
              prelines = 1

          else:
            /# We are not currently processing a block, so we just advance
            /# the empty-line counter and advance to next line.

            /# Record(i, 'empty')
            prelines += 1

          /# Advance to next line
          i += 1

        elif kind == 'table':
          /# We can consume the entire table here.
          table_start = i
          assert line.startswith('Table:')
          /# We allow an optional empty line.
          if not lines[i+1].strip():
            i += 1

          i += 1

          /# Now we advance past all lines looking like table rows.
          i = self._advancePosition(
            lines, i, matcher=table_row_re, category='table' if debug else None)
          /# print(lines[i])
          /# print(table_abbrev_re.match(lines[i]))
          i = self._advancePosition(
            lines, i, matcher=table_abbrev_re, category='table' if debug else None)
          i = self._advancePosition(
            lines, i, matcher=table_note_re, category='table' if debug else None)

          /# Create the table
          terrors = []
          table = metax.lib.markdown.Table.New(
            lines[table_start:i], terrors, parent=current_group,
            prelines=prelines)
          if table:
            current_group.addTable(table)
          if terrors:
            for err in terrors:
              sys.stderr.write('  ' + err + '\n')
          else:
            current_group.addBlock(table)
            book = self.book()
            if book:
              book.registerTable(table, location=(path, table_start))

        elif kind == 'panel':
          /# We can consume the entire panel here (all lines with four spaces
          /# of indentation).
          panel_start = i
          panel_title = None
          assert line.startswith('Panel:')
          /# We allow an optional empty line.
          panel_title = line[6:].strip()
          if not lines[i+1].strip():
            i += 1
          i += 1
          block_start = i

          /# Now we advance past all lines looking like panel rows.
          i = self._advancePosition(
            lines, i,
            matcher=panel_re, category='panel' if debug else None,
            /# The panel_re needs to accept empty lines (they can appear within
            /# the panel), but we do not want it to include the empty lines
            /# after the panel before the next object, so we set backempty true.
            backempty=True,
          )

          plines = []
          for line in lines[block_start:i]:
            m = panel_re.match(line)
            text = m.group(2)
            plines.append(text)

          /# Eventually, we want to parse the contents of the panel into a
          /# collection of markdown.Object instants, but for now we just keep
          /# it a list of strings.
          if False:
            parent = metax.lib.markdown.Section(
              None, title=panel_title, parser=self, prelines=0)
            section = self.parseLines(plines, parent=parent)
          else:
            panel = metax.lib.markdown.Panel(
              current_group, plines, prelines=prelines, title=panel_title)
            current_group.addBlock(panel)
            book = self.book()
            if book:
              book.registerPanel(panel, location=(path, panel_start))

        elif kind == 'section':
          /# We have a new section.
          /#  - it may be a child of current, or it may be a sibling, or it
          /#    may be an aunt, great-aunt, etc.
          /#  - if current_group is a ListItem instead of a Section, it is
          /#    an error to specify a section.
          /#
          /# Note that if we are invoking Parser.parseLines() from within
          /# Section.blocks(), this should never be encountered (we only
          /# parse text within a section in that method).

          /# Record(i, 'section start')
          if current_group.isSection():
            title = mdata['title']
            if titlere:
              tm = titlere.match(title)
              if tm:
                tmgd = tm.groupdict()
                if 'title' not in tmgd:
                  raise Error(
                    'If titlere specified, must have named title group')
                title = tmgd.pop('title')
                /# TODO(wmh): Consider storing the rest of tmgd somewhere
                /# in the newly created sectionl

            current_group = current_group.newNextSection(
              len(mdata['hash']), title, prelines=prelines,
              pagenum=pagenum, linenum=i+1)
          else:
            /# TODO(wmh): We should never get here, because we specify
            /# illegals=['section'] in the recursive call to parseLines()
            /# when parsing lists.
            raise Error('How to handle sections within list items?')

          i += 1
          assert not current_lines

        elif kind == 'label':
          /# A mapping from conceptual name to url.
          /#  - although they usually appear when NOT currently processing
          /#    a block, the line containing a label spec is simply ignored and
          /#    has no effect on the current_lines or prelines so it can appear
          /#    while we are parsing a block without affecting its status.

          /# Record(i, 'label specification')
          self.registerLabel(mdata['label'], mdata['url'], title=mdata['title'])
          i += 1

        elif kind == 'code':
          /# We can parse the entire code block here:
          /#  - if it started with ``` or ~~~, we look for a matching line.
          /#  - if it started because the current line has 4 spaces of indentation,
          /#    consume all lines indented 4+ spaces.
          code_start = i
          if 'code' in mdata:
            /# We have a ``` or ~~~ block.

            /# Record(i, 'start of code block')

            /# note that we cannot pre-compile this re ;-(
            term_re = re.compile(r'^' + mdata['code'][:3])
            reverse = True
            code_lang = mdata['lang']
            code_start += 1
            i = self._advancePosition(
              lines, i+1, matcher=term_re, reverse=True,
              category='code' if debug else None)
            /# i is now on the line with ``` or ~~~.
            code_end = i  # one past
            /# advance past code end line.
            i += 1
            /# Should we advance past whitespace here?
            next_prelines = prelines
          else:
            /# We have an indented code block.

            /# Record(i, 'start of indented code block')
            term_re = Parser.Code_re
            code_lang = None
            i = self._advancePosition(
              lines, i+1, matcher=term_re, category='code' if debug else None)
            code_end, next_prelines = FindEnd(lines, i-1)

          code = metax.lib.markdown.Code(
            current_group, lines[code_start:code_end], prelines=prelines,
            language=code_lang)
          current_group.addBlock(code)

          prelines = next_prelines
          keep_prelines = True

        elif kind == 'html':
          /# An html block is terminated by:
          /#  - the start line being <tag>...</tag>
          /#  - finding '</tag>' at first column of a subsequent line.
          tag = mdata['tag']
          html_start = i
          if line.strip().endswith('</%s>' % tag):
            /# We have a one-line HTML block.

            /# Record(i, 'one-line HTML block')
            i += 1
          else:
            /# Record(i, 'start of HTML block')
            i = self._advancePosition(
              lines, i, matcher=html_end_re, reverse=True,
              category='html' if debug else None)
            /# i is currently on the terminating line, but that is part of the
            /# html block, so we advance one.
            i += 1

          /# Handle the html_lines
          html = metax.lib.markdown.HTML(
            current_group, lines[html_start:i], prelines=prelines)
          current_group.addBlock(html)
          assert not current_lines

        elif kind == 'quote':
          /# We have a blockquote.
          quote_start = i
          i = self._advancePosition(
            lines, i, matcher=block_quote_re,
            category='quote' if debug else None)
          quote = metax.lib.markdown.Quote(
            current_group, lines[quote_start:i], prelines=prelines)
          current_group.addBlock(quote)

        elif kind == 'list':
          /# To simplify parsing, we do something a bit different from the
          /# original markdown specification (for now):
          /#  - a list continues until a line is encountered that has a non
          /#    whitespace first char that does not match the list indicator
          /#    used in the first listitem (so lines to be kept as part of
          /#    a list must be indented at least one space for now).
          /#  - each list item is reparsed with parseLines recursively after
          /#    stripping off a constant amount of whitespace.
          nlws = len(mdata['indent'])
          lkey = 'ol' if mdata['ol'] else 'ul'
          lchar = mdata[lkey]
          ordered = lkey == 'ol'

          if current_lines:
            /# CODETANGLE(add_para): This is a repeat of the code elsewhere.

            /# Record(i, 'list (implicit close of paragraph)')
            para = metax.lib.markdown.Paragraph(
              current_group, '\n'.join(current_lines), prelines=para_prelines)
            current_group.addBlock(para)
            current_lines = []
            prelines = 0

          else:
            /# Record(i, 'list')
            pass

          listre = Parser.ListRe()

          list_block = List(
            current_group, ordered=ordered, mark=lchar, prelines=prelines)
          current_group.addBlock(list_block)

          /# Advance to end of list, accumulating indices of list item starts.
          item_starts = [(i, m)]
          list_start = i
          list_end = None  # one past last line in list.
          redo = False
          i += 1
          while i < N:
            line = lines[i]
            /# There are various possibilities for this line:
            /#  1. if it matches listre:
            /#     - if it has the same indent level:
            /#       - if it has the same bullet, it is a new item
            /#       - if it has a different bullet, it is an implicit end of
            /#         this list (and start of a new one).
            /#     - if it has a larger indent level (for example, if
            /#       current has indent 0 and this one has indent 1, 2 or 3)
            /#       it is a sub-list, part of the current item.
            /#     - if it has a smaller indent level (for example, if
            /#       current has indent 2 and this one has indent 0 or 1),
            /#       it indicates the end of the list.
            /#  2. if it does not start with a space and the previous line
            /#     was empty.
            /#     - it ends the list (and is not part of the list)
            /#  3. otherwise
            /#     - the line is part of the current list item.
            m = listre.match(line)

            if m:
              /# We have a new list item
              newdata = m.groupdict()
              newlkey = 'ol' if newdata['ol'] else 'ul'
              newlchar = newdata[newlkey]
              newnlws = len(newdata['indent'])

              if newnlws < nlws:
                /# The new list item is indented less than the current item.
                /# It is probably a typo, since both newnlws and nlws are
                /# less-equal 3, but we interpret it as an implicit end-of-list
                /# (and start of new list).

                /# The list item is an implicit start-of-new-list.

                /# Record(i, 'implicit new list (typo?)')

                /# We account for any empty lines before 'i'.
                list_end, prelines = FindEnd(lines, i-1)
                /# Note that by breaking, we do not increment i, so the
                /# outer line-parsing loop will reprocess this line and
                /# create another list.  We set keep_prelines True so that
                /# we do not tromp on the prelines calculated above.
                keep_prelines = True
                break

              elif newnlws > nlws:
                /# The new list item is indented more than the current line,
                /# so it is part of the current list. It may be a typo, but
                /# is probably a sub-item indented fewer than 4 spaces.

                /# Record(i, 'list item cont (sub item?)')
                pass

              elif (newlkey == 'ol' and ordered) or (newlchar == lchar):
                /# The list item is a continuation of the current list.

                /# Record(i, 'list item')
                item_starts.append((i, m))

              else:
                /# The list item is an implicit start-of-new-list.

                /# Record(i, 'implicit new list')

                /# We account for any empty lines before 'i'.
                list_end, prelines = FindEnd(lines, i-1)
                /# Note that by breaking, we do not increment i, so the
                /# outer line-parsing loop will reprocess this line and
                /# create another list.  We set keep_prelines True so that
                /# we do not tromp on the prelines calculated above.
                keep_prelines = True
                break

            elif line and line[0] != ' ' and not lines[i-1].strip():
              /# This line starts with non-whitespace and the previous line
              /# is blank, so this ends the list (and is not part of it).
              list_end, prelines = FindEnd(lines, i-1)
              /# Note that by breaking, we finish the parsing of the list and do
              /# not increment i ... the outer line-parsing loop will reprocess
              /# this line, as intended.
              keep_prelines = True
              break

            else:
              /# This line is a continuation of the current list item (later, we
              /# will back up before this empty line if it turns out to be a
              /# blank line after the list before a different entity).

              /# Record(i, 'list item cont')
              pass

            i += 1

          /# We now create ListItem instances based on item_starts
          /#  - need to remove the initial indentation prefix from each line
          /#  - need to handle trailing empty lines properly (becomes prelines
          /#    of next listitem).
          item_prelines = 0  # the first listitem in a list never has prelines, because the list itself handles those prelines.
          numis = len(item_starts)
          for k, pair in enumerate(item_starts):
            item_start, m = pair

            if k == numis - 1:
              /# Last list item ... end of list item is 'i' (the line that
              /# ended the entire list).
              item_end = i
            else:
              /# End of list is the line of the next list item.
              item_end = item_starts[k+1][0]
            line = lines[item_start]
            item_end, next_prelines = FindEnd(lines, item_end-1)
            item_pre = m.start('text')  # continuation lines are usually indented this much
            /#print '*** %4d %4d %d = %s [%s %d]' % (item_start+1, item_end+1, item_prelines, line, m.groupdict(), item_pre)

            item_lines = []
            item_lines.append(m.group('text'))
            for ii in range(item_start+1, item_end):
              line = lines[ii]
              /# The first item_pre spaces of line are to be ignored (but
              /# if a non-space appears before this, it is kept).
              jj = 0
              nn = min(len(line), item_pre)
              while jj < nn and line[jj] == ' ':
                jj += 1
              item_lines.append(line[jj:])

            if False:
              print('#' * 40)
              for l in item_lines:
                print(l)
              print('-' * 40)
            listitem = ListItem(list_block, prelines=item_prelines)
            list_block.addItem(listitem)
            /# Add final empty line so last block gets processed properly.
            item_lines.append('')
            self.parseLines(
              item_lines, parent=listitem, path=path, debug=debug,
              illegals=('section',))

            /# Setup for next listitem.
            item_prelines = next_prelines

        elif kind == 'hr':
          /# We have an HR line

          /# Record(i, 'horizontal ruler')

          hr = HR(current_group, line, prelines=prelines)
          current_group.addBlock(hr)
          i += 1

        elif kind == 'comment':
          /# We have a comment.

          /# Record(i, 'comment')
          i += 1

        elif kind == 'page':
          /# We have an explicit page break.

          /# Record(i, 'page break')
          if mdata['page'].isdigit():
            pagenum = int(mdata['page'])
          else:
            pagenum = -Parser.RomanNumeral[mdata['page']]
          i += 1

        elif kind == 'newcol':
          /# We have an explicit column break
          /# TODO(wmh): Do something with this!
          i += 1

        else:
          print('#' * 70)
          print(line)
          print('#' * 70)
          raise Error('How did we get here?')

        if dotimes:
          metax.root.Object.Welford(
            'metax.lib.markdown.Parser.parseLines/%s' % kind, time.time_ns() - _s)

        if kind != 'empty' and not keep_prelines:
          /# The current line isn't empty, so we reset the empty line counter.
          prelines = 0

      if debug:
        print('Parsed %d blocks' % (len(parent.blocks()) - start_blocks))
      return parent

    test:
      md = metax.lib.markdown.Parser()
      test.maxDiff = None

      respath = metax.root.Object.Resource(
        'simple_md', fqn='metax.lib.markdown_test.TestCase')
      with open(respath, 'r') as fp:
        content = fp.read()

      lines = content.split('\n')
      root = md.parseLines(lines, debug=False)

      /# Do some list verification
      section = root.find('A Simple Document/Blocks/Lists')
      listblock = section.block(3)
      test.istrue(listblock.isList())
      item = listblock.item(1)
      test.istrue(item.isListItem())
      test.iseq('banana', item.block(0).text())
      sublist = item.block(1)
      test.istrue(sublist.isList())
      subitem = sublist.item(0)

      /# Format the file in ascii and compare it with a golden file.
      fp = test.fp()
      root.show(fp=fp, width=0)
      golden = metax.root.Object.Resource(
        'simple_golden', fqn='metax.lib.markdown_test.TestCase')
      test.iseqstrgold(fp.getvalue(), golden)

      /# Now some additional experiments.
      section = md.parseLines("""
        >|# Header 1
        >|
        >|This is a __first__ paragraph
        >|short and sweet.
        >|
        >|Another **paragraph** but with explict  |<
        >|line break here.
        >|
        >|* * *
        >|
        >|<table>
        >|  <tr><td>An HTML block</td></tr>
        >|</table>
        >|
        >|<div>
        >|  <h1>Another HTML block</h1>
        >|  <h2>And a third HTML block</h2>
        >|</div>
        >|
        >|Here's a pretty picture of red trees.
        >|![red-leaved trees in a row](https://files.brightside.me/files/news/part_0/3755/151205-R3L8T8D-880-amazing-trees-4.jpg)
        >|[which can be found here](https://files.brightside.me/files/news/part_0/3755/151205-R3L8T8D-880-amazing-trees-4.jpg) and
        >|![this][sunlit-trees] is a beautiful sunlit tree ([it can be found here][sunlit-trees])
        >|
        >|- Apple
        >|   1. way out
        >|   2. last thing
        >|- Banana
        >|   1. not fair
        >|   2. having a life
        >|- Cantelope
        >|   * nested bullet with multiple lines
        >|     to see how it works
        >|   * another nested bullet with indented
        >|     second line.
        >|
        >|How do we determine when a list ends?  When we encounter text at
        >|left margin? (or, in the case of code blocks, at code level?)
        >|
        >|    class Person(object):
        >|      def __init__(self, name):
        >|        self._name = name
        >|
        >|[sunlit-trees]: http://www.designzzz.com/wp-content/uploads/2016/02/oaks-are-beautiful-trees.jpg "Beautiful sunlit tree"
        >|""".split('\n'),
        debug=False)

      /# TODO(wmh): finish up this test by ensuring that html support
      /# in C.show() is implemented for all subclasses C of Text.
      fp = test.fp()
      section.show(fp=fp, aspect='ascii', width=0)
      golden = metax.root.Object.Resource(
        'raw_txt_golden', fqn='metax.lib.markdown_test.TestCase')
      test.iseqstrgold(fp.getvalue(), golden)

      /# TODO(wmh): finish up this test by ensuring that html support
      /# in C.show() is implemented for all subclasses C of Text.
      fp = test.fp()
      section.show(fp=fp, aspect='html')
      golden = metax.root.Object.Resource(
        'raw_html_golden', fqn='metax.lib.markdown_test.TestCase')
      test.iseqstrgold(fp.getvalue(), golden)

      simple = """
        >|# Header 1
        >|
        >|+ Apple
        >|  - more
        >|  - stuff
        >|  - here
        >|+ Banana
        >|  * and
        >|    + level3
        >|    + works
        >|    + too
        >|  * here
        >|+ Cantelope
        >|"""

      psection = md.parseLines(simple.split('\n'))
      section = psection.child('Header 1')
      test.iseq(['List'], [block.kind() for block in section.blocks()])
      list = section.blocks()[0]
      test.iseq(
        ['ListItem', 'ListItem', 'ListItem'],
        [li.kind() for li in list.items()])

      section.show(fp=test.fp(), aspect='ascii')
      test.iseqtext(simple, test.out())
      /#section.show(aspect='html')

      /# Now we test a collection of paragraphs without a section start.
      parent = metax.lib.markdown.BlockGroup(None)
      misc = md.parseLines("""
       >|this is a test to see
       >|how a collection of paragraphs
       >|without header works.
       >|
       >|Here is paragraph 2.
       >|
       >|Here is paragraph 3 on two
       >|lines.
       >|
       >|1. one
       >|2. two
       >|3. three
       >|
       >|* apple
       >|* banana
       >|* cantelope
       >|""".split('\n'), parent=parent)
      misc.show(aspect='html', parser=md, fp=test.fp())
      test.iseqtext("""
        >|<p>this is a test to see
        >|how a collection of paragraphs
        >|without header works.</p>
        >|
        >|<p>Here is paragraph 2.</p>
        >|
        >|<p>Here is paragraph 3 on two
        >|lines.</p>
        >|
        >|<ol>
        >|  <li>
        >|  one
        >|  </li>
        >|  <li>
        >|  two
        >|  </li>
        >|  <li>
        >|  three
        >|  </li>
        >|</ol>
        >|
        >|<ul>
        >|  <li>
        >|  apple
        >|  </li>
        >|  <li>
        >|  banana
        >|  </li>
        >|  <li>
        >|  cantelope
        >|  </li>
        >|</ul>
        >|""",
        test.out())

    end method parseLines;

    method parseList : List #:
      Parse a collection of lines making up a list into a List instance.
    params:
      var lines : vec<str> #:
        The lines making up the list.
      var start : int #:
        The line number of the first line within lines;
      var parent : Object #:
        The Section or List that this list belongs to.
    scope:
      ordered = False
      result = List(parent, ordered)
      /# We first identify all of the items at top level within lines.
      /# We will then be able to parse each item as a BlockGroup to support
      /# all of markdown within each item.
      listre = metax.lib.markdown.Parser.ListRe()
      pretext = []
      items = []
      indent = None
      for i in range(0, len(lines)):
        line = lines[i]
        m = listre.match(line)
        if m:
          /# We've found a new list item.
          if indent is None:
            /# This is the first list item, so the indentation of this one
            /# dictates the indentation of all subsequent items at the same
            /# level.
            indent = m.group('indent')
          if m.group('indent') == indent:
            /# We have a 'top-level' item.
            items.append({
              'm': m.groupdict(),
              'body': [m.group('text')],
              'sublines': []})
          else:
            /# This is a sub-item within the current item.
            items[-1]['sublines'].append(line)
        else:
          /# This is not the start of a top-level item.

          if indent is None:
            /# This line is initial text before the first item. This cannot
            /# happen on an initial call from Parser.parseLines(), but can
            /# occur during recursive calls.
            pretext.append(line)
          else:
            items[-1]['sublines'].append(line)

      /# Now create ListItem instances for the top level and recursively
      /# parse the subtext of those elements.
      for item in items:
        elem = ListItem(parent, prelines=0)
        para = Paragraph(parent, '\n'.join(item['body']), implicit=True)
        elem.addBlock(para)
        result.addItem(elem)

      /#result.show(aspect='html')
      /#pprint.pprint(pretext)
      /#pprint.pprint(items)

      return result
    test:
      section = test.root
      md = test.md
      result = md.parseList(
        >|"""* Apple:
        >|    A tasty red fruit.
        >|    1. way out
        >|    2. last thing
        >|- Banana
        >|    A tasty yellow fruit.
        >|    1. not fair
        >|    2. having a life
        >|+ Cantelope
        >|    * another nested bullet with indented
        >|      second line.
        >|    * nested bullet with multiple lines
        >|    to see how it works
        >|
        >|""".split('\n'),
        101,
        section)
      fp = test.fp()
      result.show(fp=fp, aspect='html')

      test.iseqtext(
        >|"""<ul>
        >|  <li>
        >|  Apple:
        >|  </li>
        >|  <li>
        >|  Banana
        >|  </li>
        >|  <li>
        >|  Cantelope
        >|  </li>
        >|</ul>
        >|""",
        fp.getvalue())

    end method parseList;

    method loadBook : Book params:
      var paths : vec #:
        The files to load up as sections in the book.
      var bookname : str = 'Book' #:
        The name of the book containing all the paths.
      var titlere : regexp = null #:
        If present, specifies how section titles should be massaged. See
        Parser.parseLines() for details.
    scope:
      book = Book(bookname, self, path=[])
      root = book.root()

      /# metax.lib.markdown.Section(None, title=bookname, parser=self)
      for path in paths:
        if os.path.exists(path):
          section = self.parseFile(path, root, titlere=titlere)
          book.path().append(path)
        else:
          print('WARNING: Path %s does not exist' % path)
      if len(book.path()) == 1:
        book.pathIs(book.path()[0])
      return book
    test:
      /# NOTE: test.parseBook() invokes test.md.loadBook()
      book = test.parseBook(['metax.lib.markdown_test.TestCase.simple_md'])
      test.iseq(2, len(book.root().children()))
    end method loadBook;

    method readBook : Book #:
      Read a book from an open istream
    params:
      var ifp : istream #:
        The stream to read from.
      var bookname : str = 'Book' #:
        The name of the book containing all the paths.
      var path : str = null #:
        The path associated with the input stream.
      var fast : bool = false #:
        If true, perform fast parse (with JIT parsing of sections later).
    scope:
      book = Book(bookname, self, path=path)
      root = book.root()
      text = ifp.read().replace('\t', '    ')

      lines = text.split('\n')
      n = len(lines)

      if fast:
        self.parseSections(root, lines, book)
      else:
        self.parseLines(lines, parent=root, path=path)

      return book
    test:
      bookpath = metax.root.Object.Resource(
        'simple_md', fqn='metax.lib.markdown_test.TestCase')

      def Accumulate(section, sink, opaque):
        opaque.append(
          '%d %3d %3d %3d %s' %
          (section.depth(), section.pagenum(), section.linenum(), section.prelines(), section.title()))

      md = metax.lib.markdown.Parser()
      with open(bookpath, 'r') as ifp:
        book1 = md.readBook(ifp)
      test.iseq('Book', book1.root().title())
      test.iseq(
        '/Book/A Simple Document',
        book1.root().children()[0].fqn())
      slist1 = []
      book1.root().visit(sfunction=Accumulate, opaque=slist1)

      md = metax.lib.markdown.Parser()
      with open(bookpath, 'r') as ifp:
        book2 = md.readBook(ifp, fast=True)
      test.iseq('Book', book2.root().title())
      test.iseq(
        '/Book/A Simple Document',
        book2.root().children()[0].fqn())
      slist2 = []
      book2.root().visit(sfunction=Accumulate, opaque=slist2)

      /# By checking slist1 and slist2 against one another we verify that
      /# both slow and fast parsing are providng the same structure.
      if False:
        pprint.pprint(slist1)
        pprint.pprint(slist2)
      else:
        test.iseqvec(slist1, slist2)
    end method readBook;

    implicit
    command wmd #:
      Wade's markdown.
    interface:
      flag destdir : str = '' #:
        Where to write output files.
      flag aspect @ a : str = 'html' #:
        How to format the input.
        TODO(wmh): The metax.root.flags.Flag class understands enum types,
        but there is currently no way to specify such types when the 'flag'
        construct has a 'type' field that is of type 'type' (instead of 'str').
        Consider changing the type, or provide some other mechanism for being
        able to specify an enum type like:
          enum<title|title*|ascii|text|canonical|html>
      flag subaspect @ A : str = null #:
        If --aspect is html, use --subaspect=kaplan to get scrollable version.
      flag debug : bool = false #:
        If true, print out a summary of each parsed file.
      command compile #:
        Compile markdown into html.
      interface:
        flag bookid @ b : str = null #:
          Provides a bookid (needed if --aspect=html and --subaspect=kaplan
      scope:
        def FilterFiles(filelist):
          mds = []
          others = []
          for path in filelist:
            if path.endswith('.wmd') or path.endswith('.md'):
              dirmd, basesuff = os.path.split(path)
              base, suffix = os.path.splitext(basesuff)
              mds.append({
                'path': path, 'dir': dirmd, 'base': base, 'suffix': suffix[1:]})
            else:
              print('WARNING: Ignoring non-markdown file %s' % path)
              others.append(path)
          return mds, others

        mds, others = FilterFiles(cli.rest)

        aspect = cli.aspect
        subaspect = cli.subaspect
        bookid = cli.bookid
        if aspect == 'html' and subaspect == 'kaplan' and not bookid:
          print('ERROR: Must provide --bookid for --subaspect=kaplan')
          sys.exit(1)

        suffix = '.html' if aspect == 'html' else '.txt'
        parser = metax.lib.markdown.Parser()
        for spec in mds:
          with open(spec['path'], 'r') as ifp:
            book = parser.readBook(ifp, path=spec['path'], fast=False)
          book.uidIs(bookid)
          /# mdfile = parser.parseFile(spec['path'], debug=cli.debug)
          if cli.debug:
            book.show(aspect='title*')
          base = spec['base']
          mddir = cli.destdir or spec['dir']
          outpath = os.path.join(mddir, spec['base'] + suffix)
          with open(outpath, 'w') as fp:
            book.show(aspect=aspect, subaspect=subaspect, fp=fp)
          print('Wrote ' + outpath)
          if subaspect == 'kaplan':
            /# The special javascript variable IdList is currently initialized
            /# to the placeholder ${IdList}, which needs to be replaced with
            /# the contents of Parser.KaplanIds.
            tmp = outpath + '.tmp'
            os.rename(outpath, tmp)
            with open(tmp, 'r') as ifp:
              with open(outpath, 'w') as ofp:
                idliststr = str(Parser.KaplanIds)
                for line in ifp:
                  ofp.write(line.replace('${IdList}', idliststr))
            os.unlink(tmp)
      end command compile;

    end command wmd;
  end class Parser;

  native scope:
    def Identity(v):
      return v

  abstract
  class Object #:
    Abstract superclass of Section and Block.
  assocs:
    std assoc hashlib;
  scope:

    field prelines : int #:
      The number of empty lines found before this block started.
      Used to establish how much spacing is desired in formatted output,
      and to properly re-render the markdown itself.

    field md5 : str #:
      The md5 encoding of the blobs() of this Object. Often null.
    scope:
      accessor get lazy:
        blobs = self.blobs()
        if not blobs:
          if self.kind() == 'Section':
            title = self.title()
            if not title:
              /# This happens when an implicit section has been added to account
              /# for a header going from level K to K+2.
              pass
            else:
              /# This happens when we have a section
              print('EMPTY below %s' % self.parent().title())
          else:
            /# If we encounter problems, add additional special casing to
            /# handle them.
            raise Error('Request for md5 on %s with empty blobs' % self.kind())

          blobs = ['fixme']

        res = hashlib.md5(' '.join(blobs).encode('utf8')).hexdigest()
        -> res
      end accessor get;
    end field md5;

    lifecycle params:
      var prelines -> prelines = 0;
    scope:
    end;

    method kind : str #:
      Return the name of the class of this instance.
    scope:
      return self.__class__.__name__
    test:
      test.iseq('Section', test.section.kind())
      test.iseq('Paragraph', test.p1.kind())
      test.iseq('Panel', test.panel2.kind())
      test.iseq('Table', test.table2.kind())
    end method kind;

    method isBlock : bool scope:
      return False
    test:
      /# TODO(wmh): Testing methods in abstract classes won't be possible
      /# in C++ and Java, but is possible in Python, Javascript, Perl, etc.
      /# which don't disallow creation of abstract classes. Solution is of
      /# course to create instances of concrete subclasses.
      obj = metax.lib.markdown.Object()
      test.isfalse(obj.isBlock())
    end method isBlock;

    method isSection : bool scope:
      return False
    test:
      test.makeLists()
      test.istrue(test.section.isSection())
      test.isfalse(test.p1.isSection())
      test.isfalse(test.ul.isSection())
      test.isfalse(test.item3.isSection())
    end method isSection;

    method isPara : bool scope:
      return False
    test:
      test.isfalse(test.section.isPara())
      test.istrue(test.p1.isPara())
    end method isPara;

    method isCode : bool scope:
      return False
    test:
      test.isfalse(test.p1.isCode())
      test.istrue(test.code.isCode())
    end method isCode;

    method isTable : bool scope:
      return False
    test:
      test.isfalse(test.section.isTable())
      test.isfalse(test.p1.isTable())
      test.istrue(test.table.isTable())
    end method isTable;

    method isQuote : bool scope:
      return False
    test:
      test.isfalse(test.section.isQuote())
      test.isfalse(test.p1.isQuote())
      test.istrue(test.quote.isQuote())
    end method isQuote;

    method isList : bool scope:
      return False
    test:
      test.makeLists()
      test.isfalse(test.section.isList())
      test.isfalse(test.p1.isList())
      test.istrue(test.ul.isList())
      test.istrue(test.ol.isList())
    end method isList;

    method isListItem : bool scope:
      return False
    test:
      test.makeLists()
      test.isfalse(test.section.isListItem())
      test.isfalse(test.p1.isListItem())
      test.isfalse(test.ul.isListItem())
      test.istrue(test.item1.isListItem())
    end method isListItem;

    method ancestorSection : Section #:
      Find the nearest ancestor (excluding self) that is a Section.
    scope:
      result = self.parent()
      while result and not result.isSection():
        result = result.parent()
      return result
    test:
      test.makeLists()
      test.issame(test.section, test.subsection.ancestorSection())
      test.issame(test.root, test.section.ancestorSection())
      test.issame(test.subsection, test.ul.ancestorSection())
      test.issame(test.subsection, test.item3.ancestorSection())
    end method ancestorSection;

    method abbrev : str #:
      The abbrev associated with the title. Some subclasses support this,
      some do not.  By default, we assume no abbrev exists.
    scope:
      return None
    test:
      test.makeLists()
      test.isnull(test.ul.abbrev())
      test.isnull(test.section.abbrev())
      test.iseq('suba', test.subsection.abbrev())
    end method abbrev;

    abstract
    method keys : map #:
      The nested collection of titles and abbrevs.  Used to implement
      find, findre, etc.

    method find : Object #:
      Obtain some named portion of this object.

      This method relies on the hierarchy of objects being searched being
      able to respond to the following methods:
        title(): the title associated with an object (titles are what can be searched on)
        keys(): maps legal keys (the titles of child objects) to child objects
    params:
      var spec : any #:
        The name(s) desired. This can be either a string with '/' delimiters
        between parent/children, or a list of hierarchial titles. The list
        version is useful when any of the titles contain a '/'.
    scope:
      parts = spec if isinstance(spec, (list, tuple)) else re.split(r'(?<!\\)/', spec)
      obj = self

      for part in parts:
        /# Exact match ... there can only be one possible result.
        part = part.replace(r'\/', '/')
        keys = obj.keys()

        if part in keys:
          obj = keys[part]
        else:
          if obj.isSection():
            /# If 'key' references a titled Block an as-yet-unparsed Section, it
            /# will appear missing. We ensure the section is parsed and recheck.
            _ = obj.blocks()
            obj = obj.keys().get(part, None)
            if obj is None:
              break
          else:
            /# print('Failed to find child "%s" of "%s"' % (part, obj.title()))
            obj = None
            break
      return obj
    test:
      root = test.root
      section = root.find('Section 1')
      test.issame(test.section, section)
      subsection = root.find('Section 1/SubSection A')
      test.issame(test.subsection, subsection)

      /# Now we load a fast-parsed book and verify the jit loading works.
      bookpath = metax.root.Object.Resource(
        'simple_md', fqn='metax.lib.markdown_test.TestCase')
      md = metax.lib.markdown.Parser()
      with open(bookpath, 'r') as ifp:
        book = md.readBook(ifp, fast=True)
      root = book.root()
      tsection = root.find('A Simple Document/Blocks/Tables')
      /# We verify the section containing table 'Fruit' is not yet parsed.
      test.isnull(tsection._blocks)
      /# We ask for the Fruit table
      table = root.find('A Simple Document/Blocks/Tables/Fruit')
      /# Verify the section was implicitly parsed and table was found
      test.notnull(tsection._blocks)
      test.iseq('Fruit', table.title())
    end method find;

    method searchInText : vec<str> #:
      Given a multi-line text string, search for a regexp within it.
    params:
      var pattern : regexp #:
        The pattern to search for.
      var results : vec<str> #:
        Where to add results.
      var text : str #:
        The text to search.
      var sink : metax.io.Sink = null #:
        Where to print results. If null, nothing printed.
    scope:
      result = None
      line = text.replace('\n', ' ')
      /# print(line)
      ms = list(pattern.finditer(line))
      if ms:
        if sink:
          sep = '-' * 80
          /# sink.writeln('PATTERN: %s' % pattern.pattern)
          sink.writeln(sep)
          if self.parent():
            sink.write('%s\n' % self.parent().fulltitle())
          sink.indent('  ')
          sink.writeln(text.strip())
          sink.undent()
        for m in ms:
          mval = m.group(0)
          if sink:
            sink.write('Found: %s\n' % mval)
          /# print('  Found: %s\n' % mval)
          results.append(mval)
    test:
      results = []
      test.subsection.searchInText(
        re.compile('insert'),
        results,
        'This is the text\nto search for insert\nwithin.')
      test.iseq(
        ['insert'],
        results)
    end method searchInText;

    static
    method TerminalWidth : int #:
      Obtain the width of the terminal
    scope:
      try:
        width = os.get_terminal_size().columns
      except OSError as e:
        width = 80
      return width
    test:
      test.iseq(80, metax.lib.markdown.Object.TerminalWidth())
    end method TerminalWidth;

    method genId : str #:
      Return an id (suitable for use in CSS) to represent this object. Record
      id in Parser.KaplanIds.

      NOTE: Currently this will add the same id multiple times if called on
      the same object multiple times. It does, however, use the same id for the
      same object as long as its blobs() content has not changed between calls.
    scope:
      result = self.md5()
      Parser.KaplanIds.append(result)
      return result
    test:
      test.iseq('bb13c75900c224fece0da7131c79b135', test.p1.md5())
      /# test.iseq(test.table.md5())
      test.iseq('00f1b6ee0783b386e0b7b8ea51758de7', test.quote.md5())
      test.iseq('82a0805a732b59884dce7da82261b6ca', test.section.md5())
      test.iseq('64766af99203dbf9e3e52d7bbae3cf5d', test.subsection.md5())
    end method genId;

  end class Object;

  abstract
  class Block < Object #:
    Abstract superclass of all Markdown classes representing text.
    This includes:
      Paragraph (a section of consecutive lines of related text)
      List (an (ordered or unordered) list of items)
      Code (pre-formatted text, possibly in a particular prog lang).
      Blockquote (quoted text)
      Table (a table of N rows with fixed-width columns)

    Each of these subclasses has an associated concept of what it means to
    be titled:
      - paragraphs are title if they start with **<text>**.
      - lists currently always return None for title()
      - code currently always returns None for title(), but we can easily
        add a concept of title code ... 'Code: <code title>'?
      - blockquotes current always return None for title()
      - tables consist of a line of the form 'Table: <title>' followed
        by an empty line followed by the table rows (starts with '\s*|').
      - panels consist of a line of the form 'Panel: <title>' followed
        by an empty line followed by the panel rows (starts with 4+ spaces)
  scope:

    field parent : BlockGroup #:
      The section that this text object belongs to (or, for Row instances,
      the Table it belongs to).

    field endpage : bool #:
      True if there is a page break at the end of this text block.

    field uid : str #:
      A unique identifier for this block.

    field linenum : int #:
      The line within the source file at which this block is defined.
      Starts at 1 (not 0!). A value of 0 means uninitialized.
      Note that this was primarily used for Section instances, and was
      initially defined there, but as of 2025-04-05 it was moved here.

    lifecycle params:
      var parent -> parent;
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
      var uid -> uid = null;
      var linenum -> linenum = 0;
    super (prelines=prelines)
    scope:
    end lifecycle;

    method fulltitle : str #:
      The fully qualified title of this text object.
    scope:
      title = self.title() or ''
      fixed_title = title.replace('/', '\\/')
      result = '%s/%s' % (self.parent().fulltitle(), fixed_title)
      return result
    test:
      /# Note that testing section instances here is misleading because
      /# Section overrides fulltitle ... see the tests therein for sections.
      test.iseq(
        '/Section 1/SubSection A/Table with \\/ in it',
        test.table.fulltitle())
    end method fulltitle;

    method fqn : str #:
      The fully qualified path of this object, prefering uids over titles.
    scope:
      parent = self.parent()
      if parent is None:
        result = '/'
      else:
        result = parent.fqn() + '/'
      uid = self.uid()
      if uid:
        result += uid
      else:
        result += self.title() or ''
      return result
    test:
      test.iseq('//Section 1', test.section.fqn())
      test.iseq('//Section 1/suba', test.subsection.fqn())
    end method fqn;

    method isBlock : bool #:
      Return true if this is a block.
    scope:
      return True
    test:
      test.istrue(test.section)
      hr = metax.lib.markdown.HR(test.subsection, '* * *', prelines=1)
      test.isfalse(hr.isBlock())
    end method isBlock;

    method isPanel : bool scope:
      return False
    test:
      test.isfalse(test.section.isPanel())
      test.istrue(test.panel2.isPanel())
    end method isPanel;

    method asStr : vec<str> #:
      Return a string representing the formatted contents of this block.

      Note that this is optimized/overridden in Paragraph.
    params:
      var raw : bool = false #:
        IF true, replace newlines with spaces.
    scope:
      fp = io.StringIO()
      self.show(fp=fp, aspect='ascii')
      text = fp.getvalue()
      if raw:
        text = text.replace('\n', ' ')
      return text
    test:
      test.iseq(
        'This is an example paragraph containing a few lines\n'
        'of text including a **bold** word and _italize phrase_.',
        test.p1.asStr())
    end method asStr;

    method asLines : vec<str> #:
      Return a list of lines representing the ascii representation of
      this block. Each element has a newline at the end.
    scope:
      return self.asStr().splitlines(keepends=True)
    test:
      test.iseq(
        [
          'This is an example paragraph containing a few lines\n',
          'of text including a **bold** word and _italize phrase_.',
        ],
        test.p1.asLines())
    end method asLines;

  end class Block;

  class BlockGroup < Block #:
    A collection of Block instances that can be treated as a Block.
  scope:

    field blocks : @vec<Block> #:
      It is critically important that this be marked as @vec rather than vec,
      as the Section subclass relies on this. In particular, it sets blocks
      to null when parsed via Parser.parseSection(), as a means of detecting
      when just-in-time parsing of blocks is needed. That said, there is
      another way Sections can detect this (whether field 'delayed' is
      initialized or not).

    lifecycle params:
      var parent : Object #:
        The parent of this block object.
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
      var uid : str = null #:
        A unique identifier for this BlockGroup
      var linenum : int = 0;
    super (parent, prelines=prelines, uid=uid, linenum=linenum)
    scope:
    setup:
      group = metax.lib.markdown.BlockGroup(test.subsection)
      p1 = metax.lib.markdown.Paragraph(
        group,
        'This is an example paragraph containing a few lines\n'
        'of text including a **bold** word and _italize phrase_.')
      p2 = metax.lib.markdown.Paragraph(
        group,
        '**Some Title**. This is an example paragraph with a\n'
        'title (the first one is not titled)')
      test.iseq(0, len(group.blocks()))
      group.addBlock(p1)
      group.addBlock(p2)
      test.group = group
    end;

    method block : Block #:
      Obtain the block with given index.
    params:
      var index : int #:
        The index of the block desired, from 0.
    scope:
      blocks = self.blocks()
      if index < len(blocks):
        result = blocks[index]
      else:
        result = None
      return result
    test:
      section = test.section
      test.isnull(section.block(0))
      section.addBlock(test.p1)
      test.issame(test.p1, section.block(0))
      test.isnull(section.block(1))
    end method block;

    method addBlock : Block params:
      var block : Block;
    scope:
      self.blocks().append(block)
      return block
    test:
      /# setup has called adBlock twice.
      group = test.group
      test.iseq(2, len(group.blocks()))
    end method addBlock;

  end class BlockGroup;

  class Paragraph < Block #:
    A collection of consecutive lines of text. Contains
     - the lines of text (as a multi-line string)
     - the Section within which the Paragraph resides
     - the start/end position of bold, italic and bold-italic text
     - hyperlink references

    A paragraph can have a title (if the first bold annotation starts at
    position 0).

    A paragraph ends when any of the following are encountered:
     - an empty line
     - a line starting an ordered or unordered list
  assocs:
    std assoc textwrap;
    std assoc os;
  scope:

    field text : str #:
      The text within the paragraph.

    field annotations : vec<map> #:
      Details on bold, italic, and strike-thru elements.
      Each element contains the start, end, delim and text of the markup.
    scope:
      accessor get lazy:
        res = metax.lib.markdown.Paragraph.ExtractAnnotations(self.text())
        -> res
    end field annotations;

    field implicit : bool = false #:
      If True, this collection of lines should not be delineated as a
      paragraph (e.g. no <p> or </p> in html renditions, etc.)

    lifecycle params:
      var parent : Section;
      var text -> text;
      var implicit -> implicit = false;
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
    super (parent, prelines=prelines)
    scope:
      if text[-1] == '\n':
        print(
          'WARNING: Paragraphs should not pass in a trailing newline (%s)' %
          parent.fulltitle())
        text = text.rstrip()
    clinit:
      /# TODO(wmh): The original markdown specification says
      /#    But if you surround an `*` or `_` with spaces, it'll be treated as a
      /#    literal asterisk or underscore.
      /# this means that ' * ', ' ** ', ' _ ', and ' __ ' do not represent
      /# emphasis ... this RE does NOT handle this.
      cls.AnnReIs(re.compile(r'(?P<d>([*_])\2?)(?P<text>[^*_]+)(?P=d)'))

      cls.UrlReIs(re.compile(
        r'(?P<nl>\n[ \t]*)?'     # if the url spec starts on a newline, we don't need to add a newline
        r'(?P<img>!)?'           # if present, this is an embedded image
        r'\[(?P<text>[^\]]*)\]'  # the visible text (alt text for images, link text for urls)
        r' {0,1}'                # a space can separate the text from url
        r'(?:'
        r'\['
        r'(?P<label>[^ \]]+)'
        r'(?:\s+(?P<xwidth>\d*)x(?P<xheight>\d*))?'
        r'(?:\s+\[(?P<xclass>[^\[\]]+)\])?'
        r'\]'
        r'|'
        r'\('
        r'(?P<url>\S+)'                            # an inline url
        r'(?:\s*\"(?P<title>[^\"]+)\")?'           # optional tooltip
        r'(?:\s+(?P<width>\d*)x(?P<height>\d*))?'  # optional display width/height
        r'(?:\s+\[(?P<class>[^\[\]]+)\])?'
        r'\)'
        r')'))
    end lifecycle;

    meta
    field ImageHtmlFunc : function = null #:
      A function used to generate HTML from image data. See Image2Html()
      below for details on signature.
    scope:
      accessor get lazy:
        -> cls.Image2Html
    end field;

    meta
    field AnnRe : regexp = null #:
      This regexp matches against *<text>*, _<text>_, **<text>**, and __<text>__
      where <text> does not contain either '*' or '_'. This can be used
      recursively to identify nested bold/italic specs.  Note that this does
      not handle strike-thru (~~).

    meta
    field UrlRe : regexp = null #:
      A regexp matching against inline url references (including image
      references) and supporting both inline and reference links. The named
      groups this regexp provides are:
        text: str
          The visible text (alt text for image urls, link text for urls)
        nl: str or None
          The newline and whitespace before the markdown url spec, if such
          a newline exists
        img: str or None
          Either '!' or None ... indicates whether this is an image url.
        label: str or None
          If present, the url is a reference link, and this key contains the
          name of the url label to use.
        xwidth: int or None
          Only present if the url is a reference link (and then only optionally),
          it indicates the desired display width of the image identified by
          'label'.
        xheight: int or None
          Only present if the url is a reference link (and then only optionally),
          it indicates the desired display height of the image identified by
          'label'.
        url: str or None
          Only present if the url is an inline link, it specifies the url itself.
        title: str or None
          Only present if the url is an inline link, it specifies a tooltip
          to associate with the url.
        width: int or None
          Only present if the url is an inline link, it indicates the desired
          display width of the image identified by 'url'.
        height: int or None
          Only present if the url is an inline link, it indicates the desired
          display height of the image identified by 'url'.
        class: str or None
          The CSS class(es) to associate with the image (inline image)
        xclass: str or None
          The CSS class(es) to associate with the image (reference image)
    end field;

    meta
    method Image2Html : str params:
      var data : map #:
        The sole argument
        to the function should be a dict containing:
          url: str
            The url of the image
          class: str
            The CSS class to attach to the outer <div>
          imgcls: str (optional)
            The CSS class to attach to the <img>
          tooltip: str
            The text to associate with the image when one hovers over it.
          width: int (optional)
            The actual width of the image.
          height: int (optional)
            The actual height of the image.
          display_width: int (optional)
            The width with which to display (not necessarily the actual width
            of the image)
          display_height: int (optional)
            The height with which to display (not necessarily the actual height
            of the image)
          header: str = null
            Text to add above the image
          headercls : str = 'fixedwidth'
            The CSS class to use for the header
          footer: str = null
            Text to add below the image
          footercls : str = 'fixedwidth'
            The CSS class to use for the footer
          indent: str (optional)
            How much indentation to insert at the beginning of each html line.
      var edit : bool = false #:
        If True, include <input> and other form input elements for editing
        the image data.
    scope:
      /# TODO(wmh): This should be moved to a generic library that both
      /# markdown.meta and story.meta (and anyone else) can use.

      if edit:
        logging.warning(
          'Not yet implementing edit semantics in Paragraph.Image2Html')

      indent = data.get('indent', '')

      /# Form the attributes of the <img> tag.
      imgattrs = {'src': data['url']}
      tooltip = data.get('tooltip', '')
      if tooltip:
        imgattrs['title'] = tooltip
      header = data.get('header', None)
      if header:
        imgattrs['alt'] = header
      display_width = data.get('display_width', None)
      if display_width:
        imgattrs['width'] = display_width
      display_height = data.get('display_height', None)
      if display_height:
        imgattrs['height'] = display_height
      imgattrstr = ' '.join(
        ['%s="%s"' % (attr, imgattrs[attr]) for attr in sorted(imgattrs)])

      /# If actual image dimensions are provided, format a string for them.
      width = data.get('width', None)
      height = data.get('height', None)
      dims = ' (%d x %d)' % (width, height) if width and height else ''

      /# Form the lines of HTML.
      lines = []
      lines.append('')
      lines.append(
        '%s<div class=\"%s\">' % (indent, data.get('class', 'image')))

      /# If a header is provided, render it above the image
      header = data.get('header', '')
      if header or dims:
        lines.append(
          '%s  <div class="%s">%s%s</div>' %
          (indent, data.get('headercls', 'fixedwidth'), header, dims))

      /# Render the <img> (wrapped in an <a> linking to actual url).
      lines.append('%s  <a href="%s">' % (indent, data['url']))
      lines.append('%s    <img %s>' % (indent, imgattrstr))
      lines.append('%s  </a>' % indent)

      /# If a footeris provided, render it below the image
      footer = data.get('footer', None)
      if footer:
        lines.append(
          '%s  <div class="%s">%s</div>' %
          (indent, data.get('footercls', 'fixedwidth'), footer))

      /# End the outer div.
      lines.append('%s</div>' % indent)

      /# Return
      return '\n'.join(lines) + '\n'
    end method Image2Html;

    meta
    method TextToHtml : str #:
      Convert a multi-line string to html by escaping bold and italic requests,
      escaping special chars, replacing url and image markdown with HTML for
      those urls and images, etc.
    params:
      var text : str #:
        The text string to convert to tex.
      var parser : Parser = null #:
        The parser instance.
      var indent : str = "";
    scope:
      orig = text
      urlmap = {'': 0}
      textlen = len(text)

      /# A collection of multi-line html strings formatting an inline image.
      /# All such html is inserted BEFORE the paragraph text.
      image_chunks = []

      /# Now handle url replacement. This is a three-step process:
      /#  1. identify the url and image references and compute the desired
      /#     HTML. Assign a special string to this html, and replace the
      /#     markdown text for the url/image with the special string.
      /#  2. Replace other special characters (underscores, asterisks, etc.)
      /#     in the text as appropriate (note that any such characters within
      /#     urls, especially underscores, were hidden away in 1 above).
      /#  3. Replace the special strings from #1 with the actual HTML.

      def ReplUrl(m):
        d = m.groupdict()
        error = None
        url = None
        title = None
        text = d['text']
        label = d['label']
        if label:
          csscls = d.get('xclass', None)
          if parser:
            labelinfo = parser.labels().get(label, None)
            if labelinfo:
              url = labelinfo['url']
              title = labelinfo.get('title', None)
            else:
              error = 'Failed to find label "%s"' % label
          else:
            /#raise Error('here')
            error = 'Failed to find label "%s" (no parser)' % label
        else:
          url = d['url']
          title = d['title']
          csscls = d.get('class', None)

        data = {
          'indent': '',
          'class': csscls or 'image right',
          'url': url,
          /# 'header': text,
          'alt': text,
          'tooltip': title,
        }

        for k in ('width', 'height'):
          for prefix in ('', 'x'):
            if d[prefix + k]:
              data['display_' + k] = d[prefix + k]

        if error:
          result = 'ERROR{%s}' % error
        elif d['img']:
          /# We are to inline an image.
          /#  - determine if the inline image is appearing at the start of the
          /#    paragraph, end of the paragraph, or in the middle of a paragraph.
          if m.start(0) < 2:
            /# Inline image at beginning of paragraph.
            align = 'left'
          elif m.end(0) >= textlen - 2:
            /# Inline image at beginning of paragraph.
            /#  - TODO(wmh): How to get the image to float to the right AND
            /#    float to the bottom of the paragraph? Currently floats right
            /#    but starts at top of paragraph.
            align = 'right'
          else:
            align = None

          if align:
            data['class'] = csscls or ('image ' + align)
            img_html = cls.Image2Html(data)
            image_chunks.append(img_html)
          else:
            orig = m.group(0)
            print('ERROR: Not currently handling inline images inside paragraph: %s' % orig)
            image_chunks.append('<b>ERROR(EMBEDDEDURL):%s:(IGNORED)' % orig)
          /# The markdown syntax is removed (we recorded the image html above).
          result = ''
        else:
          data['csscls'] = ' class="%s"' % csscls if csscls else ''
          /# Although the adding of newline-indent was meant to make certain
          /# code more readable, I'm finding that it produces less readable
          /# code in various situations, so as of 2017-12-27 I'm disabling
          /# it.
          result = (
            '%(indent)s<a target="_blank" href="%(url)s"%(csscls)s>%(alt)s</a>' % data)

        key = '<<<URLKEY%d>>>' % urlmap['']
        urlmap[''] += 1
        urlmap[key] = result
        return key

      url_re = cls.UrlRe()
      text = url_re.sub(ReplUrl, text or '')

      /# Replace *, _ and `.
      text = cls.ReplaceEmphasis(text)

      /# Handle ampersand escapes.
      /#  - do not replace ampersands that are HTML escapes.
      def ReplaceAmpersand(m):
        html = m.group('html')
        if html:
          result = '&' + html
        else:
          result = '&amp;'
        return result
      amp_re = Parser.Amp_re
      text = amp_re.sub(ReplaceAmpersand, text)

      /# Handle < and > escapes.
      /#  - if they are part of an html tag, leave them as-is
      def ReplaceBracket(m):
        pass

      /# Now replace the html keys with actual html.
      keyre = Parser.Urlkey_re
      def KeyRepl(m):
        return urlmap[m.group('key')]
      text = keyre.sub(KeyRepl, text)

      if image_chunks:
        if False:
          print('#' * 80)
          pprint.pprint(image_chunks)
          print('#' * 80)
        image_chunks.append(text)
        text = '\n'.join(image_chunks)

      return text
    test:
      func = metax.lib.markdown.Paragraph.TextToHtml

      test.iseqtext(
        >|r"""hello! <em>how</em> are <em>you today</em>?
        >|this is <b>a test</b> to <b>see how</b> things work
        >|""",
        metax.lib.markdown.Paragraph.TextToHtml(
          'hello! *how* are _you today_?\n'
          'this is __a test__ to **see how** things work\n',
          parser=test.md, indent=''))

      html = func("""
        >|[An example link](http://www.google.com)
        >|![](http://some.site/path/to/image.jpg 200x)
        >|""")
      test.iseqtext("""\
        >|
        >|<div class="image right">
        >|  <a href="http://some.site/path/to/image.jpg">
        >|    <img src="http://some.site/path/to/image.jpg" width="200">
        >|  </a>
        >|</div>
        >|
        >|<a target="_blank" href="http://www.google.com">An example link</a>
        >|""",
        html)
    end method TextToHtml;

    meta
    method ReplaceEmphasis : str #:
      Replace asterisk, ...
    params:
      var text : str;
    scope:
      debug = 0

      /# We add chars before/after in order to avoid having to special
      /# case access at start and end of value.  If Python implements
      /# strings via cords this will be efficient, otherwise not.
      text = '!!' + text + '!!'

      N = len(text) - 4
      target = None
      istwo = False
      start = None
      reason = None
      replist = []

      i = 2
      while i < N:
        c = text[i]
        /# print('%4d: %s' % (i, c))

        if c == '*' or c == '_' or c == '`':
          /# Determine if this c represents a valid start/end of emphasis.
          special = True
          active = start is not None  # we've started a region.
          p = text[i-1]
          n = text[i+1]

          if active and c != text[start]:
            /# We are already parsing a special and the current one doesn't
            /# match.
            special = False
            reason = 'Currently processing "%s" not "%s"' % (text[start], c)
          elif active and n != c and istwo:
            /# We are parsing a two-char token so we ignore this single-char version.
            special = False
            reason = 'Currently parsing two-char %s so ignoring single %s' % (
              text[start], c)
          elif p == '\\':
            /# The char is escaped and doesn't represent emphasis.
            special = False
            reason = 'char has been escaped'
          elif c != '`':
            /# If * or _ is surrounded by spaces it doesn't represent emphasis.
            if p == ' ':
              if n == ' ':
                special = False
                reason = 'surrounded by spaces'
              elif n == c and text[i+2] == ' ':
                special = False
                reason = 'double is surrounded by spaces'

          if special:
            if n == c:
              istwo = True

            if start is None:
              /# We have found the start of an emphasis region.
              start = i
              if debug > 1:
                print('Marking %d as start: "%s"' % (i, text[i-2:i+3]))
              if istwo:
                i += 1
            else:
              /# We have found the end of an emphasis region.
              end = i + 1
              if istwo:
                end += 1

              if debug:
                print('Found %d-%d: "%s"' % (start, end, text[start:end]))

              /# Obtain the conversion data.
              tag = 'code' if c == '`' else ('b' if istwo else 'em')
              adj = 2 if istwo else 1
              inner = text[start+adj:end-adj]
              replist.append((start, end, '<%s>%s</%s>' % (tag, inner, tag)))

              /# Reset
              i = end
              start = None
              istwo = None

          else:
            if debug:
              print(
                'Position %d is not special: "%s" [%s]' %
                (i, text[i-2:i+3], reason))
            if n == c:
              i += 1

        i += 1

      parts = []
      i = 0
      for start, end, repl in replist:
        if i < start:
          parts.append(text[i:start])
        parts.append(repl)
        i = end
      parts.append(text[i:len(text)])

      text = ''.join(parts)
      return text[2:-2]
    test:
      func = metax.lib.markdown.Paragraph.ReplaceEmphasis
      text = (
       >|"""This is a *big* test to **see** how things _work when_ we mark up
       >|text __with annotations__. This * and _ and ** and __ are not special.
       >|Oh, and **this * should work** and __this _ also__.
       >|Oh, and **this *should work** and __this _also__.
       >|Now `code` and ``more code`` and ` testing ` and `` ` ``.""")

      test.iseqtext(
        >|"""This is a <em>big</em> test to <b>see</b> how things <em>work when</em> we mark up
        >|text <b>with annotations</b>. This * and _ and ** and __ are not special.
        >|Oh, and <b>this * should work</b> and <b>this _ also</b>.
        >|Oh, and <b>this *should work</b> and <b>this _also</b>.
        >|Now <code>code</code> and <code>more code</code> and <code> testing </code> and <code> ` </code>.""",
        func(text))
    end method ReplaceEmphasis;

    meta
    method TextToTex : str #:
      Convert a multi-line string to tex by escaping bold and italic requests,
      escaping special chars, etc.
    params:
      var text : str #:
        The text string to convert to tex.
      var parser : Parser = null #:
        The parser instance.
    scope:
      /# TODO(wmh): Use the extract annotations instead of doing it here.
      r = cls._AnnRe
      while True:
        m = r.search(text)
        if m:
          all = m.group(0)
          d = m.group('d')
          kwd = 'textit' if len(d) == 1 else 'textbf'
          text = text.replace(all, '\\' + kwd + '{' + m.group('text') + '}')
        else:
          break
      text = text.replace('&', '\\&').replace('_', '\\_').replace('  \n', '\\\\\n')
      return text
    test:
      test.iseqtext(
        >|r"""hello! \textit{how} are \textit{you today}?
        >|this is \textbf{a test} to \textbf{see how} things work
        >|""",
        metax.lib.markdown.Paragraph.TextToTex(
          'hello! *how* are _you today_?\n'
          'this is __a test__ to **see how** things work\n'))
    end method TextToTex;

    meta
    method ExtractAnnotations : vec<map> #:
      Find emphasis indicators within specified text.
    params:
      var text : str;
    scope:
      result = []
      special = '`'
      r = cls._AnnRe
      while True:
        m = r.search(text)
        if m:
          d = m.group('d')
          t = m.group('text')
          f = special * len(d)
          s = m.start(0)
          e = m.end(0)
          text = text.replace(m.group(0), f + t + f, 1)
          entry = {
            'd': d,
            's': m.start(0),
            'e': m.end(0),
            'v': m.group('text').replace(special, ''),
          }
          result.append(entry)
        else:
          break
      return sorted(result, key=lambda e: e['s'])
    test:
      meth = metax.lib.markdown.Paragraph.ExtractAnnotations
      test.iseq(
        [{'d': '**', 'e': 14, 's': 0, 'v': 'Title Here'}],
        meth('**Title Here**. This is a test'))
      test.iseq(
        [{'d': '**', 'e': 20, 's': 8, 'v': 'a test'},
        {'d': '_', 'e': 18, 's': 12, 'v': 'test'},
        /# TODO(wmh): This needs extending, as we will not be able to
        /# properly convert the text to HTML or latex as-is ... we've
        /# last the fact that the '_' encases the '**'.
        {'d': '_', 'e': 42, 's': 32, 'v': 'this'},
        {'d': '**', 'e': 41, 's': 33, 'v': 'this'}],
        meth('This is **a _test_** to see how _**this**_ works.'))
    end;

    method isPara : bool scope:
      return True
    test:
      test.isfalse(test.section.isPara())
      test.istrue(test.p1.isPara())
    end method isPara;

    method asStr : vec<str> #:
      Return a string representing the formatted contents of this block
    params:
      var raw : bool = false #:
        IF true, replace newlines with spaces.
    scope:
      text = self.text()
      if raw:
        text = text.replace('\n', ' ')
      return text
    test:
      test.iseq(
        'This is an example paragraph containing a few lines\n'
        'of text including a **bold** word and _italize phrase_.',
        test.p1.asStr())
    end method asStr;

    method titleAndText : tuple<str,str> #:
      Obtain title (may be null) and text of this paragraph
    params:
      var tdelim : str = '**' #:
        What appears before and after the title.
      var tsep : str = null #:
        What appears after the title before the text. If null, default used.
      var raw : bool = false #:
        If true, newlines replaces with spaces in text.
    scope:
      if tsep is None:
        tsep = r'[:.]\s*'
      tdelim = re.escape(tdelim)
      tre = re.compile(
        tdelim + '(?P<title>.*?)' + tdelim + tsep + '(?P<text>.*)', re.DOTALL)
      text = self.text()
      if raw:
        text = text.replace('\n', ' ')
      title = None
      m = tre.match(text)
      if m:
        title = m.group('title')
        text = m.group('text')
      return (title, text)
    test:
      p1 = metax.lib.markdown.Paragraph(
        None, 'A first paragraph\nwith two lines')
      test.iseq(
        (None, 'A first paragraph\nwith two lines'),
        p1.titleAndText())
      test.iseq(
        (None, 'A first paragraph with two lines'),
        p1.titleAndText(raw=True))

      p2 = metax.lib.markdown.Paragraph(
        None, '**Innate Talent**: Can jump twice as high\nand far.')
      test.iseq(
        ('Innate Talent', 'Can jump twice as high\nand far.'),
        p2.titleAndText())
      test.iseq(
        ('Innate Talent', 'Can jump twice as high and far.'),
        p2.titleAndText(raw=True))

      p3 = metax.lib.markdown.Paragraph(
        None, '_Innate Talent_. Can jump twice as high\nand far.')
      test.iseq(
        ('Innate Talent', 'Can jump twice as high\nand far.'),
        p3.titleAndText(tdelim='_', tsep=r'\.\s+'))
      test.iseq(
        ('Innate Talent', 'Can jump twice as high and far.'),
        p3.titleAndText(tdelim='_', tsep=r'\.\s+', raw=True))
    end method titleAndText;

    method clone : Paragraph #:
      Make a copy of myself (NOT attached to any parent).
    scope:
      cls = self.__class__
      return cls(
        None, self.text(), implicit=self.implicit(), prelines=self.prelines())
    test:
      p1 = test.p1
      p1b = p1.clone()
      test.iseq(p1.blobs(), p1b.blobs())
    end method clone;

  end class Paragraph;

  class Quote < Block #:
    A block quote.

    TODO(wmh): This should be a subclass of BlockGroup, similar to Panel.
  scope:

    field lines : vec<str> #:
      The lines making up the block quote. No newlines in elements.

    field author : str #:
      The author, if specified after '<ws>--<ws>' on last line.

    lifecycle params:
      var parent : Section #:
        The section this code block belongs to.
      var lines -> lines;
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
    super (parent, prelines=prelines)
    scope:
      /# TODO(wmh): Either strip the '> ' from each line here, or require
      /# the caller to do so.
      self.linesIs(lines)

      /# Identify author
      last = lines[-1]
      m = Quote.AuthorRe.match(last)
      if m:
        lines.pop()
        author = m.group('author')
        self.authorIs(author)
    clinit:
      cls.AuthorRe = re.compile(r'^>\s+--\s+(?P<author>.+\S)')
    end lifecycle;

    method isQuote : bool scope:
      return True
    test:
      test.isfalse(test.section.isQuote())
      test.isfalse(test.p1.isQuote())
      test.istrue(test.quote.isQuote())
    end method isQuote;

  end class Quote;

  class List < Block #:
    A list (ordered or unordered).
  assocs:
    std assoc math;
    std usertest assoc collections;
  scope:

    field ordered : bool #:
      True if this list is ordered.

    field mark : str #:
      One of '*', '+' or '-' if unordered, or an integer if ordered.
      Note that currently we do NOT store the integers of every list item
      in the list, just of the first one (for unordered lists this is
      unnecessary because all list items must use the same mark for
      unordered lists).

    field items : @vec<ListItem> #:
      The collection of items making up the list.  Each item consists
      of one or more blocks.
      TODO(wmh): Should List inherit from BlockGroup so we can use blocks
      instead of items? Probably not, since blocks expect Block instances
      but ListItem instances are BlockGroups not Blocks.

    lifecycle params:
      var parent : Object #:
        This is a Section if the list is top-level, or a List if the
        list is nested.
      var ordered -> ordered = false;
      var mark -> mark = null;
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
    super (parent, prelines=prelines)
    scope:
    test:
      simple = test.parseMarkdown(
        'simple_md', parser=metax.lib.markdown.Parser())
      section = simple.find('A Simple Document/Blocks/Lists')
      test.iseq(
        ['Paragraph', 'List', 'Paragraph', 'List', 'Paragraph', 'List'],
        [block.kind() for block in section.blocks()])
      alist = section.blocks()[-1]
      test.iseq(
        ['ListItem', 'ListItem', 'ListItem'],
        [li.kind() for li in alist.items()])
    end;

    method isList : bool scope:
      return True
    test:
      test.makeLists()
      test.isfalse(test.section.isList())
      test.isfalse(test.p1.isList())
      test.istrue(test.ul.isList())
      test.istrue(test.ol.isList())
    end method isList;

    method item : ListItem #:
      Obtain the item with given index.
    params:
      var index : int #:
        The index of the item desired, from 0.
    scope:
      items = self.items()
      if index < len(items):
        result = items[index]
      else:
        result = None
      return result
    test:
      test.makeLists()
      ul = test.ul
      test.issame(test.item1, ul.item(0))
      test.issame(test.item2, ul.item(1))
      test.issame(test.item3, ul.item(2))
      test.isnull(ul.item(3))
    end method item;

    method addItem : void #:
      Add a list item.
    params:
      var elem : ListItem;
    scope:
      self.items().append(elem)
    test:
      test.makeLists()
    end method addItem;

    method newItem : ListItem #:
      Create and register a ListItem.
    params:
      var blocks : vec<Block> = null #:
        The Block instances in the ListItem. Parents are updated.
      var paras : vec<str> = null #:
        A list of mult-line paragraphs representing to-be-created Paragraph
        instances (elements should not end with newline). Normally one does not
        specify both blocks and paras (one or the other). If both are specified,
        blocks are added first, then the paras are created and added.
      var prelines : int = 0;
    scope:
      result = ListItem(self, prelines=prelines)
      if blocks:
        for block in blocks:
          result.addBlock(block)
      if paras:
        for text in paras:
          para = Paragraph(result, text, prelines=0)
          result.addBlock(para)
      self.addItem(result)
      return result
    test:
      /# makeLists() calls newItem() multiple times.
      test.makeLists()
      test.iseq(3, len(test.ul.items()))
    end method newItem;

    method blocksByTitle : omap #:
      Partition all blocks of this List into groups based on which Paragraph
      elements have titles.

      Returns:
        ordered map from paragraph title to
         - list of Block (if raw is false)
         - list of str (if raw is true)
        if there are blocks before the first one with a title, they are added
        under key '__pre__' unless nopre is true
    params:
      var raw : bool = false #:
        If true, each value returned is a vec<str> not vec<Block>. The strings
        represent text with newlines replaced with spaces.
      var nopre : bool = false #:
        If true, do not put a __pre__ key in the result for the initial
        collection of untitled blocks
      var tdelim : str = '**' #:
        What appears before and after the title.
      var tsep : str = '[:.]\\s*' #:
        What appears after the title before the text
    scope:
      result = collections.OrderedDict()

      untitled = 0

      /# Lists are handled diffently than Sections wrt this method:
      /#  - every listitem represents a partition (if the first element is not
      /#    a paragraph with a title, we assign a special untitled title).
      for litem in self.items():

        blocks = litem.blocks()
        n = len(blocks)
        first = blocks[0]

        title = None
        if isinstance(first, Paragraph):
          title, text = first.titleAndText(tdelim=tdelim, tsep=tsep, raw=raw)
        else:
          raise Error(
            'It is possible to have a non-Paragraph first element in a List?')
        if title is None and not nopre:
          untitled += 1
          title = '__pre%d__' % untitled

        if not title:
          /# We do not recording this listitem
          continue

        /# We create a new partition for each listitem
        current = []
        result[title] = current

        if raw:
          current.append(text)
          bi = 1
          while bi < n:
            current.append(blocks[bi].asStr(raw=raw))
            bi += 1

        else:
          /# TODO(wmh): Handle nested lists by recursing!
          current.extend(blocks)

      return result
    test:
      simple = test.parseMarkdown(
        'simple_md', parser=metax.lib.markdown.Parser())
      section = simple.find('A Simple Document/Titled Blocks')
      alist = section.blocks()[-1]
      test.iseq(
        collections.OrderedDict([
          ('Light', ['simple para.']),
          ('Dark', ['another simple', 'With second para']),
          ('Medium', ['third.']),
          ('__pre1__', ['list item with no title.']),
        ]),
        alist.blocksByTitle(raw=True))
    end method blocksByTitle;

  end class List;

  class ListItem < BlockGroup #:
    An item within a list. Contains zero or more Block instances.

    The parent field contains a List instance.
  scope:

    method isListItem : bool scope:
      return True
    test:
      test.makeLists()
      test.isfalse(test.section.isListItem())
      test.isfalse(test.p1.isListItem())
      test.isfalse(test.ul.isListItem())
      test.istrue(test.item1.isListItem())
    end method isListItem;

    method parser : Parser #:
      Obtain the parser associated with this ListItem.
    scope:
      result = None
      /# We do not store parsers in ListItems. Instead, we search up to
      /# the nearest section, which contains a parser.
      section = self.ancestorSection()
      if section:
        result = section.parser()
      return result
    test:
      test.makeLists()
      test.issame(test.md, test.item3.parser())
    end method parser;

  end class ListItem;

  class Code < Block #:
    A code block.
  scope:

    field lines : vec<str> #:
      The lines making up the code block.

    field language : str #:
      The language the code is written in.  This is null for the indented
      form of the Code construct, and is a string (maybe empty) for the
      quoted form of the Code construct.

    lifecycle params:
      var parent : Section #:
        The section this code block belongs to.
      var lines : vec<str> #:
        The lines making up the code block. No newlines in elements.
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
      var language -> language = null;
    super (parent, prelines=prelines)
    scope:
      self.linesIs(lines)
    end lifecycle;

    method isCode : bool scope:
      return True
    test:
      test.istrue(test.code.isCode())
      test.isfalse(test.p1.isCode())
      test.isfalse(test.section.isCode())
      test.isfalse(test.table2.isCode())
      test.isfalse(test.panel2.isCode())
    end method isCode;

  end class Code;

  class HR < Object #:
    A horizontal rule.
  scope:

    field text : str #:
      The exact text used to describe the rule.

    lifecycle params:
      var parent : Section #:
        The section this hr belongs to.
      var text -> text;
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
    super (prelines=prelines)
    scope:
    setup:
      test.hr = metax.lib.markdown.HR(test.section, '* * *', prelines=1)
    end lifecycle;

  end class HR;

  class HTML < Block #:
    An html block.
  scope:

    field lines : vec<str> #:
      The lines in the html block.

    lifecycle params:
      var parent : Section #:
        The section this code block belongs to.
      var lines : vec<str> #:
        The lines in the html block.
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
    super (parent, prelines=prelines)
    scope:
      self.linesIs(lines)
      /# print('Have HTML block with %d lines starting: %s' % (len(lines), lines[0]))
    setup:
      test.html = metax.lib.markdown.HTML(
        test.section, ['<p>blah</p>'])
    end lifecycle;

  end class HTML;

  class Table < Block #:
    A table.
    See https://help.github.com/articles/organizing-information-with-tables

    The conceptual children of a table (for purposes of the find() method)
    are the titles of each data Row, and the title of a Row is the value of
    its unique-key column (for now, always column 0).
  assocs:
    std assoc copy;
    std assoc pprint;
    std assoc string;
    std assoc textwrap;
  scope:

    field title : str = null #:
      The title associated with the table

    field xdent : str = '' #:
      The extra indentation that the row has relative to the title

    field csscls : str = null #:
      The CSS class(es) to associate with the table.

    field columns : @vec<map> #:
      The column information. Each element contains:
        align: str
          One of '', 'left', 'right' or 'center'
        minwidth: int
          Minimum width (in chars) of the column
        header: str (optional)
          The column header (need not be specified).

    field indices : map #:
      Maps column header values to integers (first column is 0, second is 1, etc).

    field rows : @vec<Row> #:
      The data rows of the table. Each element is a list of Row
      (size equal to the size of 'columns') representing the values
      of each column within the row.

    field separators : @vec<int> #:
      Indicies within self.rows() after which a separator should be printed.

    field abbrevs : map #:
      Provides abbreviation-to-title mappings. Each abbrev is found immediately
      after data rows in lines with format:
        |+ <abbrev> = <title>

    field notes : map #:
      Provides mark-to-note mappings. Each notes is found immediately
      after data rows and abbrevs in lines with format:
        |<mark> <note>
      where <mark> is any number of '*' or 'â€ '

    lifecycle params:
      var parent : Section #:
        The section this text object belongs to.
      var columns -> columns;
      var rawrows : vec<vec<str>> #:
        See the 'rows' field.
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
      var title -> title = null;
      var csscls -> csscls = null;
      var abbrevs -> abbrevs = null;
      var notes -> notes = null;
      var xdent -> xdent = '';
      var uid : str = null #:
        A unique identifier for this table.
    super (parent, prelines=prelines, uid=uid)
    scope:
      indices = {}
      for i, cdata in enumerate(columns):
        header = cdata.get('header', None)
        if header:
          indices[header] = i

      rows = [metax.lib.markdown.Row(self, rowdata) for rowdata in rawrows]

      self.rowsIs(rows)
      self.indicesIs(indices)
    clinit:
      cls.TableReIs(re.compile(r'^[-<|:+ ]{5,}$'))
      cls.ColReIs(re.compile(
        r'^\s*(?P<all>(?P<left>:)?-+(?P<right>:)?(?P<maxw><)?)\s*$'))
    end lifecycle;

    meta
    field TableRe : regexp;

    meta
    field ColRe : regexp;

    meta
    method New : Table #:
      Parse a list of strings into a table.

      Returns null if the input lines do not represent a table, writing
      error information to the 'errors' output parameter if provided.
    params:
      var lines : vec<str> #:
        A collection of lines potentially representing a markdown table. If
        they do, the first, third or fourth line will establish this,
        depending on whether an optional title (followed by empty line) and
        optional header line are specified).
          - optional title line
          - optional empty line (required if title line is present)
          - optional column header list
          - required data rows
          - optional post-table abbrevs starting with '+ ' (no blank line
            between data rows and start of these lines).
          - optional post-table notes starting with '*' or 'â€ ' (no blank line
            between data rows or abbrev rows and start of these lines).
        See https://help.github.com/articles/organizing-information-with-tables
        for the basics (the optional title, abbrevs, and notes are wmh add-ons).
      var errors : vec<str> = null #:
        An optional out parameter that parsing errors are written to.
      var parent : *Section = null #:
        The section this table belongs to.
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
    scope:
      if errors is None:
        errors = []

      header_start = 1
      if not lines[header_start].strip():
        header_start += 1

      /# If the lines represent a table, some line must represent the column
      /# spec, consisting solely of chars in [-<|:+ ]. We identify which line
      /# this spec is in.
      m = None
      spec = None
      tablere = cls.TableRe()
      i = -1
      for i in range(header_start, min(10, len(lines))):
        m = tablere.match(lines[i])
        if m:
          spec = lines[i]
          break
      data_start = i + 1

      if m:
        columns = []
        /# Column delimiters are either '|' or '-+'
        delim_re = Parser.Delim_re
        row_re = re.compile(r'^(?P<indent>\s*)\|\s*(?P<inner>.*\S)?\s*\|\s*$')
        table_note_re = Parser.Table_note_re
        table_abbrev_re = Parser.Table_abbrev_re
        /# TODO(wmh): The ignore string is used to specify which chars to
        /# remove from the front and back of each table row. Having '|'
        /# in this list makes it convenient when splitting so that we don't
        /# have to ignore first and last element. However, this also means that
        /# when the first or last table cell is empty, we end up deleting it
        /# entirely.
        /#
        /# Fixing this is not as simple as not using 'ignore' and dealing with
        /# the extra elements in split lists, because the (github) markdown
        /# spec allows both:
        /#    | Column1 | Column2 |
        /# and
        /#      Column1 | Column2
        /# as legal table specifiers.
        /#
        /# If we require tables to have left and right borders, we can just
        /# delete ignore, split on whitespace, remove first and last elements
        /# from lists resulting from splitting, lstrip first element, and rstrip
        /# last element. But if we want to allow non-border delimiters we'll
        /# need something more.

        ignore = '| \n'

        /# Parse the column specification
        xspec = spec.strip()
        colre = cls.ColRe()
        for colspec in delim_re.split(xspec)[1:-1]:
          m = colre.match(colspec)
          if m:
            align = ''
            if m.group('left'):
              align = 'center' if m.group('right') else 'left'
            elif m.group('right'):
              align = 'right'
            all = m.group('all')
            cdata = {'align': align}
            if m.group('maxw'):
              cdata['maxwidth'] = len(all)
            else:
              cdata['minwidth'] = len(all)
            columns.append(cdata)
          else:
            errors.append(
              '"%s" is not a valid colspec in "%s"' % (colspec, xspec))
        numcols = len(columns)

        /# Obtain the table title.
        title = None
        csscls = None
        tblid = None
        if True:
          title = lines[0].strip()
          m = re.match(
            r'^Table: (?P<title>[^\[\]]+)(?:\s*\[(?P<class>.*)\])?', title)
          if m:
            title = m.group('title')
            csscls = m.group('class')
            if csscls:
              css = []
              for part in csscls.split():
                if part[0] == '=':
                  /# This is an id specifier.
                  if tblid is None:
                    tblid = part[1:]
                  else:
                    raise Error('multiple table ids specified!')
                else:
                  css.append(part)
              csscls = ' '.join(css)

        /# Parse the column headers, if they exist.
        if i > 0:
          hi = header_start
          while hi < data_start-1:
            headers = delim_re.split(lines[hi].strip())[1:-1]
            if len(headers) != numcols:
              errors.append(
                'Found %d headers but %d columns: %s' %
                (len(headers), numcols, lines[header_start]))
              for line in lines:
                errors.append('  ' + line)
            else:
              if hi == header_start:
                /# First header line
                for j in range(0, numcols):
                  columns[j]['header'] = headers[j].strip()
              else:
                /# Not first header line (append to previously computed values)
                for j in range(0, numcols):
                  nh = headers[j].strip()
                  ch = columns[j]['header']
                  if ch:
                    if nh:
                      /# TODO(wmh): Should this use a newline or a space??
                      columns[j]['header'] = ch + ' ' + nh
                  else:
                    columns[j]['header'] = nh
            hi += 1

        /# Parse row lines
        xdent = None
        rows = []
        n = len(lines)
        r = i + 1
        while r < n:
          m = row_re.match(lines[r])
          if not m:
            break
          dent = m.group('indent')
          if xdent is None:
            xdent = dent
          else:
            assert dent == xdent, 'Table rows have differing indentation "%s" vs "%s"' % (dent, xdent)
          row = delim_re.split(m.group('inner'))
          assert row
          row[0] = row[0].lstrip()
          row[-1] = row[-1].rstrip()
          if len(row) != numcols:
            /# print(row)
            errors.append(
              'For row %d, found %d columns when expecting %d: %s (%s)' %
              (r - i, len(row), numcols, lines[r].rstrip(), row))
            for line in lines:
              errors.append('  ' + line)
          rows.append(row)
          r += 1

        /# Parse post-row abbrev mappings
        abbrevs = {}
        while r < n:
          m = table_abbrev_re.match(lines[r])
          if not m: break
          abbrevs[m.group('abbrev')] = m.group('title')
          r += 1

        /# Parse post-row notes
        notes = {}
        while r < n:
          m = table_note_re.match(lines[r])
          if not m: break
          notes[m.group('mark')] = m.group('note')
          r += 1

        /# If there are any additional lines, it is an error.
        while r < n:
          errors.append('Unknown post-row line: ' + lines[r])
          r += 1
      else:
        abbrevs = None
        errors.append('Not a table')
        for line in lines:
          errors.append('  ' + line)

      /# Return a Table instance if no errors, or None if errors.
      result = (
        None if errors
        else cls(
          parent, columns, rows, title=title, prelines=prelines,
          abbrevs=abbrevs, notes=notes, xdent=xdent,
          csscls=csscls, uid=tblid))
      return result
    test:
      table, errors = test.newTable()
      test.iseq(
        [{'minwidth': 3, 'align': '', 'header': 'Name'},
         {'minwidth': 4, 'align': 'left', 'header': 'Age'},
         {'minwidth': 4, 'align': 'right', 'header': 'Height'},
         {'minwidth': 5, 'align': 'center', 'header': 'Fruit'}],
        table.columns())
      test.iseq(
        [['Alice', '25', '1.7m', 'Kiwi'],
         ['Bob', '23', '1.9m', 'Apple']],
        [row.data() for row in table.rows()])
      test.iseq('Table Title', table.title())

      table2, errors2 = test.newTable(
        lines=['blahdk dkd s', 'dk skdks ks', 'skkdd s s skd', 'ds kdk s dk'])
      test.isnull(table2)
      test.iseq(
        [
          'Not a table',
          '  blahdk dkd s',
          '  dk skdks ks',
          '  skkdd s s skd',
          '  ds kdk s dk',
        ],
        errors2)

      table3, errors3 = test.newTable(
        ['| Name | Age | ', '| --- | ---| ', '| Bob | 23 | extra |', 'Alice'])
      test.isnull(table3)
      test.iseq(
        [
          "For row 1, found 3 columns when expecting 2: | Bob | 23 | extra | (['Bob', '23', 'extra'])",
          '  | Name | Age | ',
          '  | --- | ---| ',
          '  | Bob | 23 | extra |',
          '  Alice',
          'Unknown post-row line: Alice',
        ],
        errors3)

      table4, errors4 = test.newTable(
        ['|  .  |',
         '| :-: |',
         '| ![](http://www.google.com) |',
         '| ![](http://www.cnn.com) |'])
      /#print errors4
      /#print table4

      table5, errors5 = test.newTable(
        lines=[
          'Table: Testing Abbrevs',
          '',
          '  | Date  | A | B | C |',
          '  |-------+---+---+---|',
          '  | Feb 1 | 1 | 2 | 0 |',
          '  | Mar 1 | 3 | 1 | 1 |',
          '  = A = Apple',
          '  = B = Banana',
          '  = C = Cantelope',
          '  * This is a test',
        ])
      test.iseq([], errors5)
      /# table5.show()
      test.iseq(
        [
          {'Apple': '1', 'Banana': '2', 'Cantelope': '0', 'Date': 'Feb 1'},
          {'Apple': '3', 'Banana': '1', 'Cantelope': '1', 'Date': 'Mar 1'},
        ],
        table5.rowkeys(unwrap=True))
    end method New;

    method keys : map #:
      The mapping from row title to Row instances.
    scope:
      return {row.title(): row for row in self.rows()}
    test:
      table, errors = self.newTable()
      test.iseq(['Alice', 'Bob'], sorted(table.keys()))
    end method keys;

    method rowkeys : vec<map> #:
      Returns the list of all rows converted to column-header -> cell-value dicts
    params:
      var unwrap : bool = false #:
        If true, unwrap the table first. Unwrapping both merges multiple cells
        into a single cell and renames abbreviated column headers to full
        titles if present.
    scope:
      table = self
      if unwrap:
        table = table.unwrapped()
      return [dict(row.keys()) for row in table.rows()]
    test:
    end method rowkeys;

    method isTable : bool scope:
      return True
    test:
      test.istrue(test.table2.isTable())
      test.isfalse(test.panel2.isTable())
    end method isTable;

    method unwrapped : Table #:
      Create a new Table instance with columns unwrapped.
    scope:
      abbrevs = self.abbrevs() or {}

      columns = []
      for cdata in self.columns():
        newdata = copy.copy(cdata)
        newdata.pop('minwidth', None)
        atitle = abbrevs.get(newdata['header'], None)
        if atitle:
          newdata['header'] = atitle
        columns.append(newdata)
      ouid = self.uid()
      uid = None if ouid is None else ouid + '-unwrapped'

      rawrows = []
      for row in self.rows():
        data = row.data()
        if not data[0]:
          /# First column is empty, which indicates that this is not a real
          /# row, but rather that subsequent columns are wrapped text from
          /# previous row. We are to append all such strings to previous.
          if not rawrows:
            raise Error(
              'Table %s has an empty first column of first row' %
              self.fqn())
          prev_row = rawrows[-1]
          for i in range(1, len(data)):
            if data[i]:
              prev_row[i] += ' ' + data[i]
        else:
          rawrows.append(data[:])

      cls = self.__class__
      result = cls(
        /# TODO(wmh): Should the table have same parent, or null?
        self.parent(),
        columns,
        rawrows,
        prelines=self.prelines(),
        title=self.title(),
        csscls=self.csscls(),
        uid=uid)
      return result
    test:
      wtbl = test.table2.unwrapped()
      test.isinst(wtbl, metax.lib.markdown.Table)
    end method unwrapped;

  end class Table;

  class Row < Block #:
    A row within a table.

    The conceptual children of a row are the column names (and associated
    values are entries in the row).
  scope:

    field data : @vec<str> #:
      The values of each column within this row.

    lifecycle params:
      var table : Table;
      var columns : vec<str>;
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
        TODO(wmh): Does prelines make any sense for an individual Row?
        I think this was accidentally cut-and-pasted when it shouldn't
        have been. More generally, is Row even needed?
    super (table, prelines=prelines)
    scope:
      self.dataIs(columns)
    end;

    method keys : map #:
      Maps column header names to values for this row.
    scope:
      data = self.data()
      indices = self.parent().indices()
      result = collections.OrderedDict()
      for k in indices:
        result[k] = data[indices[k]]
      return result
    test:
      test.iseq(
        {'Age': '25', 'Fruit': 'Kiwi', 'Name': 'Alice', 'Height': '1.7m'},
        dict(test.row1.keys()))
    end method keys;

    test
    lifecycle setup:
      self.table, _ = self.newTable()
      self.row1 = self.table.rows()[0]
      self.row2 = self.table.rows()[1]
    end lifecycle;

  end class Row;

  class Panel < Block #:
    Currently this is treated as a block, but we will eventually want to parse
    the contents of the panel as a collection of markdown.Object instances, at
    which point it needs to become a subclass of BlockGroup instead of Block.

    For how to add a box around text in Latex, see
      http://tex.stackexchange.com/questions/36524/how-to-put-a-framed-box-around-text-math-environment
  scope:

    field title : str = null #:
      The title associated with the table

    field lines : vec<str> #:
      The lines in the panel. This field will change to something richer when
      we parse lines into markdown.Object instances.

    lifecycle params:
      var parent : Section #:
        The section this list belongs to.
      var lines : vec<str> #:
        The lines making up the panel. No newlines in elements.
        This will change to some richer structure when we parse the contents of
        the panel into markdown.Object instances.
      var prelines : int = 0 #:
        The number of empty lines found before this block started.
      var title -> title = null;
    super (parent, prelines=prelines)
    scope:
      self.linesIs(lines)
    test:
      panel = metax.lib.markdown.Panel(test.subsection, [], title='Testing')
      test.iseq('Testing', panel.title())
    end;

    method isPanel : bool scope:
      return True
    test:
      test.istrue(test.panel2.isPanel())
      test.isfalse(test.table2.isPanel())
    end method isPanel;

  end class Panel;

  class Section < BlockGroup #:
    A consecutive collection of blocks of text. Contains:
     - a title
     - zero or more Block elements
     - zero or more child sections
     - one or zero parent section

    A Section instance with empty title is treated specially (it is not
    allowed to have any block elements, but can have child sections). This
    allows us to use such sections as shams when the text has a '#### section'
    below a '## section' (we insert a '###' sham with empty title).

    Parsing the entire document to completion can sometimes be slower than
    a client might want. An alternative version that involves parsing
    a section into children but delaying parsing of pre-child blocks is
    available. If self.blocks() is null (as opposed to the empty list), it
    indicates the section is not fully parsed. Certain code detects this
    and invokes just-in-time block parsing (in particular, the blocks()
    method).
  assocs:
    std assoc collections;
    std assoc io;
  scope:

    meta
    field AbbrevRe : regexp;

    field parser : Parser #:
      The parser responsible for parsing the section. Stores the label map used
      in url and image reference links. If not provided, label maps cannot be
      searched for. If not defined, we could search up the ancestor chain for
      one that does define parser, but there is no space savings to be had here,
      so it is best to just pass in the parser to every section.

    field title : str #:
      The title associated with this section.

    field abbrev : str #:
      A shorter version of the title. Useable for path-based querying.
      TODO(wmh): Replace this with the newly defined 'uid' field inherited
      from Block.

    field children : @vec<Section> #:
      The ordered collection of child sections

    field depth : int #:
      The depth of this section.  The top-level section (the one without any
      parents) has a depth of 0.  Immediate children of that section have
      depth 1, etc.

    field keys : @map<str,Object> #:
      Maps section/table/panel/paragraph titles to Section/Table/Panel/Paragraph
      instances. Used by find() and child().

    field pagenum : int #:
      The page number that this section starts on

    field tables : map #:
      Maps table titles to Table instances in this section.
    scope:
      accessor get lazy:
        /# We invoke blocks() to trigger jit parsing of blocks, which will
        /# populate tables() if there are any.
        self.blocks()
        tables = self._tables or {}
        -> tables
    end field tables;

    field delayed : tuple<list,int,int> #:
      Information supporting delayed parsing of block-level details within the
      Section. If it exists, it consists of:
       0. lines : vec<str>
            All the lines in the book being parsed
       1. start : int
            Index with parser.lines() that this section is defined at
       2. cstart : int
            Index within parser.lines() of last line before another section
            (whether it is a child, sibling or higher section). The lines
            between start and cstart represent the lines that need to be
            parsed into blocks.

    lifecycle params:
      var parent : Section #:
        The parent section.  Since only the top-most section has a null parent,
        this is a required argument (but may be None).
      var title -> title;
      var abbrev -> abbrev = null;
      var parser -> parser = null;
      var prelines : int = 1 #:
        The number of empty lines found before this block started.
      var pagenum -> pagenum = 0;
      var linenum : int = 0;
      var delayed -> delayed = null;
    super (parent, prelines=prelines, uid=abbrev, linenum=linenum)
    scope:
      self.uidIs(abbrev)
      self.depthIs(0 if not parent else parent.depth() + 1)
    test:
      test.iseq(2, test.subsection.depth())
    clinit:
      cls.AbbrevReIs(re.compile(r'[^a-z]'))
    end lifecycle;

    override
    method blocks : vec<Block> #:
      Obtain my blocks.
    scope:
      /# Inherited from BlockGroup.blocks(), a field declared as @vec<Block>,
      /# which indicates it should never be null. HOWEVER, Parser.parseSection()
      /# intentionally sets the block field to null to indicate that
      /# just-in-time parsing is needed.
      blocks = self._blocks
      if blocks is None:
        if not self.delayed():
          raise Error('blocks() and delayed() should not both be null!')
        blocks = []
        self.blocksIs(blocks)  /# parseLines expects blocks to be initialized!
        parser = self.parser()
        lines, start, end = self.delayed()
        /# We expect both lines[start] and lines[end] to represent sections
        assert lines[start][0] == '#', 'Parser.parseSection not properly initializing Section.delayed: %s' % lines[start]
        assert end >= len(lines) or lines[end][0] == '#', 'Parser.parseSection not properly initializing Section.delayed: %s' % lines[end]
        /# We invoke parser.parseLines
        parser.parseLines(lines, parent=self, line_start=start+1, line_end=end)
      return blocks
    test:
      bookpath = metax.root.Object.Resource(
        'simple_md', fqn='metax.lib.markdown_test.TestCase')
      md = metax.lib.markdown.Parser()
      with open(bookpath, 'r') as ifp:
        book = md.readBook(ifp, fast=True)

      section = book.root().children()[0]
      test.iseq('A Simple Document', section.title())
      test.isnull(section._blocks)

      blocks = section.blocks()
      test.iseq(1, len(blocks))
      bsec = section.children()[0]
      test.iseq('Blocks', bsec.title())
      tmap = {}
      for child in bsec.children():
        blocks = child.blocks()
        tmap[child.title()] = [b.__class__.__name__ for b in blocks]
      test.iseq(
        {
          'Paragraphs': ['Paragraph', 'Paragraph'],
          'HTML': ['Paragraph', 'HTML'],
          'Blockquote': ['Paragraph', 'Quote'],
          'Code': ['Paragraph', 'Code', 'Paragraph', 'Code', 'Paragraph'],
          'Tables': ['Paragraph', 'Table'],
          'Panels': ['Paragraph', 'Panel'],
          'Lists': ['Paragraph', 'List', 'Paragraph', 'List', 'Paragraph', 'List'],
        },
        tmap)

      /# We obtain the very last section in the page, and ensure blocks() works
      /# for it.
      /#  - fragile test code ... if I add a new subsection to simple.md then
      /#    this won't test what it intends to (and obtaining the true last
      /#    section is a bit complicated (but is easy with visit() I suppose.
      section2 = book.root().children()[1]
      test.iseq('And another top-level section', section2.title())
      test.iseq(
        [
          'Does this get parsed too?\n'
          'DO NOT ADD MORE SECTIONS BELOW THIS '
          '(test code relies on this being the last section)'
        ],
        [b.asStr() for b in section2.blocks()])
    end method blocks;

    method root : Section #:
      Obtain the ancestor section without a parent.
    scope:
      result = self
      while result.parent():
        result = result.parent()
      return result
    test:
      test.iseq('TheBook', test.table2.parent().root().title())
    end method root;

    method addTable #:
      Add a table to myself.
    params:
      var table : Table;
    scope:
      tables = self.tables()
      if tables is None:
        tables = collections.OrderedDict()
        self.tablesIs(tables)
      tables[table.title()] = table
    test:
      section = test.root.newChild(title='Section 1')
      test.iseq({}, section.tables())
      section.addTable(test.table2)
      test.iseq(['Fruit'], sorted(section.tables()))
    end method addTable;

    method xtitle : str #:
      Return title annotated with uid if present.
    scope:
      result = self.title()
      uid = self.uid()
      if uid:
        result += ' [=' + uid + ']'
      return result
    test:
      section = test.subsection
      test.iseq('SubSection A [=suba]', section.xtitle())
      section.uidIs('newuid')
      test.iseq('SubSection A [=newuid]', section.xtitle())
    end method xtitle;

    protected
    method register #:
      Register the given object with myself.  Registration provides means of
      finding this child within myself by the following strings:
       - the title, as provided by the user (all sections have titles, but
         not all Text instances do).
       - the abbrev, as provided by the user (many sections do not have abbrevs,
         and as of yet, no text objects have abbrevs).
       - a canonical representation of title, lowercase, with all non-alpha
         characters (whitespace, punctuation, etc.) deleted (only added if
         no abbrev was specified).
    params:
      var obj : Object;
    scope:
      keys = self.keys()
      title = obj.title()
      if title is not None:
        if title in keys:
          /# NOTE: A Section contains zero or more blocks, and then zero or more
          /# children. Blocks can have titles (added to self.keys()), and
          /# child sections obvious have titles. It is possible for there to be
          /# a block and child with the same title, so the order in which we
          /# process them determines which is grabbed.
          /#  - we prioritize child sections over titled blocks.
          if not obj.isSection() and keys[title].isSection():
            /# We prioritize child sections over title blocks
            pass
          else:
            print(
              'WARNING: Found "%s" as %s being replaced with %s in %s' % (
                title, keys[title].__class__.__name__, obj.__class__.__name__, self.source()))
            keys[title] = obj
        else:
          keys[title] = obj

      if False:
        /# Expeirmenting with phasing abbrev support out in interests of
        /# parsing efficiency.
        abbrev = obj.abbrev()
        if abbrev:
          keys[abbrev] = obj
          /# print('title=%s abbrev=%s' % (title, abbrev))
        elif title:
          canonical = re.sub(self.__class__._AbbrevRe, '', title.lower())
          /# print('title=%s canonical=%s' % (title, canonical))
          keys[canonical] = obj
    test:
      section = test.subsection
      test.iseq(0, len(section.keys()))

      /# Creating a subsection with parent does NOT implicitly register child.
      sec = metax.lib.markdown.Section(
        section, title='A New Beginning', abbrev='sec1', parser=self.md)
      test.iseq(0, len(section.keys()))

      /# Explicitly registering works.
      section.register(sec)
      test.iseqvec(['A New Beginning'], sorted(section.keys()))
    end method register;

    method isSection : bool scope:
      return True
    test:
      test.istrue(test.section.isSection())
    end method isSection;

    method isParsingList : bool #:
      True if the last block in this section is a list.
    scope:
      block = self.lastBlock()
      return block and block.isList()
    test:
      test.makeLists()
      section = test.section
      test.iseq(0, len(section.blocks()))
      test.isfalse(section.isParsingList())
      section.addBlock(test.p1)
      test.isfalse(section.isParsingList())
      section.addBlock(test.ul)
      test.istrue(section.isParsingList())
    end method isParsingList;

    method lastBlock : Block #:
      The last block in this section.
    scope:
      blocks = self.blocks()
      return blocks[-1] if blocks else None
    test:
      section = test.subsection
      test.isnull(section.lastBlock())
      section.addBlock(test.p1)
      test.issame(test.p1, section.lastBlock())
    end method lastBlock;

    method addBlock : Block #:
      Add a text object to myself.
    params:
      var block : Block;
    scope:
      /# accessors optimized away because profiling says this method is
      /# surprisingly expensive. Avoiding title() and blocks() took the
      /# cost from 6us to 4us per call.
      if self._title:
        self._blocks.append(block)
        self.register(block)
      else:
        print('**** PROBLEM: %s' % self.fulltitle())
        /# raise Error('A section with empty title cannot have any blocks.')
      return block
    test:
      section = test.subsection
      test.iseq(0, len(section.blocks()))

      /# Creating a block does NOT implicitly add the block to its parent
      para = metax.lib.markdown.Paragraph(
        section, 'This is a simple paragraph\non two lines.')
      test.iseq(0, len(section.blocks()))

      /# Explicitly adding the block properly updates the blocks() field.
      section.addBlock(para)
      test.iseq(1, len(section.blocks()))
    end method addBlock;

    method child : Section #:
      Obtain an immediate child by child title.
    params:
      var title : str #:
        The title of the child.
    scope:
      result = self.keys().get(title, None)
      /# TODO(wmh): Is it possible the result is NOT a section? Should we return
      /# null if it is not?
      if result and not result.isSection():
        print(
          '************ metax.lib.markdown.Section.child: HERE with %s' % result)
        result = None
      return result
    test:
      test.isinst(
        test.section.child('SubSection A'), metax.lib.markdown.Section)
    end method child;

    method addChild #:
      Add a child section to myself.
    params:
      var section : Section;
    scope:
      self.children().append(section)
      self.register(section)
    test:
      section = test.subsection
      test.iseq(0, len(section.children()))

      /# Creating a Section (and specifying a parent) does NOT implicitly
      /# register the child with the parent.
      sssec = metax.lib.markdown.Section(
        section, title='A New Beginning', parser=self.md)
      test.iseq(0, len(section.children()))

      /# Explicitly adding the child works.
      section.addChild(sssec)
      test.iseq(1, len(section.children()))
    end method addChild;

    method newChild : Section #:
      Create a new section within myself.
    params:
      var title : str;
      var abbrev : str = null;
      var prelines : int = 1 #:
        The number of prelines before the to-be-created section.
      var pagenum : int = 0 #:
        Page number of the start of the child
      var linenum : int = 0 #:
        Line number (starting from 1) of start of the child within source file
    scope:
      child = metax.lib.markdown.Section(
        self, title=title, abbrev=abbrev, parser=self.parser(),
        prelines=prelines, pagenum=pagenum, linenum=linenum)
      self.addChild(child)
      return child
    test:
      section = test.subsection
      test.iseq(0, len(section.children()))
      child = section.newChild('A New Beginning', abbrev='new')
      test.iseq(1, len(section.children()))
    end method newChild;

    method mapChildren : map<str,Section> #:
      Obtain a mapping from child title to child Section
    scope:
      result = {}
      for child in self.children():
        result[child.title()] = child
      return result
    test:
      test.iseq(
        ['SubSection A', 'SubSection/B'],
        sorted(test.section.mapChildren()))
    end method mapChildren;

    method blocksByTitle : omap #:
      Partition all blocks of this section into groups based on which Paragraph
      elements have titles.

      Returns:
        ordered map from paragraph title to
         - list of Block (if raw is false)
         - list of str (if raw is true)
        if there are blocks before the first one with a title, they are added
        under key '__pre__' unless nopre is true
    params:
      var raw : bool = false #:
        If true, each value returned is a vec<str> not vec<Block>. The strings
        represent text with newlines replaced with spaces.
      var nopre : bool = false #:
        If true, do not put a __pre__ key in the result for the initial
        collection of untitled blocks
      var tdelim : str = '**' #:
        What appears before and after the title.
      var tsep : str = '[:.]\\s*' #:
        What appears after the title before the text
    scope:
      key = '__pre__'
      current = []
      result = collections.OrderedDict()
      result[key] = current
      for block in self.blocks():
        if isinstance(block, Paragraph):
          title, text = block.titleAndText(tdelim=tdelim, tsep=tsep, raw=raw)
          if title:
            key = title
            current = []
            if key in result:
              print('WARNING: "%s" repeats' % key)
            result[key] = current

          if raw:
            /# We are to add a raw value to current, not a Block
            current.append(text)
          else:
            current.append(block)

        elif isinstance(block, List):
          /# We add an ordered dict to current, representing a grouping of
          /# list items by those that contain titles.
          current.append(
            block.blocksByTitle(
              raw=raw, nopre=nopre, tdelim=tdelim, tsep=tsep))

        else:
          if raw:
            /# We ignore blocks that aren't Paragraph or List in raw mode
            pass
          else:
            current.append(block)

      if nopre:
        result.pop('__pre__', None)

      return result
    test:
      simple = test.parseMarkdown(
        'simple_md', parser=metax.lib.markdown.Parser())
      section = simple.find('A Simple Document/Titled Blocks')

      test.iseq(
        collections.OrderedDict([
          ('__pre__', [
           'It is sometimes useful to parse a section by title blocks, as in this example.',
          ]),
          ('Light Green', [
           'This is an initial titled paragraph',
           'With a second untitled paragraph afterward.',
          ]),
          ('Red', [
            'And this is another titled paragraph.',
            'With a second paragraph and third list.',
             collections.OrderedDict([
               ('Light', ['simple para.']),
               ('Dark', ['another simple', 'With second para']),
               ('Medium', ['third.']),
               ('__pre1__', ['list item with no title.'])
             ]),
          ]),
        ]),
        section.blocksByTitle(raw=True))
    end method blocksByTitle;

    method newNextSection : Section #:
      Create a Section to represent text after this section.  The result
      may or may not be a child of self, depending on 'depth'.
    params:
      var depth : int #:
        What section level (between 1 and 6 inclusive).
      var title : str #:
        The title (including abbrev if present).
      var debug : bool = false #:
        Enable debugging if true.
        TODO(wmh): Delete this param.
      var prelines : int = 0 #:
        The number of prelines before the to-be-created section.
      var pagenum : int = 0 #:
        The page number of the start of the new section.
      var linenum -> linenum = 0;
    scope:
      current_depth = self.depth()
      current_section = self
      /# are: title/abbrev portion of a section header
      are = Parser.Abbrev_re

      /# I have not been using section abbrevs, and this is an expensive method
      /# so I've optimized abbrev support away. However, as of 2025-03-27 I
      /# am considering reinstating it.
      assert '[=' not in title, title
      abbrev = None
      if False:
        am = are.match(title)
        if am:
          abbrev = am.group('abbrev')
          print('Found abbrev "%s" in title %s' % (abbrev, title))
          title = am.group('title')

      /# We need to establish the parent section of the new section, which
      /# we'll call the target.
      if depth <= current_depth:
        /# The target is an ancestor of current_section
        target = current_section.parent()
        dd = depth
        while dd < current_depth:
          target = target.parent()
          dd += 1
      elif depth == current_depth + 1:
        /# We have an immediate child of the current section.
        target = current_section
      else:
        /# depth > current_depth + 1.
        /# We have a section that is a non-immediate child of the current
        /# section, which suggests a formatting issue (but sometimes it
        /# is useful to allow such situations, and we can insert dummy
        /# sections in between).
        assert depth > current_depth + 1
        cb = current_section
        dd = depth
        while dd != current_depth + 1:
          cb = cb.newChild('')
          dd -= 1
        target = cb

      if debug:
        print(
          'Line %4d: section start (target=%s abbrev=%s title=%s)' %
          (lnum, target, abbrev, title))

      current_section = target.newChild(
        title, abbrev=abbrev, prelines=prelines,
        pagenum=pagenum, linenum=linenum)
      assert current_section.depth() == depth
      return current_section

    test:
      section = test.subsection
      test.iseq(2, section.depth())

      section2 = section.newNextSection(2, 'Testing')
      test.issame(section.parent(), section2.parent())

      section3 = section.newNextSection(3, 'SubBegin')
      test.issame(section, section3.parent())
    end method newNextSection;

    method fulltitle : str #:
      The fully qualified title of this section.
    scope:
      parts = []
      obj = self
      while obj is not None:
        title = obj.title() or ''
        parts.append(title.replace('/', '\\/'))
        obj = obj.parent()
      return '/'.join(reversed(parts))
    test:
      test.iseq('/Section 1/SubSection A', test.subsection.fulltitle())
      test.iseq('/Section 1/SubSection\\/B', test.subsection2.fulltitle())
    end method fulltitle;

    method source : str #:
      Returns the source page and page number of this section.
    scope:
      root = self.root()
      pstr = ('%3d' % self.pagenum()).replace(' ', '-')
      return '%s-%s' % (root.title(), pstr)
    test:
      test.iseq('TheBook---2', test.table2.parent().source())
    end method source;

    method visit #:
      Visit every leaf block in this section depth-first and apply the given
      function to each block.
    params:
      var function : function = null #:
        The function to apply to blocks. It accepts a block index, Block, Sink,
        and an arbitrary opaque object.
      var sfunction : function = null #:
        The function to apply to sections. It accepts a Section, Sink, and an
        arbitrary opaque object.
      var sink : metax.io.Sink = sout #:
        Where to write info.
      var opaque : any = null #:
        Arbitrary object useable within the function.
    scope:
      if sfunction:
        sfunction(self, sink, opaque)
      if function:
        for bi, block in enumerate(self.blocks()):
          assert block.parent() is self
          /# NOTE: Added 'bi' as a first arg on 2020-11-26, which will break
          /# any clients using this method.
          function(bi, block, sink, opaque)
      for child in self.children():
        if child.isSection():
          child.visit(
            function=function, sfunction=sfunction, sink=sink, opaque=opaque)
    test:
      chars = []
      def Add(obj):
        chars.append(len(obj.text()))
      test.section.visit(Add)
      /# TODO(wmh): Why is this empty?
      test.iseq([], chars)
    end method visit;

    method walk #:
      Visit every subsection (recursively), invoking function on each and
      adding the child to result if the function returns true. Also applies
      to self.
    params:
      var function : function #:
        A function accepting a Section that returns true if it is to be added
        to result, false otherwise.
      var result : vec<Section> #:
        Where to write matches.
    scope:
      if function(self):
        result.append(self)
      for child in self.children():
        child.walk(function, result)
    test:
      /# This filter will selection 'Section 1' and 'SubSection A', but not
      /# 'SubSection/B'.
      def Filt(section):
        return 'tion ' in section.title()
      section = test.section
      result = []
      section.walk(Filt, result)
      test.iseq(
        ['Section 1', 'SubSection A'],
        [s.title() for s in result])
    end method walk;

  end class Section;

  class Book #:
    A repository for multiple top-level files.
  assocs:
    std assoc collections;
  scope:

    field root : Section #:
      The top-level section in the book. This has the book name as its title.
      It is critically important that we NOT remove this section unless we
      provide some other way for an arbitrary child section to establish
      the book it belongs to. Currently, any Section can invoke
      self.root().title(), which searches up to this root section and returns
      its title (the name of the book).

    field name : str #:
      The name of the book.

    field uid : str #:
      The uid of the book. Only needed if support for logging readable elements
      is desired. The https://metaxy.appspot.com/qs/book app sends ajax

    field parser : Parser;

    field tables : map #:
      Mapping from table title to Table instance.

    field panels : map #:
      Mapping from panel title to Panel instance.

    field path : str #:
      Where the book resides on disk. May be null.

    lifecycle params:
      var name -> name;
      var parser -> parser;
      var path -> path = null;
      var uid -> uid = null;
    scope:
      root = Section(None, title=name, parser=parser)
      self.rootIs(root)
      parser.bookIs(self)
      tables = collections.OrderedDict()
      self.tablesIs(tables)
      panels = collections.OrderedDict()
      self.panelsIs(panels)
    clinit:
      cls.KaplanStyle = """\
        >|<style>
        >|  .kaplan_book {
        >|    width: 800px;
        >|    border: 1px solid black;
        >|    margin-left: auto;
        >|    margin-right: auto;
        >|    padding: 0px 10px;
        >|    background-color: #eee;
        >|  }
        >|  .kaplan_reading {
        >|    border: 1px solid blue;
        >|    font-size: 130%;
        >|    background-color: white;
        >|    padding: 10px;
        >|  }
        >|</style>
        >|"""

      cls.KaplanScript = """\
        >|<script>
        >|  document.onkeydown = checkKey;
        >|
        >|  // We need a unique identifier for the person reading the book if
        >|  // we want to log reading events, notes, etc. For now, this
        >|  // identifier comes from the 'pid' param of the url (but will change
        >|  // when we have the ability to establish who is currently logged in)
        >|  // For info on parsing url, see:
        >|  //  - https://developer.mozilla.org/en-US/docs/Web/API/Location
        >|  //  -  https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
        >|  var usp = new URLSearchParams(window.location.search.substring(1));
        >|  var PersonId = usp.get('pid');
        >|  if (!PersonId) {
        >|     PersonId = prompt('Reader ID: ');
        >|  }
        >|
        >|  // The Google Book Id of the book being read
        >|  var BookId = '${BookId}';
        >|
        >|  // The webapp to send RPCs to
        >|  var WebApp = 'https://metaxy.appspot.com/qs/book';
        >|
        >|  // The HTML ids of elements we can scroll through.
        >|  var IdList = ${IdList};
        >|  var N = IdList.length;
        >|
        >|  // Current index within IdList
        >|  var Index = 0;
        >|
        >|  // Current pending record-index-if-there-for-awhile
        >|  var PendingEventLogger = null;
        >|
        >|  // Generic method for sending data to http://metaxy.appspot.com/qs/book
        >|  function SendRPC(action, params) {
        >|    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send
        >|    let url = WebApp + '/' + action;
        >|    let xhr = new XMLHttpRequest();
        >|    xhr.open('POST', url, true);
        >|    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        >|    xhr.onreadystatechange = () => {
        >|      // Call a function when the state changes.
        >|      if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
        >|        // Request finished. Do processing here.
        >|      } else {
        >|        console.log('Here with state ' + xhr.readyState + ' and status ' + xhr.status);
        >|      }
        >|    };
        >|    params['pid'] = PersonId;
        >|    params['bid'] = BookId;
        >|    let usp = new URLSearchParams(params);
        >|    let uspstr = usp.toString();
        >|    console.log('Sending RPC: ' + url + '?' + uspstr);
        >|    // TODO(wmh): Get the WebApp set up so it can accept ajax sends.
        >|    // xhr.send(uspstr);
        >|  }
        >|
        >|  // Send to server a 'reading <eid>' event
        >|  function RecordReadable() {
        >|    let eid = IdList[Index];
        >|    // Make an ajax call to
        >|    //   https://metaxy.appspot.com/qs/book/read?id=<BookId>&eid=<eid>
        >|    SendRPC('reading', {eid: eid});
        >|  }
        >|
        >|  // How to advance (or go back) one displayable element
        >|  function Move(delta, confirmed) {
        >|    // We are to advance forward (delta > 0) or backward (delta < 0)
        >|    // in the list of readable elements.
        >|    //   delta : int
        >|    //     how far to advance (almost always 1 or -1)
        >|    //   confirmed : bool
        >|    //     if true, the current readable was definitely read.
        >|
        >|    // If there is a pending event logger, we clear it, as the
        >|    // reader has moved on from that previous readable element
        >|    // too quickly to be considered a real read.
        >|    if (PendingEventLogger) {
        >|      // https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout
        >|      clearTimeout(PendingEventLogger);
        >|      PendingEventLogger = null;
        >|    }
        >|
        >|    // Adjust current element
        >|    var cid = IdList[Index];
        >|    var current = document.getElementById(cid);
        >|    if (!current) {
        >|      alert('Failed to find ' + cid);
        >|      return;
        >|    }
        >|    current.classList.remove('kaplan_reading');
        >|    if (confirmed) {
        >|      // TODO(wmh): Do we send a 'read' (vs 'reading') RPC?
        >|      // SendRPC('read', {eid: cid});
        >|      console.log('confirmed read of ' + cid);
        >|    }
        >|
        >|    // delta is integer adjustment relative to current index
        >|    Index = (((Index + delta) % N) + N) % N;
        >|    let id = IdList[Index];
        >|    let elem = document.getElementById(id);
        >|    elem.classList.add('kaplan_reading');
        >|    elem.scrollIntoView({
        >|      // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView#parameters
        >|      behavior: 'instant',
        >|      block: 'start',
        >|      inline: 'nearest',
        >|    });
        >|    window.scrollBy(0, -200);
        >|
        >|    // Schedule the logging of a read event for 5 seconds in the future
        >|    //  - https://developer.mozilla.org/en-US/docs/Web/API/setTimeout
        >|    PendingEventLogger = setTimeout(RecordReadable, 5000);
        >|  }
        >|
        >|  function checkKey(e) {
        >|    e = e || window.event;
        >|    var key = e.key;
        >|    if (key == 'j') {
        >|      // console.log('next');
        >|      Move(1);
        >|    } else if (key == ' ') {
        >|      // space is like next but is also an explicit indication that
        >|      // the readable element was read and processed.
        >|      Move(1);
        >|      e.preventDefault();
        >|    } else if (key == 'k') {
        >|      // console.log('prev');
        >|      Move(-1);
        >|    } else if (key == '.') {
        >|      let note = prompt('Summary: ');
        >|      let eid = IdList[Index];
        >|      // Send this note to
        >|      //   https://metaxy.appspot.com/qs/book/summarize?id=<BookId>&pos=<eid>&note=<note>
        >|      SendRPC('summarize', {eid: eid, note: note});
        >|    } else if (key == 'Enter') {
        >|      // console.log('enter');
        >|    } else {
        >|    }
        >|  }
        >|</script>
        >|"""
    setup:
      test.book2 = metax.lib.markdown.Book('test', test.book.parser())
    end;

    method find : Object #:
      Find an Object by fully qualified title path.
    params:
      var spec : str #:
        The fully qualified title to search for.
    scope:
      return self.root().find(spec)
    test:
      book = test.book
      test.isinst(
        book.find('A Simple Document/Blocks/HTML'), metax.lib.markdown.Section)
    end method find;

    method showToc #:
      Print out the table of contents
    params:
      var sink : metax.io.Sink #:
        Where to write output.
    scope:
      root = self.root()
      /# TODO(wmh): Implement this.
    test:
      sink = metax.io.Sink()
      test.book.showToc(sink=sink)
    end method showToc;

    method registerTable #:
      Add a table to the book.
    params:
      var table : Table;
      var location : tuple<str,int> #:
        Path and line number of start of table.
    scope:
      tables = self.tables()
      title = table.title()
      current = tables.get(title, None)
      if current:
        if isinstance(current, Section):
          /# An indication that the table needs to be parsed. This method is
          /# updating the Section to a Table, so no warning is printed.
          pass
        else:
          print(
            'Found repeated table "%s" at line %d of %s' %
            (title, location[1], location[0]))
      tables[title] = table
    test:
      book = test.book
      book2 = test.book2

      table = test.table2
      test.iseq([], list(book2.tables()))
      book2.registerTable(table, ('/some/path', 37))
      test.iseq(['Fruit'], list(book2.tables()))
    end method registerTable;

    method registerPanel #:
      Add a panel to the book.
    params:
      var panel : Panel;
      var location : tuple<str,int> #:
        Path and line number of start of panel.
    scope:
      assert isinstance(panel, Panel)
      panels = self.panels()
      title = panel.title()
      current = panels.get(title, None)
      if current:
        if isinstance(current, Section):
          /# An indication that the panel needs to be parsed. This method is
          /# updating the Section to a Panel, so no warning is printed.
          pass
        else:
          print(
            'Found repeated panel "%s" at line %d of %s' %
            (title, location[1], location[0]))
      panels[title] = panel
    test:
      book = test.book
      book2 = test.book2

      panel = test.panel2
      test.iseq([], list(book2.panels()))
      book2.registerPanel(panel, ('/some/path', 37))
      test.iseq(['Example Panel'], list(book2.panels()))
    end method registerPanel;

    method tablesMatching : vec<Table> #:
      Find a table by title.
    params:
      var title_restr : str #:
        A regexp to apply to table titles.
    scope:
      result = []
      title_re = re.compile(title_restr, re.I)
      tables = self.tables()
      for title, table in tables.items():
        if title_re.search(title):
          if isinstance(table, Section):
            /# We need to just-in-time parse the section, which will register
            /# the table into tables properly.
            blocks = table.blocks()
            table = tables[title]
            assert isinstance(table, Table)
          result.append(table)
      return result
    test:
      test.iseq(['Fruit'], [t.title() for t in test.book.tablesMatching('Fru')])
      test.iseq([], test.book.tablesMatching('Blah'))

      /# Now we do delayed parsing and see if just-in-time resolution of tables
      /# works.
      bookpath = metax.root.Object.Resource(
        'simple_md', fqn='metax.lib.markdown_test.TestCase')
      md = metax.lib.markdown.Parser()
      with open(bookpath, 'r') as ifp:
        book = md.readBook(ifp, fast=True)
      test.iseq(['Fruit'], sorted(book.tables()))
      test.isinst(book.tables()['Fruit'], metax.lib.markdown.Section)
      tables = book.tablesMatching(r'^Fru')
      test.iseq(['Fruit'], [t.title() for t in tables])
      test.isinst(book.tables()['Fruit'], metax.lib.markdown.Table)
    end method tablesMatching;

    method panelsMatching : vec<Panel> #:
      Find a panel by title.
    params:
      var title_restr : str #:
        A regexp to apply to panel titles.
    scope:
      result = []
      title_re = re.compile(title_restr, re.I)
      panels = self.panels()
      for title, panel in panels.items():
        if title_re.search(title):
          if isinstance(panel, Section):
            /# We need to just-in-time parse the section, which will register
            /# the panel into panels properly.
            blocks = panel.blocks()
            panel = panels[title]
            assert isinstance(panel, Panel)
          result.append(panel)
      return result
    test:
      test.iseq(['Example Panel'], [t.title() for t in test.book.panelsMatching('Exam')])
      test.iseq([], test.book.panelsMatching('Blah'))

      /# Now we do delayed parsing and see if just-in-time resolution of tables
      /# works.
      bookpath = metax.root.Object.Resource(
        'simple_md', fqn='metax.lib.markdown_test.TestCase')
      md = metax.lib.markdown.Parser()
      with open(bookpath, 'r') as ifp:
        book = md.readBook(ifp, fast=True)
      test.iseq(['Example Panel'], sorted(book.panels()))
      test.isinst(book.panels()['Example Panel'], metax.lib.markdown.Section)
      panels = book.panelsMatching(r'nel$')
      test.iseq(['Example Panel'], [t.title() for t in panels])
      test.isinst(book.panels()['Example Panel'], metax.lib.markdown.Panel)
    end method panelsMatching;

    method tableNamed : Table #:
      Return unique table from regexp.
    params:
      var title : str #:
        A regexp to apply to table titles.
      var default : any = False #:
        What to return if the table doesn't exist. If this is False, it is a
        request to raise an exception.
    scope:
      if True:
        tables = self.tables()
        result = tables.get(title, default)
        if result is False:
          raise Error('Failed to find table named "%s"' % title)
        if isinstance(result, Section):
          /# We need to just-in-time parse the section, which will register
          /# the table into tables properly.
          blocks = result.blocks()
          result = tables[title]
          assert isinstance(result, Table)
      else:
        /# What was I thinking?
        tables = self.tablesMatching('^' + title + '$')
        if len(tables) > 1:
          raise Error('Found %d tables for "%s"' % (len(tables), title))
        elif not tables:
          if default is False:
            raise Error('Failed to find table matching "%s"' % title)
          else:
            result = None
        else:
          result = tables[0]
      return result
    test:
      test.isinst(test.book.tableNamed('Fruit'), metax.lib.markdown.Table)
      test.raises(metax.lib.markdown.Error, test.book.tableNamed, 'Blah')
    end method tableNamed;

    method panelNamed : Panel #:
      Return unique panel from regexp.
    params:
      var title : str #:
        A regexp to apply to panel titles.
      var default : any = False #:
        What to return if the panel doesn't exist. If this is False, it is a
        request to raise an exception.
    scope:
      panels = self.panelsMatching('^' + title + '$')
      if len(panels) > 1:
        raise Error('Found %d panels for "%s"' % (len(panels), title))
      elif not panels:
        if default is False:
          raise Error('Failed to find panel matching "%s"' % title)
        else:
          result = None
      else:
        result = panels[0]
      return result
    test:
      test.isinst(test.book.panelNamed('Example Panel'), metax.lib.markdown.Panel)
      test.raises(metax.lib.markdown.Error, test.book.panelNamed, 'Blah')
    end method panelNamed;

  end class Book;

  behavior blobs : vec<str> #:
    Convert this block into a collection of strings suitable for use
    in visit() and other text-based searches.
  scope:

    abstract
    receiver Block;

    receiver BlockGroup ::
      result = []
      for block in self.blocks():
        result.extend(block.blobs())
      return result
    test:
      test.iseq(['Section 1'], test.section.blobs())
    end receiver BlockGroup;

    receiver Paragraph ::
      return [self.text().replace('\n', ' ')]
    test:
      test.iseq(
        [
          'This is an example paragraph containing a few lines '
          'of text including a **bold** word and _italize phrase_.',
        ],
        test.p1.blobs())
    end receiver Paragraph;

    receiver Quote ::
      return [' '.join(self.lines())]
    test:
      test.iseq(
        ['this is a quote spanning two lines'],
        test.quote.blobs())
    end receiver Quote;

    receiver List ::
      result = []
      for item in self.items():
        result.extend(item.blobs())
      return result
    test:
      test.makeLists()
      test.iseq(['Apple', 'Banana', 'Cantelope'], test.ul.blobs())
      test.iseq(['Apple', 'Banana', 'Cantelope'], test.ol.blobs())
    end receiver List;

    receiver Code ::
      return [' '.join(self.lines())]
    test:
      test.iseq(
        ['if a == 1:   return False else:   return True'],
        test.code.blobs())
    end receiver Code;

    receiver HR ::
      return []
    test:
      test.iseq([], test.hr.blobs())
    end receiver HR;

    receiver HTML ::
      return [' '.join(self.lines())]
    test:
      test.iseq(
        ['<p>blah</p>'],
        test.html.blobs())
    end receiver HTML;

    receiver Table ::
      result = []
      title = self.title()
      if title:
        result.append(title)
      for row in self.rows():
        result.extend(row.blobs())
      return result
    test:
      test.iseq(
        ['Fruit', 'Apple', '3', 'Banana', '1', 'Cantelope', '2'],
        test.table2.blobs())
    end receiver Table;

    receiver Row ::
      return self.data()
    test:
      test.iseq(
        ['Alice', '25', '1.7m', 'Kiwi'],
        test.row1.blobs())
    end receiver Row;

    receiver Panel ::
      result = []

      para = []
      for line in self.lines():
        if not line.strip():
          /# empty line.
          if para:
            result.append(' '.join(para))
            para = []
        else:
          para.append(line)
      if para:
        result.append(' '.join(para))

      return result
    test:
      panel = metax.lib.markdown.Panel(
        test.subsection,
        lines=[
          'This is a panel',
          'with short small first paragraph.',
          '',
          '',
          'And a shorter second paragraph.',
        ],
        title='Testing')

      test.iseq('Testing', panel.title())

      test.iseq(
        [
          'This is a panel with short small first paragraph.',
          'And a shorter second paragraph.'
        ],
        panel.blobs())
    end receiver Panel;

    receiver Section ::
      result = []
      title = self.title()
      if title:
        result.append(title)
      for block in self.blocks():
        result.extend(block.blobs())
      return result
    end receiver Section;

  end behavior blobs;

  behavior __repr__ #:
    Printable representationi of object.
  scope:

    receiver Section ::
      return '<Section %s>' % self.fqn()

  end behavior __repr__;

  behavior show #:
    Write an object.
  params:
    var sink : metax.io.Sink = null #:
      Where to write output.
      TODO(wmh): Need to make sink default sout and remove fp/indent when
      code has been migrated.
    var fp : ostream = out #:
      Where to write the object. This should be replaced with sink.
      TODO(wmh): Replace with metax.io.Sink.
    var indent : str = '' #:
      Indentation before each line. This should be replaced with sink.
      TODO(wmh): Replace with metax.io.Sink.
    var aspect : str = 'ascii' #:
      What to show. Valid values are:
        ascii: show text representation
        html: render into HTML
        tex: render into latex
        titles: show only titles (indented by level)
        markdown: recreate the markdown text
    var subaspect : str = null #:
      Introduced 2023-12-30 to support a special form of html (divs around
      each readable element with support for scrolling/annotating elements),
      but will be useful in other contexts too.  Depends on value of 'aspect':
        if 'html':
          kaplan:
            we are to wrap all readable elements in <div id=id> elements
            and provide scrolling/annotating support.
    var parser : Parser = null #:
      The parser instance to use.
    var depth : int = 10000 #:
      Only recurse to children at most 'depth' levels below this one.
      A value of 0 or less means do not show children.
    multi var kwds : map = null #:
      Additional params used only by certain subclasses:

      start : int = 0 #:
        Which depth to start at. Useful for adjusting indentation levels.
      nohead : bool = false (only Section)
        If true, do not insert special header/footer for top-level.
      style : str = null (only Section)
        The CSS to use for html renderings.  If given, it should be an
        HTML <style> tag.
      preamble : str = null (only Section)
        What to insert before the generated text.
        When aspect is HTML, this is inserted after <body> before rest of
        text.
      postamble : str = null (only Section)
        What to insert after the generated text.
        When aspect is HTML, this is inserted just before </body>.
      nofirst : bool = false (only Paragraph)
        If true, and aspect is ascii, do not insert 'indent' before the
        first line of output (but do so for all others).
      mark : str = null (only ListItem)
        Indicates what to use for the list item. It will:
         - start with 0 or more spaces
         - then either '*', '+' or '-' (for unordered lists) or an
           integer followed by '.' (for ordered lists)
         - then at least one space (but maybe more)
        The length of mark is used to determine the indentation of
        subsequent lines/blocks within the listitem.
        Currently only relevant for aspect 'ascii'.
      width : int = 0
        Maximum number of characters to print per line (implies line wrapping).
        If this is 0, the width is determined by term cols.
      concise : bool = false
        If true, sections with empty title and no top-level blocks skip the
        printing of the title and just show children.
      rewriter : function = null #:
        If present, any to-be-printed text is first passed to this function
        (which accepts only the one arg of text and returns a client-specific
        modification of the text). The text may contain newlines.
      ignorepre: bool = false #:
        If true, ignore preline values (do not print n newlines before).
      ignorepre
  scope:

    abstract
    receiver Block;

    receiver BlockGroup ::
      /# TODO(wmh): We may need to provide some support for a prefix before
      /# the first block.
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      for block in self.blocks():
        block.show(
          fp=fp, indent=indent, aspect=aspect, subaspect=subaspect, parser=parser)
    test:
      fp = test.fp()
      test.group.show(fp=fp)
    end;

    receiver Paragraph ::
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      nofirst = kwds.get('nofirst', False)
      width = kwds.get('width', -1)
      rewriter = kwds.get('rewriter', Identity)
      implicit = self.implicit()
      prelines = 0 if kwds.get('ignorepre', False) else self.prelines()
      rawtext = rewriter(self.text())

      if aspect == 'ascii':
        /# width 0 means do not line wrap. width <0 means use terminal width
        if width < 0:
          /# Obtain width from the terminal
          width = Object.TerminalWidth()

        /# Insert initial blank lines as dictated by prelines.
        if prelines:
          fp.write('\n' * prelines)

        if width:
          /# We are to perform line wrapping
          /#  - if there are at least 3 bolded phrases at start of lines in
          /#    rawtext, we format each separately.
          bolds = re.split(r'(?:^|\n)(\*\*[^\*]+\*\*[:.])\s*', rawtext)
          bn = len(bolds)

          if bolds[0] == '' and bn >= 7:
            bi = 1
            while bi < bn:
              part = bolds[bi] + ' ' + bolds[bi+1]
              formatted = textwrap.fill(
                part,
                width=width,
                initial_indent='' if nofirst else indent,
                subsequent_indent=indent)
              fp.write(formatted)
              fp.write('\n')
              bi += 2
          else:
            formatted = textwrap.fill(
              rawtext,
              width=width,
              initial_indent='' if nofirst else indent,
              subsequent_indent=indent)
            fp.write(formatted)
            fp.write('\n')
        else:
          /# We are to keep the lines of the paragraph unwrapped.
          if indent:
            sep = '\n' + indent
            if not nofirst:
              fp.write(indent)
            fp.write(rawtext.replace('\n', sep) + '\n')
          else:
            fp.write(rawtext + '\n')

      elif aspect == 'html':
        if parser is None:
          parser = self.parent().parser()
        text = self.__class__.TextToHtml(rawtext, parser=parser, indent=indent)
        sep = '\n' + indent
        if prelines:
          fp.write('\n' * prelines)

        if subaspect == 'kaplan':
          fp.write(indent + '<div id="%s">\n' % self.genId())

        if implicit:
          fp.write(indent + text.replace('\n', sep) + '\n')
        else:
          fp.write(indent + '<p>' + text.replace('\n', sep) + '</p>\n')

        if subaspect == 'kaplan':
          fp.write(indent + '</div>\n')

      elif aspect == 'tex':
        text = self.__class__.TextToTex(rawtext)
        fp.write(text + '\n')

      else:
        print('ERROR: Unknown aspect %s for Paragraph.show()' % aspect)
    test:
      fp = test.fp()
      test.p2.show(fp=fp, aspect='ascii', width=0)
      test.iseqtext(
        >|"""**Some Title**. This is an example paragraph with a
        >|title (the first one is not titled)
        >|""",
        fp.getvalue())

      fp = test.fp()
      test.p2.show(fp=fp, aspect='ascii', width=80)
      test.iseqtext(
        >|"""**Some Title**. This is an example paragraph with a title (the first one is not
        >|titled)
        >|""",
        fp.getvalue())

      fp = test.fp()
      test.p2.show(fp=fp, aspect='html')
      test.iseqtext(
        >|"""<p><b>Some Title</b>. This is an example paragraph with a
        >|title (the first one is not titled)</p>
        >|""",
        fp.getvalue())
    end receiver Paragraph;

    receiver Quote ::
      author = self.author()
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      prelines = 0 if kwds.get('ignorepre', False) else self.prelines()
      if aspect == 'ascii':
        if prelines:
          fp.write('\n' * prelines)
        for line in self.lines():
          fp.write(indent + line + '\n')
        if author:
          fp.write(indent + '  -- ' + author + '\n')
      elif aspect == 'html':
        if subaspect == 'kaplan':
          fp.write('\n%s<div id="%s">\n' % (indent, self.genId()))
        fp.write('%s<blockquote><em>\n' % indent)
        for line in self.lines():
          fp.write(line[2:] + '\n')
        fp.write(
          '%s</em>%s</blockquote>\n' %
          (indent, '\n<br>&nbsp;&nbsp;&nbsp;-- %s\n' % author if author else ''))
        if subaspect == 'kaplan':
          fp.write('%s</div>\n' % indent)
      elif aspect == 'tex':
        fp.write('Not yet handling blockquotes in tex\n')
      else:
        print('ERROR: Unknown aspect %s for Quote.show()' % aspect)
    test:
      quote = metax.lib.markdown.Quote(test.section, ['> quote', '> more quote'])
      fp = test.fp()
      quote.show(fp=fp)
      test.iseqtext('> quote\n> more quote\n', fp.getvalue())
    end receiver Quote;

    receiver Panel ::
      /# TODO(wmh): When Panel becomes a BlockGroup instead of a Block, it should
      /# be moved and restructured.

      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      prelines = 0 if kwds.get('ignorepre', False) else self.prelines()
      if aspect == 'ascii':
        if prelines:
          fp.write('\n' * prelines)
        fp.write('%sPanel: %s\n\n' % (indent, self.title()))
        for line in self.lines():
          if not line:
            fp.write('\n')
          else:
            fp.write(indent + '    ' + line + '\n')
      elif aspect == 'html':
        if subaspect == 'kaplan':
          fp.write('\n%s<div id="%s">\n' % (indent, self.genId()))
        fp.write('%s<b>Panel: %s</b>\n' % (indent, self.title()))
        fp.write('%s<blockquote>\n' % indent)
        for line in self.lines():
          fp.write(line[2:] + '\n')
        fp.write('%s</blockquote>\n' % indent)
        if subaspect == 'kaplan':
          fp.write('%s</div>\n' % indent)

      elif aspect == 'tex':
        fp.write('Not yet handling blockquotes in tex\n')
      else:
        print('ERROR: Unknown aspect %s for Panel.show()' % aspect)
    test:
      panel = metax.lib.markdown.Panel(
        test.section,
        ['this is a test', 'of panel text', '', 'in two paras'],
        title='A test panel', prelines=1)
      fp = test.fp()
      panel.show(fp=fp)
      test.iseqtext("""\
        >|
        >|Panel: A test panel
        >|
        >|    this is a test
        >|    of panel text
        >|
        >|    in two paras
        >|""",
        fp.getvalue())
    end receiver Panel;

    receiver List ::
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      /# How much spacing before the list item indicator? In the past I've
      /# usually done one space, but I'm looking into using 0 spaces.
      pre_indicator_indent = ''
      prelines = 0 if kwds.get('ignorepre', False) else self.prelines()

      subindent = indent + '  '
      ordered = self.ordered()
      if aspect == 'html':
        tag = 'ol' if ordered else 'ul'
        if prelines:
          fp.write('\n' * prelines)
        fp.write('%s<%s>\n' % (indent, tag))
        for item in self.items():
          item.show(fp=fp, indent=subindent, aspect=aspect, subaspect=subaspect, **kwds)
        fp.write('%s</%s>\n' % (indent, tag))
      elif aspect == 'ascii':
        /# For ascii, the amount of extra indentation (beyond 'indent') is
        /# customizable, and depends on various things. First, let's consider
        /# the case where we want text on subsequent lines within an item
        /# to align with the column on which the text appears in the first
        /# line. This requires us to know how many characters are needed for
        /# the "list item indicator".
        /#  - how much whitespace do we want inserted before the list item
        /#    indicator (usually 0 or 1)?
        /#  - how many characters in the list indicator (1 for unordered lists,
        /#    but can be 1, 2, 3 or more for large ordered lists ... depends
        /#    on list size).
        /#  - ordered lists have a '.' after the number
        /#  - there must be at least one space after the indicator.
        items = self.items()
        if ordered:
          nitems = len(items)
          largest_num = int(self.mark()) + nitems
          num_digits = int(math.log10(largest_num)+1)
          /# Create a format that will accept a 'num' parameter representing
          /# the number of the ordered list item ... instantiating should
          /# produce the number with appropriate spaces before and after.
          /# Note that left-justifying the number will require a different
          /# mechanism because the '.' has to appear immediately after the
          /# last digit.  Using right justification will break if the result
          /# has 4 or more spaces before the number (that will get interpreted
          /# as a code block not a lit).
          mark_format = '%s%%(num)%dd. ' % (pre_indicator_indent, num_digits)
        else:
          mark_format = '%s%s ' % (pre_indicator_indent, self.mark())
          /# If we want to enforce a certain amount of indentation, we
          /# can add additional spaces to mark_format.

        if prelines:
          fp.write('\n' * prelines)
        for i, item in enumerate(items):
          if ordered:
            mark = mark_format % {'num': (i + int(self.mark()))}
          else:
            mark = mark_format
          kwds['mark'] = mark
          item.show(fp=fp, indent=indent, aspect=aspect, subaspect=subaspect, **kwds)
      elif aspect == 'tex':
        fp.write('List.show() not implemented for aspect=%s\n' % aspect)
      elif aspect == 'markdown':
        fp.write('List.show() not implemented for aspect=%s\n' % aspect)
      else:
        print('ERROR: Unknown aspect %s for List.show()' % aspect)
    test:
      test.makeLists()

      fp = test.fp()
      test.ul.show(fp=fp, aspect='html')
      test.iseqtext(
        >|"""<ul>
        >|  <li>
        >|  Apple
        >|  </li>
        >|  <li>
        >|  Banana
        >|  </li>
        >|  <li>
        >|  Cantelope
        >|  </li>
        >|</ul>
        >|""",
        fp.getvalue())
    end receiver List;

    receiver ListItem ::
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      mark = kwds.get('mark', None)
      parent = self.parent()

      if aspect == 'ascii':
        /# Things are complicated here by the fact that we need to print out
        /# a list-item indicator at the start of the first block, and indent
        /# each additional block appropriately.
        /#  - we require that the first block of a ListItem be a Paragraph,
        /#    and add a special 'nofirst' param that knows not to insert
        /#    indentation before first line.
        /#  - blocks are indented using subindent = indent + extra_dent
        if mark is None: mark = ' ? '
        extra_dent = len(mark)
        subindent = indent + (' ' * extra_dent)
        prelines = 0 if kwds.get('ignorepre', False) else self.prelines()
        /# width 0 means do not line wrap. width <0 means use terminal width
        width = kwds.get('width', -1)

        if prelines:
          fp.write('\n' * prelines)
        for i, block in enumerate(self.blocks()):
          if i == 0:
            /# This is the first block in the listitem, so we add the listitem
            /# indicator.
            if not block.isPara():
              print(
                'ERROR: Expecting paragraph but found %s in %s' %
                (type(block), block.ancestorSection().fulltitle()))
              fp.write('PROBLEM!\n')
            else:
              fp.write(indent + mark)
              block.show(
                fp=fp, indent=subindent, aspect=aspect, subaspect=subaspect, nofirst=True, **kwds)
          else:
            block.show(fp=fp, indent=subindent, aspect=aspect, subaspect=subaspect, **kwds)

      elif aspect == 'tex':
        fp.write('ListItem.show() for aspect text not yet implemented\n')

      elif aspect == 'html':
        liattrs = ''
        if subaspect == 'kaplan':
          liattrs = ' id="%s"' % self.genId()
        fp.write('%s<li%s>\n' % (indent, liattrs))
        blocks = self.blocks()
        if len(blocks) == 1:
          block = blocks[0]
          if block.prelines() == 0:
            block.implicitIs(True)
          kwds = {'fp': fp, 'indent': indent, 'aspect': aspect}
          block.show(**kwds)
        else:
          for block in blocks:
            block.show(fp=fp, indent=indent, aspect=aspect, subaspect=subaspect, **kwds)
        fp.write('%s</li>\n' % indent)

      elif aspect == 'markdown':
        pass

      else:
        print('ERROR: Unknown aspect %s for ListItem.show()' % aspect)
    test:
      test.makeLists()

      fp = test.fp()
      test.item3.show(fp=fp, aspect='ascii')
      test.iseqtext(' ? Cantelope\n', fp.getvalue())

      fp = test.fp()
      test.item3.show(fp=fp, aspect='html')
      test.iseqtext('<li>\nCantelope\n</li>\n', fp.getvalue())
    end receiver ListItem;

    receiver Code ::
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      rewriter = kwds.get('rewriter', Identity)
      prelines = 0 if kwds.get('ignorepre', False) else self.prelines()
      lines = self.lines()
      if aspect == 'html':
        if prelines:
          fp.write('\n' * prelines)

        if subaspect == 'kaplan':
          fp.write('\n%s<div id="%s">\n' % (indent, self.genId()))

        lang = self.language()
        if lang is None:
          /# The indented form
          fp.write('%s<pre><code>' % indent)
          for line in lines:
            if line:
              assert line.startswith('    ')
              /# TODO(wmh): Use translate instead of multiple replace calls()
              codeline = rewriter(line[4:]).replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
              fp.write(codeline + '\n')
            else:
              fp.write('\n')
        else:
          /# The quoted form.
          cstr = ' class="%s"' % lang if lang else ''
          fp.write('%s<pre><code%s>' % (indent, cstr))
          for line in lines:
            /# TODO(wmh): Use translate instead of multiple replace calls()
            codeline = rewriter(line).replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
            fp.write(codeline + '\n')
        fp.write('</code></pre>\n')

        if subaspect == 'kaplan':
          fp.write('%s</div>\n' % indent)

      elif aspect == 'ascii':
        if prelines:
          fp.write('\n' * prelines)
        lang = self.language()
        if lang is None:
          /# The indented form
          for line in lines:
            assert line.startswith('    ') or not line
            newline = rewriter(line) if rewriter else line
            /# TODO(wmh): Decide whether to keep the 4 spaces of indentation,
            /# or strip them. The important semantics here is that unlike
            /# paragraphs, these lines are not wrapped.
            fp.write(indent + newline + '\n')
        else:
          /# The quoted form.
          fp.write('%s~~~%s\n' % (indent, lang))
          for line in lines:
            fp.write(indent + line + '\n')
          fp.write('%s~~~\n' % indent)

      elif aspect == 'tex':
        fp.write('%sFIX tex CODE\n' % indent)
      elif aspect == 'markdown':
        fp.write('%sFIX markdown CODE\n' % indent)
      else:
        print('ERROR: Unknown aspect %s for Code.show()' % aspect)
    test:
      fp = test.fp()
      test.code.show(fp=fp, aspect='ascii')
      test.iseqtext(
        '~~~python\n'
        'if a == 1:\n'
        '  return False\n'
        'else:\n'
        '  return True\n'
        '~~~\n',
        fp.getvalue())

      fp = test.fp()
      test.code.show(fp=fp, aspect='html')
      test.iseqtext(
        '<pre><code class="python">if a == 1:\n'
        '  return False\n'
        'else:\n'
        '  return True\n'
        '</code></pre>\n',
        fp.getvalue())
    end receiver Code;

    receiver HR ::
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      prelines = 0 if kwds.get('ignorepre', False) else self.prelines()
      if aspect == 'html':
        if prelines:
          fp.write('\n' * prelines)
        fp.write('%s<hr/>\n' % indent)
      elif aspect == 'ascii':
        if prelines:
          fp.write('\n' * prelines)
        fp.write('%s%s\n' % (indent, '-' * (70 - len(indent))))
      elif aspect == 'tex':
        fp.write('%s\\hline\n' % indent)
      elif aspect == 'markdown':
        fp.write('%s%s' % (indent, self.text()))
      else:
        print('ERROR: Unknown aspect %s for HR.show()' % aspect)
    test:
      fp = test.fp()
      test.hr.show(fp=fp, aspect='ascii')
      test.iseq(
        '\n----------------------------------------------------------------------\n',
        fp.getvalue())

      fp = test.fp()
      test.hr.show(fp=fp, aspect='html')
      test.iseq('\n<hr/>\n', fp.getvalue())
    end receiver HR;

    receiver HTML ::
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      prelines = 0 if kwds.get('ignorepre', False) else self.prelines()
      lines = self.lines()
      if aspect == 'ascii':
        if prelines:
          fp.write('\n' * prelines)
        for line in lines:
          fp.write('%s%s\n' % (indent, line))
      elif aspect == 'html':
        if prelines:
          fp.write('\n' * prelines)

        if subaspect == 'kaplan':
          fp.write('\n%s<div id="%s">\n' % (indent, self.genId()))
        for line in lines:
          fp.write('%s%s\n' % (indent, line))
        if subaspect == 'kaplan':
          fp.write('%s</div>\n' % indent)

      elif aspect == 'tex':
        fp.write('%s\\begin{comment}\n' % indent)
        for line in lines:
          fp.write('%s%s\n' % (indent, line))
        fp.write('%s\\end{comment}\n' % indent)
      else:
        print('ERROR: Unknown aspect %s for HTML.show()' % aspect)
    test:
      fp = test.fp()
      test.html.show(fp=fp)
      test.iseq('<p>blah</p>\n', fp.getvalue())
    end receiver HTML;

    receiver Table ::
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      title = self.title()
      if parser is None:
        parent = self.parent()
        parser = parent.parser() if parent else None
      prelines = 0 if kwds.get('ignorepre', False) else self.prelines()
      max_line_width = kwds.get('width', -1)
      if max_line_width < 0:
        max_line_width = Object.TerminalWidth()
        /# print('HERE with max %d' % max_line_width)
      separators = self.separators()

      column_separator = ' | '
      left_delim = '| '
      right_delim = ' |'

      spre = Parser.Mark_re

      /# Checks whether the text of a column looks like a list item, and if
      /# so, indents wrapped lines accordingly.
      def WriteRow(fp, row, aligns, widths, target_widths, truncate=False):
        N = len(row)

        if truncate:
          /# This is a simple truncation solution.
          cols = []
          for i in range(0, N):
            col = row[i]
            tw = target_widths[i]
            if len(col) > tw:
              col = col[:tw-1] + '$'
            col = aligns[i](col, tw)
            cols.append(col)
          line = column_separator.join(cols)
          full_line = '%s%s%s%s' % (indent, left_delim, line, right_delim)
          if max_line_width and len(full_line) > max_line_width:
            full_line = full_line[:max_line_width-1] + '$'
          fp.write(full_line + '\n')

        elif widths == target_widths:
          /# Easy formatting
          line = column_separator.join(
            [aligns[i](row[i], widths[i]) for i in range(0, N)])
          fp.write('%s%s%s%s\n' % (indent, left_delim, line, right_delim))

        else:
          /# This performs smart wrapping of every column, ensuring
          /# that column i contributes exactly target_widths[i] characters
          /# to the output.
          column_lines = []
          for i in range(0, N):
            col = row[i]
            n = len(col)
            tw = target_widths[i]
            if n > tw:
              spm = spre.match(col)
              coldent = ''
              if spm:
                coldent = ' ' * len(spm.group('mark'))
              column_lines.append(
                textwrap.wrap(col, width=tw, subsequent_indent=coldent))
            else:
              column_lines.append([col])
          /# Now we iterate over column_lines looking at column_lines[j]. In
          /# iteration i, we grap all values in column_lines[j][i] and form
          /# them into a table row to print.
          j = 0
          while True:
            cols = []
            found = False
            for i in range(0, N):
              vlines = column_lines[i]
              if j < len(vlines):
                found = True
                cstr = vlines[j]
              else:
                cstr = ''
              col = aligns[i](cstr, target_widths[i])
              cols.append(col)
            if not found: break
            line = column_separator.join(cols)
            fp.write('%s%s%s%s\n' % (indent, left_delim, line, right_delim))
            j += 1

      if aspect == 'ascii':
        if prelines:
          fp.write('\n' * prelines)
        if title:
          fp.write('%sTable: %s\n\n' % (indent, title))

        xdent = self.xdent()
        indent += xdent

        /# Accumulate all the entries in each column (including header)
        columns = self.columns()
        N = len(columns)
        header = [cd['header'] for cd in columns]
        rows = self.rows()
        column_lists = []
        widths = []
        aligns = []
        for i in range(0, N):
          clist = [header[i]]
          for row in rows:
            clist.append(row.data()[i])
          column_lists.append(clist)
          w = max([len(val) for val in clist])
          if w < 1:
            raise Error('w=%d i=%d N=%d clist=%s' % (w, i, N, clist))
          widths.append(w)
          align = columns[i]['align'] or 'left'
          aligns.append(
            str.ljust if align == 'left' else
            (str.rjust if align == 'right' else str.center))

        if False:
          print('WIDTHS', widths)
          print(f'{max_line_width=}')

        truncate = False
        target_widths = widths
        /# print('w: %s' % str(widths))
        /# print('c: %s' % str(columns))
        if max_line_width:
          /# how much space is introduced by the column separators
          sep_width = len(column_separator) * (N-1)
          prepost_width = len(indent) + len(left_delim) + len(right_delim)
          extra_width = prepost_width + sep_width * (N-1)
          text_width = sum(widths)
          available = max_line_width - extra_width

          /# We create a new set of widths that will ensure the overall
          /# width of every line does not exceed max_line_width.
          /#  - accounts for indent, left_delim, right_delim and the N-1
          /#    column separators.
          if max_line_width < extra_width:
            truncate = True
            print('WARNING: Cannot shrink table to width %d (truncating)' % max_line_width)

          elif text_width + extra_width <= max_line_width:
            /# The widths are fine as-is
            target_widths = widths

          elif widths[0] < 10 and N == 2:
            /# This is a special case where the first column is small, so we
            /# don't adjust it.
            first_width = widths[0]
            second_width = max_line_width - first_width - extra_width
            if second_width < 2:
              /# TODO(wmh): We can do better than this.
              first_width = 2
              second_width = 2
            target_widths = [first_width, second_width]

          elif False and N == 2:
            /# TODO(wmh): This makes column1 too small sometimes.
            /# Enforce a minimum width on each column.
            fractions = [w / text_width for w in widths]
            free_width = max_line_width - extra_width
            target_widths = [
              int(free_width * fraction) for fraction in fractions]

          else:
            /# TODO(wmh): Some ideas here:
            /#  - identify a certain set of columns whose widths are fixed:
            /#     - any column whose width (ignoring header value) is less
            /#       than some value (e.g. 10)
            /#     - any column in which none of the non-header values has
            /#       any spaces
            /#  - all columns other than the ones identified above are deemed
            /#    able to be resized with impunity
            /#     - obtain the total width of all such columns, and
            /#       compute the fraction each such column contributes to
            /#       that total width
            /#     - assign widths that maintain the percentages (or, if this
            /#       doesn't work well, just assign equal width to each).
            /#     - column i never needs a width larger than widths[i]
            /#
            /#  - Alternatively:
            /#     - try a certain width distribution, then analyze the
            /#       resulting wrappings.
            /#        - for a specific column, if most rows do not wrap and
            /#          only a few do, consider giving that column more
            /#          width to avoid the uncommon wrapping.
            tws = [0] * N
            frozen = []
            resizable = []
            resize_available = available
            retot = 0
            for i, w in enumerate(widths):
              if w < 10:
                /# A column whose width is fixed.
                frozen.append(i)
                tws[i] = w
                resize_available -= w
              elif 'minwidth' in columns[i]:
                frozen.append(i)
                minw = columns[i]['minwidth']
                tws[i] = minw
                resize_available -= minw
              else:
                /# A column whose width can be resized.
                resizable.append(i)
                retot += w

            /# print('Resizable: %s' % str(resizable))

            /# Now resize each resizable width
            /#  - maintain relative proportion such that sum is 'resize_available'
            newtot = 0
            for i in resizable:
              w = widths[i]
              new_w = int((w/retot) * resize_available)
              tws[i] = new_w
              newtot += new_w
            if resizable:
              tws[resizable[-1]] += (resize_available - newtot)
              sz = sum(tws)
              /# print('here with %d + %d = %d vs %d' % (extra_width, sz, extra_width + sz, max_line_width))
            target_widths = tws
            if False:
              print(
                'max=%d avail=%d rzavail=%d extra=%d retot=%d newtot=%d tws=%s' %
                (max_line_width, available, resize_available,
                 extra_width, retot, newtot, tws))

        if False:
          print('TARGET', target_widths)

        /# Print the header.
        WriteRow(fp, header, aligns, widths, target_widths, truncate=truncate)

        /# Compute and print the separator
        seplist = []
        sepline = left_delim.replace(' ', '-')
        for i, cdata in enumerate(columns):
          align = cdata['align'] or 'left'
          left = ':' if align != 'right' else ''
          right = ':' if align != 'left' else ''
          width = target_widths[i]
          sep = left + ('-' * (max(1, width - len(left + right)))) + right
          seplist.append(sep)
          sepline += '-' * target_widths[i]
          if i < N-1:
            sepline += column_separator.replace('|', '+').replace(' ', '-')
        sepline += right_delim.replace(' ', '-') + '\n'
        /# WriteRow(fp, seplist, aligns, widths, target_widths, truncate=truncate)
        fp.write(indent + sepline)

        /# Print the data rows.
        /#   TODO(wmh): Find max width for each column.
        sepdx = 0
        for i, row in enumerate(self.rows()):
          if sepdx < len(separators) and separators[sepdx] == i:
            fp.write(sepline)
            sepdx += 1
          WriteRow(fp, row.data(), aligns, widths, target_widths, truncate=truncate)

        /# Print any abbrev rows
        abbrevs = self.abbrevs()
        for abbrev in sorted(abbrevs):
          title = abbrevs[abbrev]
          fp.write('%s= %s = %s\n' % (indent, abbrev, title))

        /# Print any note rows
        notes = self.notes()
        for mark in sorted(notes):
          note = notes[mark]
          fp.write('%s%s %s\n' % (indent, mark, note))

        /# Everything ends with an empty line.
        fp.write('\n')

      elif aspect == 'tex':
        columns = self.columns()

        aligns = []
        headers = []
        totwid = 0
        numh = 0
        for column in columns:
          align = column.get('align', '') or 'left'
          alignspec = align[0]
          h = column.get('header', '')
          w = column.get('minwidth', None)
          W = column.get('maxwidth', None)
          if h:
            numh += 1
            if w:
              totwid += w
              words = h.split()
              maxwordlen = max([len(word) for word in words])
              if w < maxwordlen and len(words) > 1:
                /# The desired minimum width is smaller than one of the words
                /# in the header. We can at least reduce the column width to
                /# the width of the largest word in the header.
                /# TODO(wmh): How to establish the size of text in cm?
                cm = 0.2 * maxwordlen
                h = '\\textbf{\\begin{minipage}[t]{%1.3fcm}%s\\end{minipage}}' % (
                  cm, h)
              else:
                h = '\\textbf{' + h + '}'
            elif W:
              alignspec = '%s{%dex}' % (alignspec.upper(), W)
              h = '\\textbf{' + h + '}'
            else:
              h = '\\textbf{' + h + '}'
          headers.append(h)
          aligns.append(alignspec)

        colspec = '|%s|' % '|'.join(aligns)
        /#print '%d for %s' % (totwid, self.fulltitle())

        if totwid > 45:
          table_type = 'table*'
          table_loc  = 't'
        else:
          table_type = 'table'
          table_loc  = 'h!'

        /# Print the table
        fp.write('\\begin{%s}[%s]\n' % (table_type, table_loc))
        fp.write('  \\centering\n')
        fp.write('  \\rowcolors{2}{gray!25}{white}\n')
        if title:
          fp.write('  \\caption{%s}\n' % title)
        /# fp.write('\\label{tab:table1}\n')
        fp.write('  \\begin{tabular}{%s}\n' % colspec)

        /# Print the header (if one exists)
        if numh:
          fp.write('    \\hline\n')
          fp.write('    \\rowcolor{gray!50}\n')
          fp.write('    %s\\\\\n' % ' & '.join(headers))
          fp.write('    \\hline\n')

        for row in self.rows():
          line = ' & '.join([
            metax.lib.markdown.Paragraph.TextToTex(cell, parser=parser)
            for cell in row.data()])
          fp.write('    %s\\\\\n' % line)
          /# fp.write('    \\hline\n')
        fp.write('    \\hline\n')
        fp.write('  \\end{tabular}\n')
        fp.write('\\end{%s}\n' % table_type)

      elif aspect == 'html':

        if subaspect == 'kaplan':
          fp.write('\n%s<div id="%s">\n' % (indent, self.genId()))

        csscls = self.csscls()
        cssclsstr = ' class="%s"' % csscls if csscls else ''
        uid = self.uid()
        uidstr = ' id="%s"' % uid if uid else ''
        fp.write('<table%s%s>\n' % (cssclsstr, uidstr))
        if title:
          fp.write('  <caption>%s</caption>\n' % title)
        for row in self.rows():
          line = '<tr>%s</tr>\n' % ''.join(
            ['<td>%s</td>' %
             (metax.lib.markdown.Paragraph.TextToHtml(cell, parser=parser).strip() or '&nbsp;')
             for cell in row.data()])
          fp.write(line)
        fp.write('</table>\n')

        if subaspect == 'kaplan':
          fp.write('%s</div>\n' % indent)

      else:
        print('ERROR: Unknown aspect %s for Table.show()' % aspect)
    test:
      table, errors = self.newTable()
      fp = test.fp()
      table.show(fp=fp, indent='...', aspect='ascii')
      test.iseqtext(
        >|r"""...Table: Table Title
        >|
        >|...| Name  | Age | Height | Fruit |
        >|...|-------+-----+--------+-------|
        >|...| Alice | 25  |   1.7m |  Kiwi |
        >|...| Bob   | 23  |   1.9m | Apple |
        >|
        >|""",
        fp.getvalue())

      test.maxDiff = None
      fp = test.fp()
      table.show(fp=fp, aspect='tex')
      test.iseqtext(
        >|r"""\begin{table}[h!]
        >|  \centering
        >|  \rowcolors{2}{gray!25}{white}
        >|  \caption{Table Title}
        >|  \begin{tabular}{|l|l|r|c|}
        >|    \hline
        >|    \rowcolor{gray!50}
        >|    \textbf{Name} & \textbf{Age} & \textbf{Height} & \textbf{Fruit}\\
        >|    \hline
        >|    Alice & 25 & 1.7m & Kiwi\\
        >|    Bob & 23 & 1.9m & Apple\\
        >|    \hline
        >|  \end{tabular}
        >|\end{table}
        >|""",
        fp.getvalue())

      table, errors = self.newTable(
        >|"""    Table: Testing images in tables.
        >|
        >|        |  .  |
        >|        | :-: |
        >|        | ![](http://tny.im/7r1 300x) |
        >|""".rstrip().split('\n'))
      fp = test.fp()
      table.show(fp=fp, aspect='html')

      text = """\
        >|Table: Subclasses
        >|
        >|| Class      | Subclass                      | Level | Description                                                       |
        >||------------+-------------------------------+-------+-------------------------------------------------------------------|
        >|| Barbarian  | Path ofthe Ancestral Guardian | 3rd   | Calls on the spirits of honored ancestors to protect others       |
        >|| Barbarian  | Path of the Storm Herald      | 3rd   | Filled with a rage that channels the primal magic of the storm    |
        >|| Barbarian  | Path ofthe Zealot             | 3rd   | Fueled by a religious zeal that visits destruction on foes        |
        >|| Bard       | College of Glamour            | 3rd   | Wields the beguiling, glorious magic of the Feywild               |
        >|| Bard       | College of Swords             | 3rd   | Entertains and slays with daring feats of weapon prowess          |
        >|| Bard       | College of Whispers           | 3rd   | Plants fear and doubt in the minds of others                      |
        >|| Cleric     | Forge Domain                  | 1st   | Clad in heavy armor, serves a god of the forge or creation        |
        >|| Cleric     | Grave Domain                  | 1st   | Opposes the blight of undeath                                     |
        >|| Druid      | Circle of Dreams              | 2nd   | Mends wounds, guards the weary, and strides through dreams        |
        >|| Druid      | Circle of the Shepherd        | 2nd   | Summons nature spirits to bolster friends and harry foes          |
        >|| Fighter    | Arcane Archer                 | 3rd   | Imbues arrows with spectacular magical effects                    |
        >|| Fighter    | Cavalier                      | 3rd   | Defends allies and knocks down enemies, often on horseback        |
        >|| Fighter    | Samurai                       | 3rd   | Combines resilience with courtly elegance and mighty strikes      |
        >|| Monk       | Way of the Drunken Master     | 3rd   | Confounds foes through a martial arts tradition inspired by the   |
        >||            |                               |       | swaying of a drunkard                                             |
        >|| Monk       | Way of the Kensei             | 3rd   | Channels ki through a set of mastered weapons                     |
        >|| Monk       | Way of the Sun Soul           | 3rd   | Transforms ki into bursts of fire and searing bolts of light      |
        >|| Paladin    | Oath of Conquest              | 3rd   | Strikes terror in enemies and crushes the forces of chaos         |
        >|| Paladin    | Oath of Redemption            | 3rd   | Offers redemption to the worthy and destruction to those who      |
        >||            |                               |       | refuse mercy or righteousness                                     |
        >|| Ranger     | Gloom Stalker                 | 3rd   | Unafraid of the dark, relentlessly stalks and ambushes foes       |
        >|| Ranger     | Horizon Walker                | 3rd   | Finds portals to other worlds and channels planar magic           |
        >|| Ranger     | Monster Slayer                | 3rd   | Hunts down creatures of the night and wielders of grim magic      |
        >|| Rogue      | Inquisitive                   | 3rd   | Roots out secrets, akin to a masterful detective                  |
        >|| Rogue      | Masterm ind                   | 3rd   | A master tactician , manipulates others                           |
        >|| Rogue      | Scout                         | 3rd   | Combines stealth with a knack for survival                        |
        >|| Rogue      | Swashbuckler                  | 3rd   | Delivers deadly strikes with speed and panache                    |
        >|| Sorcerer   | Divine Soul                   | 1st   | Harnesses magic bestowed by a god or other divine source          |
        >|| Sorcerer   | Shadow Magic                  | 1st   | Wields the grim magic of the Shadowfell                           |
        >|| Sorcerer   | Storm Sorcery                 | 1st   | Crackles with the power of the storm                              |
        >|| Warlock    | The Celestial                 | 1st   | Forges a pact with a being from celestial realms                  |
        >|| Warlock    | The Hexblade                  | 1st   | Serves a shadowy entity that bestows dread curses                 |
        >|| Wizard     | War Magic                     | 2nd   | Mixes evocation and abjuration magic to dominate the battlefield  |
        >|"""
      lines = text.split('\n')
      lines.pop()
      table, errors = test.newTable(lines=lines)
      test.iseq([], errors)
      fp = test.fp()
      table.show(width=80, fp=fp)
      out = test.out()
      golden = metax.root.Object.Resource(
        'table_golden', fqn='metax.lib.markdown_test.TestCase')
      test.iseqstrgold(out, golden)
    end receiver Table;

    receiver Section ::
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      start = kwds.get('start', 0)
      nohead = kwds.get('nohead', False)
      style = kwds.get('style', None)
      preamble = kwds.get('preamble', None)
      postamble = kwds.get('postamble', None)
      width = kwds.get('width', -1)
      if width < 0:
        width = Object.TerminalWidth()

      /# A width of 0 means do not format. But when printing the section itself
      /# we need to have some width for toc, etc.
      toc_width = width or Object.TerminalWidth()

      d = self.depth()

      /# print('Here with aspect=%s depth=%d d=%d' % (aspect, depth, d))

      prelines = 0 if kwds.get('ignorepre', False) else self.prelines()
      if aspect.startswith('title'):
        /# Show table-of-contents style output
        abbrev = self.abbrev()
        abbrevstr = ' [=%s]' % abbrev if abbrev else ''
        pagenum = self.pagenum()
        indented_title = '%s%s%s%s' % (
          indent, '  ' * (d-start), self.title() or '(sham)', abbrevstr)
        if pagenum:
          fp.write(
            '%s%s%d\n' %
            (indented_title, '.' * (toc_width-5-len(indented_title)), pagenum))
        else:
          fp.write('%s\n' % indented_title)
        if aspect == 'title*':
          for block in self.blocks():
            title = block.title()
            if title:
              /# Add some text to distinguish these text-based titles from
              /# section titles.
              title = '*' + title
              /# Write the augmented text title.
              fp.write('%s%s%s (%d)\n' % (indent, '  ' * (d+1), title))
        /# Now handle children
        if depth > 0:
          for child in self.children():
            child.show(
              fp=fp, indent=indent, aspect=aspect, subaspect=subaspect, depth=depth-1, parser=parser,
              **kwds)

      elif aspect == 'ascii':
        /# Format into ascii
        concise = kwds.get('concise', False)

        if d:
          if concise and not self.title() and len(self.blocks()) == 0:
            /# We have a stub section with no top-level blocks, so we do not
            /# print the empty title.
            pass
          else:
            if prelines:
              fp.write('\n' * prelines)
            fp.write(
              '%s%s %s\n' %
              (indent, '#' * d, self.title()))
            for block in self.blocks():
              /# print(type(block))
              block.show(fp=fp, indent=indent, aspect=aspect, subaspect=subaspect, parser=parser, **kwds)

        /# Now handle children
        if depth > 0:
          for child in self.children():
            child.show(
              fp=fp, indent=indent, aspect=aspect, subaspect=subaspect, depth=depth-1, parser=parser,
              **kwds)

      elif aspect == 'html':
        /# Format as HTML
        d = self.depth()
        title = self.title() or ''

        /# Create the initial html for this section.
        if d == 0:
          if nohead:
            pass
          else:
            special_style = ''
            special_script = ''
            if subaspect == 'kaplan':
              /# From
              /#   https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style
              /# one can have multiple <style> elements, and they are applied
              /# in order. We add the kaplan-specific elements BEFORE adding
              /# those from kwds['style']
              book = self.parser().book()
              bookuid = book.uid() or 'MISSING_BOOK_ID';
              special_style = Book.KaplanStyle
              special_script = Book.KaplanScript.replace('${BookId}', bookuid)

            /# Root level.
            fp.write(
              >|u"""<html>
              >|  <head>
              >|%(special_style)s
              >|%(caller_style)s
              >|%(special_script)s
              >|  </head>
              >|  <body>
              >|""" % {
                'caller_style': style or '',
                'special_style': special_style,
                'special_script': special_script,
              })
            if subaspect == 'kaplan':
              fp.write('<div class="kaplan_book">\n')

            if preamble:
              fp.write(preamble)
        else:
          kdata = {
            1: {'tag': 'h1'},
            2: {'tag': 'h2'},
            3: {'tag': 'h3'},
            4: {'tag': 'h4'},
            5: {'tag': 'h5'},
            6: {'tag': 'h6'},
          }[d]
          tag = kdata['tag']
          abbrev = self.abbrev()
          idstr = ' id="%s" title="%s"' % (abbrev, abbrev) if abbrev else ''
          fp.write('\n\n')
          if subaspect == 'kaplan':
            fp.write('%s<div id="%s">\n' % (indent, self.genId()))
          fp.write(
            '<%s%s>%s</%s>\n' % (
              tag, idstr,
              metax.lib.markdown.Paragraph.TextToHtml(
                title, parser=self.parser(), indent=indent),
              tag))
          if subaspect == 'kaplan':
            fp.write('%s</div>\n' % indent)

        /# Print out any block objects.
        for block in self.blocks():
          block.show(fp=fp, aspect=aspect, subaspect=subaspect, parser=parser, **kwds)

        /# Now handle children
        if depth > 0:
          for child in self.children():
            child.show(
              fp=fp, indent=indent, aspect=aspect, subaspect=subaspect, depth=depth-1, parser=parser,
              **kwds)

        /# Perform any wrap-up needed.
        if d == 0 and not nohead:
          if postamble:
            fp.write(postamble)

          if subaspect == 'kaplan':
            fp.write("""
              >|</div>  <!-- kaplan_book -->
              >|
              >|<script>
              >|Index = 1;
              >|Move(-1);
              >|</script>
              >|""")

          fp.write('  </body>\n</html>\n')

      elif aspect == 'tex':
        d = self.depth()
        title = self.title() or ''

        /# Create the initial latex for this section.
        if d == 0:
          /# root level.
          /# Section relabling performed by titlesec
          /#   http://tex.stackexchange.com/questions/59726/change-size-of-section-subsection-subsubsection-paragraph-and-subparagraph-ti
          /#   http://www.ctex.org/documents/packages/layout/titlesec.pdf
          /# Table alternating colors performed by xcolor
          /#   http://tex.stackexchange.com/questions/5363/\
          /#     how-to-create-alternating-rows-in-a-table
          /# Fixed width aligned table columns
          /#   http://tex.stackexchange.com/questions/12703/\
          /#      how-to-create-fixed-width-table-columns-with-text-raggedright-centered-raggedlef
          fp.write(
           >|r"""\documentclass[twocolumn]{report}
           >|\usepackage[margin=1cm,footskip=0.5cm]{geometry}
           >|\setlength{\columnsep}{0.75cm}
           >|\usepackage[table]{xcolor}
           >|\usepackage{titlesec}
           >|\usepackage{color}
           >|\usepackage{comment}
           >|\usepackage{array}
           >|\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
           >|\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
           >|\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
           >|
           >|%%\titleformat{\chapter}[display]{\normalfont\huge\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
           >|\titleformat{\chapter}[hang]{\color{red}\normalfont\Huge\bfseries}{}{0em}{\Huge}
           >|
           >|%% \titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
           >|\titleformat{\section}{\color{green}\normalfont\Large\bfseries}{}{0em}{}
           >|
           >|%% \titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection}{1em}{}
           >|\titleformat{\subsection}{\color{blue}\normalfont\large\bfseries}{}{0em}{}
           >|
           >|%% \titleformat{\subsubsection}{\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}
           >|\titleformat{\subsubsection}{\color{cyan}\normalfont\normalsize\bfseries}{}{0em}{}
           >|\titlespacing*{\section}{0pt}{1ex}{1ex}
           >|
           >|%% \titleformat{\paragraph}[runin]{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
           >|\titleformat{\paragraph}[runin]{\color{orange}\normalfont\normalsize\bfseries}{\theparagraph}{0em}{}
           >|
           >|%% \titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{\thesubparagraph}{1em}{}
           >|\titleformat{\subparagraph}[runin]{\normalfont\normalsize\bfseries}{\thesubparagraph}{0em}{}
           >|
           >|\title{%s}
           >|
           >|\begin{document}
           >|
           >|""" % (title))
        else:
          kdata = {
            1: {'tag': 'chapter'},
            2: {'tag': 'section'},
            3: {'tag': 'subsection'},
            4: {'tag': 'subsubsection'},
            5: {
              /# https://www.sharelatex.com/learn/Line_breaks_and_blank_spaces
              'tag': 'paragraph',
              'suffix': r'\hfill \break'
           },
          }[d]
          tag = kdata['tag']
          suffix = kdata.get('suffix', '')
          fp.write('\\%s{%s}%s\n' % (
            tag, metax.lib.markdown.Paragraph.TextToTex(title), suffix))
          fp.write('\n')

        /# Print out any block objects.
        for block in self.blocks():
          block.show(fp=fp, aspect=aspect, subaspect=subaspect, parser=parser, **kwds)

        /# Now handle children
        if depth > 0:
          for child in self.children():
            child.show(
              fp=fp, indent=indent, aspect=aspect, subaspect=subaspect, depth=depth-1, parser=parser,
              **kwds)

        /# Perform any wrap-up needed.
        if d == 0:
          fp.write('\\end{document}\n')

      else:
        raise Error('Unknown aspect "%s" for Section.show' % aspect)
    test:
      section = test.subsection
      block1 = section.addBlock(metax.lib.markdown.Paragraph(
        section, 'A first paragraph\nwith two lines', prelines=1))
      block2 = section.addBlock(metax.lib.markdown.Paragraph(
        section, 'A second paragraph\nwith three\nlines', prelines=2))
      test.iseq(1, section.prelines())
      test.iseq(1, block1.prelines())
      test.iseq(2, block2.prelines())

      fp = test.fp()
      section.show(fp=fp, width=0)
      test.iseqtext("""
        >|## SubSection A
        >|
        >|A first paragraph
        >|with two lines
        >|
        >|
        >|A second paragraph
        >|with three
        >|lines
        >|""",
        fp.getvalue())
    end receiver Section;

    receiver Book #:
      Top-level print.
    scope:
      if sink:
        fp = sink.fp()
        indent = sink.prefix()
      /# First, print out the contents.
      if aspect == 'tables':
        tables = self.tables()
        for table in tables.values():
          section = table.parent()
          fp.write('%-40s in %s\n' % (table.title(), section.fulltitle()))
      else:
        self.root().show(
          fp=fp, indent=indent, aspect=aspect, subaspect=subaspect, parser=parser, depth=depth,
          **kwds)

      /# Now print out the meta-level info.
      /# ...
    test:
      golden = metax.root.Object.Resource(
        'book_golden', fqn='metax.lib.markdown_test.TestCase')

      sink = metax.io.Sink(fp=test.fp())
      test.book.show(sink=sink)
      test.iseqstrgold(test.out(), golden)
    end receiver Book;

  end behavior show;

  behavior search #:
    Find a pattern in the given instance.
  params:
    var pattern : regexp #:
      The regexp to match against.
    var results : vec<str> #:
      Where to add results.
    var sink : metax.io.Sink = null #:
      Where to write the object
    var parser : Parser = null #:
      The parser instance to use.
  scope:

    abstract receiver Block;

    receiver BlockGroup ::
      /# TODO(wmh): We may need to provide some support for a prefix before
      /# the first block.
      for block in self.blocks():
        block.search(pattern, results, sink=sink, parser=parser)
    test:
      results = []
      pattern = re.compile('test')
      sink = metax.io.Sink(fp=test.fp())
      test.group.search(pattern, results, sink=sink, parser=test.md)
    end;

    receiver Paragraph ::
      fp = io.StringIO()
      self.show(fp=fp, parser=parser)
      text = fp.getvalue()
      self.searchInText(pattern, results, text, sink=sink)
    test:
      results = []
      sink = metax.io.Sink(fp=test.fp())
      pattern = re.compile(r'example')
      test.p2.search(pattern, results, sink=sink, parser=test.md)
      test.iseq(
        ['example'],
        results)
    end receiver Paragraph;

    receiver Quote ::
      fp = io.StringIO()
      self.show(fp=fp, parser=parser)
      self.searchInText(pattern, results, fp.getvalue(), sink=sink)
    test:
      results = []
      quote = metax.lib.markdown.Quote(
        test.section, ['> quote', '> more quote'])
      sink = metax.io.Sink(fp=test.fp())
      pattern = re.compile('more')
      quote.search(pattern, results, sink=sink, parser=test.md)
      test.iseq(1, len(results))
    end receiver Quote;

    receiver List ::
      result = None
      fp = io.StringIO()
      self.show(fp=fp, parser=parser)
      return self.searchInText(pattern, results, fp.getvalue(), sink=sink)
    test:
      results = []
      test.makeLists()
      pattern = re.compile(r'Apple')
      sink = metax.io.Sink(fp=test.fp())
      test.ul.search(pattern, results, sink=sink, parser=test.md)
      test.iseq(1, len(results))
    end receiver List;

    receiver ListItem ::
      return None
    test:
      print('fixme')
    end receiver ListItem;

    receiver Code ::
      fp = io.StringIO()
      self.show(fp=fp, parser=parser)
      self.searchInText(pattern, results, fp.getvalue(), sink=sink)
    test:
      results = []
      sink = metax.io.Sink(fp=test.fp())
      pattern = re.compile(r'return')
      res = test.code.search(pattern, results, sink=sink, parser=test.md)
      test.iseq(2, len(results))
    end receiver Code;

    receiver HR ::
      return None
    test:
      results = []
      sink = metax.io.Sink(fp=test.fp())
      pattern = re.compile('----')
      test.hr.search(pattern, results, sink=sink, parser=test.md)
      test.iseq(0, len(results))
    end receiver HR;

    receiver HTML ::
      result = None
      fp = io.StringIO()
      self.show(fp=fp, parser=parser)
      return self.searchInText(pattern, results, fp.getvalue(), sink=sink)
    test:
      results = []
      sink = metax.io.Sink(fp=test.fp())
      pattern = re.compile('blah')
      test.html.search(pattern, results, sink=sink, parser=test.md)
      test.html.search(pattern, results, sink=sink, parser=test.md)
      test.iseq(2, len(results))
    end receiver HTML;

    receiver Table ::
      result = None
      fp = io.StringIO()
      self.show(fp=fp, parser=parser)
      return self.searchInText(pattern, results, fp.getvalue(), sink=sink)
    test:
      results = []
      table, errors = self.newTable()
      sink = metax.io.Sink(fp=test.fp())
      pattern = re.compile('Alice')
      table.search(pattern, results, sink=sink, parser=test.md)
      test.iseq(1, len(results))
    end receiver Table;

    receiver Section ::
      for block in self.blocks():
        block.search(pattern, results, sink=sink, parser=parser)
      for child in self.children():
        child.search(pattern, results, sink=sink, parser=parser)
    test:
      results = []
      section = test.subsection
      block1 = section.addBlock(metax.lib.markdown.Paragraph(
        section, 'A first paragraph\nwith two lines', prelines=1))
      block2 = section.addBlock(metax.lib.markdown.Paragraph(
        section, 'A second paragraph\nwith three\nlines', prelines=2))
      test.iseq(1, section.prelines())
      test.iseq(1, block1.prelines())
      test.iseq(2, block2.prelines())

      pattern = re.compile(r'paragraph')
      sink = metax.io.Sink(fp=test.fp())
      section.search(pattern, results, sink=sink, parser=test.md)
      test.iseq(2, len(results))
    end receiver Section;

  end behavior search;

  behavior title #:
    The title of this Object.  Every subclass must provide this method.
  scope:
    abstract receiver Object;

    abstract receiver Block;

    receiver BlockGroup ::
      return None
    test:
      group = test.group
      test.isnull(group.title())
    end receiver BlockGroup;

    receiver Paragraph ::
      result = None
      text = self.text()
      if text and text[0] == '*' and text[1] == '*':
        /# We avoid calling annotations() as it is more expensive than we need.
        idx = text.find('**', 2)
        if idx > 0:
          result = text[2:idx]
      return result
    test:
      test.isnull(test.p1.title())
      test.iseq('Some Title', test.p2.title())
    end receiver Paragraph;

    receiver Quote ::
      /# TODO(wmh): Should the title be the author of the quote?
      return None
    test:
      quote = metax.lib.markdown.Quote(test.section, ['> quote'])
      test.isnull(quote.title())
    end receiver Quote;

    receiver List ::
      /# For now, we don't have a concept of titled lists, but we may want to
      /# add such a concept. Note that individual ListItem instances are
      /# subclasses of BlockGroup, contain a list of Block, and each Block may
      /# or may not have a title.
      return None
    test:
      test.makeLists()
      test.isnull(test.ul.title())
    end receiver List;

    receiver Code ::
      /# For now, we don't have a concept of titled code blocks, but we may want to
      /# add such a concept.
      return None
    test:
      test.isnull(test.code.title())
    end receiver Code;

    receiver HR ::
      /# For now, we don't have a concept of titled code blocks, but we may want to
      /# add such a concept.
      return None
    test:
      test.isnull(test.hr.title())
    end receiver HR;

    receiver HTML ::
      /# For now, we don't have a concept of titled code blocks, but we may want
      /# to add such a concept.
      return None
    test:
      test.isnull(test.html.title())
    end receiver HTML;

    receiver Row ::
      /# The value of the column within the table representing a unique key.
      return self.data()[0]
    test:
      test.iseq('Alice', test.row1.title())
      test.iseq('Bob', test.row2.title())
    end receiver Row;

  end behavior title;

  test
  class TestCase < metax.test.TestCase
  assocs:
    std assoc os;
    std assoc metastrap #:
      /# TODO(wmh): This is not actually std, but rather lib ... we need to
      /# establish an appropriate build target for it.
    resource simple_md path "testdata/markdown/simple.md";
    resource markdown_md path "testdata/markdown/markdown.md";
    resource simple_golden path "testdata/markdown/simple.md.golden";
    resource book_golden path "testdata/markdown/book.golden";
    resource raw_txt_golden path "testdata/markdown/raw.txt.golden";
    resource raw_html_golden path "testdata/markdown/raw.html.golden";
  scope:

    lifecycle setup:
      test.md = metax.lib.markdown.Parser()
      test.root = metax.lib.markdown.Section(
        None, title='', prelines=1, parser=test.md)
      test.section = test.root.newChild(title='Section 1')
      test.subsection = test.section.newChild(
        abbrev='suba', title='SubSection A')
      test.subsection2 = test.section.newChild(
        /# This is a subsection whose title contains a '/' ... need to escape
        /# it when forming fulltitle.
        abbrev='sub2', title='SubSection/B')
      test.p1 = metax.lib.markdown.Paragraph(
        test.subsection,
        'This is an example paragraph containing a few lines\n'
        'of text including a **bold** word and _italize phrase_.')
      test.p2 = metax.lib.markdown.Paragraph(
        test.subsection,
        '**Some Title**. This is an example paragraph with a\n'
        'title (the first one is not titled)')
      test.table = metax.lib.markdown.Table(
        /# This title must escaped the / when forming fulltitle.
        test.subsection, [], [], title='Table with / in it')
      test.quote = metax.lib.markdown.Quote(
        test.subsection, ['this is a quote', 'spanning two lines'], prelines=1)
      test.code = metax.lib.markdown.Code(
        test.subsection,
        ['if a == 1:',
         '  return False',
         'else:',
         '  return True'
        ],
        language='python')

      /# NOTE: Intentionally have NOT added p1 and p2 to subsection yet,
      /# although they know they are children of subsection.

      bookpath = metax.root.Object.Resource(
        'simple_md', fqn='metax.lib.markdown_test.TestCase')
      test.book = self.parseBook([bookpath])
      test.table2 = test.book.find('A Simple Document/Blocks/Tables/Fruit')
      test.panel2 = test.book.find('A Simple Document/Blocks/Panels/Example Panel')
    clsetup:
      /# TODO(wmh): Introduce a nmspsetup that performs namespace-level
      /# setup. We only need to invoke metastrap.Setup() once.
      metastrap.Setup()
    clinit:
      /# TODO(wmh): Fix this hackery!!
      import metax.c
      metax.c.Compiler.Bootstrap(['metac', 'test'])
    end lifecycle;

    method parseMarkdown : Setion params:
      var resource : str #:
        The resource (defined here in this class) containing a markdown file.
      var titlere : regexp = null #:
        If present, specifies how section titles should be massaged. See
        Parser.parseLines() for details.
      var parser : metax.lib.markdown.Parser = null #:
        If null uses self.md
    scope:
      if parser is None:
        parser = self.md
      respath = metax.root.Object.Resource(
        resource, fqn='metax.lib.markdown_test.TestCase')
      result = parser.parseFile(respath, titlere=titlere)
      return result
    end;

    method parseBook params:
      var specs : vec<str> #:
        Each element can be either a path or a resource id identifying a
        .md file to parse.
      var bookname : str = 'TheBook' #:
        The title of the book.
    scope:
      paths = []
      for spec in specs:
        if os.path.exists(spec):
          paths.append(spec)
        else:
          path = metax.root.Object.Resource(spec)
          /# print('HERE with %s and %s' % (spec, path))
          if os.path.exists(path):
            paths.append(path)
          else:
            print('ERROR: Ignoring unknown resource %s' % spec)
      book = self.md.loadBook(paths, bookname=bookname)
      return book
    end method parseBook;

    method newTable : Table params:
      var lines : vec = null;
    scope:
      if lines is None:
        lines = [
          'Table: Table Title',
          '',
          '| Name | Age | Height | Fruit |',
          '| --- | :--- | ---: | :---: |',
          '| Alice | 25 | 1.7m | Kiwi |',
          '| Bob | 23 | 1.9m | Apple |',
        ]
      errors = []
      table = metax.lib.markdown.Table.New(lines, errors=errors)
      return table, errors
    end method newTable;

    method makeLists #:
      Generate a list useful for testing.
    scope:
      self.ul = metax.lib.markdown.List(self.subsection)
      self.item1 = self.ul.newItem(paras=['Apple'])
      self.item2 = self.ul.newItem(paras=['Banana'])
      self.item3 = self.ul.newItem(paras=['Cantelope'])

      self.ol = metax.lib.markdown.List(self.subsection, ordered=True)
      self.ol.newItem(paras=['Apple'])
      self.ol.newItem(paras=['Banana'])
      self.ol.newItem(paras=['Cantelope'])
    test:
    end method makeLists;

  end class TestCase;

end namespace metax.lib.markdown;
