<html>
  <head>

  </head>
  <body>


<h1>The Implementation of Meta</h1>

<p>This document provides details about the implementation (and design)
of Meta, meant for those contributing to the implementation itself. For
individuals interested in using Meta, see the [[UserGuide]] instead.</p>


<h2>Overview</h2>

<p>This implementation of Meta is written in Meta(Oopl)<Python>.</p>

<ul>
  <li>
  <p>The compilation of the .meta source code is performed by an older 
  implementation of Meta written purely in Python.</p>
  <ul>
    <li>
    The older python implementation is NOT stored in this repository
    </li>
  </ul>
  </li>
  <li>
  <p>During the transition period from v1 to v2, we need to support both
  versions in a seamless way, so the following correspondences exist:</p>

  <pre><code>             v1                           v2
 compiler:   $METAROOT/bin/metac          $METAROOT2/bin/meta2
 filterer:   $METAROOT/bin/metafilt       $METAROOT2/bin/metafilt2
 metastrap:  $METAROOT/lib/metameta.py    $METAROOT2/lib/metameta2.py
</code></pre>
  </li>
  <li>
  <p>The following structure exists in this directory</p>
  <ul>
    <li>
    <p>Every directory has a README file that describes every subfile and subdir.</p>

    <p>bin/                         # Executables
     meta2                      # The meta compiler
     metafilt2                  # Service script for mapping line numbers
    lib/                         # Maintains all versions of Meta
     beta/                      # The live source code
     current/                   # The sanctioned source code
     stable/                    # The previous sanctioned source code
     versions/                  # All previous versions of Meta
       meta-0.000.tgz
       meta-0.001.tgz
       ...
    src/                         # All source code
     kernel/
       parser.meta
     schema/                    # The Meta-Language schemas
       meta/
         schema.meta
       oopl/
         schema.meta
     templates/</p>
    </li>
  </ul>
  </li>
  <li>
  Meta avoids using environment variables where possible, instead preferring
  to store user-specific customizations in $HOME/.config/meta
  </li>
  <li>
  <p>When Meta compiles .meta source files into baselang source code, it
  by default writes the baselang source code into a repository shared by
  all Meta source code across all base languages and all meta languages.
  The structure of that repository is:</p>

  <p>  repo/
      <metalang>
        <baselang>
          WORKSPACE
          BUILD
          BUILD.<em>
          bazel-</em>
          <namespace1>
          <namespace2>
          ...</p>

  <p>In particular:</p>
  <ul>
    <li>
    <p>Meta uses Google's Bazel build environment in all baselangs.</p>
    <ul>
      <li>
      All thirdparty source code needed to implement Meta (and to
      implement user-provided code) is defined via the per-baselang
      WORKSPACE files and associated BUILD.* files
      </li>
    </ul>
    </li>
    <li>
    Every namespace defined in a .meta source file has an associated
    sub-directory path within repo/<metalang>/<baselang>. For example,
    the Meta class 'demo.cards2.Card' in the 'demo.cards2' namespace, when
    compiled into Python, would reside in
      repo/oopl/python/demo/cards2
    </li>
  </ul>
  </li>
  <li>
  All bugs/issues/feature-requests are stored in
  https://github.com/metaesque/meta/issues
  </li>
  <li>
  Meta can auto-generate emacs major-modes for MetaLang syntax.
    % meta2 --metalang=<lang> emacs
  The major mode is written to $METAROOT2/src/schema/meta/meta<lang>-mode.el
  and defines meta<lang>-mode (metameta-mode, metaoopl-mode, etc.)
  </li>
</ul>


<h2>Adding support for a new baselang</h2>

<ul>
  <li>
  <p>Update src/kernel/parser.meta with baselang-specific code:</p>

  <ul>
    <li>
    <p>Define OoplFoo by copying a pre-existing Oopl* class like OoplPython.</p>
    <ul>
      <li>
      The class itself contains only an initializer and a test lifecycle, all
      other functionality is defined via behaviors.
      </li>
      <li>
      For each behavior defined below the Oopl* classes, add a 'receiver' for 
      OoplFoo with appropriate code and unittests.
      </li>
      <li>
      Use 
        % metac -r parser.meta metax.c.OoplFoo
      to iteratively add new code and test it.
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>Update src/kernel/{root,test}.meta2 by adding baselang specific code</p>
  <ul>
    <li>
    search for <py> and do the same thing in <foo> as was done in python.
    </li>
    <li>
    use 
      % meta2 -b foo root.meta2
      % meta2 -b foo --implicit<em>scopes test.meta2
    The --implicit</em>scopes flag is to stop the compiler from producing
    warnings like
      metax.test.TestCase.iseq is general but missing scope<foo>
    </li>
  </ul>
  </li>
  <li>
  <p>Look at the generated baselang files to see if they look syntactically correct:</p>
  <ul>
    <li>
    The repository directory can be found with:
      % repopath=$(meta2 config repository_path)
    </li>
    <li>
    The directory containing code for baselang Foo class metax.root.Object is
    (usually)
      $repopath/oopl/foo/metax/root/Object.*
    </li>
  </ul>
  </li>
  <li>
  <p>Within parser.meta, modify the test scope of BaseLanguageOopl.typeToBase(),
  extending the test method to support baselang foo.</p>
  <ul>
    <li>
    it is critically import that meta-level types be properly converted
    to baselang variants.
    </li>
  </ul>
  </li>
  <li>
  Use the 'cards1-*' target in src/kernel/Makefile as a starting point:
   % make cards1-cc
  </li>
  <li>
  <p>Deal with whatever error arises next, until no errors arise.</p>
  <ul>
    <li>
    define OoplFoo.metaMethodBody()
    </li>
    <li>
    define OoplFoo.formatParams()
    </li>
    <li>
    define OoplFoo.formatParentSpec()
    </li>
  </ul>
  </li>
  <li>
  <p>Use the 'cards2-*' target in src/kernel/Makefile to continue the
  support for the new baselang</p>
  <ul>
    <li>
    this target generates unit testing code, which will require additional
    code to be added to OoplFoo ... for example, OoplFoo.<b>init</b> needs
    to specify values for setup[case] and teardown[case] in updateConfigs().
    </li>
    <li>
    this target allows you to actually invoke the unit tests once OoplFoo
    is generating proper test code, which will allow you to formally test
    the cards2.meta source code in Foo.
    </li>
  </ul>
  </li>
  <li>
  <p>Add support for parsing the bazel log files for Foo:</p>
  <ul>
    <li>
    Test up some new data (only after unittests for cards2.meta2 are all
    passing!):
     % cd ./testdata
     ! Edit Makefile and add foo to BASELANGS
     % make refresh_repo
     # The above will tromp on testdata/repo, recreating subdirs for all
     # baselangs supported so far. This may (or may not) break unit tests.
    </li>
  </ul>
  </li>
</ul>


<h2>Defining a non-language schema and using it in Python code.</h2>

<ul>
  <li>
  <p>First, create the schema file by going to $METAROOT/src/schema and creating
  a subdirectory named 'xyz' if you are defining Meta(Xyz).</p>
  <ul>
    <li>
    Copy a schema.meta file from a sibling directory into 'xyz' and modify
    it to define all desired constructs.
    </li>
  </ul>
  </li>
  <li>
  <p>In python code:</p>
  <ul>
    <li>
    <p>Define a root construct:</p>

    <p>  class XyzRootConstruct < metax.c.Construct #:
        Abstract superclass of all Meta(Xyz) constructs.
      scope:</p>

    <pre><code>meta
lifecycle scope:
  config, config_path = metax.root.Object.Config()
  meta_root = config['src_root']
  cls.MetaData = {
    /###############
    /# Meta(Xyz) #
    /###############
    'xyz': {
      'schema': os.path.join(
        meta_root, 'src', 'schema', 'xyz', 'schema.meta'),
      'name': 'Xyz',
      'parent': 'meta',
      'toplevel': ['fixme'],
      'constructs': {
        /# FIX THESE!
        'cons1': Cons1Construct,
        'cons2': Cons2Construct,
        'consn': ConsnConstruct,
      },
      'baselangs': {},
      'basesels': [],
    }
  }
end lifecycle;

...
</code></pre>
    <p>  end;</p>
    </li>
    <li>
    <p>Define subclasses of XyzRootConstruct for each construct defined in
    the schema/xyz/schema.meta file</p>

    <p>  class FamilyConstruct < XyzRootConstruct #:
        The 'person' construct.
      scope:</p>

    <pre><code>... add fields as appropriate ...

method kind : str scope:
  return 'family'

method expandMeta scope:
  /# This should parse the construct and initialize construct-specific
  /# fields
end;

method translateMeta scope:
  /# For non-language schemas, what happens in expandMeta() and what
  /# happens in translateMeta() is rather fuzzily defined ... up to you.
end;
</code></pre>

    <p>  end;</p>

    <p>  class PersonConstruct < XyzRootConstruct #:
        The 'person' construct.
      scope:</p>

    <pre><code>method kind : str scope:
  return 'person'

...
</code></pre>
    <p>  end;</p>
    </li>
    <li>
    <p>To setup a compiler for input written in Meta(Xyz):</p>

    <p>  import metastrap
      sys.argv = ['faux', '-L', 'xyz', '-A', '0']
      Compiler, command, metacli = metastrap.ImportMeta()
      Compiler.Initialize(metadata=XyzRootConstruct.MetaData)
      metac = Compiler(metal=metacli.metalang, basel=None)</p>
    </li>
    <li>
    To parse a .meta file in Meta(Xyz) format:
      metafile, errors, warnings = metac.processMeta(path)
      if not metafile.hasErrors(show=True):
        scope = metafile.construct().attrval('scope:')
        top = scope[0]
        top.write()
    </li>
  </ul>
  </li>
</ul>


<h2>Implementing semantics of types without a prefix</h2>

<ul>
  <li>
  <p>For primitive types, it makes sense that the implicit prefix should be '@'</p>
  <ul>
    <li>
    <p>Need to establish what '@' means in Meta:</p>
    <ul>
      <li>
      could mean "pass-by-value", but then clones would need to be taken
      in baselangs other than C++ in situations they aren't necessary
      (pass-by-value in C++ is often a means of ensuring the object is
      cleaned up).
      </li>
      <li>
      could mean "guaranteed not to be null and will be automatically gced".
      </li>
      <li>
      consider how move semantics in C++ changes things
      </li>
      <li>
      ... more contemplated needed...
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>For class types:</p>
  <ul>
    <li>
    We define "pass-by-reference" to mean "pass-by-pointer and guaranteed
    to not be null".
    </li>
    <li>
    <p>Most languages other than C++ do not have a distinction between
    pass-by-value, pass-by-reference and pass-by-pointer.</p>
    <ul>
      <li>
      they mostly pass-by-pointer but use '.' to access
      </li>
    </ul>
    </li>
    <li>
    <p>We can have the default by '*' or '&amp;' or '&amp;#'</p>
    <ul>
      <li>
      <p>pros of '*'</p>
      <ul>
        <li>
        matches intuitions of most people
        </li>
      </ul>
      </li>
      <li>
      <p>cons of '*'</p>
      <ul>
        <li>
        In C++, we have to use '->'. Especially problematic if 'str' means
        '*str'.
        </li>
      </ul>
      </li>
      <li>
      <p>pros of '&amp;'</p>
      <ul>
        <li>
        In C++, we can use '.'.  This is especially useful if 'str' means
        '&amp;str', as string manipulation is very common and it would be nice
        to be able to use '.' instead of '->' in the default situation.
        </li>
        <li>
        It is arguably more common for class types to be non-null pointers
        that it is for them to be nullable pointers
        </li>
        <li>
        Distinguishes Meta<C++> more clearly from C++ ... "improvement"?
        </li>
      </ul>
      </li>
      <li>
      <p>cons of '&amp;'</p>
      <ul>
        <li>
        Some baselangs do not have a static typechecking mechanism for
        enforcing non-null pointers (so this check would either need to
        happen at runtime or not happen).
        </li>
        <li>
        <p>Without making it const, we would be allowing modification of
        the calling scope variable in some languages.</p>
        <ul>
          <li>
          in many languages, pass-by-pointer has the same issues
          (in Java, one passes by pointer and cannot make the object const).
          </li>
        </ul>
        </li>
      </ul>
      </li>
      <li>
      <p>pros of '&amp;#'</p>
      <ul>
        <li>
        same as for '&amp;'
        </li>
        <li>
        increased type safety
        </li>
      </ul>
      </li>
      <li>
      <p>cons of '&amp;#'</p>
      <ul>
        <li>
        constness not statically enforceable in many baselangs
        </li>
        <li>
        non-nullness not statically enforceable in many baselangs
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>For native types:</p>
  <ul>
    <li>
    <p>if all native types are class types in baselangs, it makes sense that 
    native types would use the same default as for class types, but I'm not
    sure all native types will be baselang class types.</p>
    <ul>
      <li>
      more contemplated needed.
      </li>
    </ul>
    </li>
  </ul>
  </li>
</ul>


<h2>Implementing the 'str' type</h2>

<ul>
  <li>
  <p>Features of the 'str' type:</p>
  <ul>
    <li>
    values are immutable
    </li>
    <li>
    efficient comparison for at least literal strings
    </li>
    <li>
    space efficiency
    </li>
    <li>
    ability to store null
    </li>
    <li>
    ability to indicate at the type level whether the 'str' can be null or not
    </li>
    <li>
    ability to efficiently concatenate values of type 'str' with other strings
    (of type 'str' or other variants)
    </li>
    <li>
    <p>using the Meta type system, we have the following variants:</p>
    <ul>
      <li>
      *str : can be null
      </li>
      <li>
      &amp;str : cannot be null
      </li>
      <li>
      @str : storage space
      </li>
      <li>
      str: same as *str
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>In languages like Perl and Python, which have good support for text
  manipulation, strings are immutable and conditionally interned.</p>

  <ul>
    <li>
    <p>in python (http://guilload.com/python-string-interning)</p>
    <ul>
      <li>
      '' and all length 1 strings are interned
      </li>
      <li>
      from the above url, all literal strings matching regexp 
        ^[a-zA-Z0-9_]{1,20}$
      are interned, but my experiments show that
        'foo!' is 'foo!'
      returns True, and it appears that ALL literal strings
      are returned (even a string of 1025 'o's is interned)
      </li>
    </ul>
    </li>
    <li>
    the conditional internment allows for O(1) equality testing between strings
    if both are interned (falling back to the O(N) algorithm if either isn't
    interned). Because strings are often keys within dicts, efficient equality
    testing is beneficial.
    </li>
    <li>
    a variable of type 'str' (Python), 'String' (Javascript), or scalar (Perl)
    can be null, and in some languages (Javascript) one can indicate a distinction
    between "string that can be null" and "string that cannot be null"
    </li>
  </ul>
  </li>
  <li>
  <p>In C++</p>
  <ul>
    <li>
    <p>there are a variety of types that can be used to represent a string:</p>
    <ul>
      <li>
      char*
      </li>
      <li>
      std::string
      </li>
      <li>
      std::string_view  (points to pre-existing char* or string)
      </li>
    </ul>
    </li>
    <li>
    <p>when needed to convert between types:</p>
    <ul>
      <li>
      char* to string requires a copy: O(N)
      </li>
      <li>
      char* to string_view does not require a copy: O(1)
      </li>
      <li>
      string to char* uses s.c_str(): O(1)
      </li>
      <li>
      string to string_view does not copy: O(1)
      </li>
      <li>
      string_view to char* uses sv.data() but is NOT guaranteed to be NUL-terminated: (O(1))
      </li>
      <li>
      string_view to NUL-terminated char*: O(N)
      </li>
      <li>
      string_view to string: O(N)
      </li>
      <li>
      creating string_view from char* needs strlen(): O(N) unless explicit length passed
      </li>
      <li>
      creating string_vew from string shares state: O(1)
      </li>
    </ul>
    </li>
    <li>
    <p>implementing 'str' using 'const char*'</p>
    <ul>
      <li>
      no length, not convenient methods for various things.
      </li>
      <li>
      not viable
      </li>
    </ul>
    </li>
    <li>
    <p>implementing 'str' using 'const std::string'</p>
    <ul>
      <li>
      <p>variants:</p>
      <ul>
        <li>
        *str --> const std::string* 
        </li>
        <li>
        &amp;str --> const std::string&amp;
        </li>
        <li>
        @str --> std::string
        </li>
      </ul>
      </li>
      <li>
      <p>notes:</p>
      <ul>
        <li>
        the most common type is '<em>str' ('str' means '</em>str'), which means one
        needs to use s->meth() instead of s.meth().  Having to remember whether
        to use -> or . depending on whether the type is '*str' or '&amp;str' is
        cumbersome
        </li>
        <li>
        no internment, so using 'str' as the key in a map incurs relatively
        expensive string comparisons.
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>implementing 'str' using a special IStr class</p>
    <ul>
      <li>
      <p>variants:</p>
      <ul>
        <li>
        *str --> IStr*
        </li>
        <li>
        &amp;str --> IStr
        </li>
        <li>
        @str --> std::string
        </li>
      </ul>
      </li>
      <li>
      <p>notes:</p>
      <ul>
        <li>
        <p>The most common type is '<em>str' which means one uses s->meth() instead
        of s.meth(), and </em>s instead of s when wanting a 'const std::string&amp;'.</p>
        <ul>
          <li>
          Can we support the syntax 's.meth()'?  C++ does not allow '.' to
          be overridden (https://stackoverflow.com/questions/8777845/overloading-member-access-operators-c)
          but does allow dereference ('*') to be overridden ... will that help
          us?  I don't think so.
          </li>
          <li>
          see proposal http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4173.pdf
          is this in c++17?
          </li>
        </ul>
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>implementing 'str' using a special IStr class that stores nullable as state</p>
    <ul>
      <li>
      <p>variants:</p>
      <ul>
        <li>
        *str --> IStr (with state indicating null allowed)
        </li>
        <li>
        &amp;str --> IStr (with state indicating null not allowed)
        </li>
        <li>
        @str --> std::string
        </li>
      </ul>
      </li>
      <li>
      <p>notes:</p>
      <ul>
        <li>
        by having state in IStr store whether nullable, we lose static
        type-checking on that aspect!
        </li>
      </ul>
      </li>
      <li>
      implement 'str' using two classes, 'IStrPtr' (nullable) and 'IStrRef' (non-nullable)
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>The 'str' type is immutable and (partially?) interned</p>
  <ul>
    <li>
    equality testing is faster (for those instances that are interned) than
    char-by-char comparison.
    </li>
    <li>
    Python, Perl, Java, and Javascript all have interned strings and
    they are by far the most common ways to interact with strings in
    those languages. C++ does not have builtin support for interned
    strings, but if we want the languages to play nice together, we
    have to provide them in C++.
    </li>
  </ul>
  </li>
  <li>
  <p>#str is redundant</p>
  <ul>
    <li>
    should it be disallowed?
    </li>
    <li>
    no methods on this type provide the ability to modify state, so instances
    are inherently const.  '#' adds clutter, which we can avoid by making
    illegal.
    </li>
  </ul>
  </li>
  <li>
  <p>In languages without builtin support for interned strings (e.g. C++),
  a class would be defined (e.g. meta::root::IStr) to represent the interned
  string.</p>
  <ul>
    <li>
    not every instance would be interned ... could use the heuristics that
    python uses (any string less than 21 chars is interned, anything that
    is a literal string, etc.)
    </li>
    <li>
    Istr.interned() is bool true if interned and false if not, used in
    operator== (et.al) to establish whether we can do ptr equality or
    need to do value equality.
    </li>
  </ul>
  </li>
  <li>
  <p>*str  (variant #1)</p>
  <ul>
    <li>
    <p>Variant 1: a pointer to the interned string</p>
    <ul>
      <li>
      details:
      </li>
      <li>
      <p>pros:</p>
      <ul>
        <li>
        matches expectations
        </li>
        <li>
        can be null
        </li>
      </ul>
      </li>
      <li>
      <p>cons:</p>
      <ul>
        <li>
        <p>in C++, 'var name : <em>str' would become 'const IStr</em> name' and one
        would need to access methods with name->len() and (*name)[0].</p>
        <ul>
          <li>
          <p>solution #1:</p>
          <ul>
            <li>
            <p>details:</p>
            <ul>
              <li>
              define an operator '.' on const IStr* that returns const IStr&amp;?
              </li>
              <li>
              define operator[] on const IStr* as well.
              </li>
            </ul>
            </li>
            <li>
            <p>pros:</p>
            <ul>
              <li>
              provides convenient access to strings while allowing us to
              distinguish between 'interned string that can be null' and
              'interned string that cannot be null'.
              </li>
            </ul>
            </li>
            <li>
            <p>cons:</p>
            <ul>
              <li>
              can we define the needed operators?
              </li>
            </ul>
            </li>
          </ul>
          </li>
          <li>
          <p>solution #2:</p>
          <ul>
            <li>
            <p>details:</p>
            <ul>
              <li>
              *str is implemented as const IStr&amp;
              </li>
              <li>
              the IStr class would overload operator '->' to be the same as '.'
              so that C++ users looking at the '*str' and assuming they need
              to use '->' won't be confused.
              </li>
              <li>
              the 'null' meta pseudovalue can be semantically overloaded. In most
              situations it is the null ptr of the baselang (nullptr, None, null,
              etc), but for 'str' types it can be IStr::Null, a special instance
              of IStr).
              </li>
            </ul>
            </li>
            <li>
            <p>pros:</p>
            <ul>
              <li>
              this allows us to support 'var name : str = null' as
              'const IStr&amp; name = IStr::Null'
              </li>
            </ul>
            </li>
            <li>
            <p>cons:</p>
            <ul>
              <li>
              it does NOT allow us to distinguish between the types
              'interned string that can be null' and
              'interned string that cannot be null' in the same way that
              it would if '*str' means IStr*
              </li>
            </ul>
            </li>
          </ul>
          </li>
        </ul>
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>&amp;str  (variant #1)</p>
  <ul>
    <li>
    <p>Variant 1: interned string that cannot be null</p>
    <ul>
      <li>
      <p>pros</p>
      <ul>
        <li>
        not null is consistent with '&amp;' semantics of other types
        </li>
      </ul>
      </li>
      <li>
      <p>cons</p>
      <ul>
        <li>
        none?
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>Variant 2: interned string that can be null</p>
    <ul>
      <li>
      <p>pros</p>
      <ul>
        <li>
        if 'str' means '&amp;str' it would be useful for &amp;str to be nullable
        (although 'null' may not mean nullptr ... could mean special
        instance of interned str class).
        </li>
      </ul>
      </li>
      <li>
      <p>cons</p>
      <ul>
        <li>
        violates the fundamental meaning of what '&amp;' means in Meta.
        DEAL BREAKER.
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>Variant 3: &amp;str is not legal</p>
    <ul>
      <li>
      <p>pros</p>
      <ul>
        <li>
        implementation-wise, vec<&amp;str> is not possible because a growable
        array must allocate more space than elements, with those elements
        somehow marked as "null", which isn't allowed for an actual reference
        (although &amp;str does not necessarily need to be implemented by a
        reference).
        </li>
      </ul>
      </li>
      <li>
      <p>cons</p>
      <ul>
        <li>
        people are very use to 'const std::string&amp;' (aka &amp;#str = &amp;str since str
        is implicitly const)
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>Notes:</p>
    <ul>
      <li>
      it is absolutely crucial to provide some mechanism for distinguishing
      between
        interned string type that can be null
      and
        interned string type that cannot be null
      because this distinction is important in Javascript when using the
      Google closure optimization javascript compiler.
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>@str  (variant ??)</p>
  <ul>
    <li>
    <p>Variant #1: is illegal</p>
    <ul>
      <li>
      <p>pros</p>
      <ul>
        <li>
        is intuitive ... @ implies copy semantics, and an immutable
        interned object cannot be copied. Even if we have @ mean
        'copy or move semantics', it is still problematic because
        we don't want to move these interned instances either.
        </li>
      </ul>
      </li>
      <li>
      <p>cons</p>
      <ul>
        <li>
        user has to remember that @str is illegal, unlike every other
        type (not a big issue).
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>Variant #2: value cannot be null</p>
    <ul>
      <li>
      <p>pros</p>
      <ul>
        <li>
        synonym for &amp;str?
        </li>
        <li>
        alternative for &amp;str if &amp;str is made illegal.     
        </li>
      </ul>
      </li>
      <li>
      <p>cons</p>
      <ul>
        <li>
        special-case semantics (does NOT mean copy-by-value, although
        @ does mean copy-by-value everywhere else).
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>Variant #3: value can be null</p>
    <ul>
      <li>
      <p>pros</p>
      <ul>
        <li>
        ??
        </li>
      </ul>
      </li>
      <li>
      <p>cons</p>
      <ul>
        <li>
        special-case semantics (does NOT mean copy-by-value, although
        @ does mean copy-by-value everywhere else).
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>str  (variant #1)</p>
  <ul>
    <li>
    <p>Variant 1: 'str' means '*str'</p>
    <ul>
      <li>
      <p>pros:</p>
      <ul>
        <li>
        consistent with how all other non-primitive types are handled
        (e.g. vec is <em>vec, map is </em>map, Person is *Person, etc.)
        </li>
        <li>
        Python, Perl and Javascript all use interned strings everywhere, and
        all string-typed variables can be null, so by having 'str' map to
        '*str', most variables can be typed as 'str' (note that Javascript
        with closure requires us to be able to distinguish betweeen 'str can
        be null' and 'str cannot be null'
        </li>
      </ul>
      </li>
      <li>
      <p>cons:</p>
      <ul>
        <li>
        In C++ syntax is cumbersome (but see '*str' discussion above for
        possible workaround).
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>Variant 2: 'str' means '&amp;str'</p>
    <ul>
      <li>
      <p>pros:</p>
      <ul>
        <li>
        Python, Perl and Javascript all use interned strings everywhere, and
        all string-typed variables can be null. If 'str' means '&amp;str' and
        '&amp;str' can be null, then the most common usecase can be represented
        by 'str' (a weak pro given the conditional).
        </li>
      </ul>
      </li>
      <li>
      <p>cons:</p>
      <ul>
        <li>
        violates the semantics of '&amp;' within Meta, which very clearly
        indicates that '&amp;' means "cannot be null".  DEAL BREAKER.
        </li>
        <li>
        it is more common for str-valued variables to be of the form
        'interned string that can be null' than 'interned string that
        cannot be null'. By having 'str' mean '&amp;str', we will be forced
        to explicitly type variables as '*str' most often. DEAL BREAKER?
        </li>
        <li>
        Python, Perl and Javascript all use interned strings
        everywhere, and all string-typed variables can be null.  If
        str maps to &amp;str, and &amp;str cannot be null, almost every
        variable in these languages would need to be explicitly
        marked as \*str.  DEAL BREAKER ... this variant is nonviable.
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>Variant 3: 'str' means '@str'</p>
    <ul>
      <li>
      <p>pros:</p>
      <ul>
        <li>
        none?
        </li>
      </ul>
      </li>
      <li>
      <p>cons:</p>
      <ul>
        <li>
        '@' means pass-by-value, which for read-only types like 'str' is
        somewhat counter-intuitive (more intuitive would be to disallow
        @str is legal).  But we could define '@' differently for read-only
        types, so this isn't a deal breaker.
        </li>
        <li>
        Unless '@str' implies that the var cannot be null (not something
        I necessarily want it to imply, since there is a case for allowing
        null values for @str), 'str' meaning '@str' would mean there is no
        type to clearly state 'interned string that cannot be null'
        (we would need to introduce another type like !str to handle this).
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>Variant 4: 'str' means '&amp;str' or '*str' depending on value assigned to var</p>
    <ul>
      <li>
      <p>details:
         .</p>
      <ul>
        <li>
        When defining a parameter
          var name1 : str;
          var name2 : str = null;
          var name3 : str = '';
        we have:
          name1 is &amp;str
          name2 is <em>str
          name3 is could be &amp;str or </em>str ... let's say &amp;str for now, and user
             can explicitly specify *str to allow null
        .
        </li>
        <li>
        When defining a field:
          field name1 : str;
          field name2 : str = null;
          field name3 : str = '';
        we do not have as much info here as we do for parameters, as fields
        are often not given explicit defaults since there are type-specific
        defaults user can rely on. So it isn't so clear cut that name1
        should be &amp;str vs <em>str, but we can assume &amp;str and allow user to
        specify </em>str if needed.  name2 is clearly <em>str, and name3 can be
        assumed to be &amp;str (user can specify </em>str if needed).
        .
        </li>
        <li>
        When defining a local var:
          var name1 : str;
          var name2 : str = null;
          var name3 : str = '';
        similar reasoning as for fields (not for params!).
        </li>
      </ul>
      </li>
      <li>
      <p>pros:</p>
      <ul>
        <li>
        the user rarely needs to explicitly specify <em>str or &amp;str, using
        'str' everywhere, then adding </em>str or &amp;str only when forced by
        type checking.
        </li>
      </ul>
      </li>
      <li>
      <p>cons:</p>
      <ul>
        <li>
        it is not as obvious what the actual type of 'str' is in this
        variant as it is in the other variants, which may lead to
        programmer confusion.
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
</ul>


<h2>Implementation of Classes in Meta<javascript></h2>

<ul>
  <li>
  The user-level class nm.sp.Foo is written to 
    $METAREP/oopl/javascript/nm/sp/Foo.js
  and Foo.js is implemented using goog.module('nm.sp.Foo'), and exports a
  single value (the defined class Foo), which allows any other namespace
  requiring nm.sp.Foo to obtain it with:
     const Foo = goog.require('nm.sp.Foo');
  </li>
  <li>
  The metaclass for nm.sp.Foo is written to 
    $METAREP/oopl/javascript/nm/sp/FooMeta.js
  and FooMeta.js is implemented using goog.module('nm.sp.FooMeta'), but
  unlike Foo.js it exports two values (the defined metaclass FooMeta and
  the singleton instance of that metaclass, MetaFoo). This means that
  namespaces needing access to the metaclass must specify which symbol(s)
  they want, with:
    const {MetaFoo} = goog.require('nm.sp.FooMeta')
  or 
    const {FooMeta} = goog.require('nm.sp.FooMeta')
  or 
    const {MetaFoo,FooMeta} = goog.require('nm.sp.FooMeta')
  </li>
  <li>
  <p>The above inconsistency in how the modules are imported is unfortunate,
  but stems from the following facts:</p>
  <ul>
    <li>
    <p>nm.sp.Foo only has one thing to return (the class itself)</p>
    <ul>
      <li>
      this may not be true if there is native code pre/post the class
      that should export symbols ... do we want to support that?
      </li>
    </ul>
    </li>
    <li>
    <p>nm.sp.FooMeta defines the meta class, but one never actual needs
    the metaclass itself ... it is the singleton instance of the metaclass
    that is needed (we can obtain the metaclass itself from
    metainst.constructor).</p>
    <ul>
      <li>
      Instead of having the metaclass module return both metainst and
      metaclass, we could just return the metainst ... that would be a
      bit more consistent, although the user would still need to remember
      that goog.require('nm.sp.Foo' returns a class, while
      goog.require('nm.sp.FooMeta') returns an instance of a metaclass.
      </li>
    </ul>
    </li>
    <li>
    it is possible that no module other than nm.sp.Foo will ever need
    to import nm.sp.FooMeta, since nm.sp.Foo.meta() provides access to
    the metainst (and thus the metaclass). Should we disallow the
    explicit importing of nm.sp.FooMeta ... that would hide the above
    inconsistency quite nicely.
    </li>
  </ul>
  </li>
  <li>
  <p>Another subtle issue here. We do NOT want to return multiple symbols
  from goog.require('nm.sp.Foo'), because if multiple symbols are provided,
  the user must explicitly specify which symbols are desired.</p>
  <ul>
    <li>
    <p>This is a problem in situations where we want to define, for example,
    metax.root.Object, which inherits from javascript Object. We cannot
    use:
      class Object extends Object { ... }
      exports = Object;
    because the compiler doesn't know what we mean by the two different
    uses of Object.  So we need to instead do something like:
      class Object_ extends Object { ... }
      exports = Object_;</p>

    <p>This works fine if clients use the following:
      const Object = goog.require('metax.root.Object');
    but if the module for metax.root.Object returned multiple objects
    (for example: 'exports {Object\_, Symbol2, Symbol3};'), then
    the client would need to use:
      const {Object_} = goog.require('metax.root.Object');
    but only in the rare situation where the basename of the class matches
    a builtin javascript class from which the class inherits.  To hide
    away this rare but important special-casing, it is best if user-level
    class modules return the class and only the class.</p>
    </li>
  </ul>
  </li>
</ul>


<h2>Accessors</h2>

<p>Meta defines the 'field' construct, which serves many purposes:</p>
<ul>
  <li>
  defines state
  </li>
  <li>
  defines various accessors on the state
  </li>
  <li>
  defines dump, read, write
  </li>
  <li>
  supports packing
  </li>
  <li>
  supports UML generation
  </li>
</ul>

<p>The standard accessors for a field:
  field foo : int;
are
   foo() : int
   fooIs(value:int)
   fooRef() : &amp;int</p>

<p>The reasoning behind using 'Is' and 'Ref' suffixes for setter and mutable
setter</p>
<ul>
  <li>
  it is useful to be able to search for '.foo' and find all accesses
  to the field, which is not as easily accomplished if the accessors are
  named 'setFoo' and 'mutableFoo'.
  </li>
  <li>
  <p>case-consistency ... foo() and setFoo() are asymettric, foo() and fooIs()
  are symmetric</p>
  <ul>
    <li>
    yes, using getFoo() and setFoo() would be symettric too, but getFoo()
    is too cumbersome.
    </li>
  </ul>
  </li>
</ul>

<p>Questions:</p>
<ul>
  <li>
  <p>Should the setter return &amp;Class instead of void?</p>
  <ul>
    <li>
    <p>pros:</p>
    <ul>
      <li>
      Returning &amp;Class allows one to cascade messages:
        obj.ageIs(32).weightIs(85).heightIs(187)
      </li>
    </ul>
    </li>
    <li>
    <p>cons:</p>
    <ul>
      <li>
      more code clutter
      </li>
      <li>
      more inefficient ... the return value will often be unused, wasting
      an assignment
      </li>
      <li>
      we can support message cascades using '..', which is a more
      general solution anyways:
        obj.ageIs(32)..weightIs(85)..heightIs(187)
      </li>
    </ul>
    </li>
    <li>
    <p>conclusion:</p>
    <ul>
      <li>
      Setters return 'void'
      </li>
    </ul>
    </li>
  </ul>
  </li>
</ul>

<p>Notes:</p>
<ul>
  <li>
  getters are const and return consts
  </li>
  <li>
  setters are not const and return nothing
  </li>
  <li>
  <p>reffers are not const and return non-const</p>
  <ul>
    <li>
    <p>in languages without the ability to return lvalues
    from methods, a different means of providing reffer
    semantics is needed</p>
    <ul>
      <li>
      for languages with properties, the reffer is
      a property instead of a method (not optimal,
      but better than nothing).
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>the type of a field determines the type of args/return of
  accessors:</p>
  <ul>
    <li>
    <p>if field F has type @T</p>
    <ul>
      <li>
      <p>getter()</p>
      <ul>
        <li>
        returns @T if T is primitive
        </li>
        <li>
        returns &amp;#T if T is class
        </li>
      </ul>
      </li>
      <li>
      <p>setter(value)</p>
      <ul>
        <li>
        value has type &amp;#T and a copy is assigned to @T
        </li>
      </ul>
      </li>
      <li>
      <p>reffer()</p>
      <ul>
        <li>
        returns &amp;T (so that T can be modified)
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>if field F has type @#T</p>
    <ul>
      <li>
      <p>getter()</p>
      <ul>
        <li>
        returns @T if T is primitive
        </li>
        <li>
        returns &amp;#T if T is class
        </li>
      </ul>
      </li>
      <li>
      setter() not generated
      </li>
      <li>
      reffer() not generated
      </li>
    </ul>
    </li>
    <li>
    <p>if field F has type &amp;T (non-null ptr)</p>
    <ul>
      <li>
      getter() returns &amp;#T
      </li>
      <li>
      setter(value) has value of type &amp;#T
      </li>
      <li>
      <p>notes</p>
      <ul>
        <li>
        in C++, vec<&amp;T> is not possible if it is implemented
        literally as a vec of references. We could still
        support this conceptually, with vec<*T> and implicit
        dereferencing.
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>the base type associated with a metatype varies depending on the
  context it is used in:</p>
  <ul>
    <li>
    <p>as a field</p>
    <ul>
      <li>
      @T     T
      </li>
      <li>
      @#T    const T
      </li>
      <li>
      &amp;T     T&amp;           <-- requires initialization via init list of constructor (cannot reside in contanier)
      </li>
      <li>
      &amp;#T    const T&amp;     <-- requires initialization via init list of constructor (cannot reside in contanier)
      </li>
      <li>
      *T     T*
      </li>
      <li>
      *#T    const T*
      </li>
      <li>
      **T    T**
      </li>
      <li>
      #<em>#T   const T</em>const         <-- cannot reside in contanier
      </li>
      <li>
      <em>#</em>#T  const T*const*
      </li>
      <li>
      #<em>#</em>#T const T<em>const</em>const   <-- cannot reside in contanier
      </li>
    </ul>
    </li>
    <li>
    as a positial parameter
    </li>
    <li>
    as a keyword parameter
    </li>
    <li>
    as a local variable without default
    </li>
    <li>
    as a local variable with default
    </li>
  </ul>
  </li>
</ul>


<h2>Class Hierarchy</h2>

<p>Every user-defined user-level class in Meta has two auto-generated classes
associated with it, a meta class and a test class.</p>
<ul>
  <li>
  <p>A user-defined user-level class A in namespace 'nm.sp' (nm.sp.A):</p>
  <ul>
    <li>
    <p>has meta class nm.sp.AMeta</p>
    <ul>
      <li>
      has metaclass instance nm.sp.MetaA
      </li>
    </ul>
    </li>
    <li>
    has test class nm.sp_test.ATest
    </li>
  </ul>
  </li>
</ul>

<p>It is useful to understand how the user-defined class hierarchy generates
a metaclass hierarchy and a testclass hierarchy.</p>

<ul>
  <li>
  <p>User Class Hierarchy</p>

  <p>baselang root object (or no parent if the baselang has no root object)
   metax.root.Object
     nm.sp1.A
       nm.sp2.BsubA
          nm.sp2.DsubB
       nm.sp3.CsubA</p>
  </li>
  <li>
  <p>Meta Class Hierarchy</p>

  <p> baselang metaclass class (if exists and compatible with Meta metaclasses)
     metax.root.ObjectMeta
       nm.sp1.AMeta
         nm.sp2.BSubAMeta
           nm.sp2.DsubBMeta
         nm.sp3.CsubAMeta</p>

  <p>In particular, the metaclass hierarchy exactly mirrors the userclass
  hierarchy, differing only above the root (Object) level.</p>
  </li>
  <li>
  <p>Test Class Hierarchy</p>

  <p> baselang testclass class (if appropriate, although we may forego these in favor of a pure-meta implementation)
     metax.test.TestCase
       metax.root<em>test.ObjectTest
         nm.sp1</em>test.ATest
           nm.sp2<em>test.BSubATest
             nm.sp2</em>test.DsubBTest
           nm.sp3_test.CsubATest</p>

  <p> The testclass hierarchy also mirrors the userclass hierarchy, but test
   classes are placed in a different namespace than the classes they test
   (classes in namespace 'nm.sp' have test classes in namespace 'nm.sp_test').</p>
  </li>
</ul>

<p>IMPORTANT QUESTIONS RELATED TO CLASS HIERARCHY:</p>
<ul>
  <li>
  <p>should the meta-defined metaclass hierarchy inherit from baselang-specific
  metaclasses where present, or should the meta-defined metaclass
  hierarchy instead inherit from metax.root.Object and contain the
  baselang-specific metaclass when it is present?</p>

  <ul>
    <li>
    <p>The metaclass hierarchy defined by Meta inherits from the metaclass(es)
    defined by baselangs.</p>
    <ul>
      <li>
      <p>pros:</p>
      <ul>
        <li>
        we aren't maintaining two separate hierarchies in languages
        that provide 
        </li>
        <li>
        the features added by Meta integrate seamlessly into the
        features provided by the baselang, instead of the two sets
        of features being forced to be independent
        </li>
      </ul>
      </li>
      <li>
      <p>cons:</p>
      <ul>
        <li>
        Metaclasses are a required feature, introducing additional
        classes and complexity without any ability to remove them if
        they are unused.
        </li>
      </ul>
      </li>
      <li>
      <p>notes about ObjectMetaRoot:</p>
      <ul>
        <li>
        This class is for the metaclass hierarchy what Object is for the
        class hierarchy. All metaclasses in Meta inherit (directly or indirectly)
        from this class unless the user specifies a metaparent outside the
        meta metaclass inheritance hierarchy (which limits what Meta can do).
        </li>
        <li>
        This class acts as a bridge between the Meta world and the non-Meta
        world, inheriting from whatever baselang-specific class is used
        for metaclasses. If such a class does not exist, this class
        inherits from the root class in the baselang. If such a class
        does not exist, this class inherits from nothing. We 
        intentionally do NOT have this class inherit from
        metax.root.Object in such cases because that would mean that
        metax.root.Object functionality would be available in some
        baselang metaclasses but not in others.
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>Meta introduces a metaclass hierarchy that is independent of the
    metaclass hierarchy of the baselang, and instances of the Meta-defined
    metaclass hierarchy contain instances of the baselang metaclass
    instances (for baselangs that have a metaclass concept).</p>
    <ul>
      <li>
      <p>pros:</p>
      <ul>
        <li>
        all metaclasses across all baselangs can inherit from
        metax.root.Object and benefit from a consistent interface,
        instead of different functionality existing in different
        baselangs.
        </li>
        <li>
        the metaclasses introduced by Meta can be completely decoupled
        from the user-classes ... they can be used if needed, but
        do not have any impact on the code if not used. Note however
        that they are implicitly being used (and thus required) if
        the user defines any 'meta'-level classic constructs.
        </li>
      </ul>
      </li>
      <li>
      <p>cons:</p>
      <ul>
        <li>
        results in an extra hierarchy
        </li>
        <li>
        implies delegation of most functionality in situations where the
        baselang has an underlying metaclass
        </li>
        <li>
        <p>*** In Python, we would not be able to set __metaclass__ to
        the Meta-defined metaclass, and would have to implement all
        meta-level functionality using @classmethod, etc.</p>
        <ul>
          <li>
          this would be definining an 'Initialize' method and ensuring
          it always gets invoked when classes are loaded, etc. ...
          not nearly as clean a solution as having the metaclass
          initializer perform such initialization.
          </li>
        </ul>
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>should test classes have meta classes?</p>
  <ul>
    <li>
    <p>pros</p>
    <ul>
      <li>
      consistency ... why should test classes be punked?
      </li>
      <li>
      needed if we want to allow 'meta' level methods and fields in test
      classes (and we are attempting, with Meta, to promote location=meta
      over the less powerful kind=static)
      </li>
    </ul>
    </li>
    <li>
    <p>cons</p>
    <ul>
      <li>
      additional complexity for something that is rarely used ... how
      many test classes need to define meta-level methods/fields?
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>should meta classes have test classes?</p>
  <ul>
    <li>
    <p>pros</p>
    <ul>
      <li>
      uniformity.
      </li>
    </ul>
    </li>
    <li>
    <p>cons</p>
    <ul>
      <li>
      unnecessary complexity ... we can test any and all methods defined
      on the metaclass from within the user-level class wolog.
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>should it be possible for users to turn off the auto-generated
  metaclass and/or testclass associated with a user-level class?</p>
  <ul>
    <li>
    <p>For test classes</p>
    <ul>
      <li>
      <p>pros:</p>
      <ul>
        <li>
        meta classes often don't need test classes (if all they do is
        initialize some state), or the methods can be defined on the
        user-level instance.
        </li>
        <li>
        exception classes almost never need test classes
        </li>
      </ul>
      </li>
      <li>
      <p>cons:</p>
      <ul>
        <li>
        none?
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>For meta classes:</p>
    <ul>
      <li>
      <p>pros:</p>
      <ul>
        <li>
        exception classes usually don't need a meta class.
        </li>
        <li>
        test clases usually don't need a meta class.
        </li>
        <li>
        if a user doesn't want the overhead of the metaclass, and
        has no need of any meta-level functionality, they should be
        able to disable it.
        </li>
        <li>
        meta classes often don't need test classes
        </li>
      </ul>
      </li>
      <li>
      <p>cons:</p>
      <ul>
        <li>
        introduces an inconsistency in the interface available on
        classes
        </li>
      </ul>
      </li>
    </ul>
    </li>
    <li>
    <p>CONCLUSION: Allow disabling!</p>
    <ul>
      <li>
      Add an 'autogen' feature attribute to the 'class' construct that
      allows one to disable test and/or meta class generation.
      </li>
    </ul>
    </li>
  </ul>
  </li>
</ul>


<h2>Exception classes.</h2>

<p>  There is an important issue that needs to be resolved related to exceptions.
  We want to be able to offer two mutually exclusive features:</p>
<ol>
  <li>
  In order for baselang code to use meta-generated classes and catch
  exceptions without using Meta exception classes, each of these classes
  should inherit from baselang coorelates where possible.
  </li>
  <li>
  <p>In order to catch ranges of exceptions, it is useful to define an
  inheritance hierarchy of exceptions (if exception classes B and C inherit
  from A, then either exception can be caught be looking for exception A).</p>

  <p>Python: https://airbrake.io/blog/python-exception-handling/class-hierarchy</p>
  </li>
</ol>
<ul>
  <li>
  <p>BaseException</p>
  <ul>
    <li>
    <p>Exception</p>
    <ul>
      <li>
      <p>ArithmeticError</p>
      <ul>
        <li>
        FloatingPointError
        </li>
      </ul>
      </li>
      <li>
      AssertionError
      </li>
      <li>
      <p>ImportError</p>
      <ul>
        <li>
        ModuleNotFoundError
        </li>
      </ul>
      </li>
      <li>
      <p>LookupError</p>
      <ul>
        <li>
        IndexError
        </li>
        <li>
        KeyError
        ...
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>

  <p>C++: http://stdcxx.apache.org/doc/stdlibug/18-2.html modiifed in http://en.cppreference.com/w/cpp/error/exception</p>
  </li>
  <li>
  <p>exception</p>
  <ul>
    <li>
    <p>logic_error</p>
    <ul>
      <li>
      domain_error
      </li>
      <li>
      invalid_argument
      </li>
      <li>
      length_error
      </li>
      <li>
      out<em>of</em>range
      </li>
    </ul>
    </li>
    <li>
    <p>runtime_error</p>
    <ul>
      <li>
      range_error
      </li>
      <li>
      overflow_error 
      </li>
      <li>
      underflow_error     - 
      ...
      </li>
    </ul>
    </li>
  </ul>

  <p>Suppose Meta also wants to define a hierarchy of exceptions</p>
  </li>
  <li>
  <p>metax.root.Error</p>
  <ul>
    <li>
    <p>metax.error.Error</p>
    <ul>
      <li>
      metax.error.LogicError
      ...
      </li>
      <li>
      metax.error.RuntimeError
      ...
      </li>
    </ul>
    </li>
  </ul>

  <p>The classes in the Meta exception hierarchy need to inherit from other classes
  from the Meta exception hierarchy ... but they should also inherit from
  baselang equivalent classes.
  a. In baselangs with support for full multiple inheritance, this is viable
  b. In baselangs with support for single class inheritance and multiple
   interface inheritance, this is viable as long as the Meta exception class
   hierarchy is instead a Meta interface hierarchy.
  c. In baselangs without support for any form of multiple inheritance, this
   is only supportable in Meta by having all exception classes be native
   types.</p>

  <p>Given that Meta does not, as of 2017/12/31, have full support for multiple
  inheritance or interfaces, the easiest (and most general) solution is (c), so
  that is what we'll go with for now.</p>
  <ul>
    <li>
    must maintain a mapping from conceptual exception class to
    baselang equivalent
    </li>
    <li>
    <p>must provide some special baselang syntax to allow baselang scope: blocks
    to refer to the conceptual meta-level exception class name and have it
    replaced with the appropiate baselang exception class.</p>
    <ul>
      <li>
      there is a more general need for such an escape mechanism within baselang
      scope: blocks
      </li>
      <li>
      <p>possible syntaxes:</p>
      <ul>
        <li>
        $#{...}  --> I don't think this is legal in perl, is it?
        </li>
        <li>
        #${...}  --> this may conflict with perl syntax
        </li>
        <li>
        $!{...}
        </li>
        <li>
        !${...}  --> conflicts with Perl
        </li>
        <li>
        $!{...}  <-- this one is promising (slight problem related to ! field access, but acceptable)
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
</ul>


<h2>Variable interpolation within literal strings</h2>

<p>Suppose we want to form a string providing a person's name, dob, height and weight.</p>

<p>  python:
    print 'Person %s born %s height %1.2fm weight %1.2fkg' % (
      p.name(), p.dob(), p.height(), p.weight())</p>

<p>  javascript:
    console.log(
        'Person ' + p.name() + ' born ' + p.dob() +
        ' height ' + p.height().toFixed(2) + 'm' +
        ' weight ' + p.weight().toFixed(2) + 'kg');</p>

<p>  C++
    cout << "Person " << p.name()
         << " born " << p.dob()
         << " height " << ios:setprecision(2) << p.height() << "m"
         << " weight " << ios:setprecision(2) << p.weight() << "h"
         << endl;</p>


<p>Meta provides a mechanism for identifying literal strings in baselang source code
that contain special variable interpolation requests, and generating the appropriate
baselang source code.</p>
<ul>
  <li>
  <p>the code generated will not be valid RHS in all baselangs, so this is
  limited to situations where an arbitrary block of code can be inserted.</p>
  <ul>
    <li>
    NOTE: not strictly true, in that Meta could define a method, but passing in all
    necessary local vars becomes complicated ... maybe later.
    </li>
  </ul>
  </li>
  <li>
  <p>rather than introducing escape syntax within baselang code to indicate
  creation of a string object based on this special syntax, we can do the more
  general thing ... use meta-level statements. Added bonus: provide a mechanism
  to embed meta-level statements inside a baselang simple block!</p>

  <p> method show
   scope<*>:
     var msg : str = 
       "Person ${.name} born ${.dob} "
       "height ${.height:1.2f}m weight ${.weight:1.2f}kg\n";
     block
     :py:
       print msg
     :js:
       console.log(msg)
     :cc:
       cout << msg << endl;
   end method;</p>
  </li>
</ul>

<p>Meta can provide lots of convenience syntax within these variables:</p>
<ul>
  <li>
  ${.name} means @self.name
  </li>
  <li>
  ${!name} means @self!name
  </li>
  <li>
  ${rec.name} means @rec.name
  </li>
  <li>
  ${rec!name} means @rec!name
  </li>
  <li>
  ${name} means local variable 'name'
  </li>
  <li>
  ${@name} means "name " + local variable 'name'
  </li>
  <li>
  ${@.name} means "name " + @self.name
  </li>
</ul>


<h2>Finding class/method/field definitions in meta files</h2>

<ul>
  <li>
  By providing the ability to define many namespaces/classes/methods in
  a single file, we introduce a problem not present in other languages ...
  how to find the right definition of a class/method/field by id.
  </li>
  <li>
  <p>Variant #1:</p>
  <ul>
    <li>
    <p>search for 'class <id>' or 'method <id>' or 'field <id>'</p>
    <ul>
      <li>
      pros:
      </li>
      <li>
      <p>cons:</p>
      <ul>
        <li>
        <p>takes a long time to type, and 'class <id>' is not very
        unique.</p>
        <ul>
          <li>
          Searching for '^J class <id>' but is cumbersome to type.
          </li>
          <li>
          Searching for 'd <id>' can be used to find field or method
          with given name.
          </li>
        </ul>
        </li>
        <li>
        because a method 'foo' might be defined via 'field' or 'behavior',
        it is not so easy to find.
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>Variant #2:</p>
  <ul>
    <li>
    <p>rely on IDE support</p>
    <ul>
      <li>
      <p>emacs and vim support for:</p>
      <ul>
        <li>
        <p>class:</p>
        <ul>
          <li>
          identifying current class
          </li>
          <li>
          going to start or end of current class
          </li>
          <li>
          going to previous/next class
          </li>
        </ul>
        </li>
        <li>
        <p>method:</p>
        <ul>
          <li>
          identifying current method
          </li>
          <li>
          going to start or end of current method
          </li>
          <li>
          going to previous/next method
          </li>
        </ul>
        </li>
        <li>
        <p>overview:</p>
        <ul>
          <li>
          display all classes, lifecycles, methods, fields, behaviors
          (and allow narrowing based on typed id) and allow jump-to
          capabilities.
          </li>
        </ul>
        </li>
      </ul>
      </li>
    </ul>
    </li>
  </ul>
  </li>
</ul>


<h2>The Importance Of Antlr</h2>

<p>Although Meta can do a great deal without having baselang parsers,
being able to produce an AST of a baselang program (across all
baselangs) would provide the following benefits:</p>
<ul>
  <li>
  can introduce { ... } block syntax in addition to indent-based blocks
  </li>
  <li>
  can automate baselang-to-meta conversations
  </li>
  <li>
  can properly identify whether fields are initialized in initializers
  </li>
  <li>
  can establish whether a method returns before end
  </li>
</ul>


<h2>C++ and Bazel</h2>

<p>C++17 offers many features that will be very useful in Meta<C++>, so we need
Meta to be C++17-enabled from the get-go. However:</p>
<ul>
  <li>
  on macos as of 2017/12/16, the default c++ compile is clang
     % c++ --version
     |c++ --version
     |Apple LLVM version 9.0.0 (clang-900.0.38)
     |Target: x86_64-apple-darwin16.7.0
     |Thread model: posix
     |InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
  </li>
  <li>
  <p>apple clang 9.0.0 is mapped to LLVM 4.? </p>
  <ul>
    <li>
    LLVM releases at http://releases.llvm.org/ 
    </li>
    <li>
    C++ status for LLVM at https://clang.llvm.org/cxx_status.html
    </li>
    <li>
    <p>apple version numbers to LLVM version numbers: https://en.wikipedia.org/wiki/Xcode#cite<em>note-LLVM</em>versions-80</p>
    <ul>
      <li>
      nothing specified for most recent apple clang, but presumably LLVM 4*
      </li>
    </ul>
    </li>
    <li>
    one can supposedly use -std=c++1z (according to https://clang.llvm.org/cxx<em>status.html
    in the 'C++17 implementation status' section), but that doesn't work:
      % cd meta2/src/kernel/tests/cc/c++17
      % make 
      % /usr/bin/clang++ -std=c++1z main.cc
      |main.cc:2:10: fatal error: 'any' file not found
      |#include <any>
      |         ^~~~~
      |1 error generated.
      % which clang++
      |clang++ is /usr/bin/clang++
      % cd /usr/include
      % find . -name '*any*'
      |./apr-1/apr</em>anylock.h
    </li>
  </ul>
  </li>
  <li>
  g++ does handle C++17 properly:
    % cd meta2/src/kernel/tests/cc/c++17
    % /usr/local/wmh/gcc-7.2/bin/g++ -std=c++17 main.cc
    % ./main
    |Hello World
    |val1 = 1
  </li>
  <li>
  <p>bazel's default CROSSTOOL uses clang:
    % cd meta2/src/kernel/tests/cc/c++17
    % make bazel-clobber
    % blaze build --cxxopt=-std=c++1z --verbose_failures :main
    |...
    |main.cc:2:10: fatal error: 'any' file not found
    |#include <any>
    |         ^~~~~</p>

  <p>  % grep cxx $(find $(bazel info execution<em>root) -name CROSSTOOL)
    |...
    |cxx</em>builtin<em>include</em>directory: "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.0.0/include"
    |...</p>
  </li>
  <li>
  <p>it is possible to have bazel use a different compiler</p>
  <ul>
    <li>
    <p>a discussion of cc_configure</p>
    <ul>
      <li>
      https://blog.bazel.build/2016/03/31/autoconfiguration.html
      </li>
    </ul>
    </li>
    <li>
    <p>indicates that one can set envvar CC and rerun:
      % cd meta2/src/kernel/tests/cc/c++17
      % bazel clean --expunge
      % make bazel-clobber
      % export CC=/usr/local/wmh/gcc-7.2/bin/g++
      % blaze build --cxxopt=-std=c++17 --verbose_failures :main
      |...
      |g++: error: unrecognized command line option '-Wthread-safety'; did you mean '-fthread-jumps'?
      |g++: error: unrecognized command line option '-Wself-assign'; did you mean '-Wcast-align'?
      |...</p>

    <ul>
      <li>
      <p>Looks like the crosstool generation code defined in cc<em>configure is accidentally
      inserting some compiler</em>flag options that aren't legal for gcc.</p>
      <ul>
        <li>
        comment out 
           compiler<em>flag: "-Wthread-safety"
           compiler</em>flag: "-Wself-assign"
        in
          % emacsclient $(find $(bazel info execution_root) -name CROSSTOOL)
        </li>
      </ul>
      </li>
      <li>
      Retrying the build:
       % blaze build --cxxopt=-std=c++17 --verbose_failures :main
       |...
       |collect2: fatal error: cannot find 'ld'
       |...
      </li>
    </ul>
    </li>
  </ul>

  <p>https://stackoverflow.com/questions/41356173/how-to-use-clang-instead-g-in-bazel</p>
  </li>
</ul>


<h2>Supporting native methods</h2>

<p>Many languages provide a mechanism for interacting with code written in other
languages</p>
<ul>
  <li>
  perlxs (https://perldoc.perl.org/perlxs.html) links to C code
  </li>
  <li>
  python (https://docs.python.org/2.0/ext/intro.html) links to C code
  </li>
  <li>
  java JNI (https://en.wikipedia.org/wiki/Java<em>Native</em>Interface) links to C, C++, assembler
  </li>
</ul>

<p>As well, there are means of perform whole-program conversion to other languages:</p>
<ul>
  <li>
  emscripten (https://en.wikipedia.org/wiki/Emscripten) compiles C++ and
  outputs asm.js, a subset of Javascript !!!
  </li>
  <li>
  mono/.NET
  </li>
</ul>

<p>Meta can make these cross-language capabilities much easier:</p>

<p>  Suppose we have a program written in python. A specific method could instead
  be written in C++ (with Meta automatically providing all of the glue needed
  to interface between the languages).</p>

<pre><code>class Matrix scope:

  method times : Matrix #:
    Implemented in C++ for efficiency.
  params:
    var matrix : Matrix;
  scope&lt;py&gt;:
    native lang c++ scope:
      ... add C++ code here ...
    end;
  end method times;
</code></pre>

<p>  Note that my original idea that an entire method could be marked
  'native' does not work because we need to specify both the target baselang
  and the native baselang, which would only be possible if we put the 
  target baselang on the 'scope:' of 'class' (that is too limiting).</p>
<ul>
  <li>
  Will need to expand this idea further.
  </li>
</ul>


<h2>Supporting I/O (etc.) in Javascript</h2>

<p>We need to provide I/O capabilities in Javascript.  Since phantomjs already
has such support (and would also be the sensible choice to provide the
javascript version of 'meta2 repl') we can use phantomjs.</p>

<p>TODO(wmh): Establish how to properly specify the needed dependencies if a
certain javascript class uses phantomjs libraries like 'require(webpage)', etc.</p>

<p>Note that 
  https://github.com/bazelbuild/rules<em>closure/blob/master/closure/testing/phantomjs</em>harness.js
(and the other files in its directory) may be helpful here.  For example,
note how one types phantomjs objects:
  var webpage = /<b> @type {!phantomjs.WebPage} */ (require('webpage'));
  var fs = /</b> @type {!phantomjs.FileSystem} <b> (require('fs'));
  var webserver = /</b> @type {!phantomjs.WebServer} <b> (require('webserver'));
  var system = /</b> @type {!phantomjs.System} */ (require('system'));</p>

<p>And from
  https://github.com/bazelbuild/rules<em>closure/blob/master/closure/testing/BUILD
the BUILD target:
  closure</em>js<em>library(
      name = "phantomjs</em>harness",
      srcs = ["phantomjs<em>harness.js"],
      no</em>closure_library = True,
      deps = ["//closure/testing/externs:phantomjs"],
  )
I suspect the dep will need to be modified to use @ syntax, but it should be
a helpful starting point ... we may be able to use</p>


<h2>Languages to Support</h2>

<p>Java
Perl
Go
Eiffel
Ada
C#
ObjC
Ruby
Emacs (EIEIO): https://www.gnu.org/software/emacs/manual/html_mono/eieio.html</p>


<h2>History</h2>
<ul>
  <li>
  Pxx and Cxx
  </li>
  <li>
  X3
  </li>
  <li>
  Meta (uwo, in perl)
  </li>
  <li>
  Meta (uwo, in Meta<perl>)
  </li>
  <li>
  Meta (sf, in python)
  </li>
  <li>
  Meta2 (in Meta<python>)
  </li>
</ul>


<h2>Units of Measurement</h2>

<ul>
  <li>
  <p>Research</p>
  <ul>
    <li>
    https://dl.acm.org/citation.cfm?id=1035292.1029008
    </li>
  </ul>
  </li>
  <li>
  <p>For C++</p>
  <ul>
    <li>
    https://github.com/nholthaus/units (https://sourceforge.net/projects/tuoml/)
    </li>
  </ul>
  </li>
  <li>
  <p>For python</p>
  <ul>
    <li>
    https://pypi.python.org/pypi/units/
    </li>
    <li>
    https://pypi.python.org/pypi/measurement/1.8.0
    </li>
    <li>
    https://pypi.python.org/pypi/quantities/
    </li>
    <li>
    http://home.scarlet.be/be052320/Unum.html
    </li>
    <li>
    http://dirac.cnrs-orleans.fr/ScientificPython/ScientificPythonManual/Scientific.Physics.PhysicalQuantities-module.html
    </li>
    <li>
    https://pint.readthedocs.io/en/latest/
    </li>
  </ul>
  </li>
  <li>
  <p>For .NET?</p>
  <ul>
    <li>
    https://www.codeproject.com/Articles/216191/Quantities-Units-and-Values-an-Object-Oriented-Imp
    </li>
  </ul>
  </li>
</ul>


<h2>Languages To Add To Meta</h2>

<ul>
  <li>
  Python            py
  </li>
  <li>
  Javascript        js
  </li>
  <li>
  C++               cc
  </li>
  <li>
  Java              java
  </li>
  <li>
  Ruby              rb
  </li>
  <li>
  C#                cs
  </li>
  <li>
  Objective-C       mm
  </li>
  <li>
  Delphi            pas
  </li>
  <li>
  Swift             swift
  </li>
  <li>
  Perl              pm
  </li>
  <li>
  Go                go
  </li>
  <li>
  Dart              dart
  </li>
  <li>
  Ada               ada
  </li>
  <li>
  R?                r
  </li>
  <li>
  Eiffel
  </li>
  <li>
  EIEIO
  </li>
  <li>
  Smalltalk/Squeak  st
  </li>
  <li>
  Tcl               tcl
  </li>
</ul>


<h2>Pain Points</h2>

<ul>
  <li>
  <p>finding specific code in a large file is problematic</p>
  <ul>
    <li>
    <p>having code defined in various possible places makes searching for it difficult</p>
    <ul>
      <li>
      is it a field or a method?
      </li>
      <li>
      is it defined in the class or in a behavior?
      </li>
    </ul>
    </li>
  </ul>
  </li>
</ul>


<h2>Important To Remember</h2>

<ul>
  <li>
  <p>Metaclass initializers get invoked N+1 times if there are N descendent
  classes of the underclass. In hindsight, this is obvious, but I had been
  assuming that code written into metaclass <b>init</b> blocks was executed
  exactly once. Important to keep this in mind.</p>
  <ul>
    <li>
    puts more importance on providing 'static' fields separate from 'meta'
    fields, for situations where we want to ensure code occurs exactly
    once.
    </li>
  </ul>
  </li>
</ul>


<h2>Bugs</h2>

<ul>
  <li>
  The 'default' attribute of 'var' is of type 'word' instead of 'expr'.
  This means we cannot use:
    var  delim : str = '  ';
  and is totally limiting in many other ways. Fix!!
  </li>
  <li>
  Cannot define a 'native' construct before the first 'class' in a namespace
  scope: because the code is looking for a class to attach the native code
  to.  Need to support this usecase ... it will be common to add a native
  block before any classes.
  </li>
  <li>
  NamespaceConstruct._mergeClassesPython() has to deal with the fact that
  we sometimes want to refer to class nm.sp.Class2 from within nm.sp.Class1
  as nm.sp.Class2, when python prefers we use Class2 when they share a
  namespace (because python does not add 'sp' to 'nm' until 'nm.sp' is fully
  parsed).  The code currently inserts some magic at the top of each
  module to define nm.sp within nm.sp, but it is entirely possible that this
  code will break something in python's control flow.
  </li>
  <li>
  <p>The Emacs major-mode has various weaknesses:</p>
  <ul>
    <li>
    Within Meta comment blocks, inserting the character \" immediately kills
    all syntax highligting
    </li>
    <li>
    When in a comment block, if the current line has a '(' without matching
    ')' and newline-tab is entered, the cursor is moved below the unmatch
    ')' rather than being moved to the start of block position.
    </li>
    <li>
    <p>When searching up for start of construct, it can be mislead by matching
    regexps in comments.</p>
    <ul>
      <li>
      could be improved by having Meta know how many spaces appear before
      each construct (usually 0 for namespace, 2 for class, 4 for method),
      but this will obviously break for nested classes, etc.
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>The fundamentally important Construct.attrpair() method has a problem:
     locattr, location = self.attrpair('location', default=LOOKUP)
  Suppose that the construct in question does not explicitly specify a
  'location'. That means it does not have a location in the metafile, which
  means locattr.line() will not be meaningful ... but often the whole point
  of keeping locattr around is to get the meta linenum!</p>

  <ul>
    <li>
    In such situations, attrpair() should return (None, <value>) instead of
    returning the misleading special Attribute instance.
    </li>
    <li>
    To identify places where this is causing problems, we could initialize
    the 'line' field of the special Attribute instances cached in attrinfo
    to some sentinal like -123, and whenever Attribute.line() is invoked, if
    the value is -123, we raise an error.
    </li>
  </ul>
  </li>
  <li>
  <p>Suppose we have a class with user and meta methods and a user-defined
  TestCase class in 'test' location.  The meta method test blocks cannot
  benefit from the initialization done in the TestCase, because they
  are defined separately.</p>
  <ul>
    <li>
    consider merging tests into a single class, or otherwise fixing this
    (copying TestCase code to TestCaseMeta?)
    </li>
  </ul>
  </li>
</ul>


<h2>Critical Missing Features</h2>

<ul>
  <li>
  Meta needs someone to write code for vim that does syntax highlighting, etc.
  </li>
  <li>
  <p>Should Meta support python-like continuations in all baselangs?</p>
  <ul>
    <li>
    https://www.ps.uni-saarland.de/~duchier/python/continuations.html
    </li>
  </ul>
  </li>
  <li>
  <p>Support for multiple inheritance (state and/or interface).</p>
  <ul>
    <li>
    Meta can do a lot here, but there is almost zero support for
    multiple inheritance as of 2018-01-01, even at the level of
    individual baselangs (never mind making it work for Meta<X1|X2>).
    </li>
  </ul>
  </li>
  <li>
  Support for interfaces
  </li>
</ul>


<h2>TODO</h2>

<ul>
  <li>
  <p>In type specifications, support named params:</p>

  <p>  For example:
      tuple<dirname:str,basename:str>
    vs
      tuple<str,str></p>

  <p>  And
      map<{name:str,height:float,cards:int,present:bool}>
    vs
      map<str,any></p>
  </li>
  <li>
  <p>For every native type, introduce a class in the Meta library that
  provides a baselang-independent implementation and describes the
  public interface available.  Introduce some secondary simplex attribute
  on 'executable' to allow specification of native code:</p>

  <p>  class Vector<T> < Container<T> #:
      A collection of contiguous element indexed by integer
       - get(index) = O(1)
       - set(index) = O(1)
       - sort() = O(N)
    nativetype<py> list
    nativetype<cc> std::vector<$T>
    nativetype<js> Array
    scope:</p>

  <pre><code>field allocated : int #:
  How many elements are allocated.
field size : int #:
  How many elements are assigned.
 
lifecycle params:
  var size : int = 0 #:
    Initialize size of list.
scope:
end;

method size : int aliases "len,length" #:
  Number of elements in vector.
scope&lt;*&gt;:
  return @self.size;
native&lt;py&gt; 'len($rec)'
native&lt;cc&gt; '$rec-&gt;size()'
native&lt;js&gt; 'this.length'
end method;
</code></pre>
  <p>  end class;</p>

  <p>  NOTES:</p>
  <ul>
    <li>
    <p>there should be both 'native' and 'native:' defined on methods</p>
    <ul>
      <li>
      native accepts a string, and represents baselang code that can be
      used to implement the method as a statement
      </li>
      <li>
      native: defines a block of baselang code and implies that the
      method cannot be implemented in the given baselang as a statement
      (requires multiple lines).  The result can still be used as a RHS,
      as long as it is possible to insert lines of code into the
      baselang code stream before the line requiring the RHS.
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <p>Support aliases for method and field names</p>
  <ul>
    <li>
    will at the very least be useful for 
    </li>
  </ul>
  </li>
  <li>
  <p>The 'default' attribute of 'var', 'field' and 'flag' should have type 'expr'
  not 'word'</p>
  <ul>
    <li>
    will allow us to support
       var item : nm.sp.Class = @nm.sp.Class2.Func;
    or
       var item : map = {'a': 1, 'b': 2};
    </li>
  </ul>
  </li>
  <li>
  <p>In describing Meta, emphasize the utility in being able to add good ideas
  from arbitrary languages into all baselangs</p>
  <ul>
    <li>
    'new' vs 'override' semantics on methods is crucial ... not all baselangs
    support it.  Meta can ensure this semantics exists everywhere.
    </li>
    <li>
    python-like repl
    </li>
    <li>
    java-like per-class entry points
    </li>
    <li>
    ability to distinguish "nullable ptr" vs "non-nullable ref" vs "value"
    </li>
    <li>
    easy-to-use multi-match regexp
    </li>
    <li>
    variable interpolation in strings
    </li>
    <li>
    units of measurement
    </li>
    <li>
    unified test environment
    </li>
    <li>
    formalized resources and associations
    </li>
    <li>
    automated uml generation
    </li>
    <li>
    <p>source code configuration and canonicalization</p>
    <ul>
      <li>
      index generation
      </li>
    </ul>
    </li>
    <li>
    trivial aspect-oriented capabilities
    </li>
    <li>
    cross-language native embedding
    </li>
    <li>
    cross-language typechecking
    </li>
    <li>
    'auto' type
    </li>
  </ul>
  </li>
  <li>
  <p>NamespaceConstruct.expandMeta() needs updating so that each namespace has an
  'id' with not dots in it. The code in
     NamespaceConstruct.createImplicitParents()
  was designed for use in the namespace initializer, but similar code can be
  crafter for expandMeta. </p>
  <ul>
    <li>
    start with the test namespace, which is being created within expandMeta
    (instead of creating a namespace with multi-dots, create individual
    namespaces). 
    </li>
    <li>
    once the test namespace is working properly, move on to updating the
    user namespace, which is a bit more subtle because it already exists.
    </li>
  </ul>
  </li>
  <li>
  <p>Statement level support!!</p>
  <ul>
    <li>
    recursive loading of dependency classes
    </li>
    <li>
    proper initialization of symbol tables
    </li>
  </ul>
  </li>
  <li>
  <p>Decide how to handle exceptions</p>
  <ul>
    <li>
    See discussion above entitled 'Exception classes'.
    </li>
    <li>
    <p>Looks like providing a mapping from conceptual exception naems to
    baselang equivalents is the way to go for now.</p>
    <ul>
      <li>
      This could be a real problem moving forward...
      </li>
    </ul>
    </li>
  </ul>
  </li>
</ul>

<p>Define metax.error, a namespace consisting solely of exception classes.</p>
<ul>
  <li>
  each exception class should inherit from appropriate baselang 
  classes where possible.
  </li>
  <li>
  each should be clearly documented with when it should be raised
  </li>
  <li>
  all code in the Meta implementation should use these classes.
  </li>
</ul>

<ul>
  <li>
  Support aliases on primary attributes (e.g. 'arg' for 'flag')
  </li>
  <li>
  In addition to the >| syntax, which does:
     namespace nm.sp scope:
       class A scope:
          method f scope:
            text = """
             >|some text
             >|more text"""
  we should also support
     namespace nm.sp scope:
       class A scope:
          method f scope:
            text = """
     !meta<em>inline:
     some text
     more text"""
     !end meta</em>inline:
  which inserts the text to the same level as the line before !meta_inline:
  This is not optimal, and will require special support from the simple-block
  parsing code, but having to indent text via >| is sometimes cumbersome.
  Is there a better solution?  emacs and vim support for >|?
  </li>
  <li>
  <p>Implement C++ to the point where 'make cards2-cc' works.</p>
  <ul>
    <li>
    need to get C++ unit testing working
    </li>
    <li>
    may need to improve the type system.
    </li>
  </ul>
  </li>
  <li>
  <p>uml generation</p>
  <ul>
    <li>
    this should use the HTML syntax so that we can draw association lines
    from field to field rather than just class to class.
    </li>
  </ul>
  </li>
  <li>
  <p>implement behavior stubs?</p>
  <ul>
    <li>
    Problem: if one looks for a method in a class but it is defined
    in a behavior instead, it can be confusing.
    </li>
    <li>
    <p>Solution: support "behavior stubs" ... method declarations
    in classes with a featval 'stub' to indicate they are replaced
    by a behavior.</p>

    <p>  class Foo scope:
        stub method methname;
      end class;</p>
    </li>
  </ul>
  </li>
  <li>
  <p>Provide a 'Meta' symbol in every namespace, to give access to:</p>
  <ul>
    <li>
    all reflection capabilities
    </li>
    <li>
    a parsed dict of the ~/.config/metameta file
    </li>
    <li>
    ... there are more benefits here ... list them...
    </li>
  </ul>
  </li>
</ul>


<h2>Ideas</h2>

<ul>
  <li>
  <p>Add a 'preamble:' block to 'behavior' constructs that is inserted at the
  start of each receiver scope block before user code after auto-gened
  preamble code.  Useful for initializing params with same logic.</p>
  <ul>
    <li>
    less useful if per-baselang blocks are needed .. more useful if
    logic can be written in Meta*
    </li>
  </ul>
  </li>
  <li>
  <p>The 'lazy' block on accessors in fields should be moved up to being
  a block on 'field' itself, not on accessors</p>
  <ul>
    <li>
    it doesn't make sense for 'set'
    </li>
    <li>
    the same code applies to both 'get' and 'ref' (confirm this before moving)
    </li>
  </ul>
  </li>
  <li>
  <p>Add a 'super' feature attribute to the 'var' construct for use in params:
  blocks ... implicitly added to the super() attribute:
    method f params:
      super var a : int;
    scope:
    end;
  is equivalent to
    method f params:
      var a : int;
    super (a)
    scope:
    end;</p>

  <p>For bonus points, can skip type and comment because meta can look it up
  from the parent method:
    method f params:
      super var a;
    scope:
    end;
  is equivalent to
    method f params:
      var a : int;
    super (a)
    scope:
    end;
  because Meta can find the parent definition to determine that param
  'a' has type int (and can insert parent comment block, etc.) </p>
  </li>
  <li>
  <p>Provide a syntax on 'var' within 'params:' to indicate that the
  default value should be "whatever the default of the parent invocation is"
  for use in super calls.</p>
  <ul>
    <li>
    in python, this can be implemented by not passing the keyword parameter
    at all in the super call.
    </li>
    <li>
    example:
       method f params:
         super var a : int;
         super var b : int = 3;
         super var c : int = super;
    this would be equivalent to
       super (a, b=b)
    (the c arg is marked as 'use default from super' so we don't
     pass it to the super call).
    </li>
  </ul>
  </li>
  <li>
  <p>Support literal syntax for bases other than 10.
     723R8
     010001100010100R2
     ab8373aR16
     1234R10
   or
     0o723
     0b010001100010100
     0xab8373a
     123</p>

  <p> Note: Meta does NOT support 0235 as being base 8! (too ambiguous)</p>

  <p> Note: How will this interact with literal units? 
     83kg in base 8?</p>

  <p> Note that suffixes like Ki, Mi, Gi, Ti, and Pi implicitly
   encode a base-2 interpretation, but somewhat special in nature.</p>
  <ul>
    <li>
    Ki = 2^10
    </li>
    <li>
    Mi = 2^20
    </li>
    <li>
    Gi = 2^30
    </li>
    <li>
    Ti = 2^40
    </li>
    <li>
    Pi = 2^50
    </li>
  </ul>
  </li>
</ul>


<h2>Stack</h2>

<ul>
  <li>
  ability to see ConsInfo data for specific construct
  --> meta shell
    --> native type for 'date', 'time', etc
      - units of measurement
    --> getting 'run' command working
      --> creating a 'hierarchy' summary of a meta file using org-mode
        --> supporting 'aliases' attribute on 'command' construct
          --> getting 'str' attribute type working
            --> auto-filtering exceptions raised when meta2 invoked 
              - blocked because exception was occuring during creation of Compiler
                and since filterMetaOutput is an instance method I have a catch-22
            - solution to 'str' issue was 
                Attribute path : str = <empty> #:
              vs
                Attribute path : str = empty #:
          --> timing how long it takes to parse/expand/translate/compile each metafile
            --> adding file/line counts to writeSummary
          --> tracking down the bug in metax.root.flags.Command.instantiate()
               - was a use of 'current<em>arg</em>index' instead of 'index' when forming
                 argv to consume with multi-valued catch flags!
          - finally got aliases working!
        --> provide a total in writeSummary when more than two files were parsed.
  </li>
</ul>
  </body>
</html>
