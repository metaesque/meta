# Meta

## Installation

First, add a definition for environment variable METAROOT to your
.bashrc, .cshrc, etc. file.

 - this variable should be an absolute path to a directory
 - this directory indicates where Meta is installed on the local machine

Second, execute the following unix commands:
 % curl -O http://life.holst.ca/static/meta/meta-0.095.tgz
 % tar xzvf meta-0.095.tgz
 % mv meta-0.095 $METAROOT
 % cd $METAROOT
 % make build
 % make test
 % make install

## Meta From The Bottom Up: Example Programs

Figure: Example Meta<Python> code. [=fig1]

    ```meta
    class Person comment:
      A simple Person class.
    scope:

      ro field name type Name;

      ro field height type real<64> #:
        Height of person, in meters.

      ro field weight : real<64> #:
        Weight of person, in kilograms.
      
      initializer Person params:
        var name : Name;
        var height : real<64>;
        var weight : real<64>;
      scope:
        self.nameIs(name);
        self.heightIs(height);
        self.weightIs(weight);
      end initializer;

      public method BMI : real<64> #:
        Returns the body mass index
        of the person.
      scope:
        return (self.weight() /
          (self.height() * self.height()));
      end;
    
    end class Person;</textarea>
    ``` 

Figure: Example Meta<C++> code. [=fig2]

    ```meta
    class Person comment:
      A simple Person class.
    scope:

      ro field name type Name;

      ro field height type real<64> #:
        Height of person, in meters.

      ro field weight : double #:
        Weight of person, in kilograms.
      
      initializer Person params:
        var name : Name;
        var height : real<64>;
        var weight : real<64>;
      scope:
        this->nameIs(name);
        this->heightIs(height);
        this->weightIs(weight);
      end initializer;
      
      public method BMI : real<64> #:
        Returns the body mass index
        of the person.
      scope:
        return (this->weight() /
          (this->height() * this->height()));
      end;
    
    end class Person;</textarea>
    ``` 

One of the central aims of Meta is the **augmententation** of
pre-existing languages, where augmentation means numerous things (more
readable code, more expressive code, more concise code, new features
and idioms, etc.). This augmentation is realized by introducing a
family of new languages that each extend an underlying (pre-existing)
language with new syntax and associated semantics. For example,
Meta<C++> is a programming language that extends C++ (and provides a
concrete set of object-oriented features whether or not they exist
natively within C++). Meta<C++> shares certain syntax in common with
C++ (statement-level syntax and below), but introduces new syntax for
concepts above the level of statements (e.g. when defining data
members, methods, classes, namespaces and everything else outside of a
method body). Similarly, Meta<Java> is a programming language that
extends Java (and provides a concrete set of features whether or not
they exist natively within Java). Meta<Java> shares some syntax in
common with Java (statement-level syntax and below), and introduces
new syntax for concepts above the level of statements. In general, for
any existing _base language_ {L} supported by Meta, Meta defines
Meta<L>, which provides guarantees about the existence of certain
language features whether or not they exist natively within {L}, and
introduces new syntax (shared across all Meta<L> languages) for
high-level concepts.

Another of the central aims of Meta is the **unification** of families
of languages. Consider the family of object-oriented programming
languages. C++ is an object-oriented programming language with a
certain set of features and capabilities. Java is also an
object-oriented programming language, with some features in common
with C++, and some differences. The same is true of Python, Perl,
Javascript and all the other languages with object-oriented features.
Each language has its only set of strengths and weaknesses, some
shared features, idioms and syntax, and various differences. As
mentioned above, Meta<L> shares statement level syntax with base
language {L}, but what allows Meta to act as a unifier of languages is
that the new syntax introduced by Meta<L> (for syntax above the level
of statements) is _exactly_ the same as for Meta<L'>. The way one
defines a field, a method, a class, a namespace (and many other
syntactic and semantic concepts associated with object-oriented
programming languages) is exactly the same in Meta<C++> as it is in
Meta<Java> as it is in Meta<Python>; it is _unified_ across an entire
family of languages. This has an important impact on various things,
ranging from how quickly one can learn a new language, to addressing
legacy code issues, to creating multi-language libraries (more on these
later).

Figure 1 shows a toy Meta<Python> program, and Figure 2 shows the
same program written in Meta<C++>. Note that both programs are exactly
the same except in lines 15-17 and 24-25. Those lines consist of
statement-level syntax, and a Meta<Python> program shares
statement-level syntax with Python, while a Meta<C++> program shares
statement-level syntax with C++.

A person familiar with object-oriented concepts
(classes/methods/fields, visibility/inheritance/invocation, etc.) can
easily understand the basics of these programs even without any
discussion of the semantics behind the syntax (that is, the syntax is
intuitive), but the structure of the syntax makes it easy to document
every aspect of Meta and make it easy to discover. A person familiar
with C++ can be writing Meta<C++> code in minutes, and the same is
true for someone familiar with Python starting to write Meta<Python>,
[^1]. 

[^1] In a more comprehensive example, a larger percentage of the line
count would be made up of statements, so this example over-represents
the amount of code commonality between Meta<Python> and Meta <C++>,
but is useful for the purpose of illustration

### Meta Syntax

Meta syntax consists of exactly one self-contained syntactic construct,
referred to simply as a **construct**. There are different kinds of constructs
(fields, methods, classes, namespaces, and many others), but every construct
has the same overall structure; each construct is a collection of attributes
followed by a construct terminator.

    BNF Grammer

    <file> ::- 
      <construct>...

    <construct> ::- 
      [<feature-attribute>]... {<primary-attribute>} [<secondary-attribute>]... <term>

    <feature-attribute>   ::- [<key>] <enum-value>
    <primary-attribute>   ::- {<key>} <value>
    <secondary-attribute> ::- <key> <value>

    <key> ::- <word-value>

    <value> ::-
      <enum-value> |
      <id-value> |
      <xid-value> |
      <idlist-value> |
      <expr-value> |
      <int-value> |
      <word-value> |
      <wordlist-value> |
      <str-value> |
      <type-value> |
      <simple-block-value> |
      <complex-block-value>
      
    <expr-value> ::-
      <num-value> |
      <id-value> |
      <str-value> |
      <literal-list> |
      <literal-plist> |
      <literal-map> |
      <callsite>

    <term> ::-
      ';' |
      'end;' |
      <kind> 'end;' |
      <kind> <id-value> 'end;'

In Meta, an **attribute** is a key/value pair, coupled with
meta-information (defined in a schema) that influences how an
attribute is parsed. For example, each attribute value has a type that
influences how it is tokenized, a set of recognized aliases, an
indication of whether the key and/or value is optional, etc.
Attributes comes in three flavors: <ol>

 - **feature attributes**:
   - Keys are always optional
   - Values come from a pre-defined fixed set of words
   - These attributes always appear _before_ the primary attribute
   - Example: the {visibility} attribute is defined on various
     Meta constructs, with values limitied to (for example),
     {public}, {protected} and {private}.

 - **primary attribute**:
   - The primary attribute key is the name of a construct, and is always
     present (it or an alias), as it defines what other attributes are legal
     within the construct.
   - The primary attribute value is a unique identifier for this construct
     (unique only amongst all over constructs at the same _block
     level_). Some constructs have optional primary values
     (if not provided, Meta auto-assigns a unique id). 
   - Each construct has exactly one primary attribute. 
   - Examples include
     {class} {Person}, {field} {weight}, and {method} {BMI}. 

 - **secondary attributes**:
   - Keys are usually required but sometimes optional.
   - Values can vary from a simple identifier to a complex block
     containing arbitrarily nested sub-constructs).
   - Secondary attributes always appear _after_ the primary attribute.
   - A simple example is the {returns} secondary attribute of the
     {method} construct, whose value is a Meta type (more on types in
     Meta later).
   - A more complex example is the {scope} secondary attribute, whose
     value is a block of zero or more constructs. The type of this
     attribute is referred to as a _complex-block_ to distinguish it
     from something like the {comment} secondary attribute whose value
     is a block of zero or more lines of arbitrary text, referred to
     as a _simple-block_.
   - Meta provides various secondary attribute value types, ranging
     from ids to words to strings to lists of ids to simple-blocks
     and complex-blocks.

In Figure 1 and 2, some of the syntactic aspects of Meta are
highlighted via color coding: {primary attribute keys}, {secondary
attribute keys}, {feature attribute values}, {Meta
primitive}, and {constructor terminators}. The
entirety of Figure 1 is a single instance of the {class} construct,
and its id (primary attribute value) is {Person}. Two
of the secondary attributes defined on {class} constructs are
{comment} (whose value is a "simple block", an arbitrary collection of
lines of text) and {scope} (whose value is a "complex block"
containing zero or more construct instances). In our example, the
{comment} attribute has as a value a single line of text ("A simple
Person class."), and the {scope} attibute has as a value a list of 6
constructs (4 fields, 1 initializer, and 1 method). Block-valued
attributes (simple or complex) can be indicating one of two ways, via
indentation (ala python) or by using block-start/end syntax (curly
braces ala C++, Java, etc.). This example uses the indentation-based
approach, which is generally more readable. </blockquote>

### The Meta Compiler

Meta provides a compiler that converts a Meta<L> program into a
program written entirely in base language {L}. Thus, a Meta<C++>
program is compiled into a C++ program, a Meta<Java> program is
compiled into Java, etc. For statement-level code, this is trivial
(code within Meta<C++> methods are C++ code, and are copied verbatim
into resulting C++ code, code within Meta<Java> methods are Java code
and copied verbatim into resulting Java code, etc.). For higher-level
meta syntax (definitions of classes, methods, fields, etc.),
appropriate base-language code is generated by the metac compiler. Similarly,
compiling Meta<Python> code involves generating Python code. In
general, compiling Meta<L> involves generating base language {L} code.

A particular base language may not directly support a particular
feature guaranteed by Meta, but such features can always be emulated
in any turing-complete language with enough effort (although doing so
efficiently is sometimes another matter).

## Meta From The Top Down

Meta is:
 * a high-level source-based programming environment for augmenting
   and unifying families of languages.
 * a flexible, unified, general-purpose syntax for describing data and
   code.
 * a collection of meta-languages, each of which represents a
   hierarchy of languages for capturing the similiarites between
   members of a family of related languages.

Meta is a hierarchy of languages built on top of pre-existing languages
that provides:

 * Increased expressivity (do more by typing less)
 * Augmentation
 * Unification
 * Readability
 * Writability
 * Adjacency (related code is adjacent instead of separated)

### Meta(Oopl)

Although Meta is more general than Meta(Oopl), an understanding of
Meta(Oopl) will give one an excellent understanding of Meta in
general. In fact, in what follows, Meta and Meta(Oopl) are used
interchangeably. Details on how Meta extends beyond Meta(Oopl) will be
discussed later.

Meta(Oopl) is a source-based programming environment for augmenting
and unifying object-oriented programming languages. It identifies a
supported set of _base languages_ (e.g. C++, Java, Python, Perl,
Javascript, with more added incrementally over time), and defines
augmented versions of each (Meta<C++>, Meta<Java>, etc.) that ensure
support for a long list of object-oriented features regardless of
whether each base language does.

Keeping in mind that Meta defines meta languages beyond Meta(Oopl),
note that Meta<C++> is more properly denoted Meta(Oopl)<C++>,
Meta<Java> is more properly denoted Meta(Oopl)<Java>, etc., but one
can usually establish the Meta-language from the base language alone,
so it is easy to see that Meta<C++> refers to Meta(Oopl)<C++> and that
Meta<HTML> refers to Meta(Doc)<HTML>.

Figure: Example Meta<Python|C++> code. [=fig3]

    ```meta
    class Person comment:
       A simple Person class.
    scope:
      ro field name type Name;

      rw field height type real<64> #:
        Height of person, in meters.

      rw field weight : real<64> #:
        Weight of person, in kilograms.
      
      initializer Person params:
        var name : Name;
        var height : real<64>;
        var weight : real<64>;
      scope<cpp>:
        this->nameIs(name);
        this->heightIs(height);
        this->weightIs(weight);
      scope<py>:
        self.nameIs(name);
        self.heightIs(height);
        self.weightIs(weight);
      end initializer;

      public method BMI : real<64> #:
        /# Returns the body mass index
        /# of the person.
      scope<cpp>:
        return (this->weight() /
          (this->height() * this->height()));
      scope<py>:
        return (self.weight() /
          (self.height() * self.height()));
      end;
    end class Person;</textarea>
    ```

Figure: Example Meta(Oopl)* code. [=fig4]

    ```meta
    class Person comment:
      A simple Person class.
    scope:
      ro field name type Name;

      rw field height type real<64> #:
        Height of person, in meters.

      rw field weight : real<64> #:
        Weight of person, in kilograms.
      
      initializer Person params:
        var name : Name;
        var height : real<64>;
        var weight : real<64>;
      scope<*>:
        @self.nameIs(name);
        @self.heightIs(height);
        @self.weightIs(weight);

      public method BMI : real<64> #:
        /# Returns the body mass index
        /# of the person.
      scope<*>:
        return @self.weight * self.height;
      end;
    end class Person;
    ```

### The Meta(Oopl) Language Hierarchy

As already mentioned, the Meta<C++> syntax used to define a class, or
method, or field (or various other high-level constructs needed in an
object-oriented programming language) is exactly the same as that used
in Meta<Python> or Meta<Java> or Meta<L> (for any object-oriented
base-language {L} that Meta supports). That is, high-level syntax is
unified across all base languages in a family of languages. What this
means is that a program written in, for example, Meta<Python> is
implicitly also partially implemented in Meta<Java>, Meta<C++>, etc.
Specifically, although a Meta<Python> program does not provide any
statement-level information about the corresponding Meta<Java> or
Meta<C++> implementation, the Meta<Python> program does provide
complete information about the overall structure of each class (its
methods and fields, what namespace it belongs to, its inheritance
hierarchy, etc.) in Meta<C++>, Meta<Java> or arbitrary Meta<L>.

The above observation, and, more viscerally, the similarity between
Figure 1 and Figure 2, suggests a way in which Meta could do even more
in its goal to augment and unify languages. What if there was a means
of specifying statement-level Python and C++ (and any base language L)
code in the same Meta program? This would have significant benefits in
any situation where code is being maintained in dual languages (for
example, rapid prototyping in one language followed by formal
implementation in another more efficient language, implementing
"native" C++ methods in a Java or Python or Perl program, legacy code
migration, etc.) and makes cross-language libraries (we might even
call these ... meta-libraries) a real possibility.

Figure 3 shows how Meta can accomplish this, by adding one simple
extension to its syntax. By allowing attribute keys to be qualified by
a base-language indicator, we can provide base-language specific
values for any attribute, including the crucial {scope} attribute
which defines (for the {method} construct) the body of the method. The
resulting program can be referred to as a Meta<Python|C++> program to
indicate that it has both Python and C++ implementations. The meta
compiler can thus be invoked on this single program and compiled into
either C++ or Python at the user's discretion.

This in turn suggests an entire hierarchy of Meta languages. In
addition to Meta<Python|C++> there is Meta<Perl|Java> and
Meta<Javascript|Ruby> and Meta<C++|Java|Python> and
Meta<C++|Java|Python|Javascript|Perl> and every other combination of
the base languages Meta provides support for.

Being able to specify statement-level code in multiple base languages
at the same time within a single Meta program obviously suggests yet
another level of potential language unification. If Meta were to
define its own syntax for statements, there would be no need to
provide base-language-specific statements, and yet the Meta compiler
would be able to compile the program into any base language supported
by Meta. This language is denoted as Meta(Oopl)\*, and Figure 4 shows
an example.

Meta(Oopl)\* is the fixed-point closure language of Meta(Oopl) at the
top of the language hierarchy formed by base languages {L}, {L'}, {L''}, ...
(at the bottom), Meta<L>, Meta<L'>, Meta<L''>, ... (at the second
level), Meta<L|L'>, Meta<L|L''>, ... (at the third level),
Meta<L|L'|L''|...> (at higher levels), and finally Meta(Oopl)\* at the
top of the hierarchy. Figure 5 summarizes this language hierarchy for
Meta(Oopl).

Meta(Oopl)\* introduces statement-level constructs:
 * {var}: declare a local variable (also used in parameters)
 * {call}: invoke a method (or access a field)
 * {loop}: loop (over, while/until, from/to/step)
 * {cond}: conditional code (if/elif/else, switch, etc.)
 
These statements in turn rely on __expressions__, which take on one of the
following forms:
 * literal number
 * literal string
 * literal hash
 * literal list
 * literal parameter list
 * variable
 * callsite
 * binary operator

Consider Figure 4. One of the secondary attributes of the
{initializer} construct is {scope}, whose value is a complex-block (a
block containing zero or more statement-level meta constructs). In our
example, we need to invoke three setter methods to initialize the
{name}, {height} and {weight} fields respectively. The first line in
the scope shows the verbose version of the {call} construct, which
makes clear the key/value attribute pairs making up the construct. In
particular, the primary key is {call} and its value is a unique
identifier for that call-site within its calling scope (we use '_' in
the example). The {call} defines (amongst others) the following
secondary attributes:

 * {on}, which specifies the receiver of the message.
 * {message}, which specifies the name of the method being invoked.
 * {arglist}, which specifies the args to the list.
 * ... various other attributes to handle more complex calls, for example
   when an argument is another method invocation, etc.

The second line of this method shows how the hyper-verbose syntax of
the first line can be improved:

* By providing the abbrev {@} for {call}, we can indicate the {call}
  construct with a single character.
* By making the attribute value of {call} be optional (auto-assigned
  to a unique id by the meta compiler), we can avoid having to name
  every callsite, while still allowing one to do so when it is useful
  (for aspect oriented programming, for example).
* By providing the abbrev {.} for {message}, we get to use
  syntax familiar to users of most OO languages.
* By providing the abbrev {(} for {arglist}, we
  get what looks like a simple parethesized list while still abiding
  by our everything-is-a-construct syntax.
* By providing a special secondary attribute {endarglist} with abbrev
  {)} and optional value, we can finish the parethensized list started
  above. This is admittedly rather "esoteric", but allows us to get
  close to the syntax used in most programming languages).

The third line of this method shows a few final improvements in syntax:

 * By allowing for optional attribute keys, Meta can support
   situations where the {on} attribute key is not present.
 * By not requiring whitespace between tokens when they can be
   uniquely identified without whitespace, we manage to get syntax
   that is only one character more verbose than exists in most
   languages. However, this only applies for trivial method
   invocations. For more complex invocations where the receiver or
   args are themselves method calls or expressions, Meta(Oopl)\*
   syntax is inevitable more cumbersome than base-language syntax.

Figure: The Meta(Oopl)\* language hierarchy. [=fig5]

>>>> INSERT FIGURE??

The {method} construct also supports the complex-block-valued secondary
attribute {scope<*>}, and the code in Figure 4 highlights where
Meta(Oopl)\* syntax can be more cumbersome than its base-language
equivalent. A simple expression in C++ or Java may need to be broken
up into multiple statements to get it into a form supportable by Meta.
However, continued improvements in how Meta can support concise,
readable, familiar statement-level syntax while keeping the
"everything-is-a-construct" rule will make Meta(Oopl)\* more and more
convenient as the implemention evolves.

Fortunately, an implementation in Meta(Oopl)\* is often unnecessary,
or can at least be delayed and incrementally moved toward. In fact,
there is a very natural incremental transition possible from
implementations in languages at the bottom of the hierarchy to
successively higher languages. For example, a Python program can be
easily (and to a large part automatically) converted into a
Meta<Python> program, which can easily (and incrementally) be
converted into a Meta<Python|C++> program, which can easily (and
incrementally) be converted into a Meta(Oopl)\* program if there is
benefit to do so.

### The Meta Library

One area where Meta(Oopl)\* programs are especially powerful is when
one wants to define the exact same code in multiple languages at the
same time. Such "multi-language" libraries have a huge benefit when it
comes to increasing programmer productivity. Once a programmer knows a
few languages, picking up the syntax of a new language is
straightforward. It isn't proficiency with language syntax that
separates novice programmers from experienced programmers, it is the
depth of knowledge one has of the libraries and idioms of the
language.

Meta makes it easier to work in multiple languages in two core ways.
First, if one knows Python, learning Meta<Python> is trivial, and it
is much easier to learn Meta<C++> based on Meta<Python> than it is to
learn C++ based on Python, because all of the esoteric C++ syntax
above the level of statements is hidden away behind Meta<C++> syntax
(the exact same syntax as used in Meta<Python>). Second, if one knows
Meta<Python>, it means one knows the Meta Library (a collection of
classes and APIs providing useful general-purpose functionality) ...
and the Meta Library is implemented in Meta(Oopl)\*, which means the
exact same library from Meta<Python> is available in Meta<C++>, so the
programmer already knows the Meta<C++> library.

The Meta Library is "meta" in two ways. It is a library provided by
Meta (more accurately, by Meta(Oopl). It is also "meta" in that it is
language-independent ... the same code and APIs in multiple languages
at the same time.

### Meta(Meta) and the Meta Meta Hierarchy

The syntax/semantics needed for object-oriented programming
languages (classes, methods, fields, etc.) is obviously quite
different than the syntax needed for type-setting languages (articles,
chapters, sections, etc.), which leads us to the concept of a
_Meta-language_.  At a high-level, Meta provides a mechanism for
defining <me>Meta-languages</em>, where a Meta-language is a hierarchy
of languages built on top of a family of pre-existing languages that
augment and unify those pre-existing languages. Each Meta-language
identifies the set of features it deems canonical, and ensures that
those features are available to users regardless of whether a
particular base language has that feature. Each Meta-language also
defines new syntax that can be shared amongst all of its augmented
languages (more on this below). 

Meta(Oopl) defines a collection of constructs useful for augmenting
and unifying object-oriented programming languages. But the definition
of the Meta(Oopl) schema does not require all of the constructs that
Meta(Oopl) requires ... schemas are fully defined by a handful of
constructs: Schema, Construct, Attribute, FeatureValue, and File.
These constructs constitute the meta language denoted Meta(Meta),
which is the root of a hierarchy of Meta-Languages, of which
Meta(Oopl) is just one. Meta(Oopl) "inherits" from Meta(Meta), which
means that Meta(Oopl) files can understand the constructs provided by
Meta(Meta) in addition to those provided by Meta(Oopl).

In a similar fashion, additional Meta-Languages could be defined. A
meta-language consists of:

 - a collection of zero or more related and similar pre-existing
   languages (_base languages_).
 - a schema for describing Meta-level constructs relevant to the
   Meta-Language being defined.
 - a set of rules for transforming the MetaLanguage syntax into
   lower-level syntax.
 - a collection of features guaranteed to be available in the Meta
   language, even if one or more of those features are not intrinsically
   available in the base language itself.

Examples of Meta-Languages one can define in Meta:

 - **Oopl**: the family of object-oriented programming languages. Base
   languages include: C++, Java, Python, Perl, etc.
 - **Func**: the family of functional programming languages. Base
   languages include: Lisp, Haskel, Erlang, Scheme, etc.
 - **Proc**: the family of procedural programming languages. Base
   languages include: C, Pascal, Fortran, Cobol, etc.
 - **Doc**: the family of type-setting languages. Base languages include:
   LaTeX, HTML, Markdown, Wiki markup, etc.
 - **Story**: a use-case not involving the augmentation of pre-existing
   languages, but rather using the Meta syntax to capture syntactic
   structure (defining constructs like chapters, events, persons, etc.)
   and a means of converting this syntax into something else (e.g. html,
   latex, etc.). In some ways this is similar to Meta(Doc), but specialized
   to the writing of a story.
   
### The Philosophy Behind Meta

 * Augment existing languages
   * Make it possible to say more with less (caveat: some simple things
     are more concise in baselangs in Meta, but as those simple things
     turn into more complex things, Meta syntax is often more concise)
   * Ensure that a core set of features exists in Meta<L> regardless of
     whether it exists explicitly in L.
 
 * Unify existing languages
   * Make it easy to implement code in one language and then incrementally
     migrate that code to a different language
   * Make it easy to keep code and native code together and provide the
     glue for linking said code together (e.g. Java JNI, Python extensions,
     Perl XSUBs.
     
 * General
   * Accessing fields directly breaks encapsulation ... always use accessors
   * Accessors without visibility scoping allows encapsulation to be broken,
     so visibility scoping is crucial
   * If you always do something, Meta should automatically do it for you:
      - print out this object
      - how big is this object?
   * Detailed information about the fields within a class allow for a massive
     amount of auto-generation to occur:
      - UML diagrams
      - object print and serialize/deserialize
      - object size
   * Anything worth doing for L is many times more worth doing for Meta<L>
     as it leads to having it done in Meta* and thus for all Meta<L>
   * Psychology plays an important role in how a program is written: 
      * the easier it is to do something, the more likely it is to be used
      * the more difficult it is to do something, the less likely it is to
        be used.
      * turing complete does not mean turing easy ... things possible in
        baselangs are often never done because of how much work would be
        needed to do it ... Meta hides away much of the tedium to make such
        things much easier.
      * Examples:
         - functions and classes within methods, functions, etc.

## Meta From The Middle Ground

### Features Guaranteed By Meta

Meta provides a very diverse collection of features, enumerated in
subsections below. Here is a quick summary:

 - Documentation as a first-class citizen
 - Source Code Customization/Canonicalization 
    - Customization
    - Canonicalization
 - The Meta Type System 
   - Type Syntax
   - Native Types
   - Primitive Types
   - Static vs Dynamic Typing
 - The Meta Library 
    - Units of Measurement
 - Meta Schemas: Meta in Meta 
 - Native Methods 
 - Unit Tests
 - Overloading
    - Operators
    - Methods
 - First-class objects
    - namespaces
    - classes
    - methods/functions
    - enums
 - Reflection In Meta
    - Meta Classes
 - Inheritance
    - One class, many interfaces
    - Multiple-class inheritance
 - Higher-Level Syntax
    - Lifecycle
    - Behaviors: multi-method dispatch
    - pre and post attributes
 - Access Control
 - Regular Expressions
 - Multithreading
 - The Power Of Fields
   - Serialization (protobufs)
   - Size analysis
   - Copying and Moving
   - UML diagram generation
 - The Power of Parameters
    - Initializer parameters and fields
    - Positional and keyword arguments
 - Consistency Across Base-Languages
    - How to compile source code
    - How to run unittests 
    - How to invoke a REPL
    - How to perform profiling
    - How to perform coverage analysis

#### Source Code Customization/Canonicalization 

##### Customization

Almost every aspect of the syntax of a meta document is customizable
by the user. In particular, the names associated with constructs,
attribute keys, and feature attribute values are all under user
control. For example, if you don't like defining your methods using
{method} and instead want to use {def}, you can do that. If you don't
want to type {protected}, you can instead introduce the alias {prot}.
If you don't like using {scope}, you can instead introduce the alias
{$}.  In general, most everything that you type in a meta program is
customizable (with a few exceptions, of course ;-)

This customization is provided by a simple reflexive mechanism.  Every
Meta-Language is defined by a schema. That schema defines a collection
of constructs and the attributes that are legal on those constructs.
One of the constructs that are available in every Meta-Language is the
special construct {Construct}, used to define constructs.  Another
special construct available in every Meta-Language is {Attribute}, used
to define attributes within a construct.  In order to provide customization,
all we need to do is provide access to these special constructs within
a Meta document, and some mechanism for modifying the constructs within
lexical scopes.

This is done by introduce the special {config} attribute on most
constructs (any construct that has a {scope} attribute also has a
{config} attribute). The {config} attribute has a complex-block as a
value, and the constructs that can appear within it are {Construct}.
The {Construct} construct also has a {config} attribute, and within it
can appear {Attribute} instances.

##### Canonicalization

Depending on how much customization you perform, your program can end
up looking entirely different from another person's meta program.
Customization is useful, but a downside is that others may find your
syntax less intuitive than their own. To address this issue, there is
always a canonical representation of every Meta program, and one can
switch between the canonical and customized views instanteously (or
between two completely different customized views).

#### The Meta Type System

The type system of a language is one of it's most critical aspects.
But Meta isn't trying to define a new type system so much as find a way
to unify all the type systems already existing across the various
object-oriented languages. The extent to which this is possible is still
under exploration, but here's where we are so far.

##### Type Syntax

Types in Meta have the following bnf grammar:

    <type>      ::- [<prefix>] <base> [ '<' <params> '>' ]
    <prefix>    ::- ( [ ['#'] '*' ]... | '&' | '@' ) ['#']
    <base>      ::- <primitive> | <native> | <extended-identifier>
    <primitive> ::- <base-prim> | <num-prim>
    <base-prim> ::- 'bool' | 'boolean' | 'trilean' | 'byte' | 'char'
    <num-prim>  ::- ( 'int' | 'uint' | 'real' ) [ '<' <num> '>' ]
    <num>       ::- 1 | 2 | ... | 127 | 128
    <native>    ::- 'str' | 'string' | 'vec' | 'tuple' | 'map' | 'imap' |
                    'omap' | 'set' | 'class'
                    '!regexp' | '!ostream' | '!istream' | '!sstream'

##### Native Types

There are a core set of types that every programming language provides, 
without which one is not very expressive, but with which one can implement
basically everything one needs.  Meta identifies a small collection of
such types, and provides the following for each such type:

 - a meta-level name by which to refer to the type
 - an implementation of the type in the Meta-Library
 - a mapping from base language to semantically equivalent type within
   that base language, for the meta-level type under consideration.
   
These types are called _native types_, because they have "native" (aka
base-language) representations. For example, one of the native types
in Meta is {map}, representing an associative array mapping keys to
values. This conceptual type exists in every language (and often in
multiple variants). For example, it is std::map or std::unordered_map
in C++, dict or collections.OrderedDict in Python, HashMap or
Hashtable in Java, etc. And it is also defined in the Meta Library
(meta.native.Map, meta.native.OrderedMap, etc.).

When the Meta compiler is compiling a Meta program down into Python,
any reference to type {map} can be replaced with either (depending on
compilation options) {meta.native.Map} or {dict}). When compiling down
into C++, any reference to type {map} can be replaced with either
(depending on compilation options) {meta::native::Map} or
{std::unordered_map}.

In summary, a program written using native types will produce base
language programs that use base-language specific representations of
those types. Here are the list of native types recognized by Meta
(in addition to the primitive types discussed in the next section):

Table: Native Types

| Type     | Semantics                            | index | get      | push   | insert   | pop  | delete   |
| :---     | -------------------------            | ----- | ------   | ------ | ------   | ---- | ------   |
| str      | immutable interned string            | int   | O(1)     | -      | -        | -    | -        |
| string   | mutable string                       | int   | O(1)     | O(N)   | O(N)     | O(N) | O(N)     |
| vec      | ordered int-indexable collection     | int   | O(1)     | O(1)*  | O(N)     | O(1) | O(N)     |
| tuple    | immutable ordered list               | int   | O(1)     | -      | -        | -    | -        |
| map      | unordered assoc array                | any   | O(1)     | -      | O(1)     | -    | O(1)     |
| imap     | ordered (insertion time) assoc array | any   |          |        |          |      |          |
| omap     | ordered (by key) assoc array         | any   | O(log n) | -      | O(log n) | -    | O(log n) |
| set      | unordered non-indexable collection   | -     |          |        |          |      |          |
| class    | a class type                         | -     |          |        |          |      |          |
| !regexp  | a compiled regexp pattern            | -     |          |        |          |      |          |
| !ostream | an output stream                     | -     |          |        |          |      |          |
| !istream | an input stream                      | -     |          |        |          |      |          |
| !sstream | a string-based I/O stream            | -     |          |        |          |      |          |
| date     | a date (year, month, day)            | -     |          |        |          |      |          |
| datetime | a date and time (hour, min, sec)     | -     |          |        |          |      |          |

* amoritized time

##### Primitive Types

Meta defines a simple collection of primitive types similar to those
available in most programming languages. Meta, however, provides both
_basic primitives_ and _parameterized primitives_

Table: Basic Primitives In Meta

| Type    | Abbrev | Semantics                  |
| ---     | ------ | ---------                  |
| boolean | bool   | values: true, false        |
| trilean | tri    | values: true, false, null  |
| byte    |        | one ascii value (0 to 255) |
| char    |        | one unicode character      |

Table: Parameterized Primitives in Meta

| Type |  Param | Abbrev     | Semantics                        |
| ---  | ------ | ---------  | ---------                        |
| int  |      N |            | values from -2^(N-1) to +2^(N-1) |
|      |     16 | short      |                                  |
|      |     32 | int        |                                  |
|      |     64 | long       |                                  |
|      |    128 | longlong   |                                  |
| uint |      N |            | values from 0 to +2^N            |
|      |     16 | ushort     |                                  |
|      |     32 | uint       |                                  |
|      |     64 | ulong      |                                  |
|      |    128 | ulonglong  |                                  |
| real |      N |            | floating point number            |
|      |     32 | float      |                                  |
|      |     64 | double     |                                  |
|      |    128 | longdouble |                                  |

Each of these meta-level primitive types acts as a native type per the
discussion in the pervious section. Thus, when compiling a program
that references the meta-level primitive type {uint<17>} into C++, the
Meta compiler determines that the best C++ primitive type
corresponding to the semantics of {uint<17>} is C++'s uint32_t, so
that is what will be generated in the C++ code.

##### Static vs dynamic typing

any 'var' or 'field' or 'method' can be assigned a type, but that
type is optional.  if not specified, a type may be inferable (for
example, if an integer is assigned to an untyped variable, one can
assume the variable is supposed to be an integer. but even if no
type can be established, meta provides the 'any' type in all base
languages to represent such untyped values.  Thus, types can be
left off during intial development, and incrementally added to
improve readability, efficiency and various meta-level features
like native-type rewrites.

#### The Meta Library

As with any programming environment, it is really not the syntax that
makes a language, but rather the robustness of the library associated
with the language.

What sets Meta apart is not the vastness of its library (it is currently
tiny, but growing), but rather the fact that the library is, whereever
possible, implemented in Meta(Oopl)*.  Which means that exactly the same
library exists in C++ and Java and Python and every other language Meta
supports.  Not only that, but the existing implementation of the Meta
Library becomes available in a language not yet supported by Meta as
soon as support is added.

Which means that the Meta Library is also compilable down tolanguages
not even invented yet! Suppose you implement a new object-oriented
language called PurpleRain tomorrow. The entire meta library will
become available in PurpleRain as soon as support for PurpleRain is
added to Meta (which takes between a day and a week for each new
language).

##### Units Of Measurement

The Meta Library provides a collection of classes representing the SI Base Units
(https://en.wikipedia.org/wiki/International_System_of_Units#Base_units)
with functionality to convert between different units, etc.

The Meta compiler provide support for literals with SI scaling
suffixes. For example,
  `field weight : kilograms = 10K`
defines weight to be 10 tonnes

Meta also supports SI unit symbols so that specifying types isn't
necessary in certain situations (and are validated when provided). For
example,
   `field temp = 11.5 C` 
defines temperature to be of type Temperature (because C is recognized
as specifying temperature) and has value 11.5 celsius). Furthermore,
   `field length : @meta.units.length = 9.8 kg`
produces a compile-time error because the constant `9.8 kg` indicates
the type meta.units.mass, not meta.units.length.

#### Meta Schemas: Meta in Meta

What is syntactially legal in Meta(Oopl) is dictated by the following things:
 1. the overall syntactic structure: 
    - everything is a construct
    - constructs consist of zero or more feature attributes, a required primary attribute,
      and zero or more secondary attributes.
    - each attribute consists of an attribute key (sometimes optional) and an
      attribute value (sometimes optional)
    - constructs can be terminated with `;`, `end;`, `end <construct>;` or
      `end <construct> <name>;`
 2. the set of legal constructs (and, within a construct, the set of legal attributes)
    that can appear in a particular complex block.
    
The first of these is controlled by the Meta parser. The second is
controlled by a _Meta schema_, which the parser uses to identify
constructs and attributes. A Meta schema is described using Meta
syntax (that is, as a collection of constructs). The special
{Construct} construct defines the legal constructs, and the special
{Attribute} construct defines legal attributes within a construct.

#### Native Methods

Suppose you are writing a Meta<Python> program, and discover that one
specific method is causing a bottle-neck in performance. One
alternative would be to incrementally migrate the program to Meta<C++>
or even Meta(Oopl)*.  But it is also possible to just mark the method
as native and provide a C++ implementation of the method, relying on
the Meta compiler to perform all the actions necessary to invoke the
C++ code from python.

#### Unit Tests

When Meta compiles each class, it automatically generates a test
class, within which test methods can be added. Every method in
Meta(Oopl) can be provided with one or more tests. This has a number
of advantages over base languages:

 - the testing code is adjacent to the code it is testing, making it
   easier to understand the code from the tests perspective and
   vice-versa.
 - the boiler-plate tedium of creating a separate file to contain tests,
   a test class to contain the tests within the class, and the per-method
   test signatures are completely removed from the user. You can just
   write testing code and rely on Meta to auto-generate all the glue.
   
Some unit testing terminology

    code under test:
      The code being tested. In an OOPL, this is a class or method within
      that class.
    test fixture:
      A fixed state of a set of objects used as a baseline for
      running tests. The purpose of a test fixture is to ensure that
      there is a well-known and fixed environment in which tests are
      run so that results are repeatable. setUp() and tearDown()
      methods initialize test fixtures. In an OOPL, instance(s) of
      the class being tested are a common test fixture.
    unittest:
      Code that executes a specific functionality in the code under test
      and verifies that the functionality produces expected results. In an
      OOPL, it is common to have at least one unittest for every method,
      preferably one unittest for every control path thru the method.
      External dependencies should be removed (using a mock, etc.)
    behavior unittest (or interaction test):
      A unittest that confirms that certain code wa called with the
      expected input parameters (tests behavior of code under test).
      In an OOPL, this monitors which methods the method being tested
      invoked, and with what args.
    state unittest:
      A unittest that validates the result returned by code under test
      and that expected side-effects occurred. In an OOPL, this verifies
      that the correct return objects are created and that object state
      is modified as intended.
    integration test or functional test:
      Tests the behavior of a comopnent or the integration between a set
      of components. In an OOPL, integration tests verify that classes
      interact with one another in expected ways.
    performance test:
      Used to benchmark software components repeatedly to ensure that
      code under test runs fast enough.
    assert statements:
      A collection of methods or functions that compare one value
      against an expected value. If the assert fails, the test
      within which the assert resides is marked as failing.

    TestCase:
      A class that defines fixtures (and setUp() and tearDown() methods
      for initializing those fixtures) and a collection of one or more
      test methods.  Each instance of TestCase is responsible for
      invoking one of these test methods, and each such instance
      represents a single 'unittest'.  The set of test methods is
      normally auto-discovered, by assuming all methods defined on
      the TestCase class starting with 'test' are test methods.
    TestSuite:
      A collection of TestCase and TestSuite instances whose tests are
      to be executed.
    TestRunner:
      Responsible for performing the tests. All TestRunner implementations
      should do the following:
       - for each TestCase in a provided TestSuite
         - invoke setUpClass()
         - identify the test methods on the TestCase and create an instance
           of TestCase for each one.
         - for each TestCase instance
            - invoke setUp()
            - invoke the test method
            - invoke tearDown()
         - invoke tearDownClass()

Every meta-generated class in every base language has an associated
test class for testing the methods within the class. The test class
inherits (directly or indirectly) from the class you are currently
reading (meta.testing.TestCase). The structure is as follows:

- Given a user-defined class <C> within namespace <N> (in meta syntax):
  - A namespace <N>\_test is implicitly defined by Meta
  - A class <C>Test within <N>\_test is implicitly defined by Meta
  - For every user-defined method <M> defined within <C>
    - If there is a {test} attribute defined on <M>, its
      content represents a test method for testing <M>, and
      Meta defines the method test\_<M> within <C>Test with the
      contents of this {test} attribute.
    - Alternatively, if there is a {tests} attribute defined
      on <M>, it is a complex block accepting all the normal
      constructs that can appear within a class (method,
      field, etc.), and these constructs are inserted
      verbatim into <C>Test. However, more importantly, the
      {tests} attribute can contain {testx} constructs as
      well, the scope of which represents code for testing
      some aspect of <M>. If a {testx} construct has primary
      value <id>, then Meta creates test\_<M><id> in <C>Test
      and adds the code within the {testx} scope as the body of
      this method.
  - Meta defines meta.testing.TestCase, and each class <C>Test
    inherits (directly or indirectly) from this class. This
    class provides three kinds of functionality:
    
     1. fixture initialization code via
         setUp:
         tearDown:
         SetUp (meta)
         TearDown (meta)
     2. assertions
          iseq
          iseqvec
          iseqtup
          iseqset
          iseqelems
          iseqmap
          iseqtext
          isfeq
          isgt
          isge
          islt
          isle
          issubset
          isempty
          isnull
          isinstance
          isin
          isfalse
          istrue
     3. unittests
         - each instance of TestCase represents a single unittest, usually
           a test method associated with a user-defined class.

#### Overloading

##### Operators

Meta allows one to define operators on classes, and finds a way to
emulate those operators in base languages that don't support operators.

For example, Meta(Oopl) has syntax of the form:

    ```meta
    operator +
    scope<py>:
      return lhs.value() + rhs.value()
    scope<cc>:
      return lhs.value() + rhs.value()
    ```

When compiling into C++, this becomes `operator+`, while in python it becomes __add__.
In languages like Java, special methods (similar to what Python provides) are
defined, but the ability to invoke these methods via operator syntax is necessarily
somewhat curtailed within Meta<Java> (but not within Meta(Oopl)*, which can invoke
the appropriate method when it sees operator syntax in its statement-level meta
constructs.

##### Methods

The ability of a class to have the same method name with differing
implementations (because the static types of arguments become part of
the name) is offered in C++ and Java, but not in various other
languages. Meta can provide support for this, but it is unlikely to
be particularly useful in languages that don't already support it.
If code is being migrated from a language without good support for
it to a language with good support, it is unlikely that the initial
design will have tried using this idiom.

TODO(wmh): More here.

#### First-Class Objects

In "Structure and Interpretation of Computer Programs" by Gerald Jay Sussman and Harry Abelson,
they define a first-class object as one that:
 * may be named by variables.
 * may be passed as arguments to procedures.
 * may be returned as the results of procedures.
 * may be included in data structures.

In an object-oriented programming language, one easy way to ensure that a particular
concept is a first-class object is to provide a class that is available to the
programmer that defines that concept ... instances of the class are specific
instantiations of the concept.

Meta guarantees that the following concepts are first-class objects regardless of
whether the underlying base language does (by using base-lang functionality when
it is available, and/or by defining a class within the baselang to represent the
concept)

##### Namespaces

##### Classes

##### Methods/Functions

##### Enums

  
#### Reflection In Meta

##### Meta Classes

Every time Meta compiles a class, it creates a _meta class_ associated
with the class. This meta class guarantees that classes are
first-class objects in Meta<L> regardless of whether they are in {L},
and is the platform by which Meta can guarantee various kinds of
reflection and thus meta-programming.

Most classes defined within Meta inherit eventually from meta.root.Object
(what meta.root.Object inherits from is baselang-specific ... 'object' in
python, 'java.lang.Object' in Java, 'UNIVERSAL' in Perl, nothing in C++,
'Object' in javascript, etc.).  There is a metaclass associated with
meta.root.Object, namely meta.root.ObjectMetaClass

Suppose that class Shape inherits from meta.root.Object.

#### Inheritance

##### One class, many interfaces

Meta guarantees state inheritance from a single class, and functionality
inheritance from zero or more interfaces.

##### Multiple-class inheritance

Multiple inheritance of state from multiple classes is not currently
guaranteed, but may be in the future.

#### Higher-Level Syntax

This section discusses various constructs and features Meta provides,
built up on the core constructs (class, method, field).

##### Lifecycle

The {lifecycle} construct is reponsible for the lifecycle aspects of
an object, including initialization, finalizing, copy/move semantics,
setup (for unittests) and teardown (for unittests).

##### Behaviors: multi-method dispatch

The {behavior} construct turns the 'methods-within-classes' structure
of object-oriented programs on its head. Suppose you have a class
hierarchy (e.g. a Shape hierarchy), and each class in the hierarchy
needs to implement various methods (e.g. area(), perimeter(),
containsPoint(), boundingBox(), draw(), etc.). There are a few
problems with the traditional approach of syntactically defining the
relevants methods in each class: 

 1. The exact same signature (and documentation) gets repeated in all
    of the classes, and changes to anything in the signature requires
    changes in all classes.
 2. The implementations for a particular method are scattered across the
    code base, when adjacency could facilitate better understanding of
    the differeing implementations.
 3. Traditional object-oriented programs allow one to perform dispatch
    based on the dynamic type of a single receiver object, but sometimes
    a more expressive and intuitive implementation can be produced when
    the code to execute depends on the dynamic type of multiple receiver
    objects.

The behavior construct addresses all of the above.

TODO(wmh): Provide an example using the Shape hierarchy.

##### pre and post attributes

Meta provides 'pre' and 'post' attributes on methods, allowing one to
specify invariants that should be true when the method is entered and when
it is exited, ala Eiffel.

#### Access Control

Meta ensures that methods and fields can have public, protected and private
scope.

#### Regular Expressions

Meta provides perl-style operators for dealing with regexps, with formalized
object instances containing multiple matches.


#### Multithreading

Meta provides the 'synchronized' feature attribute on executables ala Java.
Meta also provides built-in support for thread-local variables.

#### The Power Of Fields

One defines state in Meta via the 'field' construct, and this construct is used
to provide a variety of useful features.

##### Serialization

For every class, Meta auto-generates a method that can serialize an arbitrary
instance to disk (shallow or deep).  This is based on protobufs ...

##### Size Analysis

For every class, Meta auto-generates a method that can calculate how much
memory an arbitrary instance is taking up.

##### Copying and Moving

For every class, Meta can auto-generate methods for cloning (or, to support
move semantics in C++'011) moving instances.

##### UML Diagram generation

Meta can automatically generate UML class diagrams from its source.
The attributes available on the various constructs (in particular,
{class}, {method} and {field}) provide all the information needed to
produce robust comprehensive class diagrams.

#### The Power of Parameters

##### Initializer parameters and fields

Almost always, at least some of the parameters past to an initializer
are destined to be used to initialize some subset of the fields
defined on the class. In many baselanguages this results in a
duplication of documentation and declaration (a field has a given type
and docstr, and the initializer parameter destined to be stored in
that field has the same type and docstr). Meta provides a special
'provides' syntax for initializer parameters that concisely indicates
that the parameter is to be stored verbatim in a field. No type
information is needed, nor is a docstr usually provided, since it
presumably has the same docstr as its underlying field.

##### Positional and keyword arguments

One of the more powerful and flexible aspects of method invocations in
Perl is the ability to pass 'named' key/value pairs (in addition to
positional parameters). Python took this idea even further, truly
formalizing positional and keyword parameters and allowing for a great
deal of flexibility in how methods are invoked.

Meta provides the same positional/keyword parameters across all
base-languages, although this power is only fully realized in code
written in Meta*.

#### Consistency Across Base-Languages

##### How to compile source code

One uses exactly the same mechanism to compile meta into any base language.

% metac -b <baselang> -c <metafile>...

##### How to run unittests

One uses exactly the same mechanism to invoke unittests in any base language,

To run all tests in one or more namespaces:
% metac -b <baselang> <namespace>...

To run all tests in a specific class
% metac -b <baselang> <namespace>.<class>

To run a specifc test within a class:
% metac -b <baselang> <namespace>.<class>.<method>

##### How to invoke a REPL

Meta ensures there is a read-execute-print loop (REPL) available in all
base languages, and it is invoked the same across all languages:

% metac -b <baselang> repl

##### How to perform profiling

Meta can instrument every method's entry/exit and execute timing code
to count invocation counts and time spent in each method, providing
detailed profiling information.

##### How to perform coverage analysis

Meta can instrument every branch (in statement-level code written in
Meta*, but not statements written in base languages) and from this
can identify what code a particualr set of executions touchs and
doesn't touch. Useful for unittesting coverage analysis amongst other
things.

### Some Benefits of Meta

 * legacy code becomes less of an issue, as a program written in Meta<old>
   is implicitly partially implemented in Meta<new>, with a clear incremental
   path available toward complete implementation.
 
 * language interoperability: meta can define classes in different languages
   in the same file, and within a class written in language L can specify
   "native" methods implmented in language K.
   
 * the benefits of having a consistent and universal mechanism for associating
   a comment with every construct cannot be overstated:
    - variables are often initialized in code without any explanation of what
      they are for, because comments are second-class citizens in most 
      languages that break up the flow of the code.
    - comment attributes can be conditionally hidden from view, allowing
      clutter to be removed, but available when needed.

 * every language is extended (more expressive than original)
    * optional typing
    * behaviors
    * categories
    * formalized comments
    * ... many bullets in this "benefits" section represent languages extensions.
    
 * Inlining of field accessors
   * Meta knows what the definition of field accessors is (both natively and
     inherited) and can thus determine when a field accessor can be inlined
   * Caveat: 
      * Suppose
        * class nmsp2.B (defined in B.meta) inherits from class nmsp1.A
          (defined in A.meta).
        * A defines a field 'f' with no specialized accessors.
        * B specifies obj.fIs(10)
        * compiler inlines the field accessor at the callsite
      * Now suppose nmsp1.A is modified such that field 'f' *does*
        have a special setter implementation.
        * We would need to recompile nmsp2.B (NOT in the inheritance
          path of nmsp1.A, but rather a child thereof) to ensure
          correctness.
        * Meta can record, for every class, its list of ancestors.
          From there, it can identify the set of all descendents of a
          given class, and recompile all metafiles containing
          descendents when necessary.  HOWEVER, detecting when a field
          accessor has been added is not so obvious ... PROBLEM!!!
          

 * WRT the Meta Library
   * A single implementation of core classes across all languages gives an
     opportunity to focus on making it the best possible implementation.     
   * Effort expended once, benefits every language (current and future)

 * more concise syntax where possible, more encapsulated syntax where necessary,

 * metaclass provide:
   - reflection everywhere (at level of base-language AND at level of Meta code)
   - in base languages that have some support for metaclasses, we can improve
     on idioms. Example: In python, it is common to define class variables,
     and a @classmethod Initialize() that initializes those variables ...
     with the invocation of <class>.Initialize() after the class definition.
     By putting such code into a metaclass, we do not need to explicitly
     specify an Initialize() method ... the code is put into the initializer
     of the metaclass which is automatically invoked at the right time by
     the python runtime.
      - TODO(wmh): Will we find things we cannot do within these initializers
        that we could have done using an Initialize() method?

 * profiling
    - When compiling code, Meta can be asked to instrument every method
      with code that counts invocations and the time taken to execute each
      invocation of each method.
    - Provides a single environment across all baselangs for profiling
      code execution
    - Allows one to see differences between languages based on changes in
      the ordering of which methods are most expensive in each language.
      
 * coverage
    - For code written in Meta*, suppose Meta were to do the following:
       - insert code at the beginning and end of every block within each
         method (including the entire method itself) counting how many
         times that block was executed
       - creating some global datastructure that initializes
         per-method datastructures with all of the blocks within the
         method, initializing invocation counts to 0.
       - running test code over some set of classes/methods
       - analyzing the global datastructure to identify which methods were
         and were not invoked, and when blocks within each method were and
         were not invoked, and what the values of all variables in the scope
         of the method was at the time of invocation.
       - from this, we can provide comprehensive coverage analysis in all
         baselangs.
    - The big downside is that this requires Meta*, at least at the level of
      all blocks.
 
 * more expressive syntax (fields allow auto-uml, auto serialization, etc.)

 * unit tests are part of the syntax
 
 * comments are part of the syntax (no more losing comments when code moves)

 * Because of the uniformity of syntax and the easy with which one can
   query all constructs, all sorts of things that were hard are easy,
   and things impossible in the past become possible.
    - show all classes with public meta fields
    - what kinds of new ideas will others come up with based on these queries?

 * Meta ensures that a REPL (read-execute-print loop) is available for all
   baselangs and makes it trivial to access.
 
 * anything implemented to make Meta better makes implementations of all
   base languages better (bigger impact justifies more effort)
    - most code written only benefits the language it is written in,
      whereas code written for Meta benefits all languages it supports!

 * source code canonicalization:
    * the source code can be translated into dramatically different
      representations based on user-level configuration of the schema (and
      back to a canonical form again)
    * allows people to pick the syntax that works best for them, while still
      allowing others to pick a completely different syntax (as long as
      the version submitted to repository is canonical).
    * moves away from the psychologically limiting idea that the specific format
      of the program is important
    * style-guide enforcement is automatic
    * allows non-english speakers to create keywords in their own languages,
      rather than having to use English.
       - https://en.wikipedia.org/wiki/Non-English-based_programming_languages

 * More information available to syntax highlighters and auto-indentation
   code bases.
    * one of the problems with python is there is no safe auto-indenting.
    * in meta, auto-indenters have access to the entire parsed meta tree,
      with which they can do a much better job of figuring out where 
      something should be indented (probably still not perfectly safe
      unless one never uses implicit construct termination though.
    * can produce construct-speecific auto-generation facilities, including
      prompting for values, etc.

 * consistency across languages makes for increased productivity
    * same library
    * same functionality (implement once, use everywhere)
    * currently, a barrier to using different languages is that the entire
      environment can be very different and one loses time "getting up to speed"
      
 * syntax is consistent and doesn't do special casing:
    - Example: 
      - In most languages, 'if ... elif ... else ...' has an inconsistency builtin,
        in that when you want to reorder, you need to change syntax.
      - In meta, move the individual blocks without having to change syntax.
    - Example:
      - In most languages, there are two places where parameters get specified,
        in the signature, and in associated documentation. Reordering a parameter
        requires cumbersome changes in multple places.
      - In Meta, one just moves a single 'var' block up or down.
 
 * language comparisons
    * apples-to-apples comparison of language efficiency for particular problem
    * one can learn how to emulate a specific language feature from one langue within
      another language by looking at how Meta compiles that feature into languages
      not providing direct support

 * Every meta construct instance is addressable because the id of each constuct
   is unique within its scope.  This means we can obtain every statement by
   name, which makes aspect-oriented programming (etc.) much simpler than in
   languages that do not have such support.

 * Changes/evolutions in a base language (new ways to do things, etc.)
   can be incorporated into Meta and automatically available to end-users
   with a simple recompilation of meta code.

 * Every construct can be documented, and comments can be selectively shown
   or hidden.  How comments in base languages are associated with the entities
   they apply to are often inconsistent and informal, and it is easy during
   cut&paste operations for the comments to get lost.  Furthermore, comments
   sometimes add bulk to code that decreases readability, which inhibits
   individuals from adding those comments.  Meta allows comments to be shown
   when desired, and hidden otherwise.

 * Native code can be embedded directly into the actual source code, and the
   glue needed to make it work can be automated.

 * When a template method is defined in a root class, and overridden in various
   subclasses, the documentation of the subclass definitions is redundant, but
   it is useful to provide that documentation anyways (but then docs can get
   out of date).  Meta can help remove this redundancy:
    * by providing instantiations of "see parent docstr" references
    * by implementing the concept of a 'behavior' 

 * Incremental improvement everywhere.
    * take the post-extend, pre-extend, super-extend functionality as an example.
      we can provide an initiail implementation of these.  Then, later, we might
      realize that there is another variant of pre-extend that is useful, one
      in which we invoke the parent conditionally (we test some arg for certain
      values, processing those values, and delegate unknown values to a parent
      implementation).  We can easily add a fourth value to the 'inheritance'
      feature attribute of construct 'method' to handle this.

 * Syntactic shorthands
     * instead of having to repeat every arg when invoking a parent definition
       of a method, Meta can replace special syntax with the appropriate
       call.  Same for printf statements, etc.

 * Better language syntax evolution
    * A particular program is written against a specific version of the
      language grammar, and usually changes to the grammar will break old
      programs.
    * The grammar of a Meta program is defined by the associated schema
      (appropriately modified by user-level extensions to that schema).
    * The set of changes between one version of a schema and another consists
      of:
        * adding, renaming or deleting an attribute value associated with
          a particular attribute key within a construct.
        * adding, renaming or deleting an attribute key from a construct
        * adding, renaming or deleting a construct
      All of these can be formally expressed, so that we can automate the
      process of converting a program written against version A of a schema
      into one written against version Z (by successively applying all
      changes for A to B, B to C, ..., Y to Z.
    * relies on canonicalization
    * The fact that we can automatically convert languages written against
      old schemas into newer versions means we are not inhibited from
      evolving the language rapidly (in constrast to current languages,
      which change very slowly over time).

    * The above is can be used to hide away changes in base languages as
      well (i.e automate the conversion of old baselang code into new
      baselang code), as long as the changes occur above the level
      of method scopes (or, for methods implemented in meta, even they will
      be auto-converted).
      
 * Units library
   - literal units
       95kg
       38C
       01:32:50
       2017:02:01
       2017:02:01-01:32:50
       
 * Minimal source code bundles
    - Meta can identify, given a seed .meta file, every other .meta file
      in the transitive closure of dependencies.
    - All such .meta files can be merged into a single .meta file
      containing all the code for the project in question.
    - Could conceivable also do analysis of methods invoked, and
      delete any method not referenced.
      
 * A distinction can be made between comments that are informative,
   and comments meant to ignore certain code. 
    - It is common in code to see things like:
        # We have previously seen the same relative type, and can use it.
        # print 'NOTE: Found previously cached wrapper %s' % wrapper.wrappedRaw()
      where the first line is an informative comment, and the second is
      debugging code that has been commented out.

### Meta Syntax and its ramifications 

The syntax that Meta introduces is designed to be consistent,
intuitive, expressive, readable, writable and concise. But most
languages have at least some of these same goals, so how does Meta
differ?

 - Concise and Consistent: One Syntactic Construct
 - Expressivity: Code merging
 - Intuitive, Readable and Writable: Source Code Customization and Canonicalization
 - Self-referential: Every construct has a unique identifier

#### Concise and Consistent: One Syntactic Construct </h4>

Many languages find that conciseness, consistency and expressivity are
sometimes at odds with one another. Even if a language starts out with
these as goals, as the language evolves and new syntax is added, some
of these goals often suffer.

Meta addresses these issues by have exactly one syntactically legal
construct. Everything that can be defined in Meta is a construct.
Every construct is a collection of attributes. Syntactically, every
construct consists of a key (a single word, often a single character)
and a value (the type of which is defined by Meta for the construct in
question, and can vary from an identifier to a block of arbitrarily
nested constructs). Which attribute keys are legal for a given
construct, and which constructs exist, are dictated by the
meta-language in question (Meta(Oopl), Meta(Doc), etc), but in all
cases, everything is a construct, and every construct is simply a
collection of attribute key/value pairs. As such, the consistency of
meta syntax is future-proofed ... extensions to the language involve
adding new attributes, or extended the type of existing attribute
values, but the basics of how one writes a Meta program never changes.

Conciseness is achieved in Meta primarily thru support for source code
customization (see the next section), which allows one to introduce
arbitrary aliases for existing attribute keys and values. As well,
Meta provides support for certain attribute keys being optional
(feature attribute keys are always optional, and some secondary keys
can be optional as well, depending on context).

#### Expressivity: Code merging

One of the aims of Meta is to be able to express more with less code.
Any non-trivial program written in Meta<L> will involve less code than
in the resulting base language {L} code produced by compilation. For
example, in C++, best practice suggests that every class have at least
two files files (a header file and a source file). Although there are
excellent reasons for this (efficient separate compilation, separation
of interface and implementation, etc.), the two-files-per-class idiom
puts an unnecessary burden on programmers, as one must edit multiple
files (often repeating changes in various places with various minor
tweaks). On the other hand, not only is a Meta<C++> class defined in
only one file, a meta file can contain an arbitary number of classes
from an arbitrary number of namespaces. When the file is compiled, the
appropriate per-class header and source files are automatically
generated by the Meta<C++> compiler. The redundancy inherent in C++
method declarations vs method definitions, and numerous other
subtleties of C++ implementation, are entirely hidden away in
Meta<C++> implementations.

Another example of code redundancy has to do with unit testing. Each
method should have one or more unit tests, testing the various control
flows thru the method. In base languages, these tests are placed in
separate files, but in Meta the unit testing code is integrated into
the source code; every {method} construct has a complex-block-valued
{tests} attribute that allows unit tests to be defined adjacent to the
code being tested. As well, every {class} construct has a
complex-block-valued {tests} attribute that allows one to define
unit-testing service methods, and every {namespace/span> construct has
a complex-block-valued {tests} that allows one to define unit-testing
classes. All of the work involved in setting up the proper
unit-testing infrastructure is provided by the Meta compiler, across
every base language.

In existing languages, comments are often treated as second class
citizens, being loosely coupled with the code they are nominally
associated with (does this collection of comments refer to the code
below, or the code above?). Furthermore, it is easy for comments to
get separated from the code being documented. Meta addresses these
issues by ensuring that every kind of construct has a
simple-block-valued {comment} attribute that unambiguously identifies
which code the comment is associated with and makes it impossible to
move the construct without also moving the comment. Furthermore, Meta
can properly add comments into multiple places (for example, C++
declaration and definition files, in code and unit tests, etc.), and
can auto-generate C++ doxygen, Java javadoc, Perl pod, Python docstrs
and all the other base-language documentation idioms ... all without
requiring the user to know anything about these low-level issues.

#### Intuitive, Readable and Writable: Source Code Customization and Canonicalization

The problem with most languages when it comes to intuitive and
readable syntax is that different people find different things to be
intuitive and readable, whereas most languages offer only a single
canonical syntax. One size does not necessarily fit all programmers,
but most languages force the same "synactic size" upon them. Meta
addresses this by allowing individuals a great deal of customization
over the syntax of a Meta program. If you prefer to define your
methods using {def} and/or {sub} instead of {method}, you can
customize Meta to understand this. Or if you prefer to use the keyword
{slot} and/or {property} and/or {instance_variable} and/or
{data_member} instead of {field}, Meta can allow this. Meta(Oopl)
introduces 20+ constructs, 75+ attribute keys, and 100+ feature
attribute values (with the number steadily increasing over time) and
the user can provide their own abbreviations/aliases/alternatives for
any or all of them.

One of the big disadvantages of this kind of "personalized syntax",
however, is that it decreases the ease with which another person can
read the code. Put another way, one of the advantages of a canonical
syntax is that different people can all read the same source code. How
can we offer the benefits of personalized syntax without its
downsides? This is where Meta's _source code canonicalization_ comes
into play. Although a person can dramatically change the overall look
and feel of a Meta(Oopl) program, every construct, attribute key and
feature value has a canonical representation, and any Meta program can
be converted from a personalized syntax to this canonical
representation and back again ... or into someone else's personalized
syntax. In a multi-person coding project, the canonical representation
of the Meta program would be stored in the shared code repository, and
individuals would then convert this canonical representation to their
personal representation on the fly as desired.

#### Self-referential: Every construct has a unique identifier

Every construct in a Meta source file has a unique identifier within
its parent scope, and thus every construct, from a namespace down to
the third callsite within a while loop in a method, has a unique
fully-qualified identifier.  This id is used internally for many
purposes, and is of course available to the programmer for additional
uses.  Note that aspect-oriented programming goes to a great deal
of effort to find ways to identify locations in code for aspect
injection ... in Meta, this is trivial.

### Base Language Attribution

Augmentation ideas that come from base languages:

 - Java: ability to run code associated with arbitrary class, throws in signatures
 - Python: indentation-based syntax, interactive shell, keyword parameters
 - C++: type system
 - Perl: regexp support
 - Smalltalk: method categories, per-class metaclass
 - Eiffel: pre and post conditions
 - Tcl: upvar, wish
 - Beta: sub extend, monands

## CLEAN THESE UP

### Implications

Here are some implications/ramifications of Meta's aim to augment
and unify existing languages:

 * Meta<L> is a proper superset of base language {L} (it can do
  everything {L} can, and also guarantees various
  features/concepts/idioms regardless of whether they exist natively
  within {L}.

 * Meta<L> can do more while writing less. This has impacts on both
  readability and writability of code.

 * A program written in Meta<L>, for some base language {L}, is also
  implicitly partially implemented in Meta<L'> (for any other base
  language {L'} supported by Meta). For example, a program written in
  Meta<Java> defines namespaces, classes, methods, fields and various
  other concepts, and it is only the statements within methods that
  use Java syntax ... everything else in the program uses Meta(Oopl)
  syntax, which is the same in Meta<C++>, Meta<Java>, Meta<Python> and
  every other language Meta(Oopl) supports.
  
### Special Meta Syntax Within Method Scopes

In Meta<L>, the syntax used for statements is that of {L} (for
anything above the level of statements, the construct-based Meta
syntax is used).  However, even within {L} syntax, there are a few
things that the Meta compiler recognizes. They are enumerated below,
and implemented within BaseLanguage.getBody():

 - comments (lines starting with whitespace then '/#')
 - the string '__metafile__' is replaced with the absolute path of the
   .meta file being compiled
    - this happens in 
 - the string 'META_SUPER()' is replaced with baselang syntax to invoke
   the superclass version of the same method (with args specified by
   the 'super' parameter).

### Weaknesses Of Meta

TODO(wmh): Move this someplace more structured within this doc.

 - searching for a method within a class in a .meta file with many
   namespaces or classes is problematic.
    - etags
    - major-mode support
    - syntax modifications ('method' becomes 'meth@' or some such?)
      maybe f> and m> abbrevs for construct names field> and method>?
      
 - the source customization features of Meta may exceed the ability of
   editors like emacs and VIM to fully implement.


{^(L|L'|L'')$}: <code class="baselang">
{^(primary attribute keys|class|method|initializer|field|call|testx|@)$}: <span class="construct">
{^(Person|name|height|weight|BMI)$}: <span class="primary-value">
{^(secondary attribute keys|visibility|returns|scope|comment|tests|on|message|\.|arglist|\(|endarglist|\))$}: <span class="attribute-key">
{^(feature attribute values|public|private|protected)$}: <span class="feature-value">
{^(constructor terminators)$}: <span class="endcons">


